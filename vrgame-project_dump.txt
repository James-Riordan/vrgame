ğŸ“¦ Dumping from: C:\Workspaces\Zigadel\code\ZGD\games\vrgame
ğŸ“¤ Output: C:\Workspaces\Zigadel\code\ZGD\games\vrgame\project_dump.txt
ğŸ“ Max file size: 104857600 bytes
ğŸš« Ignore rules (in order):
  C:/Workspaces/Zigadel/code/ZGD/games/vrgame/project_dump.txt

ğŸ§± Filtered Tree:
- .git
  - .git/COMMIT_EDITMSG
  - .git/config
  - .git/description
  - .git/FETCH_HEAD
  - .git/HEAD
  - .git/hooks
    - .git/hooks/applypatch-msg.sample
    - .git/hooks/commit-msg.sample
    - .git/hooks/fsmonitor-watchman.sample
    - .git/hooks/post-update.sample
    - .git/hooks/pre-applypatch.sample
    - .git/hooks/pre-commit.sample
    - .git/hooks/pre-merge-commit.sample
    - .git/hooks/pre-push.sample
    - .git/hooks/pre-rebase.sample
    - .git/hooks/pre-receive.sample
    - .git/hooks/prepare-commit-msg.sample
    - .git/hooks/push-to-checkout.sample
    - .git/hooks/sendemail-validate.sample
    - .git/hooks/update.sample
  - .git/index
  - .git/info
    - .git/info/exclude
  - .git/logs
    - .git/logs/HEAD
    - .git/logs/refs
      - .git/logs/refs/heads
        - .git/logs/refs/heads/main
      - .git/logs/refs/remotes
        - .git/logs/refs/remotes/origin
          - .git/logs/refs/remotes/origin/main
  - .git/objects
    - .git/objects/00
      - .git/objects/00/704ec8659f29bc46ef891d1e1f8f1b586d40e3
    - .git/objects/02
      - .git/objects/02/cc1957edb711001034db979a555f64c93d0213
    - .git/objects/05
      - .git/objects/05/edc8760357a70810f4f1e230ca98424ae20874
    - .git/objects/06
      - .git/objects/06/2b2b67a0a65e2346e4d825d27ecd5c9c7a3a77
      - .git/objects/06/ca6cda7d7cb9a5c5354af95b6f7f6740e1977c
      - .git/objects/06/ff3dfdd9d5ac9f892afd8caf76acee80d3d3bc
    - .git/objects/07
      - .git/objects/07/fd2a242dc5a7ed18d4bab1aa259e74b6fb71bb
    - .git/objects/0a
      - .git/objects/0a/274ada321aea218c0ebbacf188495cd85443ac
    - .git/objects/0d
      - .git/objects/0d/08a05f28b5f6679ccd128bab3bcb06622ab915
      - .git/objects/0d/40882bcaa0ce5350209c3079f2892c5bb4b5fd
      - .git/objects/0d/7f88484017ad27788ac5b7d667c8056479ee21
    - .git/objects/0e
      - .git/objects/0e/5847e0609342408bbce866c81885443567f2f0
    - .git/objects/0f
      - .git/objects/0f/2cf81c110831e5eaa100973aafcd45a70f46d2
    - .git/objects/15
      - .git/objects/15/9745a13282276b65104aaa6ec0064bb5b7b055
    - .git/objects/1a
      - .git/objects/1a/0bb9843f0b410d896e8d602fa84ebde510185b
    - .git/objects/1b
      - .git/objects/1b/0fb87d400cbbd003122e1e789124f61a51efef
    - .git/objects/1e
      - .git/objects/1e/3460113f59f2fc51ab5e2c0387107ba3a4995b
    - .git/objects/1f
      - .git/objects/1f/f8365ad7d2975508c3d8ed18ef9bc9fa27f2c6
    - .git/objects/22
      - .git/objects/22/8e883baaf9856d4f7b5235b0b72b343d63d50e
    - .git/objects/24
      - .git/objects/24/f1ebaae58ecc1c041f1cbdce8e1b3cbe67f784
    - .git/objects/2a
      - .git/objects/2a/2fa2c348a9f6e1149079bff4d4d799de3fafea
      - .git/objects/2a/d43a01f4cc7132471339a19191dcdfc9cda8ff
      - .git/objects/2a/ff36792c67e6025c4b97b231bd181fc4afd058
    - .git/objects/2b
      - .git/objects/2b/8dfa5aa8d144b39369111122da96a7ab2a5815
      - .git/objects/2b/9b79e26c9051673d71c955dab4de5b2e0e6b76
    - .git/objects/2c
      - .git/objects/2c/659d6351f79d7abf56bce630c76e7bf4de8681
    - .git/objects/2d
      - .git/objects/2d/bfb3916ebcd20bbe0b8fbdc0aa651ef909b897
      - .git/objects/2d/f74d74f804371962c9fb52215c9788554bc313
    - .git/objects/2f
      - .git/objects/2f/5e15364a775a21597c7d58ecf4868101e26ea3
      - .git/objects/2f/958d1989dd5c11600cd5db6563f970f84439de
      - .git/objects/2f/cfe5f83f5fd239d0954bb2620b6ba8d85b1048
      - .git/objects/2f/ffe5c1faa22b4106cb0b38f9d218d17af87e4e
    - .git/objects/31
      - .git/objects/31/422da6fdc64ef9a2a9c438922703744b0e92eb
    - .git/objects/32
      - .git/objects/32/f6d09b2f094d2379bbe41ce91292ae9ae757b4
    - .git/objects/34
      - .git/objects/34/2cfae3562160cf6dd55883cd9d5fe06411fb95
    - .git/objects/35
      - .git/objects/35/ee3d8d22464747a85796390011a7d91a743f29
      - .git/objects/35/f38469568ff0c482382817ec52efe616d4625a
    - .git/objects/36
      - .git/objects/36/919d8a1cbdb25856fd1ddec88fd4d05fff3ef4
    - .git/objects/3b
      - .git/objects/3b/44f9b183927fff332734449e9b20ada53a929f
    - .git/objects/3d
      - .git/objects/3d/0abe9db0cdb7f4612614ed0038066d587fe967
    - .git/objects/3e
      - .git/objects/3e/19e5abe5c3dd76714532277a0e6bf25cdb6ad5
      - .git/objects/3e/2c35165d3f0a5b4c4efdaf7327dd3a814bf7d5
      - .git/objects/3e/4810fbc19502c71879ef03305e253d2bcdbab0
    - .git/objects/3f
      - .git/objects/3f/30397c744e4bed60469e71f5ee4c99f1ea7b63
      - .git/objects/3f/89e1c546bcc3beb6dcdb9550e04dde59ac9c22
    - .git/objects/41
      - .git/objects/41/1f152a0623156e17bb4c7506bbc5699b031df7
    - .git/objects/42
      - .git/objects/42/f9fffa365c0cc754455bd02952da8233212969
    - .git/objects/44
      - .git/objects/44/c22e40d0e3e35389aa1ff68ee98f4b39c90410
    - .git/objects/46
      - .git/objects/46/35d604c6cb40491f0b39036d510b1fffec27d0
      - .git/objects/46/425a9e42d6b7a20882bf5184279d7644fb5c16
      - .git/objects/46/6b7aac536849fc613156f8311d84cec2fd2871
      - .git/objects/46/d3359785e3633e8ac7c2ceacc88379b76d3a69
    - .git/objects/47
      - .git/objects/47/74483e2dc26a0cb30bd9b7fa2d7e4884e63c85
      - .git/objects/47/e62831a81f4c3199c8816cfa0078e8c14b9511
    - .git/objects/48
      - .git/objects/48/012f74d33abe8b9a0154ab3b05850c65990cd9
    - .git/objects/49
      - .git/objects/49/b0babde54ca7082c4d69d7501ce26996a50921
    - .git/objects/4a
      - .git/objects/4a/6b459ca34875aa0126a5cd9b862bd40ddb052d
      - .git/objects/4a/b1d12b58074fb19a3f218540022420701bb67b
    - .git/objects/4c
      - .git/objects/4c/11622b1be6602c55df49169bc3640f9ee8676e
    - .git/objects/4f
      - .git/objects/4f/e6198def7366eb4372e2f6c011e5d7b2ffac33
    - .git/objects/51
      - .git/objects/51/edead29a5569fde44e74bd6e39600e517b81b5
    - .git/objects/54
      - .git/objects/54/263a48230a748d107ca2cba5cbe149c0131f36
      - .git/objects/54/3211c4066cdd4fca06adde70bca3d6ec1f3f56
    - .git/objects/55
      - .git/objects/55/03f3d31bead2c633117d7613f417b49332b276
      - .git/objects/55/4f5584674aedf6965cec7bd102b53a8d17be8a
      - .git/objects/55/bdf2bc77d759a361e7f1131c7811c47934a6be
    - .git/objects/5b
      - .git/objects/5b/ce420f1a05d38e9d252c8c18e0848baf873bd5
      - .git/objects/5b/fbcb557e6ed57bc22302660752ca6307316b52
    - .git/objects/5d
      - .git/objects/5d/01e92ad4468886c63aa6f8c4eb05dc420c382a
      - .git/objects/5d/74823b11271946fe875a9a8550a29c69ec1039
      - .git/objects/5d/a3f1c35a6063a1a7bfa717c004f24958dcea61
      - .git/objects/5d/c2dfb7ea3334a4380373d05dc93770139fd99a
    - .git/objects/5e
      - .git/objects/5e/030865fc93079192ac315b42a2d3f5d76d7353
      - .git/objects/5e/25f46572dadd81dfec0ee3a8a6386b7b1ad7fb
    - .git/objects/60
      - .git/objects/60/2bfc1586f9d2290dac330453376be2ab5a17be
    - .git/objects/61
      - .git/objects/61/5ea62414d4ff2212616978a3dc3a0b44fa7086
    - .git/objects/63
      - .git/objects/63/9c66bddbab3cdac4e3603961491c702dcab9d0
      - .git/objects/63/fe2ccb60aeb5a6a6196d7b017c37d6cc0b4b08
    - .git/objects/64
      - .git/objects/64/4c4263b91c6eadad634641ccbfc22abaa5d40b
    - .git/objects/65
      - .git/objects/65/988a0276dbf0a3024558489d263817e9556c3b
    - .git/objects/66
      - .git/objects/66/0c31435d49e3627773a63edcf03fbb6fa603ca
      - .git/objects/66/8773e2f41dd8696f60576236690866c5f13872
    - .git/objects/68
      - .git/objects/68/24af0ed80fec6e1a0b4302911501773b1fa838
      - .git/objects/68/750a132bb2dffd55396af081750cbe62e148ae
      - .git/objects/68/cc8934a51ca9f4a3c2cc978dd0ebd4388488b1
    - .git/objects/6c
      - .git/objects/6c/382557dd47c4289040f6bd599b6119623c8632
    - .git/objects/6d
      - .git/objects/6d/3a56f3905b7f1e60420cf2fd7b5416b0c2a544
      - .git/objects/6d/9d77071fa1a1951e5e175f3a62ea7c8c5600d2
    - .git/objects/6f
      - .git/objects/6f/5d8ccee2fb0f45a5df458e440f16f7c2912d5d
      - .git/objects/6f/e42bcef0c0b6d3549a66e348038a41f22ebe50
    - .git/objects/70
      - .git/objects/70/aedfdedac6892ff6363e7f211519eea108776c
    - .git/objects/71
      - .git/objects/71/7a6c5dc6f6292a10c623fcb411cef4c6a39e7a
    - .git/objects/72
      - .git/objects/72/3b9cc625148c9fb90bc986bc1b1236d5c70d10
    - .git/objects/74
      - .git/objects/74/111a8550f468e0bc044546412f21325f0e2f2e
    - .git/objects/75
      - .git/objects/75/3fbdb812f126cab3346da470ab36c52229a776
      - .git/objects/75/7fd2b80da0fd5d245ad4e22fc3aaab7817ebcb
    - .git/objects/76
      - .git/objects/76/f072847b0d5baab3264b56be51ebb1a4b8d069
    - .git/objects/77
      - .git/objects/77/6be0f55589d444f86d43658f92a4a41d3a1e39
      - .git/objects/77/b9ca70cabefffc09f894c515a8cc90bf8fa8d5
    - .git/objects/79
      - .git/objects/79/5ca8c90a5f0d846ae5fd00c5466ba0a07a6ed7
      - .git/objects/79/e4be2b6ea666fbb41e06e6b1b7a7427c7a0b8d
      - .git/objects/79/ea28f8372736458cbfbffca29054c5a229e8c2
    - .git/objects/7a
      - .git/objects/7a/286cc06656f0e76197532706b9a01929ec050a
      - .git/objects/7a/4726a72b7415b548ff7dea344f6fe4afbfc8ee
    - .git/objects/7d
      - .git/objects/7d/0ebe85722ab24d52a50859da3e05ee6aac30c9
      - .git/objects/7d/23015643fa10e51992978a8fdd35325a57f452
    - .git/objects/83
      - .git/objects/83/e388fb9694f0c247dd42f26928d8f725c01f9f
    - .git/objects/84
      - .git/objects/84/8bbb22114456aea23b68e34093265c787d8e05
      - .git/objects/84/fd311f253091512c891748eb954f104274641c
    - .git/objects/85
      - .git/objects/85/87d7ce1c61bec4b0228113be6f7ab9625587f0
    - .git/objects/86
      - .git/objects/86/358414442743af7d6a5a6d1f0dc746c77584f8
      - .git/objects/86/bdd855c414443aa143b17e7f48a9448290cea2
    - .git/objects/87
      - .git/objects/87/87fc5cb273ba362cf65f96f94813e0d741ec27
    - .git/objects/88
      - .git/objects/88/863767c942edada130250a6d790907e01f7d90
    - .git/objects/8a
      - .git/objects/8a/d524eea225bdda77a5e29033ec2e0fdd1eb574
    - .git/objects/8b
      - .git/objects/8b/3fac5d362079f9e06d744a517b1cf55edcea2e
      - .git/objects/8b/9e223698169254e99be245649fa588c8d448b7
      - .git/objects/8b/d79b165db75cbea70e274a857f139cec531e56
      - .git/objects/8b/f0d3940d0c8e1b8608e767b2bad7b903dae392
    - .git/objects/8c
      - .git/objects/8c/952fec7b1a94fbbcd816eb34041f39905dec30
    - .git/objects/8e
      - .git/objects/8e/c8a314b4427402e50dc2ae51863612ebe2d628
    - .git/objects/8f
      - .git/objects/8f/95f1781f7362e7452255d68efedf3b7ccf8092
    - .git/objects/92
      - .git/objects/92/cb6ff3b17df4e78f177429de0cde846d957789
    - .git/objects/94
      - .git/objects/94/4afec26753525c813506abd0ebe8bb217380ee
    - .git/objects/95
      - .git/objects/95/b85e255b41ff7e9795bd55d661861fe0ebbf1a
    - .git/objects/96
      - .git/objects/96/1a590852265cd46bf39c4f9a1990e663aef72d
    - .git/objects/97
      - .git/objects/97/064d7132a10aeb3c2c2e368aef97cf973e27eb
      - .git/objects/97/6ff82f88da884adbb7a5e59866f5a47e0e267c
    - .git/objects/99
      - .git/objects/99/54627c0978a29386624eefbf9801e3f82a7a8a
    - .git/objects/9c
      - .git/objects/9c/0aebe43966aa6812fd40a2b6b0a79ba4fed0db
      - .git/objects/9c/742395c107590e439acddeba06069077bfd330
      - .git/objects/9c/d626edd5dc5d5d2af92f00861861a6925a0a0e
    - .git/objects/9d
      - .git/objects/9d/88993ddef78c72c139e3ba2409a2bbb0048d80
    - .git/objects/9e
      - .git/objects/9e/8083251d46ea0e1a3161776ac7238a4a6d37ff
      - .git/objects/9e/a3bb988117502408b47c0d0ca560cb188fa0c9
    - .git/objects/9f
      - .git/objects/9f/2d066dc347cdf8763c0cbe34cd9fcf4e06ae0d
      - .git/objects/9f/8884bacc48acd385183cf57bb7009d1da95a34
    - .git/objects/a2
      - .git/objects/a2/7627344cb6ee1adb5dafdca5a62fe40b90d472
    - .git/objects/a3
      - .git/objects/a3/80657413fa908e0126cc59326dd273ec45eb5b
      - .git/objects/a3/853269734f8c2c800d6a4cd89c2d65cf6f2f84
      - .git/objects/a3/de61551501acaab9828608b2eea48808fbc73e
    - .git/objects/a7
      - .git/objects/a7/adca77508b87276955bbd65919e72fcce56059
    - .git/objects/a9
      - .git/objects/a9/e2ecfb168b7850ede543240cddc3a7c57ade5e
    - .git/objects/aa
      - .git/objects/aa/f090b2d964c98c3c7dc1d8d2cd3eab37baf569
    - .git/objects/ab
      - .git/objects/ab/34740558f6ce0aceb1caf79dd5c114d56c91b9
    - .git/objects/ac
      - .git/objects/ac/9b90ea880316403b956ad149f779284830526a
      - .git/objects/ac/da4ec2448f8647feb4e0d83900fa1ff8c8f313
    - .git/objects/ae
      - .git/objects/ae/3dc41aa855a422980fdcc74db99ce2cc0aaff7
    - .git/objects/b0
      - .git/objects/b0/2dc17b04142a6aea3c893be2b0061764a83a0e
      - .git/objects/b0/6248b93b189737f6b003794e900cb261cf06bf
    - .git/objects/b1
      - .git/objects/b1/0ebde2568f1f4af170d0c77b38807c249830d1
    - .git/objects/b2
      - .git/objects/b2/82478c2f71c5d57beb84f51056ba1de3e92f34
    - .git/objects/b3
      - .git/objects/b3/ea1343058de107739aafd2c124a806fb77c363
    - .git/objects/ba
      - .git/objects/ba/05b10dad93cb4dfb43d0ef70fff7f98131e4f1
    - .git/objects/bb
      - .git/objects/bb/721f50d535ad62e31d589e976e13372f9b16a5
    - .git/objects/bf
      - .git/objects/bf/6868ac3585064b6bf33862cb01829377b4e0de
      - .git/objects/bf/fabcef04390cccd9d7c66c760da59800b1d452
    - .git/objects/c2
      - .git/objects/c2/1469cc113f1b4ad3eaec900dcfb6094c8f3aad
      - .git/objects/c2/9ba633a76f000fc90fce2e2f0dbdd2ccfd082b
    - .git/objects/c3
      - .git/objects/c3/b015cae01aa0e266dfe6948a448f8eff719395
    - .git/objects/c7
      - .git/objects/c7/e0df5ef0393aa219325065548e6b652185d78e
      - .git/objects/c7/e314cb7c5a64b331694f5923678bf1f8613f68
    - .git/objects/c8
      - .git/objects/c8/9b88e0203aa72d99480f2b97e68cc0790f3fa5
    - .git/objects/c9
      - .git/objects/c9/af962d384885fe538b0c914b01be33bcf98db9
    - .git/objects/cc
      - .git/objects/cc/e581555f4fe1d355d44d06c892edd2a24bd1c0
    - .git/objects/cf
      - .git/objects/cf/f93f4efb55ac7807104ce11c565a850e735440
    - .git/objects/d5
      - .git/objects/d5/0d7c2ba936f64a67d071af8dc5e8bdb74cb002
    - .git/objects/d7
      - .git/objects/d7/21eb4bf8dda2666529ed16c9a02c79ddef1eda
      - .git/objects/d7/e7329b18daf1a3e73625681d07767457e67a36
    - .git/objects/d8
      - .git/objects/d8/aab825568b1515d38051670f252376b518fba4
      - .git/objects/d8/d59d48c10409c6cbc5c0b295964873636bff18
    - .git/objects/d9
      - .git/objects/d9/030549d395cf94c6010df212644d99947918c9
      - .git/objects/d9/0ce937b57c1f1263599285461887a61008d561
      - .git/objects/d9/752078f4d94f7dff452d7a1adfcf2f53128de9
    - .git/objects/db
      - .git/objects/db/934256bf51316fff6f90c6bff62db572060c26
    - .git/objects/dd
      - .git/objects/dd/92fbad080dc7d767aa3d0113dca4769f2b2dab
    - .git/objects/e0
      - .git/objects/e0/340c236d2e4805b2f699eba420645cda9c43ca
      - .git/objects/e0/ddae762342c30387fcccc7f347665137b7a373
    - .git/objects/e1
      - .git/objects/e1/2cb327561b2d220ae0cbea562780543d64b7a0
    - .git/objects/e5
      - .git/objects/e5/8ac83a2263b55cca5743065a6d6542feb096cf
      - .git/objects/e5/cc9859e453a01509482f533d2d0d61d4368b42
    - .git/objects/e6
      - .git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391
    - .git/objects/e7
      - .git/objects/e7/529ab023e69e480c722d9f53d7017fa9252b42
    - .git/objects/e9
      - .git/objects/e9/cb43c5ab07bd645fcafe80fb25f3be6d21ee39
    - .git/objects/ea
      - .git/objects/ea/044d701243904161e1d2c0342664aeba9bd4f3
    - .git/objects/eb
      - .git/objects/eb/7468ac1800fcdeff9083b97ee368ccaa10c635
    - .git/objects/ec
      - .git/objects/ec/63592a95a479d193f5d3171f84abf3275fbe98
    - .git/objects/f0
      - .git/objects/f0/8902c9cd8b24b0789c447800c4d9779f4618ac
    - .git/objects/f1
      - .git/objects/f1/0b1948110b7ec1bc47f3ad411e298676b7aa22
      - .git/objects/f1/763e2a92cab9b267b2f19883c7a037085ca2f0
      - .git/objects/f1/841406a029ff78969e7379837ac15f53269695
    - .git/objects/f2
      - .git/objects/f2/d9292d304b836f8a1aa275dffe45cce70dad0f
    - .git/objects/f3
      - .git/objects/f3/32d4e6628074790eb71caf0e896047019ec5b0
      - .git/objects/f3/c9fe1df526018e6d6af80aaf16f6167edeb63e
    - .git/objects/f5
      - .git/objects/f5/9afb3b98f3bbe32b9fb4dbda810487e582ba4a
    - .git/objects/f6
      - .git/objects/f6/c2cd202584279ee70935f3841929f6d67c427f
      - .git/objects/f6/f64fd2a28a81898102e0876926666b976f177b
    - .git/objects/f8
      - .git/objects/f8/874b649a36fcf867b41b86992a2f17202cd363
      - .git/objects/f8/8f576f8c4aa1956dda589a993859068434ab86
    - .git/objects/f9
      - .git/objects/f9/f6140c6ee8ede8d4d3f06ac2da054bae0029de
      - .git/objects/f9/fe70bd252129dfebf05599a3df84eb7be26cc0
    - .git/objects/fa
      - .git/objects/fa/1fd642905f5b7e8a44b546d31dee27ad503c19
      - .git/objects/fa/71031715ab8da45abb50c4612c1095fec88150
    - .git/objects/fc
      - .git/objects/fc/60e9ddb486ed8819b58b3e35bd256875a3ae1c
      - .git/objects/fc/6a8ddfa3c8028ee93db2ae06e437e2a9334d9c
    - .git/objects/fd
      - .git/objects/fd/3554675bb16c3ffc6b17cf3ba31957ee418d82
      - .git/objects/fd/92d578fd36560a080dcb61a6773f17e4f4aea4
    - .git/objects/fe
      - .git/objects/fe/acd003260d790139566d84dd536350a91e0931
    - .git/objects/info
    - .git/objects/pack
  - .git/ORIG_HEAD
  - .git/refs
    - .git/refs/heads
      - .git/refs/heads/main
    - .git/refs/remotes
      - .git/refs/remotes/origin
        - .git/refs/remotes/origin/main
    - .git/refs/tags
- .gitattributes
- .gitignore
- build.zig
- build.zig.zon
- ideal-project-directory-structure.txt
- project_dump.txt
- README.md
- registry
  - registry/vk.xml
  - registry/xr.xml
- shaders
  - shaders/triangle.frag
  - shaders/triangle.vert
- src
  - src/game
    - src/game/camera3d.zig
    - src/game/frame_time.zig
    - src/game/game.zig
  - src/graphics
    - src/graphics/graphics_context.zig
    - src/graphics/swapchain.zig
    - src/graphics/vertex.zig
  - src/main.zig
  - src/math
    - src/math/math3d.zig
  - src/root.zig
- tests
  - tests/_support.zig
  - tests/conformance
    - tests/conformance/pipeline_defaults.zig
  - tests/e2e
    - tests/e2e/smoke_cli_build.zig
  - tests/integration
    - tests/integration/camera3d_exports.zig
    - tests/integration/camera3d_public_decls.zig
    - tests/integration/frame_time_exports.zig
    - tests/integration/frame_time_public_decls.zig
    - tests/integration/frame_timer_window.zig
    - tests/integration/glfw_exports.zig
    - tests/integration/glfw_vulkan_headers_sanity.zig
    - tests/integration/glsl_sources_present.zig
    - tests/integration/graphics_context_exports.zig
    - tests/integration/graphics_context_public_decls.zig
    - tests/integration/math3d_lookat_orthonormal.zig
    - tests/integration/math3d_mul_props.zig
    - tests/integration/math3d_perspective_basic.zig
    - tests/integration/math3d_projection_props.zig
    - tests/integration/math3d_sanity.zig
    - tests/integration/math3d_viewproj_center_ndc.zig
    - tests/integration/repo_layout_sanity.zig
    - tests/integration/shader_sources_exist.zig
    - tests/integration/shaders_exist.zig
    - tests/integration/swapchain_public_decls.zig
    - tests/integration/types_size_sanity.zig
    - tests/integration/vertex_contract.zig
    - tests/integration/vertex_layout.zig
    - tests/integration/vk_headers_sanity.zig
    - tests/integration/vk_structs_compile.zig
    - tests/integration/xr_headers_sanity.zig
    - tests/integration/xr_registry_exists.zig
  - tests/test_all_conformance.zig
  - tests/test_all_e2e.zig
  - tests/test_all_integration.zig

ğŸ“„ File Contents:

`.gitattributes`: >>>

* text=auto eol=lf


<<<

`.gitignore`: >>>

# This file is for zig-specific build artifacts.
# If you have OS-specific or editor-specific files to ignore,
# such as *.swp or .DS_Store, put those in your global
# ~/.gitignore and put this in your ~/.gitconfig:
#
# [core]
#     excludesfile = ~/.gitignore
#

.zig-cache/
zig-out/
registry/vk.xml
registry/xr.xml
/src/generated/

zig-glfw-vulkan-example-advanced-project_dump.txt
project_dump.txt
<<<

`build.zig`: >>>

const std = @import("std");

//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Platform helpers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
fn linkVulkanLoader(
    exe: *std.Build.Step.Compile,
    target: std.Build.ResolvedTarget,
    b: *std.Build,
) void {
    switch (target.result.os.tag) {
        .windows => {
            // Add %VULKAN_SDK%\Lib if present (helps the linker find 'vulkan-1').
            if (std.process.getEnvVarOwned(b.allocator, "VULKAN_SDK") catch null) |sdk_path| {
                defer b.allocator.free(sdk_path);
                if (std.fs.path.join(b.allocator, &.{ sdk_path, "Lib" }) catch null) |ld| {
                    defer b.allocator.free(ld);
                    exe.addLibraryPath(.{ .cwd_relative = ld });
                }
            }
            exe.linkSystemLibrary("vulkan-1");
        },
        .linux, .macos => {
            exe.linkSystemLibrary("vulkan");
        },
        else => {},
    }
}

//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Registry fetchers (download to ./registry if missing)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
fn ensureVkRegistry(b: *std.Build) std.Build.LazyPath {
    const xml_rel = "registry/vk.xml";
    const registry_dir = "registry";
    const cwd = std.fs.cwd();

    if (cwd.openFile(xml_rel, .{})) |f| {
        f.close();
        return b.path(xml_rel);
    } else |err| switch (err) {
        error.FileNotFound => {},
        else => {
            std.debug.print("error: failed to open {s}: {s}\n", .{ xml_rel, @errorName(err) });
            @panic("cannot access registry/vk.xml");
        },
    }

    cwd.makeDir(registry_dir) catch |err| switch (err) {
        error.PathAlreadyExists => {},
        else => {
            std.debug.print("error: failed to create '{s}': {s}\n", .{ registry_dir, @errorName(err) });
            @panic("cannot create registry directory");
        },
    };

    var argv = [_][]const u8{
        "curl",
        "-L",
        "https://raw.githubusercontent.com/KhronosGroup/Vulkan-Docs/main/xml/vk.xml",
        "-o",
        xml_rel,
    };

    var child = std.process.Child.init(&argv, b.allocator);
    child.stdin_behavior = .Inherit;
    child.stdout_behavior = .Inherit;
    child.stderr_behavior = .Inherit;

    const term = child.spawnAndWait() catch |e| {
        std.debug.print("error: curl vk.xml spawn failed: {s}\n", .{@errorName(e)});
        @panic("curl not available");
    };

    switch (term) {
        .Exited => |code| if (code != 0) {
            std.debug.print("error: curl (vk.xml) exited with code {d}\n", .{code});
            @panic("failed to download vk.xml");
        },
        else => {
            std.debug.print("error: curl (vk.xml) abnormal term: {any}\n", .{term});
            @panic("failed to download vk.xml");
        },
    }

    if (cwd.openFile(xml_rel, .{})) |f2| f2.close() else |e| {
        std.debug.print("error: vk.xml missing after download: {s}\n", .{@errorName(e)});
        @panic("vk.xml missing after download");
    }
    return b.path(xml_rel);
}

fn ensureXrRegistry(b: *std.Build) std.Build.LazyPath {
    const cwd = std.fs.cwd();
    const registry_dir = "registry";
    const xml_rel = "registry/xr.xml";

    if (std.process.getEnvVarOwned(b.allocator, "VRGAME_XR_XML") catch null) |env_path| {
        defer b.allocator.free(env_path);
        const open_result = if (std.fs.path.isAbsolute(env_path))
            std.fs.openFileAbsolute(env_path, .{})
        else
            cwd.openFile(env_path, .{});
        if (open_result) |f| {
            f.close();
            std.log.info("Using xr.xml from VRGAME_XR_XML={s}", .{env_path});
            return b.path(env_path);
        } else |e| {
            std.log.warn("VRGAME_XR_XML={s} but failed to open: {s}", .{ env_path, @errorName(e) });
        }
    }

    if (cwd.openFile(xml_rel, .{})) |f| {
        f.close();
        std.log.info("Using existing xr.xml at {s}", .{xml_rel});
        return b.path(xml_rel);
    } else |err| switch (err) {
        error.FileNotFound => {},
        else => {
            std.debug.print("error: failed to open {s}: {s}\n", .{ xml_rel, @errorName(err) });
            @panic("cannot access registry/xr.xml");
        },
    }

    cwd.makeDir(registry_dir) catch |err| switch (err) {
        error.PathAlreadyExists => {},
        else => {
            std.debug.print("error: failed to create '{s}': {s}\n", .{ registry_dir, @errorName(err) });
            @panic("cannot create registry directory");
        },
    };

    std.log.info("Downloading xr.xml into {s}", .{xml_rel});
    var argv = [_][]const u8{
        "curl",
        "-L",
        "https://raw.githubusercontent.com/zigadel/openxr-zig/ef4d73159ea71eaf496a83dd108e719e54831b8d/examples/xr.xml",
        "-o",
        xml_rel,
    };

    var child = std.process.Child.init(&argv, b.allocator);
    child.stdin_behavior = .Inherit;
    child.stdout_behavior = .Inherit;
    child.stderr_behavior = .Inherit;

    const term = child.spawnAndWait() catch |e| {
        std.debug.print("error: curl xr.xml spawn failed: {s}\n", .{@errorName(e)});
        @panic("curl not available");
    };

    switch (term) {
        .Exited => |code| if (code != 0) {
            std.debug.print(
                "error: curl (xr.xml) exited with code {d}\n" ++
                    "hint: manually fetch and save as ./registry/xr.xml if needed\n",
                .{code},
            );
            @panic("failed to download xr.xml");
        },
        else => {
            std.debug.print("error: curl (xr.xml) abnormal term: {any}\n", .{term});
            @panic("failed to download xr.xml");
        },
    }

    if (cwd.openFile(xml_rel, .{})) |f2| f2.close() else |e| {
        std.debug.print("error: xr.xml missing after download: {s}\n", .{@errorName(e)});
        @panic("xr.xml missing after download");
    }
    std.log.info("Successfully downloaded xr.xml into {s}", .{xml_rel});
    return b.path(xml_rel);
}

//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Shader build (GLSL â†’ SPIR-V) into zig-out/bin/shaders
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
fn addShaderBuildSteps(
    b: *std.Build,
    exe: *std.Build.Step.Compile,
) *std.Build.Step {
    var glslc_path: ?[]const u8 = null;

    if (b.findProgram(&.{"glslc"}, &.{}) catch null) |p| {
        glslc_path = p;
        std.log.info("Using glslc in PATH at {s}", .{p});
    } else if (std.process.getEnvVarOwned(b.allocator, "VULKAN_SDK") catch null) |sdk| {
        defer b.allocator.free(sdk);
        const exe_name = if (@import("builtin").os.tag == .windows) "glslc.exe" else "glslc";
        if (std.fs.path.join(b.allocator, &.{ sdk, "Bin", exe_name }) catch null) |candidate| {
            defer b.allocator.free(candidate);
            if (b.findProgram(&.{candidate}, &.{}) catch null) |p2| {
                glslc_path = p2;
                std.log.info("Using glslc from VULKAN_SDK at {s}", .{p2});
            }
        }
    }

    const shaders_step = b.step("shaders", "Build or stage SPIR-V into zig-out/bin/shaders");

    if (glslc_path) |gl| {
        // vertex
        var v_cmd = b.addSystemCommand(&.{ gl, "-c", "-fshader-stage=vert", "shaders/triangle.vert" });
        v_cmd.addArg("-o");
        const v_out = v_cmd.addOutputFileArg("triangle_vert");

        // fragment
        var f_cmd = b.addSystemCommand(&.{ gl, "-c", "-fshader-stage=frag", "shaders/triangle.frag" });
        f_cmd.addArg("-o");
        const f_out = f_cmd.addOutputFileArg("triangle_frag");

        // Install beside the exe: zig-out/bin/shaders/*
        const inst_v = b.addInstallFileWithDir(v_out, .bin, "shaders/triangle_vert");
        const inst_f = b.addInstallFileWithDir(f_out, .bin, "shaders/triangle_frag");

        shaders_step.dependOn(&v_cmd.step);
        shaders_step.dependOn(&f_cmd.step);
        shaders_step.dependOn(&inst_v.step);
        shaders_step.dependOn(&inst_f.step);
    } else {
        // Fallback to committed blobs if present.
        const have_vert = blk: {
            _ = std.fs.cwd().statFile("shaders/triangle_vert") catch break :blk false;
            break :blk true;
        };
        const have_frag = blk: {
            _ = std.fs.cwd().statFile("shaders/triangle_frag") catch break :blk false;
            break :blk true;
        };

        if (have_vert and have_frag) {
            const inst_v = b.addInstallFileWithDir(b.path("shaders/triangle_vert"), .bin, "shaders/triangle_vert");
            const inst_f = b.addInstallFileWithDir(b.path("shaders/triangle_frag"), .bin, "shaders/triangle_frag");
            shaders_step.dependOn(&inst_v.step);
            shaders_step.dependOn(&inst_f.step);
            std.log.warn("glslc not found; using prebuilt SPIR-V from repo.", .{});
        } else {
            std.log.err(
                "glslc not found and prebuilt SPIR-V missing; expected {s} and {s}. Install Vulkan SDK (glslc) or add blobs.",
                .{ "shaders/triangle_vert", "shaders/triangle_frag" },
            );
            @panic("no SPIR-V available");
        }
    }

    // Ensure the exe install depends on shaders as well.
    exe.step.dependOn(shaders_step);
    return shaders_step;
}

fn addTestRun(b: *std.Build, root_mod: *std.Build.Module) *std.Build.Step.Run {
    const t = b.addTest(.{ .root_module = root_mod });
    return b.addRunArtifact(t);
}

//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Build graph
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    // Registries (download into workspace if missing).
    const vk_registry = ensureVkRegistry(b);
    const xr_registry = ensureXrRegistry(b);

    // â”€â”€ External dependencies â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const glfw_dep = b.dependency("glfw_zig", .{ .target = target, .optimize = optimize });
    const glfw_mod = glfw_dep.module("glfw");
    const glfw_lib = glfw_dep.artifact("glfw-zig");

    const vk_dep = b.dependency("vulkan", .{
        .target = target,
        .optimize = optimize,
        .registry = vk_registry,
    });
    const vk_mod = vk_dep.module("vulkan-zig");

    const xr_dep = b.dependency("openxr", .{ .target = target, .optimize = optimize });
    const xr_gen_exe = xr_dep.artifact("openxr-zig-generator");
    const xr_gen_cmd = b.addRunArtifact(xr_gen_exe);
    xr_gen_cmd.addFileArg(xr_registry);
    const xr_zig = xr_gen_cmd.addOutputFileArg("xr.zig");
    const xr_mod = b.createModule(.{
        .root_source_file = xr_zig, // lazy path from the generator
        .target = target,
        .optimize = optimize,
    });

    // â”€â”€ Project modules (no relative @imports; everything wired here) â”€â”€â”€â”€â”€
    const math3d_mod = b.createModule(.{
        .root_source_file = b.path("src/math/math3d.zig"),
        .target = target,
        .optimize = optimize,
    });

    const vertex_mod = b.createModule(.{
        .root_source_file = b.path("src/graphics/vertex.zig"),
        .target = target,
        .optimize = optimize,
    });
    vertex_mod.addImport("vulkan", vk_mod);
    vertex_mod.addImport("math3d", math3d_mod);

    const graphics_context_mod = b.createModule(.{
        .root_source_file = b.path("src/graphics/graphics_context.zig"),
        .target = target,
        .optimize = optimize,
    });
    graphics_context_mod.addImport("glfw", glfw_mod);
    graphics_context_mod.addImport("vulkan", vk_mod);
    graphics_context_mod.addImport("openxr", xr_mod);
    graphics_context_mod.addImport("vertex", vertex_mod);

    const swapchain_mod = b.createModule(.{
        .root_source_file = b.path("src/graphics/swapchain.zig"),
        .target = target,
        .optimize = optimize,
    });
    swapchain_mod.addImport("vulkan", vk_mod);
    swapchain_mod.addImport("graphics_context", graphics_context_mod);
    swapchain_mod.addImport("vertex", vertex_mod);

    const frame_time_mod = b.createModule(.{
        .root_source_file = b.path("src/game/frame_time.zig"),
        .target = target,
        .optimize = optimize,
    });

    const game_mod = b.createModule(.{
        .root_source_file = b.path("src/game/game.zig"),
        .target = target,
        .optimize = optimize,
    });

    const camera3d_mod = b.createModule(.{
        .root_source_file = b.path("src/game/camera3d.zig"),
        .target = target,
        .optimize = optimize,
    });
    camera3d_mod.addImport("math3d", math3d_mod);

    const vrgame_root = b.createModule(.{
        .root_source_file = b.path("src/root.zig"),
        .target = target,
        .optimize = optimize,
    });
    vrgame_root.addImport("graphics_context", graphics_context_mod);
    vrgame_root.addImport("swapchain", swapchain_mod);
    vrgame_root.addImport("vertex", vertex_mod);
    vrgame_root.addImport("frame_time", frame_time_mod);
    vrgame_root.addImport("game", game_mod);
    vrgame_root.addImport("math3d", math3d_mod);
    vrgame_root.addImport("camera3d", camera3d_mod);

    // â”€â”€ Executable â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const exe_mod = b.createModule(.{
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    });
    exe_mod.addImport("glfw", glfw_mod);
    exe_mod.addImport("vulkan", vk_mod);
    exe_mod.addImport("openxr", xr_mod);
    exe_mod.addImport("graphics_context", graphics_context_mod);
    exe_mod.addImport("swapchain", swapchain_mod);
    exe_mod.addImport("vertex", vertex_mod);
    exe_mod.addImport("frame_time", frame_time_mod);
    exe_mod.addImport("game", game_mod);
    exe_mod.addImport("vrgame", vrgame_root);
    exe_mod.addImport("math3d", math3d_mod);
    exe_mod.addImport("camera3d", camera3d_mod);

    const exe = b.addExecutable(.{
        .name = "vrgame",
        .root_module = exe_mod,
    });

    // Make sure OpenXR codegen happens before anything that imports xr_mod.
    exe.step.dependOn(&xr_gen_cmd.step);

    // GLFW + Vulkan loader
    exe.linkLibrary(glfw_lib);
    linkVulkanLoader(exe, target, b);

    // Install exe
    b.installArtifact(exe);

    // Shaders â†’ zig-out/bin/shaders
    const shaders_step = addShaderBuildSteps(b, exe);

    // Run
    const run_cmd = b.addRunArtifact(exe);
    run_cmd.step.dependOn(b.getInstallStep());
    run_cmd.step.dependOn(shaders_step);
    if (b.args) |args| run_cmd.addArgs(args);

    const run_step = b.step("run", "Run vrgame");
    run_step.dependOn(&run_cmd.step);

    // â”€â”€ Tests (ZTable-style: unit in files, integration/e2e in /tests) â”€â”€â”€â”€
    const unit_step = b.step("test-unit", "Run unit tests (modules)");
    const integration_step = b.step("test-integration", "Run integration tests");
    const e2e_step = b.step("test-e2e", "Run end-to-end tests");

    // Unit tests per module
    const run_main_tests = addTestRun(b, exe_mod);
    const run_graphics_context_tests = addTestRun(b, graphics_context_mod);
    const run_swapchain_tests = addTestRun(b, swapchain_mod);
    const run_vertex_tests = addTestRun(b, vertex_mod);
    const run_frame_time_tests = addTestRun(b, frame_time_mod);
    const run_game_tests = addTestRun(b, game_mod);
    const run_vrgame_root_tests = addTestRun(b, vrgame_root);
    const run_math3d_tests = addTestRun(b, math3d_mod);
    const run_camera3d_tests = addTestRun(b, camera3d_mod);

    // Any unit test can transitively pull XR; make them all depend on codegen.
    inline for ([_]*std.Build.Step.Run{
        run_main_tests,
        run_graphics_context_tests,
        run_swapchain_tests,
        run_vertex_tests,
        run_frame_time_tests,
        run_game_tests,
        run_vrgame_root_tests,
        run_math3d_tests,
        run_camera3d_tests,
    }) |r| {
        r.step.dependOn(&xr_gen_cmd.step);
        // If any unit test embeds SPIR-V later, this keeps them safe:
        r.step.dependOn(shaders_step);
    }

    unit_step.dependOn(&run_main_tests.step);
    unit_step.dependOn(&run_graphics_context_tests.step);
    unit_step.dependOn(&run_swapchain_tests.step);
    unit_step.dependOn(&run_vertex_tests.step);
    unit_step.dependOn(&run_frame_time_tests.step);
    unit_step.dependOn(&run_game_tests.step);
    unit_step.dependOn(&run_vrgame_root_tests.step);
    unit_step.dependOn(&run_math3d_tests.step);
    unit_step.dependOn(&run_camera3d_tests.step);

    // Integration tests (wired with imports; no relative @import)
    const have_integration = blk: {
        _ = std.fs.cwd().statFile("tests/test_all_integration.zig") catch break :blk false;
        break :blk true;
    };
    if (have_integration) {
        const integration_mod = b.createModule(.{
            .root_source_file = b.path("tests/test_all_integration.zig"),
            .target = target,
            .optimize = optimize,
        });
        integration_mod.addImport("glfw", glfw_mod);
        integration_mod.addImport("vulkan", vk_mod);
        integration_mod.addImport("openxr", xr_mod);
        integration_mod.addImport("graphics_context", graphics_context_mod);
        integration_mod.addImport("swapchain", swapchain_mod);
        integration_mod.addImport("math3d", math3d_mod);
        integration_mod.addImport("vertex", vertex_mod);
        integration_mod.addImport("frame_time", frame_time_mod);
        integration_mod.addImport("game", game_mod);
        integration_mod.addImport("vrgame", vrgame_root);
        integration_mod.addImport("camera3d", camera3d_mod);

        const integration_tests = b.addTest(.{ .root_module = integration_mod });
        // XR codegen + shaders must precede integration tests.
        integration_tests.step.dependOn(&xr_gen_cmd.step);
        integration_tests.step.dependOn(shaders_step);

        const run_integration = b.addRunArtifact(integration_tests);
        integration_step.dependOn(&run_integration.step);
    }

    // E2E tests
    const have_e2e = blk: {
        _ = std.fs.cwd().statFile("tests/test_all_e2e.zig") catch break :blk false;
        break :blk true;
    };
    if (have_e2e) {
        const e2e_mod = b.createModule(.{
            .root_source_file = b.path("tests/test_all_e2e.zig"),
            .target = target,
            .optimize = optimize,
        });
        e2e_mod.addImport("glfw", glfw_mod);
        e2e_mod.addImport("vulkan", vk_mod);
        e2e_mod.addImport("openxr", xr_mod);
        e2e_mod.addImport("graphics_context", graphics_context_mod);
        e2e_mod.addImport("swapchain", swapchain_mod);
        e2e_mod.addImport("vertex", vertex_mod);
        e2e_mod.addImport("frame_time", frame_time_mod);
        e2e_mod.addImport("game", game_mod);
        e2e_mod.addImport("vrgame", vrgame_root);
        e2e_mod.addImport("math3d", math3d_mod);
        e2e_mod.addImport("camera3d", camera3d_mod);

        const e2e_tests = b.addTest(.{ .root_module = e2e_mod });
        e2e_tests.step.dependOn(&xr_gen_cmd.step);
        e2e_tests.step.dependOn(shaders_step);

        const run_e2e = b.addRunArtifact(e2e_tests);
        e2e_step.dependOn(&run_e2e.step);
    }

    // Aggregate test steps + default
    const test_all_step = b.step("test-all", "Build vrgame + run unit, integration, and e2e tests");
    test_all_step.dependOn(b.getInstallStep());
    test_all_step.dependOn(unit_step);
    test_all_step.dependOn(integration_step);
    test_all_step.dependOn(e2e_step);

    const test_step = b.step("test", "Alias for test-all");
    test_step.dependOn(test_all_step);

    b.default_step = test_all_step;
}

<<<

`build.zig.zon`: >>>

.{
    .name = .vrgame,
    .version = "0.0.1",
    .fingerprint = 0xedc412406bf4c6ff,

    .minimum_zig_version = "0.16.0-dev.1470+32dc46aae",

    .dependencies = .{
        .glfw_zig = .{
            .url = "git+https://github.com/zigadel/glfw-zig#6c10f9d1ad2e17e20bb5621de731bc48f98a12f4",
            .hash = "glfw_zig-0.1.0-vua0KFK1AQCqxZBV8Aql1wll2j7rFJemjMa-Tov-nl-N",
        },
        .vulkan = .{
            .url = "git+https://github.com/Snektron/vulkan-zig#f69af7a9248982cf7536aaf32111843f1a4fa4a9",
            .hash = "vulkan-0.0.0-r7Ytx91DAwDKIXS2K_fFa-c_SJ5py7K1eCKwPcc33NcQ",
        },
        .openxr = .{
            .url = "git+https://github.com/zigadel/openxr-zig#ef4d73159ea71eaf496a83dd108e719e54831b8d",
            .hash = "openxr-0.0.0-KqIT7BW2AgBnSkNOTzbVt03CqNIGdto8RqNDGe76KuDs",
        },
    },

    .paths = .{
        "",
    },
}

<<<

`ideal-project-directory-structure.txt`: >>>

# vrgame â€” Ideal Project Directory Layout (FINAL v1)
# 3D freeâ€‘fly camera demo  â†’  PC+VR hero shooter (AAA stack)
#
# Legend:
#   [OK]   = exists & wired (in this repo today)
#   [TODO] = planned; create as we evolve
#   [OPT]  = optional / later, when ready
#   [GEN]  = generated at build/run time (not committed)
#
# Design invariants
# - Crossâ€‘platform first: Windows + macOS (MoltenVK) + Linux. No â€œworks on my OSâ€ regressions.
# - Unit tests live inline at the bottom of Zig source files. tests/ hosts integration/e2e/conformance.
# - src/root.zig is the public engine/game facade; src/main.zig is the PC demo launcher.
# - Graphics (GLFW + Vulkan + OpenXR) is under src/graphics and src/client/render.
# - Simulation/gameplay and input are separated from graphics and evolve in parallel.
# - ZDBs power longâ€‘lived data (players, matches, replays, telemetry), not perâ€‘frame world state.
# - Shaders: GLSL sources live under shaders/src; build.zig compiles to SPIRâ€‘V into shaders/ at install time
#   so the runtime looks up files next to the exe (e.g. ./shaders/triangle_vert).
#
# Phase milestones
# P0  Camera demo solid on Win/mac/Linux (viewport/projection parity locked by tests).
# P1  Real 3D scene (multiâ€‘mesh, transforms, depth, a light), zero 2D leftovers.
# P2  OpenXR desktop VR (instanced stereo, proper swapchain paths, controller input).
# P3  Client/Server split, prediction/reconciliation, bot match demo.
# P4  Replay format + viewer; beginning of hero shooter loop.
# P5  Liveops hooks (ZDBs), antiâ€‘cheat signals, matchmaking, telemetry.
#
# Topâ€‘level
vrgame/
|   [OK]  .gitattributes
|   [OK]  .gitignore
|   [OK]  build.zig
|   [OK]  build.zig.zon
|   [OK]  ideal-project-directory-structure.txt        # this file (keep truthful as reality changes)
|   [OK]  README.md                                    # current: 3D camera demo overview
|   [TODO] .editorconfig                               # shared Zigadel whitespace/style rules
|   [TODO] .dpignore                                   # for dump_project / vault tooling
|   [OPT]  LICENSE
|   [OPT]  CHANGELOG.md
|   [OPT]  CONTRIBUTING.md
|   [OPT]  SECURITY.md
|   [OPT]  CODEOWNERS
|
+---registry/                                          # registries kept inâ€‘repo for generators & sanity tests
|       [OK]  vk.xml
|       [OK]  xr.xml
|
+---shaders/                                           # runtimeâ€‘loaded SPIRâ€‘V blobs (placed next to exe)
|   [OK]  triangle.frag                                # SPIRâ€‘V binary produced by build.zig (name w/o .spv ok)
|   [OK]  triangle.vert
|   +---src/                                           # GLSL/HLSL/WGSL sources (authoring)
|   |       [TODO] triangle.vert.glsl
|   |       [TODO] triangle.frag.glsl
|   |       [TODO] basic_lit.vert.glsl
|   |       [TODO] basic_lit.frag.glsl
|   \---include/                                       # shared shader headers (ubos, common.glsl, etc.)
|           [TODO] common.glsl
|
+---assets/                                            # canonical home for art/audio/UI (authoring)
|   +---textures/
|   |       [TODO] checker.png
|   |       [TODO] hero_skyline.png
|   +---models/
|   |       [TODO] cube.gltf
|   |       [TODO] hero_skyline.gltf
|   +---audio/
|   |       [TODO] sfx_click.wav
|   |       [TODO] music_theme.ogg
|   \---ui/
|           [TODO] fonts/
|           [TODO] icons/
|           [TODO] layouts/
|
+---docs/
|       [TODO] ARCHITECTURE.md                         # engine, client, server, graphics, dataâ€‘plane
|       [TODO] GRAPHICS_STACK.md                       # glfwâ€‘zig + vulkanâ€‘zig + openxrâ€‘zig integration
|       [TODO] GAMEPLAY.md                             # heroes, roles, abilities, maps, modes
|       [TODO] NETCODE.md                              # prediction, reconciliation, lagâ€‘comp, hitâ€‘reg
|       [TODO] VR.md                                   # OpenXR flows, tracking, comfort modes, UX
|       [TODO] REPLAY.md                               # format, killâ€‘cam, highlight system
|       [TODO] ANTI_CHEAT.md                           # threat model, detection, policy, tooling
|       [TODO] MATCHMAKING.md                          # MMR, queues, parties
|       [TODO] PROGRESSION.md                          # XP, unlocks, cosmetics, guardrails
|       [TODO] ZDB_INTEGRATION.md                      # ZPlayerDB, ZMatchDB, ZReplayDB, ZTelemetryDB, ZACDB
|       [TODO] LIVEOPS.md                              # config rollout, patches, experiments
|       [TODO] PERF.md                                 # budgets, profiling, platform specifics
|
+---configs/
|       [TODO] default.zson                            # baseline (singleâ€‘player dev environment)
|       [TODO] dev.zson                                # dev overrides: verbose logs, localhost servers
|       [TODO] staging.zson                            # staging cluster config for Hydra
|       [TODO] production.zson                         # production config for Hydra/Zap
|       [OPT]  input_pc.zson                           # default PC keybinds/sensitivities
|       [OPT]  input_vr.zson                           # default VR bindings/comfort modes
|       [OPT]  graphics_presets.ztable                 # Low/Medium/High/Ultra presets
|
+---schemas/                                           # game/content/ZDB schemas (ZTable)
|       [TODO] heroes.ztable
|       [TODO] abilities.ztable
|       [TODO] maps.ztable
|       [TODO] modes.ztable
|       [TODO] matchmaking.ztable
|       [TODO] progression.ztable
|       [TODO] cosmetics.ztable
|       [TODO] telemetry_signals.ztable
|       [TODO] anti_cheat_signals.ztable
|
+---zdb/                                               # nonâ€‘primitive game DBs (fileâ€‘mode & clusterâ€‘mode)
|   +---ZPlayerDB/
|   |       [TODO] README.md
|   |       [TODO] config.zson
|   +---ZMatchDB/
|   |       [TODO] README.md
|   |       [TODO] config.zson
|   +---ZReplayDB/
|   |       [TODO] README.md
|   |       [TODO] config.zson
|   +---ZTelemetryDB/
|   |       [TODO] README.md
|   |       [TODO] config.zson
|   \---ZAntiCheatDB/
|           [TODO] README.md
|           [TODO] config.zson
|
+---deploy/
|   +---docker/
|   |       [TODO] Dockerfile.client
|   |       [TODO] Dockerfile.server
|   +---hydra/
|   |       [TODO] game_server.zson
|   |       [TODO] matchmaker.zson
|   |       [TODO] replay_worker.zson
|   |       [TODO] anticheat_worker.zson
|   \---zap/
|           [TODO] zap_routes.zson
|
+---examples/                                          # tiny, focused demos built on the real engine
|   +---01-local-sandbox/
|   |       [TODO] README.md
|   |       [TODO] src/main.zig                        # Skyline vs bots on a test map
|   +---02-bot-match/
|   |       [TODO] README.md
|   |       [TODO] src/main.zig                        # 6v6 bots; stress test net/sim
|   \---03-replay-viewer/
|           [TODO] README.md
|           [TODO] src/main.zig                        # standalone replay viewer
|
+---src/
|   [OK]  main.zig                                     # PC demo entry point (GLFW + Vulkan)
|   [OK]  root.zig                                     # public facade; wraps engine/client/server/tools
|   |
|   +---math/
|   |       [OK]  math3d.zig                           # Vec3/Mat4, projections, camera math
|   |       [TODO] geom.zig                            # AABB, frustum, intersections
|   |
|   +---game/
|   |       [OK]  camera3d.zig                         # canonical FPSâ€‘style Camera3D + CameraInput
|   |       [OK]  frame_time.zig                       # FrameTimer used by main.zig
|   |       [OK]  game.zig                             # legacy 2D sample; keep for reference
|   |
|   +---graphics/
|   |   [OK]  graphics_context.zig                     # Vk instance/device/queues/surface/allocator
|   |   [OK]  swapchain.zig                            # swapchain, resizeâ€‘safe recreation, sync, fences
|   |   [OK]  vertex.zig                               # vertex format + binding/attribute descs
|   |   \---camera/                                    # legacy math camera stack (kept for reference)
|   |           [OK]  camera.zig
|   |           [OK]  projection.zig
|   |           [OK]  transform.zig
|   |           [OK]  vector.zig
|   |           [OK]  view.zig
|   |
|   +---engine/                                        # simulation core (future)
|   |   +---core/
|   |   |       [TODO] math.zig                        # engineâ€‘level math faÃ§ade
|   |   |       [TODO] rng.zig
|   |   |       [TODO] time.zig
|   |   |       [TODO] world.zig
|   |   |       [TODO] physics.zig
|   |   |       [TODO] nav.zig
|   |   |       [TODO] movement.zig
|   |   |       [TODO] damage.zig
|   |   |       [TODO] status.zig
|   |   |       [TODO] projectiles.zig
|   |   +---lagrangian/
|   |   |       [TODO] base.zig                        # generic actionâ€‘graph engine
|   |   |       [TODO] ability.zig                     # cooldowns, charges, events
|   |   +---animation/
|   |   |       [TODO] skeleton.zig
|   |   |       [TODO] pose.zig
|   |   |       [TODO] ik.zig
|   |   |       [TODO] anim_graph.zig
|   |   +---biomech/
|   |   |       [TODO] rig.zig
|   |   |       [TODO] muscle.zig
|   |   |       [TODO] controller.zig
|   |   |       [TODO] contact.zig
|   |   +---audio/
|   |   |       [TODO] mixer.zig
|   |   |       [TODO] spatial.zig
|   |   |       [TODO] events.zig
|   |   +---vfx/
|   |   |       [TODO] system.zig
|   |   |       [TODO] events.zig
|   |   +---camera/
|   |   |       [TODO] pc_camera.zig                   # wraps game/camera3d.zig for PC
|   |   |       [TODO] vr_camera.zig                   # OpenXR head + controllers view
|   |   |       [TODO] spectator.zig
|   |   +---replay/
|   |   |       [TODO] recorder.zig
|   |   |       [TODO] player.zig
|   |   |       [TODO] highlight.zig
|   |   \---anti_cheat/
|   |           [TODO] signals.zig
|   |           [TODO] detector.zig
|   |           [TODO] review.zig
|   |
|   +---gameplay/
|   |   +---heroes/
|   |   |       [TODO] catalog.zig                     # register Skyline/Cascade/Bastion/Rupture
|   |   |       [TODO] hero_skyline.zig                # DPS: airâ€‘blade
|   |   |       [TODO] hero_cascade.zig                # Support: waterâ€‘bender
|   |   |       [TODO] hero_bastion_guard.zig          # Tank: shieldâ€‘breaker
|   |   |       [TODO] hero_rupture_gauntlet.zig       # Brawler: diver
|   |   +---abilities/
|   |   |       [TODO] ability_defs.zig
|   |   |       [TODO] ability_air_slash.zig
|   |   |       [TODO] ability_ice_ramp.zig
|   |   |       [TODO] ability_tidal_heal.zig
|   |   |       [TODO] ability_shield_break.zig
|   |   |       [TODO] ability_meteor_fist.zig
|   |   +---maps/
|   |   |       [TODO] map_catalog.zig
|   |   |       [TODO] script_city_rooftops.zig
|   |   |       [TODO] script_canal_plaza.zig
|   |   |       [TODO] script_foundry_crossing.zig
|   |   +---modes/
|   |   |       [TODO] mode_payload.zig
|   |   |       [TODO] mode_control_point.zig
|   |   |       [TODO] mode_hybrid.zig
|   |   +---progression/
|   |   |       [TODO] xp.zig
|   |   |       [TODO] unlocks.zig
|   |   \---economy/
|   |           [TODO] currencies.zig
|   |           [TODO] store.zig
|   |
|   +---net/
|   |       [TODO] protocol.zig
|   |       [TODO] snapshot.zig
|   |       [TODO] prediction.zig
|   |       [TODO] lag_comp.zig
|   |
|   +---client/
|   |   [TODO] app.zig                                  # client runtime; wraps graphics + engine
|   |   [TODO] loop.zig                                 # main loop; inputâ†’simâ†’render
|   |   +---input/
|   |   |       [TODO] pc.zig
|   |   |       [TODO] vr.zig
|   |   |       [TODO] accessibility.zig
|   |   +---render/
|   |   |       [TODO] vulkan_device.zig
|   |   |       [TODO] vulkan_renderer.zig
|   |   |       [TODO] openxr_session.zig
|   |   |       [TODO] glfw_window.zig
|   |   |       [TODO] post_process.zig
|   |   |       [TODO] debug_draw.zig
|   |   \---ui/
|   |           [TODO] hud.zig
|   |           [TODO] menus.zig
|   |           [TODO] scoreboard.zig
|   |           [TODO] social.zig
|   |
|   +---server/
|   |   [TODO] app.zig
|   |   [TODO] loop.zig
|   |   +---auth/
|   |   |       [TODO] sessions.zig
|   |   +---match/
|   |   |       [TODO] session.zig
|   |   |       [TODO] rules.zig
|   |   |       [TODO] matchmaking.zig
|   |   +---bots/
|   |   |       [TODO] ai_controller.zig
|   |   |       [TODO] behavior.zig
|   |   +---net/
|   |   |       [TODO] listener.zig
|   |   |       [TODO] client_conn.zig
|   |   \---zdb_hooks/
|   |           [TODO] player_sync.zig
|   |           [TODO] match_log.zig
|   |           [TODO] replay_export.zig
|   |           [TODO] telemetry_export.zig
|   |           [TODO] anticheat_export.zig
|   |
|   \---lib/
|           [TODO] bitset.zig
|           [TODO] pool.zig
|           [TODO] ring_buffer.zig
|           [TODO] string_pool.zig
|           [OPT]  logger.zig
|
+---tests/                                             # inline unit tests stay in source files; these are higher level
|   [OK]  test_all_conformance.zig
|   [OK]  test_all_e2e.zig
|   [OK]  test_all_integration.zig
|   [OK]  _support.zig
|   +---conformance/
|   |       [OK]  pipeline_defaults.zig
|   |       [TODO] test_config_conformance.zig
|   |       [TODO] test_schema_conformance.zig
|   |       [TODO] test_protocol_conformance.zig
|   |       [TODO] test_zdb_integration_conformance.zig
|   +---integration/
|   |       [OK]  camera3d_exports.zig
|   |       [OK]  camera3d_public_decls.zig
|   |       [OK]  frame_time_exports.zig
|   |       [OK]  frame_time_public_decls.zig
|   |       [OK]  glfw_exports.zig
|   |       [OK]  glfw_vulkan_headers_sanity.zig
|   |       [OK]  glsl_sources_present.zig
|   |       [OK]  graphics_context_exports.zig
|   |       [OK]  graphics_context_public_decls.zig
|   |       [OK]  math3d_lookat_orthonormal.zig
|   |       [OK]  math3d_mul_props.zig
|   |       [OK]  math3d_perspective_basic.zig
|   |       [OK]  math3d_projection_props.zig
|   |       [OK]  math3d_sanity.zig
|   |       [OK]  math3d_viewproj_center_ndc.zig
|   |       [OK]  repo_layout_sanity.zig
|   |       [OK]  shader_sources_exist.zig
|   |       [OK]  shaders_exist.zig
|   |       [OK]  swapchain_public_decls.zig
|   |       [OK]  types_size_sanity.zig
|   |       [OK]  vertex_contract.zig
|   |       [OK]  vertex_layout.zig
|   |       [OK]  vk_headers_sanity.zig
|   |       [OK]  xr_headers_sanity.zig
|   |       [OK]  xr_registry_exists.zig
|   |       [TODO] viewport_projection_y_parity.zig     # asserts: mac uses negative viewport height; others flip proj
|   \---e2e/
|           [OK]  smoke_cli_build.zig
|           [TODO] test_local_sandbox_cli.zig
|           [TODO] test_dedicated_server_cli.zig
|           [TODO] test_match_flow_e2e.zig
|           [TODO] test_liveops_config_rollout.zig
|
+---tools/
|   +---bench/
|   |       [TODO] core_physics.zig
|   |       [TODO] net_pipeline.zig
|   |       [TODO] lagrangian.zig
|   |       [TODO] biomech.zig
|   |       [TODO] bench_all.zig
|   +---dev/
|   |       [TODO] hero_editor.zig
|   |       [TODO] map_editor.zig
|   |       [TODO] replay_tools.zig
|   |       [TODO] telemetry_inspector.zig
|   \---scripts/
|           [TODO] fmt.sh
|           [TODO] dev.ps1
|           [TODO] build_assets.sh
|           [TODO] release_notes_from_git.sh
|
+---third_party/
|   [OPT]  glfw/                                      # only if vendoring C sources instead of Zon deps
|   [OPT]  imgui/                                     # future: Dear ImGui
|   [OPT]  audio_backend/                             # e.g., miniaudio
|
\---ci/
        [OPT]  github-actions.yml                      # matrix (Win/mac/Linux), zig 0.16 nightly, shader build smoke
        [OPT]  precommit.sh

# Build & run cheatsheet
#   zig build test-all --summary all
#   zig build run
#
# Crossâ€‘platform Yâ€‘parity rule (lock by test):
#   macOS (MoltenVK):   negative viewport height, keep standard projection.
#   Windows/Linux:      standard viewport, flip projection by negating m[5].
# This yields identical controls/camera sense and correct â€œfloor is floorâ€ everywhere.

<<<

`README.md`: >>>

# zig-glfw-vulkan-openxr

Cross-compatible **Zig (nightly) + GLFW + Vulkan** triangle demo, wired up with:

- [`glfw-zig`](https://github.com/zigadel/glfw-zig) for windowing and input  
- [`vulkan-zig`](https://github.com/Snektron/vulkan-zig) for Vulkan bindings + codegen  
- A small but realistic **graphics stack**: instance, device, swapchain, pipeline, command buffers, resize handling, etc.

---

## What this example shows

- How to use **glfw-zig** to create a Vulkan-compatible window (no client API).
- How to integrate **vulkan-zig**:
  - Auto-generate `vk.zig` from `vk.xml` at build time.
  - Use the generated loader (`vkb`, `vki`, `vkd`) in idiomatic Zig.
- A clean separation of concerns:
  - `graphics_context.zig` â€“ instance, device, queues, surface, allocator.
  - `swapchain.zig` â€“ swapchain creation, resize-safe recreation, per-frame sync.
  - `vertex.zig` â€“ vertex format and binding/attribute descriptions.
- **SPIR-V shader** compilation via `glslc`, embedded with `@embedFile`.
- Cross-platform behavior:
  - **Windows**: LunarG Vulkan SDK + `vulkan-1.dll`
  - **macOS**: MoltenVK (`libvulkan.dylib` â†’ `libMoltenVK.dylib`)
  - **Linux**: system Vulkan loader (`libvulkan.so`)

---

## Requirements

### 1. Zig

- A recent **Zig 0.16.0-dev** build (same major/dev line as the one used in `build.zig.zon`).
- Make sure `zig` is on your `PATH`.

### 2. Vulkan loader + drivers

You need a working Vulkan runtime + loader for your platform.

**Windows**

- Install the LunarG Vulkan SDK: <https://vulkan.lunarg.com/sdk/home>  
  This gives you:
  - `vulkan-1.dll` (loader)
  - GPU drivers integration
  - `glslc` and tools

**macOS**

- Install the Vulkan SDK for macOS (which includes MoltenVK), **or**:
  - Install MoltenVK + loader via your package manager (e.g. Homebrew).
- You should end up with:
  - `libvulkan.dylib` in a system or SDK location
  - `libMoltenVK.dylib` available to the loader

**Linux**

- Install Vulkan loader + dev packages via your distro:
  - e.g. `vulkan-loader`, `vulkan-tools`, appropriate Mesa/NVIDIA/AMD drivers.

### 3. `glslc` (shader compiler)

The build calls `glslc` to compile the shaders in `shaders/` to SPIR-V.

- If you installed the Vulkan SDK, `glslc` is already there.
- Just ensure itâ€™s on your `PATH`:
  - **macOS example** (`~/.zprofile`):

    ```sh
    export PATH="$PATH:$HOME/VulkanSDK/<VERSION>/macOS/bin"
    ```

  - **Windows**: the SDK installer can add this automatically; otherwise add the `bin` folder manually to `PATH`.

---

## vk.xml / vulkan-zig integration

`vulkan-zig` generates `vk.zig` from the official **Vulkan registry XML** (`vk.xml`).

This project uses a **â€œbest of both worldsâ€** approach:

- If `registry/vk.xml` exists (youâ€™ve pinned a specific version), it is used.
- Otherwise, the **first `zig build`** will:
  - Create `registry/` (if needed).
  - Download the latest `vk.xml` from the Khronos GitHub repo into `registry/vk.xml`.
  - Run the `vulkan-zig` generator to produce `vk.zig` in the Zig cache.

`registry/vk.xml` is **git-ignored** so your repo stays light, but you still get reproducible builds once itâ€™s been fetched once.

You normally **donâ€™t need to do anything manually**. Just:

```sh
zig build
```

and let the build script handle it.

If you want to pin a specific registry version (e.g. for long-term reproducibility):

1. Download `vk.xml` from the Vulkan-Docs repo.

2. Place it at `registry/vk.xml`.

3. Commit everything except `vk.xml` itself (it remains in `.gitignore`)

## Cloning & running the example

```sh
git clone https://github.com/James-Riordan/zig-glfw-vulkan-openxr.git
cd zig-glfw-vulkan-openxr
```

Build & run in one go:

```sh
zig build run
```

On the first build, you will see steps like:

- `run exe vulkan-zig-generator (vk.zig)`
- `run curl (vk.xml)`
- `run glslc (triangle_vert.spv)`
- `run glslc (triangle_frag.spv)`

After that, incremental builds will be much faster.

You should see a window with a **colored triangle** rendered via Vulkan.
Resizing the window will trigger a **safe swapchain recreation** (tested on Windows + macOS via MoltenVK)

## Repository layout

High-level structure (only the interesting bits):

```txt
zig-glfw-vulkan-openxr/
â”œâ”€ src/
â”‚  â”œâ”€ main.zig                    # Entry point; GLFW loop, wiring everything together
â”‚  â””â”€ graphics/
â”‚     â”œâ”€ graphics_context.zig     # Vulkan instance, device, queues, surface, allocator
â”‚     â”œâ”€ swapchain.zig            # Swapchain + per-frame sync + resize-safe recreation
â”‚     â””â”€ vertex.zig               # Vertex struct + binding/attribute descriptions
â”œâ”€ shaders/
â”‚  â”œâ”€ triangle.vert               # GLSL vertex shader
â”‚  â””â”€ triangle.frag               # GLSL fragment shader
â”œâ”€ registry/
â”‚  â””â”€ vk.xml                      # (ignored by git) Vulkan registry; auto-fetched if absent
â”œâ”€ build.zig                      # Build script: deps, shader compilation, vk.xml handling
â”œâ”€ build.zig.zon                  # Zig package dependencies (glfw-zig, vulkan-zig)
â””â”€ README.md                      # You are here
```

## Troubleshooting

`curl: command not found`

- Install `curl` and ensure itâ€™s on your `PATH`.
The build uses it once to download `vk.xml` if itâ€™s missing.

`glslc: command not found`

- Install the Vulkan SDK or `glslc` via your package manager.

- Confirm `glslc` is visible in your terminal shell (`glslc --version`).

`IncompatibleDriver` / **Vulkan initialization errors**

- Usually means:

    - No Vulkan-capable GPU/driver.

    - MoltenVK / Vulkan loader not properly installed or discoverable.

- On macOS, double-check your **Vulkan SDK / MoltenVK** install and that `libvulkan.dylib` + `libMoltenVK.dylib` are in the expected locations.

**Weird crashes on window resize**

- This codebase already includes a safe swapchain recreation path (create new swapchain first, then tear down the old one).

- If you see issues, theyâ€™re likely from:

    - A partially broken Vulkan install.

    - Very old drivers / SDK.

- Updating your Vulkan SDK + GPU drivers usually resolves it.

Thatâ€™s it. This repo is meant to be a **clean, minimal reference** for:

- `glfw-zig` windowing

- `vulkan-zig` integration

- A small but realistic Vulkan render loop in Zig

From here you can start layering in descriptor sets, depth buffers, multiple pipelines, or (eventually) OpenXR on top
<<<

`_support.zig`: >>>

const std = @import("std");

pub const A = std.testing.allocator;

/// Safe file read with hard cap to avoid OOM in tests.
pub fn readFileAllocLimit(path: []const u8, limit_bytes: usize) ![]u8 {
    const Limit = std.Io.Limit;
    const lim: Limit = @enumFromInt(limit_bytes);
    return try std.fs.cwd().readFileAlloc(path, A, lim);
}

/// Simple PRNG for property tests (seeded deterministically per test seed).
pub fn prng() std.rand.DefaultPrng {
    var seed: u64 = 0xC0FFEE;
    // Mix in the global test seed if available in env (optional).
    if (std.process.getEnvVarOwned(A, "ZTEST_SEED")) |s| {
        defer A.free(s);
        seed ^= std.hash.Wyhash.hash(0, s);
    }
    return std.rand.DefaultPrng.init(seed);
}

/// Approx helpers
pub fn approxEq(a: f32, b: f32, eps: f32) bool {
    return @abs(a - b) <= eps;
}

pub fn approxVec3(a: anytype, b: anytype, eps: f32) bool {
    return approxEq(a.x, b.x, eps) and approxEq(a.y, b.y, eps) and approxEq(a.z, b.z, eps);
}

<<<

`test_all_conformance.zig`: >>>

const std = @import("std");

test {
    _ = @import("conformance/pipeline_defaults.zig");
}

test {
    std.testing.refAllDecls(@This());
}

<<<

`test_all_e2e.zig`: >>>

const std = @import("std");

test {
    _ = @import("e2e/smoke_cli_build.zig");
}

test {
    std.testing.refAllDecls(@This());
}

<<<

`test_all_integration.zig`: >>>

const std = @import("std");

test {
    _ = @import("integration/math3d_sanity.zig");
    _ = @import("integration/math3d_projection_props.zig");
    _ = @import("integration/shaders_exist.zig");
    _ = @import("integration/glsl_sources_present.zig");
    _ = @import("integration/xr_registry_exists.zig");
    _ = @import("integration/vertex_contract.zig");
    _ = @import("integration/graphics_context_exports.zig");
    _ = @import("integration/camera3d_exports.zig");
    _ = @import("integration/frame_time_exports.zig");
    _ = @import("integration/vk_structs_compile.zig");
    _ = @import("integration/glfw_exports.zig");
    _ = @import("integration/math3d_lookat_orthonormal.zig");
    _ = @import("integration/math3d_perspective_basic.zig");
    _ = @import("integration/xr_headers_sanity.zig");
    _ = @import("integration/types_size_sanity.zig");
    _ = @import("integration/shader_sources_exist.zig");
    _ = @import("integration/math3d_viewproj_center_ndc.zig");
    _ = @import("integration/graphics_context_public_decls.zig");
    _ = @import("integration/swapchain_public_decls.zig");
    _ = @import("integration/camera3d_public_decls.zig");
    _ = @import("integration/frame_time_public_decls.zig");
    _ = @import("integration/glfw_vulkan_headers_sanity.zig");
    _ = @import("integration/repo_layout_sanity.zig");
}

test {
    std.testing.refAllDecls(@This());
}

<<<

`camera3d_exports.zig`: >>>

const std = @import("std");
const camera3d = @import("camera3d");
const math3d = @import("math3d");

test "camera3d: basic exports exist" {
    try std.testing.expect(@hasDecl(camera3d, "Camera3D"));
    try std.testing.expect(@hasDecl(camera3d, "CameraInput"));
}

// If Camera3D exposes view/proj, sanity-check theyâ€™re finite when eye looks at origin.
test "camera3d: view*proj finite if available" {
    if (@hasDecl(camera3d, "Camera3D")) {
        const eye = math3d.Vec3.init(0, 0, 5);
        const center = math3d.Vec3.init(0, 0, 0);
        const up = math3d.Vec3.init(0, 1, 0);

        const view = math3d.Mat4.lookAt(eye, center, up);
        const proj = math3d.Mat4.perspective(std.math.degreesToRadians(70.0), 16.0 / 9.0, 0.1, 100.0);
        const vp = math3d.Mat4.mul(proj, view);

        // elements finite
        for (vp.m) |x| try std.testing.expect(std.math.isFinite(x));
    }
}

<<<

`camera3d_public_decls.zig`: >>>

const std = @import("std");
const cam = @import("camera3d");

test "integration: camera3d exports Camera3D & CameraInput" {
    try std.testing.expect(@hasDecl(cam, "Camera3D"));
    try std.testing.expect(@hasDecl(cam, "CameraInput"));
}

<<<

`frame_time_exports.zig`: >>>

const std = @import("std");
const frame_time = @import("frame_time");

test "frame_time: exports exist" {
    try std.testing.expect(@hasDecl(frame_time, "FrameTimer"));
    // Add deeper checks later once we lock the API surface.
}

<<<

`frame_time_public_decls.zig`: >>>

const std = @import("std");
const ft = @import("frame_time");

test "integration: frame_time exports FrameTimer (+tick or update)" {
    try std.testing.expect(@hasDecl(ft, "FrameTimer"));

    const has_tick_module = @hasDecl(ft, "tick");
    const has_update_module = @hasDecl(ft, "update");

    const has_tick_type =
        @hasDecl(ft, "FrameTimer") and
        @hasDecl(ft.FrameTimer, "tick");

    const has_update_type =
        @hasDecl(ft, "FrameTimer") and
        @hasDecl(ft.FrameTimer, "update");

    try std.testing.expect(has_tick_module or has_update_module or has_tick_type or has_update_type);
}

<<<

`frame_timer_window.zig`: >>>

const std = @import("std");
const FrameTimer = @import("frame_time").FrameTimer;

test "integration: FrameTimer emits fps in ~1s window" {
    var ft = FrameTimer.init(0, 1000);
    var ms: i64 = 0;
    var saw = false;
    while (ms < 1200) : (ms += 16) {
        const t = ft.tick(ms);
        if (t.fps_updated) {
            saw = true;
            try std.testing.expect(t.fps > 40 and t.fps < 80);
        }
    }
    try std.testing.expect(saw);
}

<<<

`glfw_exports.zig`: >>>

const std = @import("std");
const glfw = @import("glfw");

test "glfw wrapper: essential symbols present" {
    // We donâ€™t actually open a window in integration tests â€” just ensure API is wired.
    try std.testing.expect(@hasDecl(glfw, "init"));
    try std.testing.expect(@hasDecl(glfw, "terminate"));
    try std.testing.expect(@hasDecl(glfw, "getVersion"));
}

<<<

`glfw_vulkan_headers_sanity.zig`: >>>

const std = @import("std");
const glfw = @import("glfw");
const vk = @import("vulkan");

test "integration: glfw + vulkan headers expose core types" {
    try std.testing.expect(@hasDecl(glfw, "Window"));
    try std.testing.expect(@hasDecl(glfw, "init"));
    try std.testing.expect(@hasDecl(vk, "Instance"));
    try std.testing.expect(@hasDecl(vk, "Device"));
}

<<<

`glsl_sources_present.zig`: >>>

const std = @import("std");

test "glsl sources present" {
    // just assert they can be stat'd; discard the Stat value
    _ = try std.fs.cwd().statFile("shaders/triangle.vert");
    _ = try std.fs.cwd().statFile("shaders/triangle.frag");
}

<<<

`graphics_context_exports.zig`: >>>

const std = @import("std");
const gc = @import("graphics_context");

test "graphics_context: core exports exist" {
    try std.testing.expect(@hasDecl(gc, "GraphicsContext"));
    // Keep this flexible; add more once API surface is locked.
}

<<<

`graphics_context_public_decls.zig`: >>>

const std = @import("std");
const gc = @import("graphics_context");

test "integration: GraphicsContext exposes expected public decls" {
    try std.testing.expect(@hasDecl(gc, "GraphicsContext"));

    // accept either a top-level init function or a builder/init struct
    const ok =
        @hasDecl(gc, "init") or
        @hasDecl(gc, "initInstanceOnly") or
        (@hasDecl(gc.GraphicsContext, "init")) or
        (@hasDecl(gc.GraphicsContext, "initInstanceOnly")) or
        (@hasDecl(gc, "Builder")) or
        (@hasDecl(gc, "create") or @hasDecl(gc, "createInstance"));

    try std.testing.expect(ok);
}

<<<

`math3d_lookat_orthonormal.zig`: >>>

const std = @import("std");
const math3d = @import("math3d");

test "integration: lookAt produces an orthonormal basis" {
    const eye = math3d.Vec3.init(1.0, 2.0, 3.0);
    const center = math3d.Vec3.init(0.0, 0.0, 0.0);
    const up = math3d.Vec3.init(0.0, 1.0, 0.0);

    const V = math3d.Mat4.lookAt(eye, center, up);
    const m = V.m;

    // Column-major: [col*4 + row]
    const s = math3d.Vec3.init(m[0], m[1], m[2]); // right
    const u_axis = math3d.Vec3.init(m[4], m[5], m[6]); // up
    const neg_f = math3d.Vec3.init(m[8], m[9], m[10]); // -forward

    const tol: f32 = 1e-5;
    try std.testing.expectApproxEqAbs(@as(f32, 1.0), s.length(), tol);
    try std.testing.expectApproxEqAbs(@as(f32, 1.0), u_axis.length(), tol);
    try std.testing.expectApproxEqAbs(@as(f32, 1.0), neg_f.length(), tol);

    try std.testing.expectApproxEqAbs(@as(f32, 0.0), s.dot(u_axis), 1e-4);
    try std.testing.expectApproxEqAbs(@as(f32, 0.0), s.dot(neg_f), 1e-4);
    try std.testing.expectApproxEqAbs(@as(f32, 0.0), u_axis.dot(neg_f), 1e-4);
}

<<<

`math3d_mul_props.zig`: >>>

const std = @import("std");
const math3d = @import("math3d");

test "Mat4.mul respects identity on both sides" {
    const I = math3d.Mat4.identity();

    // Random but fixed values to avoid NaNs.
    var M = math3d.Mat4.identity();
    // Nudge a couple entries to make it non-trivial.
    M.m[0] = 2.0;
    M.m[5] = 3.0;
    M.m[10] = 4.0;
    M.m[12] = 1.0;
    M.m[13] = -2.0;
    M.m[14] = 0.5;

    const left = math3d.Mat4.mul(I, M);
    const right = math3d.Mat4.mul(M, I);

    inline for (0..16) |i| {
        try std.testing.expectApproxEqAbs(M.m[i], left.m[i], 1e-6);
        try std.testing.expectApproxEqAbs(M.m[i], right.m[i], 1e-6);
    }
}

<<<

`math3d_perspective_basic.zig`: >>>

const std = @import("std");
const math3d = @import("math3d");

test "integration: perspective matrix core entries" {
    const fov: f32 = std.math.degreesToRadians(60.0);
    const aspect: f32 = 16.0 / 9.0;
    const near: f32 = 0.1;
    const far: f32 = 100.0;

    const P = math3d.Mat4.perspective(fov, aspect, near, far);
    const m = P.m;

    const f = 1.0 / @tan(fov / 2.0);
    const tol: f32 = 1e-5;

    // [0,0] and [1,1]
    try std.testing.expectApproxEqAbs(@as(f32, f / aspect), m[0], tol);
    try std.testing.expectApproxEqAbs(@as(f32, f), m[5], tol);

    // Z mapping (Vulkan/D3D-style: [0,1])
    try std.testing.expectApproxEqAbs(@as(f32, far / (near - far)), m[10], tol);
    try std.testing.expectApproxEqAbs(@as(f32, (far * near) / (near - far)), m[14], tol);

    // -1 in [2,3] (row 2, col 3) â†’ index col=3,row=2 â†’ 3*4+2 = 14? (we already used 14 above)
    // The -1 lives at [2,3] = m[11] (col=3,row=2 â†’ 3*4+2 = 14; careful: here it's [*row* 2, col 3] = m[11])
    // Our implementation sets m[idx(2,3)] = -1 â†’ that is m[11].
    try std.testing.expectApproxEqAbs(@as(f32, -1.0), m[11], tol);
}

<<<

`math3d_projection_props.zig`: >>>

const std = @import("std");
const math3d = @import("math3d");

test "math3d.perspective basic coefficients sane" {
    const fov = std.math.degreesToRadians(70.0);
    const aspect: f32 = 16.0 / 9.0;
    const near: f32 = 0.1;
    const far: f32 = 100.0;

    const P = math3d.Mat4.perspective(fov, aspect, near, far);

    // Focal terms present and finite
    try std.testing.expect(std.math.isFinite(P.m[0])); // m00
    try std.testing.expect(std.math.isFinite(P.m[5])); // m11

    // Depth row/column follow our convention
    try std.testing.expectApproxEqAbs(@as(f32, far / (near - far)), P.m[10], 1e-5); // m22
    try std.testing.expectApproxEqAbs(@as(f32, -1.0), P.m[11], 1e-6); // m23
    try std.testing.expectApproxEqAbs(@as(f32, (far * near) / (near - far)), P.m[14], 1e-5); // m32

    // No NaNs anywhere
    for (P.m) |x| try std.testing.expect(std.math.isFinite(x));
}

<<<

`math3d_sanity.zig`: >>>

const std = @import("std");
const math3d = @import("math3d");
const Mat4 = math3d.Mat4;

test "integration: Mat4 identity behaves" {
    var I = Mat4.identity();
    const v = [4]f32{ 1, 2, 3, 1 };
    const out = I.mulVec4(v);
    try std.testing.expectEqualDeep(v, out);
}

<<<

`math3d_viewproj_center_ndc.zig`: >>>

const std = @import("std");
const math3d = @import("math3d");

test "integration: P*V maps world origin near NDC center (xâ‰ˆ0,yâ‰ˆ0, z in [0,1])" {
    const eye = math3d.Vec3.init(0.0, 0.0, 3.0);
    const center = math3d.Vec3.init(0.0, 0.0, 0.0);
    const up = math3d.Vec3.init(0.0, 1.0, 0.0);

    const V = math3d.Mat4.lookAt(eye, center, up);
    const P = math3d.Mat4.perspective(std.math.degreesToRadians(60.0), 16.0 / 9.0, 0.1, 100.0);
    const VP = math3d.Mat4.mul(P, V);

    const clip = VP.transformPoint(center);

    try std.testing.expectApproxEqAbs(@as(f32, 0.0), clip.x, 2e-3);
    try std.testing.expectApproxEqAbs(@as(f32, 0.0), clip.y, 2e-3);
    try std.testing.expect(clip.z >= 0.0 and clip.z <= 1.0);
}

<<<

`repo_layout_sanity.zig`: >>>

const std = @import("std");
const fs = std.fs;
const mem = std.mem;

/// Does `abs_dir/name` exist and is it a directory?
fn containsSubdir(alloc: mem.Allocator, abs_dir: []const u8, name: []const u8) bool {
    const p = std.fs.path.join(alloc, &.{ abs_dir, name }) catch return false;
    defer alloc.free(p);

    var d = fs.openDirAbsolute(p, .{}) catch return false;
    d.close();
    return true;
}

/// Walk upward from CWD until we find a directory that contains "src".
fn findWorkspaceRoot(alloc: mem.Allocator) ![]u8 {
    var cur = try fs.cwd().realpathAlloc(alloc, ".");
    errdefer alloc.free(cur);

    while (true) {
        if (containsSubdir(alloc, cur, "src")) return cur;

        const parent_opt = std.fs.path.dirname(cur);
        if (parent_opt) |parent| {
            if (mem.eql(u8, parent, cur)) break; // reached FS root
            const next = try alloc.dupe(u8, parent);
            alloc.free(cur);
            cur = next;
        } else break;
    }

    alloc.free(cur);
    return error.NotFound;
}

test "repo layout sanity" {
    const A = std.testing.allocator;

    const root = try findWorkspaceRoot(A);
    defer A.free(root);

    // Must at least have `src/` at the workspace root.
    try std.testing.expect(containsSubdir(A, root, "src"));

    // And we can open that root dir.
    var rd = try fs.openDirAbsolute(root, .{});
    defer rd.close();
}

<<<

`shader_sources_exist.zig`: >>>

const std = @import("std");

fn exists(path: []const u8) bool {
    _ = std.fs.cwd().statFile(path) catch return false;
    return true;
}

test "shader sources exist" {
    try std.testing.expect(exists("shaders/triangle.vert"));
    try std.testing.expect(exists("shaders/triangle.frag"));
}

<<<

`shaders_exist.zig`: >>>

const std = @import("std");

const A = std.testing.allocator;

inline fn exists(path: []const u8) bool {
    _ = std.fs.cwd().statFile(path) catch return false;
    return true;
}

fn ensureDir(path: []const u8) !void {
    try std.fs.cwd().makePath(path);
}

fn readFileAllocLimit(path: []const u8, limit_bytes: usize) ![]u8 {
    const lim: std.Io.Limit = @enumFromInt(limit_bytes);
    return try std.fs.cwd().readFileAlloc(path, A, lim);
}

fn runGlslc(argv: []const []const u8) !void {
    const res = try std.process.Child.run(.{
        .allocator = A,
        .argv = argv,
        .max_output_bytes = 1 << 20,
    });
    defer {
        A.free(res.stdout);
        A.free(res.stderr);
    }

    switch (res.term) {
        .Exited => |code| {
            if (code != 0) {
                std.debug.print("glslc failed (code {d})\n{s}\n", .{ code, res.stderr });
                return error.GlslcFailed;
            }
        },
        else => {
            std.debug.print("glslc did not exit normally\n", .{});
            return error.GlslcFailed;
        },
    }
}

/// Compile only (no link) and write to `out` with -o.
/// We pass exactly one input file and make the output explicit.
fn compileIfMissing(stage: []const u8, src: []const u8, out: []const u8) !void {
    if (exists(out)) return;

    const parent = std.fs.path.dirname(out) orelse ".";
    try ensureDir(parent);

    const flag = try std.fmt.allocPrint(A, "-fshader-stage={s}", .{stage});
    defer A.free(flag);

    const argv = [_][]const u8{
        "glslc",
        "-c",
        flag,
        src,
        "-o",
        out,
    };
    try runGlslc(&argv);

    if (!exists(out)) return error.FileNotFound;
}

test "compiled SPIR-V files exist and are valid-looking" {
    const out_root = "zig-out/shaders";
    try ensureDir(out_root);

    const targets = [_]struct {
        name: []const u8,
        stage: []const u8,
        src: []const u8,
    }{
        .{ .name = "triangle_vert", .stage = "vert", .src = "shaders/triangle.vert" },
        .{ .name = "triangle_frag", .stage = "frag", .src = "shaders/triangle.frag" },
    };

    for (targets) |t| {
        const out_path = try std.fs.path.join(A, &.{ out_root, t.name });
        defer A.free(out_path);

        if (!exists(out_path)) {
            if (!exists(t.src)) {
                std.debug.print("Shader source missing: {s}\n", .{t.src});
                return error.TestExpectedEqual;
            }
            try compileIfMissing(t.stage, t.src, out_path);
        }

        const buf = try readFileAllocLimit(out_path, 16 * 1024 * 1024);
        defer A.free(buf);

        try std.testing.expect(buf.len >= 8);

        // SPIR-V magic number 0x07230203 (little endian on disk).
        const magic = std.mem.readInt(u32, buf[0..4], .little);
        try std.testing.expectEqual(@as(u32, 0x07230203), magic);

        // Version dword is next (sanity read only).
        const _version = std.mem.readInt(u32, buf[4..8], .little);
        _ = _version;
    }
}

<<<

`swapchain_public_decls.zig`: >>>

const std = @import("std");
const swap = @import("swapchain");

test "integration: Swapchain module basic API surface" {
    // Accept either struct+methods or free helpers.
    const ok =
        @hasDecl(swap, "Swapchain") or
        @hasDecl(swap, "SupportDetails") or
        @hasDecl(swap, "chooseSurfaceFormat") or
        @hasDecl(swap, "create") or
        (@hasDecl(swap, "acquireNext") or @hasDecl(swap, "acquire"));

    try std.testing.expect(ok);
}

<<<

`types_size_sanity.zig`: >>>

const std = @import("std");
const math3d = @import("math3d");
const vertex = @import("vertex");

test "integration: math3d sizes and alignments" {
    try std.testing.expect(@sizeOf(math3d.Vec3) == 12);
    try std.testing.expect(@alignOf(math3d.Vec3) == 4);

    try std.testing.expect(@sizeOf(math3d.Mat4) == 64);
    try std.testing.expect(@alignOf(math3d.Mat4) == 4);
}

test "integration: vertex stride/attributes sane" {
    const bd = vertex.Vertex.binding_description;
    try std.testing.expect(bd.stride > 0);
    try std.testing.expect(bd.stride % 4 == 0);

    // Allow user-defined padding; just assert struct fits within stride.
    try std.testing.expect(bd.stride >= @sizeOf(vertex.Vertex));

    var prev_off: u32 = 0;
    for (vertex.Vertex.attribute_description, 0..) |ad, i| {
        try std.testing.expect(ad.offset < bd.stride);
        if (i != 0) try std.testing.expect(ad.offset >= prev_off);
        prev_off = ad.offset;
        _ = ad.format; // existence
        _ = ad.location;
        _ = ad.binding;
    }
}

<<<

`vertex_contract.zig`: >>>

const std = @import("std");
const vk = @import("vulkan");
const vertex = @import("vertex");

test "vertex: exports + binding matches struct size" {
    try std.testing.expect(@hasDecl(vertex, "Vertex"));

    const stride_expected = @sizeOf(vertex.Vertex);
    try std.testing.expectEqual(stride_expected, vertex.Vertex.binding_description.stride);
    try std.testing.expectEqual(@as(u32, 0), vertex.Vertex.binding_description.binding);
    try std.testing.expectEqual(vk.VertexInputRate.vertex, vertex.Vertex.binding_description.input_rate);
}

test "vertex: attributes sane (binding=0, offsets < stride, monotonic)" {
    const stride = vertex.Vertex.binding_description.stride;
    const attrs = vertex.Vertex.attribute_description;

    try std.testing.expect(attrs.len > 0);

    var last_off: u32 = 0;
    for (attrs, 0..) |a, i| {
        try std.testing.expectEqual(@as(u32, 0), a.binding);
        try std.testing.expect(a.offset < stride);
        if (i > 0) try std.testing.expect(a.offset >= last_off);
        last_off = a.offset;

        // location monotonic non-decreasing (relaxed assumption)
        if (i > 0) try std.testing.expect(a.location >= attrs[i - 1].location);

        // Touch the enum to ensure it's a valid format (permissive).
        switch (a.format) {
            .r32_sfloat,
            .r32g32_sfloat,
            .r32g32b32_sfloat,
            .r32g32b32a32_sfloat,
            => {},
            else => {},
        }
    }
}

<<<

`vertex_layout.zig`: >>>

const std = @import("std");
const vertex = @import("vertex");

test "vertex binding/attributes match struct layout" {
    // Basic invariants that should hold regardless of your Vertex fields.
    const bd = vertex.Vertex.binding_description;
    try std.testing.expect(bd.binding == 0); // usually 0 in single-VB demos
    try std.testing.expect(bd.stride > 0);
    try std.testing.expect(bd.input_rate.vertex == true);

    // Every attribute must sit within the stride.
    for (vertex.Vertex.attribute_description) |ad| {
        try std.testing.expect(ad.offset < bd.stride);
        try std.testing.expect(ad.location >= 0);
        // Minimal sanity: known formats ought to exist in enum; we just check the tag is valid.
        _ = ad.format;
    }
}

<<<

`vk_headers_sanity.zig`: >>>

const std = @import("std");
const vk = @import("vulkan");

test "vulkan headers present and key decls exist" {
    try std.testing.expect(@hasDecl(vk, "Pipeline"));
    try std.testing.expect(@hasDecl(vk, "ShaderModuleCreateInfo"));
    try std.testing.expect(@hasDecl(vk, "PipelineShaderStageCreateInfo"));
    try std.testing.expect(@hasDecl(vk, "PipelineVertexInputStateCreateInfo"));
}

<<<

`vk_structs_compile.zig`: >>>

const vk = @import("vulkan");

// Typed Bool32 helpers for Zig 0.16/vulkan-zig
const FALSE = @as(vk.Bool32, @enumFromInt(0));
const TRUE = @as(vk.Bool32, @enumFromInt(1));

// This is a compile-time contract check: the common create-info structs we use
// can be instantiated with our preferred default patterns.
test "vulkan create-info patterns compile" {
    const ia = vk.PipelineInputAssemblyStateCreateInfo{
        .flags = .{},
        .topology = .triangle_list,
        .primitive_restart_enable = FALSE,
    };
    _ = ia;

    const vp = vk.PipelineViewportStateCreateInfo{
        .flags = .{},
        .viewport_count = 1,
        .p_viewports = undefined,
        .scissor_count = 1,
        .p_scissors = undefined,
    };
    _ = vp;

    const rs = vk.PipelineRasterizationStateCreateInfo{
        .flags = .{},
        .depth_clamp_enable = FALSE,
        .rasterizer_discard_enable = FALSE,
        .polygon_mode = .fill,
        .cull_mode = .{}, // none
        .front_face = .clockwise,
        .depth_bias_enable = FALSE,
        .depth_bias_constant_factor = 0,
        .depth_bias_clamp = 0,
        .depth_bias_slope_factor = 0,
        .line_width = 1,
    };
    _ = rs;

    const ms = vk.PipelineMultisampleStateCreateInfo{
        .flags = .{},
        .rasterization_samples = .{ .@"1_bit" = true },
        .sample_shading_enable = FALSE,
        .min_sample_shading = 1,
        .p_sample_mask = null,
        .alpha_to_coverage_enable = FALSE,
        .alpha_to_one_enable = FALSE,
    };
    _ = ms;

    const ds = vk.PipelineDepthStencilStateCreateInfo{
        .flags = .{},
        .depth_test_enable = TRUE,
        .depth_write_enable = TRUE,
        .depth_compare_op = .less,
        .depth_bounds_test_enable = FALSE,
        .stencil_test_enable = FALSE,
        .front = .{
            .fail_op = .keep,
            .pass_op = .keep,
            .depth_fail_op = .keep,
            .compare_op = .always,
            .compare_mask = 0,
            .write_mask = 0,
            .reference = 0,
        },
        .back = .{
            .fail_op = .keep,
            .pass_op = .keep,
            .depth_fail_op = .keep,
            .compare_op = .always,
            .compare_mask = 0,
            .write_mask = 0,
            .reference = 0,
        },
        .min_depth_bounds = 0.0,
        .max_depth_bounds = 1.0,
    };
    _ = ds;

    const blend_att = vk.PipelineColorBlendAttachmentState{
        .blend_enable = FALSE,
        .src_color_blend_factor = .one,
        .dst_color_blend_factor = .zero,
        .color_blend_op = .add,
        .src_alpha_blend_factor = .one,
        .dst_alpha_blend_factor = .zero,
        .alpha_blend_op = .add,
        .color_write_mask = .{ .r_bit = true, .g_bit = true, .b_bit = true, .a_bit = true },
    };
    const blend = vk.PipelineColorBlendStateCreateInfo{
        .flags = .{},
        .logic_op_enable = FALSE,
        .logic_op = .copy,
        .attachment_count = 1,
        .p_attachments = @as([*]const vk.PipelineColorBlendAttachmentState, @ptrCast(&blend_att)),
        .blend_constants = [_]f32{ 0, 0, 0, 0 },
    };
    _ = blend;
}

<<<

`xr_headers_sanity.zig`: >>>

const std = @import("std");

// Contract: the OpenXR module must be importable via build.zig wiring.
// If codegen/import breaks, this test won't even compile.
test "integration: openxr module wires in" {
    _ = @import("openxr");
    try std.testing.expect(true);
}

<<<

`xr_registry_exists.zig`: >>>

const std = @import("std");

test "OpenXR registry (xr.xml) is present in ./registry" {
    _ = try std.fs.cwd().statFile("registry/xr.xml");
}

<<<

`smoke_cli_build.zig`: >>>

test "e2e: placeholder (enable later when headless window/device is harnessed)" {
    // Keep empty; real E2E will spawn vrgame with a dummy surface when we add one.
    // This file exists so the aggregator pattern matches your ZTable setup.
}

<<<

`pipeline_defaults.zig`: >>>

const std = @import("std");

test "conformance: shader files have stable names/locations" {
    const A = std.testing.allocator;
    const exe_dir = try std.fs.selfExeDirPathAlloc(A);
    defer A.free(exe_dir);
    for (&[_][]const u8{ "shaders/triangle_vert", "shaders/triangle_frag" }) |rel| {
        const full = try std.fs.path.join(A, &.{ exe_dir, rel });
        defer A.free(full);
        _ = try std.fs.cwd().statFile(full);
    }
}

<<<

`main.zig`: >>>

const std = @import("std");
const builtin = @import("builtin");
const glfw = @import("glfw");
const vk = @import("vulkan");

const GraphicsContext = @import("graphics_context").GraphicsContext;
const Swapchain = @import("swapchain").Swapchain;
const Vertex = @import("vertex").Vertex;

const frame_time = @import("frame_time");
const FrameTimer = frame_time.FrameTimer;

const camera3d = @import("camera3d");
const Camera3D = camera3d.Camera3D;
const CameraInput = camera3d.CameraInput;

const math3d = @import("math3d");
const Vec3 = math3d.Vec3;
const Mat4 = math3d.Mat4;

// (kept for future; not used directly since we load from exe dir)
const vert_spv = @embedFile("generated/shaders/triangle_vert");
const frag_spv = @embedFile("generated/shaders/triangle_frag");

const Allocator = std.mem.Allocator;

const VK_FALSE32: vk.Bool32 = @enumFromInt(vk.FALSE);
const VK_TRUE32: vk.Bool32 = @enumFromInt(vk.TRUE);

const window_title_cstr: [*:0]const u8 = "VRGame â€” Zigadel Prototype\x00";
const window_title_base: []const u8 = "VRGame â€” Zigadel Prototype";

// â”€â”€ World grid
const GRID_HALF: i32 = 64;
const GRID_STEP: f32 = 1.0;
const GRID_SIZE: i32 = GRID_HALF * 2;
const QUAD_COUNT: usize = @intCast(GRID_SIZE * GRID_SIZE);
const FLOOR_VERTS: u32 = @intCast(QUAD_COUNT * 6);

const TOTAL_VERTICES: u32 = FLOOR_VERTS;
const VERTEX_BUFFER_SIZE: vk.DeviceSize =
    @intCast(@as(usize, TOTAL_VERTICES) * @sizeOf(Vertex));

// Depth resources
const DepthResources = struct { image: vk.Image, memory: vk.DeviceMemory, view: vk.ImageView };

// Push-constant block (std430)
const Push = extern struct { m: [16]f32 };

// â”€â”€ Y-flip policy (mutually exclusive)
inline fn wantViewportFlip() bool {
    // Empirically correct: MoltenVK (macOS) prefers negative viewport height.
    return builtin.os.tag == .macos;
}
inline fn wantProjectionFlip() bool {
    // Non-mac platforms: flip once in projection.
    return !wantViewportFlip();
}

// â”€â”€ File helpers
fn readWholeFile(alloc: std.mem.Allocator, path: []const u8, max_bytes: usize) ![]u8 {
    return try std.fs.cwd().readFileAlloc(path, alloc, @as(std.Io.Limit, @enumFromInt(max_bytes)));
}

fn loadSpirvFromExeDirAligned(alloc: Allocator, rel: []const u8) ![]u8 {
    const exe_dir = try std.fs.selfExeDirPathAlloc(alloc);
    defer alloc.free(exe_dir);

    const full = try std.fs.path.join(alloc, &.{ exe_dir, rel });
    defer alloc.free(full);

    var tmp = try readWholeFile(alloc, full, 16 * 1024 * 1024);
    defer alloc.free(tmp);

    if (tmp.len % 4 != 0) return error.BadSpirvSize;

    const out = try alloc.alignedAlloc(u8, .@"4", tmp.len);
    @memcpy(out, tmp);
    return out;
}

// â”€â”€ UI / misc
fn updateWindowTitle(window: *glfw.Window, fps: f64, cam: *const Camera3D) void {
    var buf: [200]u8 = undefined;
    const title = std.fmt.bufPrintZ(
        &buf,
        "{s} | FPS: {d:.1} | Cam: x={d:.2}, y={d:.2}, z={d:.2}",
        .{ window_title_base, fps, cam.position.x, cam.position.y, cam.position.z },
    ) catch return;
    glfw.setWindowTitle(window, title);
}

fn nowMsFromGlfw() i64 {
    return @as(i64, @intFromFloat(glfw.getTime() * 1000.0));
}

fn errorCallback(err_code: c_int, desc: [*c]const u8) callconv(.c) void {
    var msg: []const u8 = "no description";
    if (desc) |p| {
        const z: [*:0]const u8 = @ptrCast(p);
        msg = std.mem.span(z);
    }
    if (glfw.errorCodeFromC(err_code)) |e| {
        std.log.err("GLFW error {s} ({d}): {s}", .{ @tagName(e), err_code, msg });
    } else {
        std.log.err("GLFW error code: {d}: {s}", .{ err_code, msg });
    }
}

fn sampleCameraInput(window: *glfw.Window) CameraInput {
    var ci: CameraInput = .{};
    const Key = struct {
        fn isDown(w: *glfw.Window, key: c_int) bool {
            const s = glfw.getKey(w, key);
            return s == glfw.c.GLFW_PRESS or s == glfw.c.GLFW_REPEAT;
        }
    };
    if (Key.isDown(window, glfw.c.GLFW_KEY_W)) ci.move_forward = true;
    if (Key.isDown(window, glfw.c.GLFW_KEY_S)) ci.move_backward = true;
    if (Key.isDown(window, glfw.c.GLFW_KEY_A)) ci.move_left = true;
    if (Key.isDown(window, glfw.c.GLFW_KEY_D)) ci.move_right = true;
    if (Key.isDown(window, glfw.c.GLFW_KEY_SPACE)) ci.move_up = true;
    if (Key.isDown(window, glfw.c.GLFW_KEY_LEFT_CONTROL)) ci.move_down = true;

    const CursorState = struct {
        var last_pos: ?[2]f64 = null;
    };
    const rmb = glfw.getMouseButton(window, glfw.c.GLFW_MOUSE_BUTTON_RIGHT);
    if (rmb == glfw.c.GLFW_PRESS) {
        const raw = glfw.getCursorPos(window);
        const pos = [2]f64{ raw.x, raw.y };
        if (CursorState.last_pos) |prev| {
            const dx = pos[0] - prev[0];
            const dy = pos[1] - prev[1];
            ci.look_delta_x = @as(f32, @floatCast(dx));
            ci.look_delta_y = @as(f32, @floatCast(dy));
        }
        CursorState.last_pos = pos;
    } else {
        CursorState.last_pos = null;
    }
    return ci;
}

// â”€â”€ Depth helpers
fn createDepthResources(gc: *const GraphicsContext, format: vk.Format, extent: vk.Extent2D) !DepthResources {
    const img = try gc.vkd.createImage(gc.dev, &vk.ImageCreateInfo{
        .flags = .{},
        .image_type = .@"2d",
        .format = format,
        .extent = .{ .width = extent.width, .height = extent.height, .depth = 1 },
        .mip_levels = 1,
        .array_layers = 1,
        .samples = .{ .@"1_bit" = true },
        .tiling = .optimal,
        .usage = .{ .depth_stencil_attachment_bit = true },
        .sharing_mode = .exclusive,
        .queue_family_index_count = 0,
        .p_queue_family_indices = undefined,
        .initial_layout = .undefined,
    }, null);

    const reqs = gc.vkd.getImageMemoryRequirements(gc.dev, img);
    const mem = try gc.allocate(reqs, .{ .device_local_bit = true });
    try gc.vkd.bindImageMemory(gc.dev, img, mem, 0);

    const view = try gc.vkd.createImageView(gc.dev, &vk.ImageViewCreateInfo{
        .flags = .{},
        .image = img,
        .view_type = .@"2d",
        .format = format,
        .components = .{ .r = .identity, .g = .identity, .b = .identity, .a = .identity },
        .subresource_range = .{
            .aspect_mask = .{ .depth_bit = true },
            .base_mip_level = 0,
            .level_count = 1,
            .base_array_layer = 0,
            .layer_count = 1,
        },
    }, null);

    return .{ .image = img, .memory = mem, .view = view };
}

fn destroyDepthResources(gc: *const GraphicsContext, depth: DepthResources) void {
    gc.vkd.destroyImageView(gc.dev, depth.view, null);
    gc.vkd.destroyImage(gc.dev, depth.image, null);
    gc.vkd.freeMemory(gc.dev, depth.memory, null);
}

// â”€â”€ Fill world geometry
fn writeFloorWorld(verts: [*]Vertex) void {
    var idx: usize = 0;
    const half: i32 = GRID_HALF;
    const step: f32 = GRID_STEP;

    var z: i32 = -half;
    while (z < half) : (z += 1) {
        const z0 = @as(f32, @floatFromInt(z)) * step;
        const z1 = @as(f32, @floatFromInt(z + 1)) * step;

        var x: i32 = -half;
        while (x < half) : (x += 1) {
            const x0 = @as(f32, @floatFromInt(x)) * step;
            const x1 = @as(f32, @floatFromInt(x + 1)) * step;

            const p00 = [3]f32{ x0, 0.0, z0 };
            const p10 = [3]f32{ x1, 0.0, z0 };
            const p11 = [3]f32{ x1, 0.0, z1 };
            const p01 = [3]f32{ x0, 0.0, z1 };

            const is_light = (((x + GRID_HALF) + (z + GRID_HALF)) & 1) == 0;
            const color: [3]f32 = if (is_light) .{ 0.86, 0.88, 0.92 } else .{ 0.20, 0.22, 0.26 };

            verts[idx + 0] = .{ .pos = p00, .color = color };
            verts[idx + 1] = .{ .pos = p10, .color = color };
            verts[idx + 2] = .{ .pos = p11, .color = color };
            verts[idx + 3] = .{ .pos = p00, .color = color };
            verts[idx + 4] = .{ .pos = p11, .color = color };
            verts[idx + 5] = .{ .pos = p01, .color = color };
            idx += 6;
        }
    }
    std.debug.assert(idx == @as(usize, TOTAL_VERTICES));
}

// â”€â”€ Buffer copy
fn copyBuffer(gc: *const GraphicsContext, pool: vk.CommandPool, dst: vk.Buffer, src: vk.Buffer, size: vk.DeviceSize) !void {
    var cmdbuf: vk.CommandBuffer = undefined;
    try gc.vkd.allocateCommandBuffers(gc.dev, &vk.CommandBufferAllocateInfo{
        .command_pool = pool,
        .level = .primary,
        .command_buffer_count = 1,
    }, @ptrCast(&cmdbuf));
    defer gc.vkd.freeCommandBuffers(gc.dev, pool, 1, @ptrCast(&cmdbuf));

    try gc.vkd.beginCommandBuffer(cmdbuf, &vk.CommandBufferBeginInfo{
        .flags = .{ .one_time_submit_bit = true },
        .p_inheritance_info = null,
    });

    const region = vk.BufferCopy{ .src_offset = 0, .dst_offset = 0, .size = size };
    gc.vkd.cmdCopyBuffer(cmdbuf, src, dst, 1, @ptrCast(&region));

    try gc.vkd.endCommandBuffer(cmdbuf);

    const si = vk.SubmitInfo{
        .wait_semaphore_count = 0,
        .p_wait_semaphores = undefined,
        .p_wait_dst_stage_mask = undefined,
        .command_buffer_count = 1,
        .p_command_buffers = @ptrCast(&cmdbuf),
        .signal_semaphore_count = 0,
        .p_signal_semaphores = undefined,
    };

    try gc.vkd.queueSubmit(gc.graphics_queue.handle, 1, @ptrCast(&si), .null_handle);
    try gc.vkd.queueWaitIdle(gc.graphics_queue.handle);
}

// â”€â”€ Framebuffers / Render pass / Pipeline
fn createFramebuffers(gc: *const GraphicsContext, allocator: Allocator, render_pass: vk.RenderPass, swapchain: Swapchain, depth_view: vk.ImageView) ![]vk.Framebuffer {
    const fbs = try allocator.alloc(vk.Framebuffer, swapchain.swap_images.len);
    errdefer allocator.free(fbs);

    var i: usize = 0;
    errdefer for (fbs[0..i]) |fb| gc.vkd.destroyFramebuffer(gc.dev, fb, null);

    for (fbs) |*fb| {
        const attachments = [_]vk.ImageView{ swapchain.swap_images[i].view, depth_view };
        fb.* = try gc.vkd.createFramebuffer(gc.dev, &vk.FramebufferCreateInfo{
            .flags = .{},
            .render_pass = render_pass,
            .attachment_count = @intCast(attachments.len),
            .p_attachments = &attachments,
            .width = swapchain.extent.width,
            .height = swapchain.extent.height,
            .layers = 1,
        }, null);
        i += 1;
    }

    return fbs;
}

fn destroyFramebuffers(gc: *const GraphicsContext, allocator: Allocator, framebuffers: []const vk.Framebuffer) void {
    for (framebuffers) |fb| gc.vkd.destroyFramebuffer(gc.dev, fb, null);
    allocator.free(framebuffers);
}

fn createRenderPass(gc: *const GraphicsContext, swapchain: Swapchain, depth_format: vk.Format) !vk.RenderPass {
    const color_attachment = vk.AttachmentDescription{
        .flags = .{},
        .format = swapchain.surface_format.format,
        .samples = .{ .@"1_bit" = true },
        .load_op = .clear,
        .store_op = .store,
        .stencil_load_op = .dont_care,
        .stencil_store_op = .dont_care,
        .initial_layout = .undefined,
        .final_layout = .present_src_khr,
    };

    const depth_attachment = vk.AttachmentDescription{
        .flags = .{},
        .format = depth_format,
        .samples = .{ .@"1_bit" = true },
        .load_op = .clear,
        .store_op = .dont_care,
        .stencil_load_op = .dont_care,
        .stencil_store_op = .dont_care,
        .initial_layout = .undefined,
        .final_layout = .depth_stencil_attachment_optimal,
    };

    const color_ref = vk.AttachmentReference{ .attachment = 0, .layout = .color_attachment_optimal };
    const depth_ref = vk.AttachmentReference{ .attachment = 1, .layout = .depth_stencil_attachment_optimal };

    const subpass = vk.SubpassDescription{
        .flags = .{},
        .pipeline_bind_point = .graphics,
        .input_attachment_count = 0,
        .p_input_attachments = undefined,
        .color_attachment_count = 1,
        .p_color_attachments = @ptrCast(&color_ref),
        .p_resolve_attachments = null,
        .p_depth_stencil_attachment = @ptrCast(&depth_ref),
        .preserve_attachment_count = 0,
        .p_preserve_attachments = undefined,
    };

    const attachments = [_]vk.AttachmentDescription{ color_attachment, depth_attachment };

    return try gc.vkd.createRenderPass(gc.dev, &vk.RenderPassCreateInfo{
        .flags = .{},
        .attachment_count = @intCast(attachments.len),
        .p_attachments = &attachments,
        .subpass_count = 1,
        .p_subpasses = @ptrCast(&subpass),
        .dependency_count = 0,
        .p_dependencies = undefined,
    }, null);
}

fn createPipeline(gc: *const GraphicsContext, layout: vk.PipelineLayout, render_pass: vk.RenderPass) !vk.Pipeline {
    const A = std.heap.c_allocator;
    const vert_bytes = try loadSpirvFromExeDirAligned(A, "shaders/triangle_vert");
    defer A.free(vert_bytes);
    const frag_bytes = try loadSpirvFromExeDirAligned(A, "shaders/triangle_frag");
    defer A.free(frag_bytes);

    const vert = try gc.vkd.createShaderModule(gc.dev, &vk.ShaderModuleCreateInfo{
        .flags = .{},
        .code_size = vert_bytes.len,
        .p_code = @ptrCast(@alignCast(vert_bytes.ptr)),
    }, null);
    defer gc.vkd.destroyShaderModule(gc.dev, vert, null);

    const frag = try gc.vkd.createShaderModule(gc.dev, &vk.ShaderModuleCreateInfo{
        .flags = .{},
        .code_size = frag_bytes.len,
        .p_code = @ptrCast(@alignCast(frag_bytes.ptr)),
    }, null);
    defer gc.vkd.destroyShaderModule(gc.dev, frag, null);

    const stages = [_]vk.PipelineShaderStageCreateInfo{
        .{ .flags = .{}, .stage = .{ .vertex_bit = true }, .module = vert, .p_name = "main", .p_specialization_info = null },
        .{ .flags = .{}, .stage = .{ .fragment_bit = true }, .module = frag, .p_name = "main", .p_specialization_info = null },
    };

    const vi = vk.PipelineVertexInputStateCreateInfo{
        .flags = .{},
        .vertex_binding_description_count = 1,
        .p_vertex_binding_descriptions = @as([*]const vk.VertexInputBindingDescription, @ptrCast(&Vertex.binding_description)),
        .vertex_attribute_description_count = Vertex.attribute_description.len,
        .p_vertex_attribute_descriptions = @as([*]const vk.VertexInputAttributeDescription, @ptrCast(&Vertex.attribute_description)),
    };

    const ia = vk.PipelineInputAssemblyStateCreateInfo{
        .flags = .{},
        .topology = .triangle_list,
        .primitive_restart_enable = VK_FALSE32,
    };

    const vp = vk.PipelineViewportStateCreateInfo{
        .flags = .{},
        .viewport_count = 1,
        .p_viewports = undefined, // dynamic
        .scissor_count = 1,
        .p_scissors = undefined, // dynamic
    };

    const rs = vk.PipelineRasterizationStateCreateInfo{
        .flags = .{},
        .depth_clamp_enable = VK_FALSE32,
        .rasterizer_discard_enable = VK_FALSE32,
        .polygon_mode = .fill,
        .cull_mode = .{}, // no culling
        .front_face = .clockwise,
        .depth_bias_enable = VK_FALSE32,
        .depth_bias_constant_factor = 0,
        .depth_bias_clamp = 0,
        .depth_bias_slope_factor = 0,
        .line_width = 1,
    };

    const ms = vk.PipelineMultisampleStateCreateInfo{
        .flags = .{},
        .rasterization_samples = .{ .@"1_bit" = true },
        .sample_shading_enable = VK_FALSE32,
        .min_sample_shading = 1,
        .p_sample_mask = null,
        .alpha_to_coverage_enable = VK_FALSE32,
        .alpha_to_one_enable = VK_FALSE32,
    };

    const ds = vk.PipelineDepthStencilStateCreateInfo{
        .flags = .{},
        .depth_test_enable = VK_TRUE32,
        .depth_write_enable = VK_TRUE32,
        .depth_compare_op = .less,
        .depth_bounds_test_enable = VK_FALSE32,
        .stencil_test_enable = VK_FALSE32,
        .front = .{ .fail_op = .keep, .pass_op = .keep, .depth_fail_op = .keep, .compare_op = .always, .compare_mask = 0, .write_mask = 0, .reference = 0 },
        .back = .{ .fail_op = .keep, .pass_op = .keep, .depth_fail_op = .keep, .compare_op = .always, .compare_mask = 0, .write_mask = 0, .reference = 0 },
        .min_depth_bounds = 0.0,
        .max_depth_bounds = 1.0,
    };

    const blend_att = vk.PipelineColorBlendAttachmentState{
        .blend_enable = VK_FALSE32,
        .src_color_blend_factor = .one,
        .dst_color_blend_factor = .zero,
        .color_blend_op = .add,
        .src_alpha_blend_factor = .one,
        .dst_alpha_blend_factor = .zero,
        .alpha_blend_op = .add,
        .color_write_mask = .{ .r_bit = true, .g_bit = true, .b_bit = true, .a_bit = true },
    };

    const blend = vk.PipelineColorBlendStateCreateInfo{
        .flags = .{},
        .logic_op_enable = VK_FALSE32,
        .logic_op = .copy,
        .attachment_count = 1,
        .p_attachments = @as([*]const vk.PipelineColorBlendAttachmentState, @ptrCast(&blend_att)),
        .blend_constants = [_]f32{ 0, 0, 0, 0 },
    };

    const dyn = [_]vk.DynamicState{ .viewport, .scissor };
    const dyn_state = vk.PipelineDynamicStateCreateInfo{
        .flags = .{},
        .dynamic_state_count = dyn.len,
        .p_dynamic_states = &dyn,
    };

    const gpci = vk.GraphicsPipelineCreateInfo{
        .flags = .{},
        .stage_count = 2,
        .p_stages = &stages,
        .p_vertex_input_state = &vi,
        .p_input_assembly_state = &ia,
        .p_tessellation_state = null,
        .p_viewport_state = &vp,
        .p_rasterization_state = &rs,
        .p_multisample_state = &ms,
        .p_depth_stencil_state = &ds,
        .p_color_blend_state = &blend,
        .p_dynamic_state = &dyn_state,
        .layout = layout,
        .render_pass = render_pass,
        .subpass = 0,
        .base_pipeline_handle = .null_handle,
        .base_pipeline_index = -1,
    };

    var pipeline: vk.Pipeline = undefined;
    _ = try gc.vkd.createGraphicsPipelines(
        gc.dev,
        .null_handle,
        1,
        @as([*]const vk.GraphicsPipelineCreateInfo, @ptrCast(&gpci)),
        null,
        @as([*]vk.Pipeline, @ptrCast(&pipeline)),
    );
    return pipeline;
}

// â”€â”€ Main
pub fn main() !void {
    _ = glfw.setErrorCallback(errorCallback);
    try glfw.init();
    defer glfw.terminate();

    var extent = vk.Extent2D{ .width = 1280, .height = 800 };
    glfw.defaultWindowHints();
    glfw.windowHint(glfw.c.GLFW_CLIENT_API, glfw.c.GLFW_NO_API);

    if (glfw.getPrimaryMonitor()) |mon| {
        const wa = glfw.getMonitorWorkarea(mon);
        if (wa.width > 0 and wa.height > 0) {
            extent.width = @intCast(@divTrunc(wa.width * 3, 4));
            extent.height = @intCast(@divTrunc(wa.height * 3, 4));
        } else if (glfw.getVideoMode(mon)) |vm| {
            extent.width = @intCast(@divTrunc(vm.width * 3, 4));
            extent.height = @intCast(@divTrunc(vm.height * 3, 4));
        }
    }

    const window = try glfw.createWindow(
        @as(i32, @intCast(extent.width)),
        @as(i32, @intCast(extent.height)),
        window_title_cstr,
        null,
        null,
    );
    defer glfw.destroyWindow(window);

    // Use true framebuffer pixels (retina-safe).
    const fb = glfw.getFramebufferSize(window);
    extent.width = @intCast(@max(@as(i32, 1), fb.width));
    extent.height = @intCast(@max(@as(i32, 1), fb.height));

    const allocator = std.heap.c_allocator;
    var gc = try GraphicsContext.init(allocator, window_title_cstr, window);
    defer gc.deinit();

    var swapchain = try Swapchain.init(&gc, allocator, extent);
    defer swapchain.deinit();

    // Pipeline layout with push constants (mat4 VP)
    const push_range = vk.PushConstantRange{
        .stage_flags = .{ .vertex_bit = true },
        .offset = 0,
        .size = @sizeOf(Push),
    };
    const pipeline_layout = try gc.vkd.createPipelineLayout(gc.dev, &vk.PipelineLayoutCreateInfo{
        .flags = .{},
        .set_layout_count = 0,
        .p_set_layouts = undefined,
        .push_constant_range_count = 1,
        .p_push_constant_ranges = @ptrCast(&push_range),
    }, null);
    defer gc.vkd.destroyPipelineLayout(gc.dev, pipeline_layout, null);

    const depth_format: vk.Format = .d32_sfloat;
    var depth = try createDepthResources(&gc, depth_format, swapchain.extent);
    defer destroyDepthResources(&gc, depth);

    const render_pass = try createRenderPass(&gc, swapchain, depth_format);
    defer gc.vkd.destroyRenderPass(gc.dev, render_pass, null);

    const pipeline = try createPipeline(&gc, pipeline_layout, render_pass);
    defer gc.vkd.destroyPipeline(gc.dev, pipeline, null);

    var framebuffers = try createFramebuffers(&gc, allocator, render_pass, swapchain, depth.view);
    defer destroyFramebuffers(&gc, allocator, framebuffers);

    // Command pool
    const cmd_pool = try gc.vkd.createCommandPool(gc.dev, &vk.CommandPoolCreateInfo{
        .flags = .{ .reset_command_buffer_bit = true },
        .queue_family_index = gc.graphics_queue.family,
    }, null);
    defer gc.vkd.destroyCommandPool(gc.dev, cmd_pool, null);

    // Vertex buffers
    const vbuf = try gc.vkd.createBuffer(gc.dev, &vk.BufferCreateInfo{
        .flags = .{},
        .size = VERTEX_BUFFER_SIZE,
        .usage = .{ .transfer_dst_bit = true, .vertex_buffer_bit = true },
        .sharing_mode = .exclusive,
        .queue_family_index_count = 0,
        .p_queue_family_indices = undefined,
    }, null);
    defer gc.vkd.destroyBuffer(gc.dev, vbuf, null);

    const vreqs = gc.vkd.getBufferMemoryRequirements(gc.dev, vbuf);
    const vmem = try gc.allocate(vreqs, .{ .device_local_bit = true });
    defer gc.vkd.freeMemory(gc.dev, vmem, null);
    try gc.vkd.bindBufferMemory(gc.dev, vbuf, vmem, 0);

    const sbuf = try gc.vkd.createBuffer(gc.dev, &vk.BufferCreateInfo{
        .flags = .{},
        .size = VERTEX_BUFFER_SIZE,
        .usage = .{ .transfer_src_bit = true },
        .sharing_mode = .exclusive,
        .queue_family_index_count = 0,
        .p_queue_family_indices = undefined,
    }, null);
    defer gc.vkd.destroyBuffer(gc.dev, sbuf, null);

    const sreqs = gc.vkd.getBufferMemoryRequirements(gc.dev, sbuf);
    const smem = try gc.allocate(sreqs, .{ .host_visible_bit = true, .host_coherent_bit = true });
    defer gc.vkd.freeMemory(gc.dev, smem, null);
    try gc.vkd.bindBufferMemory(gc.dev, sbuf, smem, 0);

    // Upload world vertices
    {
        const ptr = try gc.vkd.mapMemory(gc.dev, smem, 0, vk.WHOLE_SIZE, .{});
        defer gc.vkd.unmapMemory(gc.dev, smem);
        const verts: [*]Vertex = @ptrCast(@alignCast(ptr));
        writeFloorWorld(verts);
        try copyBuffer(&gc, cmd_pool, vbuf, sbuf, VERTEX_BUFFER_SIZE);
    }

    // Camera
    const fovy: f32 = @floatCast(std.math.degreesToRadians(70.0));
    var camera = Camera3D.init(
        Vec3.init(0.0, 1.7, 4.0),
        fovy,
        @as(f32, @floatFromInt(swapchain.extent.width)) /
            @as(f32, @floatFromInt(swapchain.extent.height)),
        0.1,
        500.0,
    );

    var frame_timer = FrameTimer.init(nowMsFromGlfw(), 1000);

    // Lazy-allocated command buffers (cached)
    const cmdbufs = cmdbufsForSwap(&gc, allocator, cmd_pool, framebuffers.len);

    while (!glfw.windowShouldClose(window)) {
        const tick = frame_timer.tick(nowMsFromGlfw());
        var dt = @as(f32, @floatCast(tick.dt));
        if (tick.fps_updated) updateWindowTitle(window, tick.fps, &camera);

        const esc = glfw.getKey(window, glfw.c.GLFW_KEY_ESCAPE);
        if (esc == glfw.c.GLFW_PRESS or esc == glfw.c.GLFW_REPEAT) glfw.setWindowShouldClose(window, true);

        const ls = glfw.getKey(window, glfw.c.GLFW_KEY_LEFT_SHIFT);
        const rs = glfw.getKey(window, glfw.c.GLFW_KEY_RIGHT_SHIFT);
        if (ls == glfw.c.GLFW_PRESS or ls == glfw.c.GLFW_REPEAT or rs == glfw.c.GLFW_PRESS or rs == glfw.c.GLFW_REPEAT) {
            dt *= 2.5;
        }

        const input = sampleCameraInput(window);
        camera.update(dt, input);

        // Record
        const cmdbuf = cmdbufs[swapchain.image_index];
        try gc.vkd.resetCommandBuffer(cmdbuf, .{});
        try gc.vkd.beginCommandBuffer(cmdbuf, &vk.CommandBufferBeginInfo{ .flags = .{}, .p_inheritance_info = null });

        const fb_extent = swapchain.extent;

        var viewport = vk.Viewport{
            .x = 0,
            .y = if (wantViewportFlip()) @as(f32, @floatFromInt(fb_extent.height)) else 0,
            .width = @as(f32, @floatFromInt(fb_extent.width)),
            .height = if (wantViewportFlip())
                -@as(f32, @floatFromInt(fb_extent.height))
            else
                @as(f32, @floatFromInt(fb_extent.height)),
            .min_depth = 0,
            .max_depth = 1,
        };
        const scissor = vk.Rect2D{ .offset = .{ .x = 0, .y = 0 }, .extent = fb_extent };
        gc.vkd.cmdSetViewport(cmdbuf, 0, 1, @as([*]const vk.Viewport, @ptrCast(&viewport)));
        gc.vkd.cmdSetScissor(cmdbuf, 0, 1, @as([*]const vk.Rect2D, @ptrCast(&scissor)));

        const clear_color = vk.ClearValue{ .color = .{ .float_32 = .{ 0.05, 0.05, 0.07, 1.0 } } };
        const clear_depth = vk.ClearValue{ .depth_stencil = .{ .depth = 1.0, .stencil = 0 } };
        var clears = [_]vk.ClearValue{ clear_color, clear_depth };

        const rp_begin = vk.RenderPassBeginInfo{
            .render_pass = render_pass,
            .framebuffer = framebuffers[swapchain.image_index],
            .render_area = .{ .offset = .{ .x = 0, .y = 0 }, .extent = fb_extent },
            .clear_value_count = @intCast(clears.len),
            .p_clear_values = &clears,
        };
        gc.vkd.cmdBeginRenderPass(cmdbuf, &rp_begin, vk.SubpassContents.@"inline");

        gc.vkd.cmdBindPipeline(cmdbuf, .graphics, pipeline);
        const offsets = [_]vk.DeviceSize{0};
        gc.vkd.cmdBindVertexBuffers(cmdbuf, 0, 1, @as([*]const vk.Buffer, @ptrCast(&vbuf)), &offsets);

        // Push VP (apply projection flip on non-mac platforms)
        var vp = camera.viewProjMatrix();
        if (wantProjectionFlip()) {
            vp.m[5] = -vp.m[5];
        }
        const push = Push{ .m = vp.m };
        gc.vkd.cmdPushConstants(cmdbuf, pipeline_layout, .{ .vertex_bit = true }, 0, @sizeOf(Push), @ptrCast(&push));

        gc.vkd.cmdDraw(cmdbuf, TOTAL_VERTICES, 1, 0, 0);
        gc.vkd.cmdEndRenderPass(cmdbuf);
        try gc.vkd.endCommandBuffer(cmdbuf);

        const state = swapchain.present(cmdbuf) catch |err| switch (err) {
            error.OutOfDateKHR => Swapchain.PresentState.suboptimal,
            else => |narrow| return narrow,
        };

        // Resize path
        if (state == .suboptimal) {
            const fb2 = glfw.getFramebufferSize(window);
            extent.width = @intCast(@max(@as(i32, 1), fb2.width));
            extent.height = @intCast(@max(@as(i32, 1), fb2.height));
            try swapchain.recreate(extent);

            const new_aspect: f32 =
                @as(f32, @floatFromInt(extent.width)) / @as(f32, @floatFromInt(extent.height));
            if (comptime @hasField(@TypeOf(camera), "aspect")) camera.aspect = new_aspect;

            destroyFramebuffers(&gc, allocator, framebuffers);
            destroyDepthResources(&gc, depth);
            depth = try createDepthResources(&gc, depth_format, swapchain.extent);
            framebuffers = try createFramebuffers(&gc, allocator, render_pass, swapchain, depth.view);
        }

        glfw.pollEvents();
    }

    try swapchain.waitForAllFences();
}

// Allocate per-swapchain command buffers once (idempotent helper).
fn cmdbufsForSwap(gc: *const GraphicsContext, A: Allocator, pool: vk.CommandPool, count: usize) []vk.CommandBuffer {
    const State = struct {
        var bufs: ?[]vk.CommandBuffer = null;
    };
    if (State.bufs) |b| return b;
    var bufs = A.alloc(vk.CommandBuffer, count) catch @panic("oom");
    gc.vkd.allocateCommandBuffers(gc.dev, &vk.CommandBufferAllocateInfo{
        .command_pool = pool,
        .level = .primary,
        .command_buffer_count = @intCast(count),
    }, bufs.ptr) catch @panic("alloc cmdbufs");
    State.bufs = bufs;
    return bufs;
}

// â”€â”€ Inline tests (your convention)
test "Y-flip policy is mutually exclusive" {
    const viewport_neg = builtin.os.tag == .macos;
    const proj_neg = !viewport_neg;
    try std.testing.expect(viewport_neg != proj_neg);
}

test "projection flip negates m[5] on non-mac" {
    var m: [16]f32 = .{0} ** 16;
    m[5] = 2.0;
    if (builtin.os.tag != .macos) {
        m[5] = -m[5];
        try std.testing.expect(m[5] == -2.0);
    } else {
        try std.testing.expect(m[5] == 2.0); // mac keeps projection; uses viewport flip
    }
}

<<<

`root.zig`: >>>

const std = @import("std");

// Public facade for the vrgame library.
// This lets external code (and tests) do:
//
//   const vr = @import("vrgame");
//   const Game = vr.game.Game;
//   const GraphicsContext = vr.graphics.GraphicsContext;
//
pub const graphics = struct {
    pub const GraphicsContext = @import("graphics_context").GraphicsContext;
    pub const Swapchain = @import("swapchain").Swapchain;
    pub const Vertex = @import("vertex").Vertex;
};

pub const game = struct {
    pub const Game = @import("game").Game;
    pub const InputState = @import("game").InputState;

    pub const FrameTimer = @import("frame_time").FrameTimer;
    pub const TickResult = @import("frame_time").TickResult;
};

test "refAllDecls(vrgame root)" {
    std.testing.refAllDecls(@This());
}

<<<

`math3d.zig`: >>>

const std = @import("std");

/// Simple 3D/4D vectors + 4x4 matrices (column-major, Vulkan/GL style).
pub const Vec3 = struct {
    x: f32,
    y: f32,
    z: f32,

    pub fn init(x: f32, y: f32, z: f32) Vec3 {
        return .{ .x = x, .y = y, .z = z };
    }

    pub fn zero() Vec3 {
        return .{ .x = 0, .y = 0, .z = 0 };
    }

    pub fn add(self: Vec3, other: Vec3) Vec3 {
        return .{ .x = self.x + other.x, .y = self.y + other.y, .z = self.z + other.z };
    }

    pub fn sub(self: Vec3, other: Vec3) Vec3 {
        return .{ .x = self.x - other.x, .y = self.y - other.y, .z = self.z - other.z };
    }

    pub fn scale(self: Vec3, s: f32) Vec3 {
        return .{ .x = self.x * s, .y = self.y * s, .z = self.z * s };
    }

    pub fn dot(self: Vec3, other: Vec3) f32 {
        return self.x * other.x + self.y * other.y + self.z * other.z;
    }

    pub fn cross(self: Vec3, other: Vec3) Vec3 {
        return .{
            .x = self.y * other.z - self.z * other.y,
            .y = self.z * other.x - self.x * other.z,
            .z = self.x * other.y - self.y * other.x,
        };
    }

    pub fn length(self: Vec3) f32 {
        return @sqrt(self.dot(self));
    }

    pub fn normalized(self: Vec3) Vec3 {
        const len = self.length();
        return if (len == 0.0) self else self.scale(1.0 / len);
    }
};

pub const Vec4 = struct {
    x: f32,
    y: f32,
    z: f32,
    w: f32,

    pub fn init(x: f32, y: f32, z: f32, w: f32) Vec4 {
        return .{ .x = x, .y = y, .z = z, .w = w };
    }

    pub fn fromVec3(v: Vec3, w: f32) Vec4 {
        return .{ .x = v.x, .y = v.y, .z = v.z, .w = w };
    }

    pub fn toVec3(self: Vec4) Vec3 {
        const inv_w: f32 = if (self.w != 0.0) 1.0 / self.w else 1.0;
        return Vec3.init(self.x * inv_w, self.y * inv_w, self.z * inv_w);
    }

    pub fn toArray(self: Vec4) [4]f32 {
        return .{ self.x, self.y, self.z, self.w };
    }

    /// Accepts Vec4, [4]f32, or *[4]f32 (and *Vec4). Used by Mat4.mulVec4.
    pub fn fromAny(v_any: anytype) Vec4 {
        const T = @TypeOf(v_any);
        const ti = @typeInfo(T);
        return switch (ti) {
            .@"struct" => {
                if (T == Vec4) return v_any;
                @compileError("Vec4.fromAny: unsupported struct type");
            },
            .array => |a| blk: {
                if (a.len != 4) @compileError("Vec4.fromAny: array length must be 4");
                if (a.child != f32) @compileError("Vec4.fromAny: array element type must be f32");
                break :blk Vec4.init(v_any[0], v_any[1], v_any[2], v_any[3]);
            },
            .pointer => blk: {
                break :blk Vec4.fromAny(v_any.*);
            },
            else => @compileError("Vec4.fromAny: unsupported type"),
        };
    }
};

pub const Mat4 = struct {
    /// Column-major 4x4 matrix: m[col*4 + row]
    m: [16]f32,

    inline fn idx(row: usize, col: usize) usize {
        return col * 4 + row;
    }

    pub fn identity() Mat4 {
        var res = Mat4{ .m = [_]f32{0} ** 16 };
        res.m[idx(0, 0)] = 1;
        res.m[idx(1, 1)] = 1;
        res.m[idx(2, 2)] = 1;
        res.m[idx(3, 3)] = 1;
        return res;
    }

    /// Matrix multiply: a * b (column-major).
    pub fn mul(a: Mat4, b: Mat4) Mat4 {
        var r = Mat4{ .m = [_]f32{0} ** 16 };
        var row: usize = 0;
        while (row < 4) : (row += 1) {
            var col: usize = 0;
            while (col < 4) : (col += 1) {
                var sum: f32 = 0;
                var k: usize = 0;
                while (k < 4) : (k += 1) {
                    sum += a.m[idx(row, k)] * b.m[idx(k, col)];
                }
                r.m[idx(row, col)] = sum;
            }
        }
        return r;
    }

    /// Multiply by a 4D vector. Returns the **same shape** as the input:
    ///  - Vec4 -> Vec4
    ///  - [4]f32 -> [4]f32
    pub fn mulVec4(self: Mat4, v_any: anytype) @TypeOf(v_any) {
        const v = Vec4.fromAny(v_any);
        const m = self.m;

        const rx = m[idx(0, 0)] * v.x + m[idx(0, 1)] * v.y + m[idx(0, 2)] * v.z + m[idx(0, 3)] * v.w;
        const ry = m[idx(1, 0)] * v.x + m[idx(1, 1)] * v.y + m[idx(1, 2)] * v.z + m[idx(1, 3)] * v.w;
        const rz = m[idx(2, 0)] * v.x + m[idx(2, 1)] * v.y + m[idx(2, 2)] * v.z + m[idx(2, 3)] * v.w;
        const rw = m[idx(3, 0)] * v.x + m[idx(3, 1)] * v.y + m[idx(3, 2)] * v.z + m[idx(3, 3)] * v.w;

        const RetT = @TypeOf(v_any);
        const ti = @typeInfo(RetT);
        return switch (ti) {
            .@"struct" => {
                if (RetT == Vec4) return Vec4.init(rx, ry, rz, rw);
                @compileError("Mat4.mulVec4: unsupported struct return type");
            },
            .array => |a| blk: {
                if (a.len != 4 or a.child != f32)
                    @compileError("Mat4.mulVec4: only [4]f32 arrays supported");
                break :blk [_]f32{ rx, ry, rz, rw };
            },
            .pointer => @compileError("Mat4.mulVec4: pointer inputs not supported; pass by value"),
            else => @compileError("Mat4.mulVec4: unsupported input/return type"),
        };
    }

    /// Transform a point (w=1) with perspective divide.
    pub fn transformPoint(self: Mat4, v: Vec3) Vec3 {
        const v4 = self.mulVec4(Vec4.fromVec3(v, 1.0)); // returns Vec4
        return v4.toVec3();
    }

    /// Right-handed perspective (Vulkan/D3D Z in [0,1]).
    pub fn perspective(fov_y: f32, aspect: f32, near: f32, far: f32) Mat4 {
        const f = 1.0 / @tan(fov_y / 2.0);
        var m = Mat4{ .m = [_]f32{0} ** 16 };

        // diag
        m.m[idx(0, 0)] = f / aspect;
        m.m[idx(1, 1)] = f;

        // Depth (RH, Vulkan/D3D clip: z in [0,1])
        m.m[idx(2, 2)] = far / (near - far); // m22
        m.m[idx(3, 2)] = -1.0; // m32  <-- moved here
        m.m[idx(2, 3)] = (far * near) / (near - far); // m23  <-- moved here
        m.m[idx(3, 3)] = 0.0;

        return m;
    }

    /// Right-handed lookAt, camera at `eye`, looking to `center`, `up` up-vector.
    pub fn lookAt(eye: Vec3, center: Vec3, up: Vec3) Mat4 {
        const f = center.sub(eye).normalized();
        const s = f.cross(up).normalized();
        const u = s.cross(f);

        var r = Mat4{ .m = [_]f32{0} ** 16 };

        // column 0 (s)
        r.m[idx(0, 0)] = s.x;
        r.m[idx(1, 0)] = s.y;
        r.m[idx(2, 0)] = s.z;
        // column 1 (u)
        r.m[idx(0, 1)] = u.x;
        r.m[idx(1, 1)] = u.y;
        r.m[idx(2, 1)] = u.z;
        // column 2 (-f)
        r.m[idx(0, 2)] = -f.x;
        r.m[idx(1, 2)] = -f.y;
        r.m[idx(2, 2)] = -f.z;
        // column 3 (translation)
        r.m[idx(0, 3)] = -s.dot(eye);
        r.m[idx(1, 3)] = -u.dot(eye);
        r.m[idx(2, 3)] = f.dot(eye);
        r.m[idx(3, 3)] = 1.0;

        return r;
    }

    /// Alias (kept for convenience).
    pub fn mulPoint(self: Mat4, v: Vec3) Vec3 {
        return self.transformPoint(v);
    }
    pub fn mulPoint3(self: Mat4, v: Vec3) Vec3 {
        return self.transformPoint(v);
    }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Tests
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

test "Vec3 basics" {
    const a = Vec3.init(1, 2, 3);
    const b = Vec3.init(-1, 0.5, 4);
    const c = a.add(b);
    try std.testing.expectApproxEqAbs(@as(f32, 0), c.x, 0.0001);
    try std.testing.expectApproxEqAbs(@as(f32, 2.5), c.y, 0.0001);
    try std.testing.expectApproxEqAbs(@as(f32, 7), c.z, 0.0001);
}

test "Mat4.identity mulVec4 returns same shape as input" {
    const I = Mat4.identity();
    const v_arr: [4]f32 = .{ 1, 2, 3, 1 };
    const out_arr = I.mulVec4(v_arr);
    try std.testing.expectEqualDeep(v_arr, out_arr);

    const v4 = Vec4.init(1, 2, 3, 1);
    const out_v4 = I.mulVec4(v4);
    try std.testing.expectEqual(@as(f32, v4.x), out_v4.x);
    try std.testing.expectEqual(@as(f32, v4.y), out_v4.y);
    try std.testing.expectEqual(@as(f32, v4.z), out_v4.z);
    try std.testing.expectEqual(@as(f32, v4.w), out_v4.w);
}

test "Mat4.transformPoint identity" {
    const I = Mat4.identity();
    const v = Vec3.init(1.0, -2.0, 3.5);
    const out = I.transformPoint(v);
    try std.testing.expectApproxEqAbs(v.x, out.x, 0.0001);
    try std.testing.expectApproxEqAbs(v.y, out.y, 0.0001);
    try std.testing.expectApproxEqAbs(v.z, out.z, 0.0001);
}

test "Vec3 normalization â†’ unit length (128 samples)" {
    var prng = std.Random.DefaultPrng.init(0xC0FFEE);
    var rng = prng.random();

    var i: usize = 0;
    while (i < 128) : (i += 1) {
        var v = Vec3.init(
            rng.float(f32) * 2.0 - 1.0,
            rng.float(f32) * 2.0 - 1.0,
            rng.float(f32) * 2.0 - 1.0,
        );
        if (v.length() < 1e-6) continue; // skip near-zero
        v = v.normalized();
        try std.testing.expectApproxEqAbs(@as(f32, 1.0), v.length(), 1e-3);
    }
}

test "Mat4 identity invariants (I*M==M && M*I==M)" {
    const I = Mat4.identity();
    const proj = Mat4.perspective(std.math.degreesToRadians(60.0), 16.0 / 9.0, 0.1, 100.0);
    const view = Mat4.lookAt(Vec3.init(1, 2, 3), Vec3.init(0, 0, 0), Vec3.init(0, 1, 0));
    const M = Mat4.mul(proj, view);

    const IM = Mat4.mul(I, M);
    const MI = Mat4.mul(M, I);

    var k: usize = 0;
    while (k < 16) : (k += 1) {
        try std.testing.expectApproxEqAbs(M.m[k], IM.m[k], 1e-5);
        try std.testing.expectApproxEqAbs(M.m[k], MI.m[k], 1e-5);
    }
}

// test "refAllDecls(math3d)" {
//     std.testing.refAllDecls(@This());
// }

<<<

`graphics_context.zig`: >>>

const std = @import("std");
const builtin = @import("builtin");
const glfw = @import("glfw");
const vk = @import("vulkan");

const Allocator = std.mem.Allocator;

const GetInstanceProc = *const fn (vk.Instance, [*:0]const u8) callconv(.c) vk.PfnVoidFunction;
const GetDeviceProc = *const fn (vk.Device, [*:0]const u8) callconv(.c) vk.PfnVoidFunction;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Optional instance extensions (portability on macOS)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const optional_instance_extensions = blk: {
    if (builtin.os.tag == .macos) {
        break :blk [_][*:0]const u8{
            vk.extensions.khr_get_physical_device_properties_2.name,
            vk.extensions.khr_portability_enumeration.name,
        };
    } else {
        break :blk [_][*:0]const u8{
            vk.extensions.khr_get_physical_device_properties_2.name,
        };
    }
};

// Device extensions
const required_device_extensions = [_][*:0]const u8{
    vk.extensions.khr_swapchain.name,
};
const optional_device_extensions = [_][*:0]const u8{};

// Dispatch aliases (modern vulkan-zig)
const BaseDispatch = vk.BaseWrapper;
const InstanceDispatch = vk.InstanceWrapper;
const DeviceDispatch = vk.DeviceWrapper;

// Module-scope flag toggled by GLFW framebuffer callback
var g_need_swapchain_recreate: bool = false;

pub const GraphicsContext = struct {
    // Vulkan dispatchers
    vkb: BaseDispatch,
    vki: InstanceDispatch,
    vkd: DeviceDispatch,

    // Core handles
    instance: vk.Instance,
    surface: vk.SurfaceKHR,
    pdev: vk.PhysicalDevice,
    props: vk.PhysicalDeviceProperties,
    mem_props: vk.PhysicalDeviceMemoryProperties,
    dev: vk.Device,

    // Queues
    graphics_queue: Queue,
    present_queue: Queue,

    // Keep the window so we can query framebuffer pixels
    window: *glfw.Window,
    resize_requested: bool = false,

    pub fn init(
        allocator: Allocator,
        app_name: [*:0]const u8,
        window: *glfw.Window,
    ) !GraphicsContext {
        var self: GraphicsContext = undefined;
        self.window = window;

        // Base dispatch via GLFW proc adapter
        const get_proc: GetInstanceProc = glfwGetInstanceProc;
        self.vkb = BaseDispatch.load(get_proc);

        // Instance extensions (GLFW + optional)
        const glfw_exts_opt = glfw.getRequiredInstanceExtensions(allocator) catch |err| {
            if (glfw.getLastError()) |info| {
                const code_opt = glfw.errorCodeFromC(info.code);
                const code_str = if (code_opt) |c| @tagName(c) else "UnknownError";
                const desc_str: []const u8 = info.description orelse "no description";
                std.log.err("GLFW Vulkan extensions failed: {s}: {s}", .{ code_str, desc_str });
            } else {
                std.log.err("GLFW Vulkan extensions failed: {s}", .{@errorName(err)});
            }
            return error.VulkanInstanceExtensionsQueryFailed;
        };
        const glfw_exts = glfw_exts_opt orelse {
            std.log.err("GLFW reported no required Vulkan instance extensions", .{});
            return error.VulkanInstanceExtensionsMissing;
        };

        var instance_extensions = try std.ArrayList([*:0]const u8).initCapacity(
            allocator,
            glfw_exts.len + optional_instance_extensions.len,
        );
        defer instance_extensions.deinit(allocator);

        for (glfw_exts) |ext_name_z| {
            try instance_extensions.append(allocator, ext_name_z.ptr);
        }

        var ext_count: u32 = 0;
        _ = try self.vkb.enumerateInstanceExtensionProperties(null, &ext_count, null);
        const propsv = try allocator.alloc(vk.ExtensionProperties, ext_count);
        defer allocator.free(propsv);
        _ = try self.vkb.enumerateInstanceExtensionProperties(null, &ext_count, propsv.ptr);

        for (optional_instance_extensions) |ext_name| {
            const want = std.mem.span(ext_name);
            for (propsv) |p| {
                const nlen = std.mem.indexOfScalar(u8, &p.extension_name, 0) orelse p.extension_name.len;
                if (std.mem.eql(u8, p.extension_name[0..nlen], want)) {
                    try instance_extensions.append(allocator, ext_name);
                    break;
                }
            }
        }

        const app_version: u32 = @as(u32, @bitCast(vk.makeApiVersion(0, 0, 0, 0)));
        const api_version: u32 = @as(u32, @bitCast(vk.makeApiVersion(0, 1, 0, 0))); // Vulkan 1.0

        const app_info = vk.ApplicationInfo{
            .p_application_name = app_name,
            .application_version = app_version,
            .p_engine_name = app_name,
            .engine_version = app_version,
            .api_version = api_version,
        };

        const enabled_ext_count: u32 = @intCast(instance_extensions.items.len);
        const enabled_ext_ptr: [*]const [*:0]const u8 = @ptrCast(instance_extensions.items.ptr);

        self.instance = try self.vkb.createInstance(&vk.InstanceCreateInfo{
            .flags = if (builtin.os.tag == .macos)
                .{ .enumerate_portability_bit_khr = true }
            else
                .{},
            .p_application_info = &app_info,
            .enabled_layer_count = 0,
            .pp_enabled_layer_names = undefined,
            .enabled_extension_count = enabled_ext_count,
            .pp_enabled_extension_names = enabled_ext_ptr,
        }, null);

        // Instance/device dispatch
        const get_inst_proc: GetInstanceProc = self.vkb.dispatch.vkGetInstanceProcAddr.?;
        self.vki = InstanceDispatch.load(self.instance, get_inst_proc);
        errdefer self.vki.destroyInstance(self.instance, null);

        self.surface = try createSurface(self.instance, window);
        errdefer self.vki.destroySurfaceKHR(self.instance, self.surface, null);

        const candidate = try pickPhysicalDevice(self.vki, self.instance, allocator, self.surface);
        self.pdev = candidate.pdev;
        self.props = candidate.props;

        self.dev = try initializeCandidate(allocator, self.vki, candidate);
        const get_dev_proc: GetDeviceProc = self.vki.dispatch.vkGetDeviceProcAddr.?;
        self.vkd = DeviceDispatch.load(self.dev, get_dev_proc);
        errdefer self.vkd.destroyDevice(self.dev, null);

        self.graphics_queue = Queue.init(self.vkd, self.dev, candidate.queues.graphics_family);
        self.present_queue = Queue.init(self.vkd, self.dev, candidate.queues.present_family);

        self.mem_props = self.vki.getPhysicalDeviceMemoryProperties(self.pdev);

        // Install framebuffer resize callback (sets a module-scope flag)
        self.installFramebufferResizeCallback();

        return self;
    }

    pub fn deinit(self: GraphicsContext) void {
        _ = self.vkd.deviceWaitIdle(self.dev) catch {};
        self.vkd.destroyDevice(self.dev, null);
        self.vki.destroySurfaceKHR(self.instance, self.surface, null);
        self.vki.destroyInstance(self.instance, null);
    }

    /// Width/height in **framebuffer pixels** (Retina-aware).
    pub fn framebufferExtent(self: *const GraphicsContext) vk.Extent2D {
        const fb = glfw.getFramebufferSize(self.window);
        const w: i32 = if (fb.width < 1) 1 else fb.width;
        const h: i32 = if (fb.height < 1) 1 else fb.height;
        return .{ .width = @intCast(w), .height = @intCast(h) };
    }

    /// Returns true once when the OS reports framebuffer size change.
    pub fn takeResizeFlag(_: *GraphicsContext) bool {
        const r = g_need_swapchain_recreate;
        g_need_swapchain_recreate = false;
        return r;
    }

    pub fn installFramebufferResizeCallback(self: *GraphicsContext) void {
        glfw.setWindowUserPointer(self.window, self);
        _ = glfw.setFramebufferSizeCallback(self.window, framebufferSizeChanged);
    }

    pub fn deviceName(self: *const GraphicsContext) []const u8 {
        return std.mem.sliceTo(self.props.device_name[0..], 0);
    }

    pub fn findMemoryTypeIndex(self: GraphicsContext, memory_type_bits: u32, flags: vk.MemoryPropertyFlags) !u32 {
        for (self.mem_props.memory_types[0..self.mem_props.memory_type_count], 0..) |mem_type, i| {
            const bit: u32 = (@as(u32, 1)) << @as(u5, @truncate(i));
            if (memory_type_bits & bit != 0 and mem_type.property_flags.contains(flags))
                return @intCast(i);
        }
        return error.NoSuitableMemoryType;
    }

    pub fn allocate(self: GraphicsContext, reqs: vk.MemoryRequirements, flags: vk.MemoryPropertyFlags) !vk.DeviceMemory {
        return try self.vkd.allocateMemory(self.dev, &.{
            .allocation_size = reqs.size,
            .memory_type_index = try self.findMemoryTypeIndex(reqs.memory_type_bits, flags),
        }, null);
    }
};

// â”€â”€ Queues â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
pub const Queue = struct {
    handle: vk.Queue,
    family: u32,
    fn init(vkd: DeviceDispatch, dev: vk.Device, family: u32) Queue {
        return .{ .handle = vkd.getDeviceQueue(dev, family, 0), .family = family };
    }
};

// â”€â”€ GLFW proc adapter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
fn glfwGetInstanceProc(instance: vk.Instance, name: [*:0]const u8) callconv(.c) vk.PfnVoidFunction {
    const opaque_instance: ?*anyopaque = blk: {
        if (instance == .null_handle) break :blk null;
        break :blk @ptrFromInt(@intFromEnum(instance));
    };
    const name_slice: [:0]const u8 = std.mem.span(name);
    const raw: glfw.VkProc = glfw.getInstanceProcAddress(opaque_instance, name_slice);
    if (raw) |p| return @ptrCast(p);
    return null;
}

// â”€â”€ Surface creation (GLFW â†’ VkSurfaceKHR) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
extern fn glfwCreateWindowSurface(instance: vk.Instance, window: *glfw.Window, allocator: ?*const anyopaque, surface: *vk.SurfaceKHR) vk.Result;

fn createSurface(instance: vk.Instance, window: *glfw.Window) !vk.SurfaceKHR {
    var surface: vk.SurfaceKHR = undefined;
    const res = glfwCreateWindowSurface(instance, window, null, &surface);
    if (res != .success) return error.SurfaceInitFailed;
    return surface;
}

// â”€â”€ Device selection, queues, extensions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const DeviceCandidate = struct { pdev: vk.PhysicalDevice, props: vk.PhysicalDeviceProperties, queues: QueueAllocation };
const QueueAllocation = struct { graphics_family: u32, present_family: u32 };

fn pickPhysicalDevice(vki: InstanceDispatch, instance: vk.Instance, allocator: Allocator, surface: vk.SurfaceKHR) !DeviceCandidate {
    var n: u32 = 0;
    _ = try vki.enumeratePhysicalDevices(instance, &n, null);
    const pdevs = try allocator.alloc(vk.PhysicalDevice, n);
    defer allocator.free(pdevs);
    _ = try vki.enumeratePhysicalDevices(instance, &n, pdevs.ptr);

    for (pdevs) |pdev| {
        if (try checkSuitable(vki, pdev, allocator, surface)) |c| return c;
    }
    return error.NoSuitableDevice;
}

fn checkSuitable(vki: InstanceDispatch, pdev: vk.PhysicalDevice, allocator: Allocator, surface: vk.SurfaceKHR) !?DeviceCandidate {
    const props = vki.getPhysicalDeviceProperties(pdev);
    if (!try checkExtensionSupport(vki, pdev, allocator)) return null;
    if (!try checkSurfaceSupport(vki, pdev, surface)) return null;
    if (try allocateQueues(vki, pdev, allocator, surface)) |q| {
        return .{ .pdev = pdev, .props = props, .queues = q };
    }
    return null;
}

fn allocateQueues(vki: InstanceDispatch, pdev: vk.PhysicalDevice, allocator: Allocator, surface: vk.SurfaceKHR) !?QueueAllocation {
    var count: u32 = 0;
    vki.getPhysicalDeviceQueueFamilyProperties(pdev, &count, null);
    const families = try allocator.alloc(vk.QueueFamilyProperties, count);
    defer allocator.free(families);
    vki.getPhysicalDeviceQueueFamilyProperties(pdev, &count, families.ptr);

    var gfx: ?u32 = null;
    var prs: ?u32 = null;

    for (families, 0..) |props, i| {
        const idx: u32 = @intCast(i);
        if (gfx == null and props.queue_flags.graphics_bit) gfx = idx;

        if (prs == null) {
            const s: vk.Bool32 = try vki.getPhysicalDeviceSurfaceSupportKHR(pdev, idx, surface);
            if (@intFromEnum(s) != 0) prs = idx;
        }
    }

    if (gfx != null and prs != null) return .{ .graphics_family = gfx.?, .present_family = prs.? };
    return null;
}

fn checkSurfaceSupport(vki: InstanceDispatch, pdev: vk.PhysicalDevice, surface: vk.SurfaceKHR) !bool {
    var f: u32 = 0;
    _ = try vki.getPhysicalDeviceSurfaceFormatsKHR(pdev, surface, &f, null);
    var m: u32 = 0;
    _ = try vki.getPhysicalDeviceSurfacePresentModesKHR(pdev, surface, &m, null);
    return f > 0 and m > 0;
}

fn checkExtensionSupport(vki: InstanceDispatch, pdev: vk.PhysicalDevice, allocator: Allocator) !bool {
    var n: u32 = 0;
    _ = try vki.enumerateDeviceExtensionProperties(pdev, null, &n, null);
    const propsv = try allocator.alloc(vk.ExtensionProperties, n);
    defer allocator.free(propsv);
    _ = try vki.enumerateDeviceExtensionProperties(pdev, null, &n, propsv.ptr);

    for (required_device_extensions) |ext_name| {
        const want = std.mem.span(ext_name);
        var found = false;
        for (propsv) |p| {
            const len = std.mem.indexOfScalar(u8, &p.extension_name, 0) orelse p.extension_name.len;
            if (std.mem.eql(u8, p.extension_name[0..len], want)) {
                found = true;
                break;
            }
        }
        if (!found) return false;
    }
    return true;
}

fn initializeCandidate(allocator: Allocator, vki: InstanceDispatch, cand: DeviceCandidate) !vk.Device {
    const priority = [_]f32{1.0};
    const qci = [_]vk.DeviceQueueCreateInfo{
        .{ .flags = .{}, .queue_family_index = cand.queues.graphics_family, .queue_count = 1, .p_queue_priorities = &priority },
        .{ .flags = .{}, .queue_family_index = cand.queues.present_family, .queue_count = 1, .p_queue_priorities = &priority },
    };
    const queue_count: u32 = if (cand.queues.graphics_family == cand.queues.present_family) 1 else 2;

    var dev_exts = try std.ArrayList([*:0]const u8).initCapacity(allocator, required_device_extensions.len);
    defer dev_exts.deinit(allocator);
    try dev_exts.appendSlice(allocator, required_device_extensions[0..]);

    // Optionals per device (safe no-op if missing)
    var n: u32 = 0;
    _ = try vki.enumerateDeviceExtensionProperties(cand.pdev, null, &n, null);
    const propsv = try allocator.alloc(vk.ExtensionProperties, n);
    defer allocator.free(propsv);
    _ = try vki.enumerateDeviceExtensionProperties(cand.pdev, null, &n, propsv.ptr);

    for (optional_device_extensions) |name| {
        const want = std.mem.span(name);
        for (propsv) |p| {
            const len = std.mem.indexOfScalar(u8, &p.extension_name, 0) orelse p.extension_name.len;
            if (std.mem.eql(u8, p.extension_name[0..len], want)) {
                try dev_exts.append(allocator, name);
                break;
            }
        }
    }

    return try vki.createDevice(cand.pdev, &.{
        .flags = .{},
        .queue_create_info_count = queue_count,
        .p_queue_create_infos = &qci,
        .enabled_layer_count = 0,
        .pp_enabled_layer_names = undefined,
        .enabled_extension_count = @intCast(dev_exts.items.len),
        .pp_enabled_extension_names = @as([*]const [*:0]const u8, @ptrCast(dev_exts.items.ptr)),
        .p_enabled_features = null,
    }, null);
}

// GLFW callback â†’ set the module-scope flag
fn framebufferSizeChanged(win: ?*glfw.Window, _: c_int, _: c_int) callconv(.c) void {
    if (win) |w| {
        if (glfw.getWindowUserPointer(w)) |p| {
            const gc: *GraphicsContext = @ptrCast(@alignCast(p));
            gc.resize_requested = true;
        }
    }
}

<<<

`swapchain.zig`: >>>

const std = @import("std");
const vk = @import("vulkan");
const GraphicsContext = @import("graphics_context").GraphicsContext;
const Allocator = std.mem.Allocator;

pub const Swapchain = struct {
    pub const PresentState = enum { optimal, suboptimal };

    gc: *const GraphicsContext,
    allocator: Allocator,

    surface_format: vk.SurfaceFormatKHR,
    present_mode: vk.PresentModeKHR,
    extent: vk.Extent2D,
    handle: vk.SwapchainKHR,

    swap_images: []SwapImage,
    image_index: u32,
    next_image_acquired: vk.Semaphore,

    /// First-time creation.
    /// Note: extent parameter is ignored on HiDPI platforms; we pick from framebuffer size.
    pub fn init(gc: *const GraphicsContext, allocator: Allocator, extent: vk.Extent2D) !Swapchain {
        _ = extent; // we compute from framebuffer
        return try buildSwapchain(gc, allocator, .null_handle);
    }

    /// Recreate after resize/suboptimal present.
    pub fn recreate(self: *Swapchain, new_extent: vk.Extent2D) !void {
        _ = new_extent; // ignored; derived from framebuffer
        const gc = self.gc;
        const allocator = self.allocator;
        const old_handle = self.handle;

        try gc.vkd.deviceWaitIdle(gc.dev);

        const new_swapchain = try buildSwapchain(gc, allocator, old_handle);

        self.deinitExceptSwapchain();
        gc.vkd.destroySwapchainKHR(gc.dev, old_handle, null);

        self.* = new_swapchain;
    }

    fn deinitExceptSwapchain(self: Swapchain) void {
        for (self.swap_images) |si| si.deinit(self.gc);
        self.allocator.free(self.swap_images);
        self.gc.vkd.destroySemaphore(self.gc.dev, self.next_image_acquired, null);
    }

    pub fn deinit(self: Swapchain) void {
        self.deinitExceptSwapchain();
        self.gc.vkd.destroySwapchainKHR(self.gc.dev, self.handle, null);
    }

    pub fn waitForAllFences(self: Swapchain) !void {
        for (self.swap_images) |si| si.waitForFence(self.gc) catch {};
    }

    pub fn currentImage(self: Swapchain) vk.Image {
        return self.swap_images[self.image_index].image;
    }

    pub fn currentSwapImage(self: Swapchain) *const SwapImage {
        return &self.swap_images[self.image_index];
    }

    pub fn present(self: *Swapchain, cmdbuf: vk.CommandBuffer) !PresentState {
        const current = self.currentSwapImage();
        try current.waitForFence(self.gc);
        try self.gc.vkd.resetFences(self.gc.dev, 1, @ptrCast(&current.frame_fence));

        const wait_stage = [_]vk.PipelineStageFlags{.{ .top_of_pipe_bit = true }};
        try self.gc.vkd.queueSubmit(self.gc.graphics_queue.handle, 1, &[_]vk.SubmitInfo{.{
            .wait_semaphore_count = 1,
            .p_wait_semaphores = @ptrCast(&current.image_acquired),
            .p_wait_dst_stage_mask = &wait_stage,
            .command_buffer_count = 1,
            .p_command_buffers = @ptrCast(&cmdbuf),
            .signal_semaphore_count = 1,
            .p_signal_semaphores = @ptrCast(&current.render_finished),
        }}, current.frame_fence);

        _ = try self.gc.vkd.queuePresentKHR(self.gc.present_queue.handle, &vk.PresentInfoKHR{
            .wait_semaphore_count = 1,
            .p_wait_semaphores = @ptrCast(&current.render_finished),
            .swapchain_count = 1,
            .p_swapchains = @ptrCast(&self.handle),
            .p_image_indices = @ptrCast(&self.image_index),
            .p_results = null,
        });

        const result = try self.gc.vkd.acquireNextImageKHR(
            self.gc.dev,
            self.handle,
            std.math.maxInt(u64),
            self.next_image_acquired,
            .null_handle,
        );

        std.mem.swap(
            vk.Semaphore,
            &self.swap_images[result.image_index].image_acquired,
            &self.next_image_acquired,
        );
        self.image_index = result.image_index;

        return switch (result.result) {
            .success => .optimal,
            .suboptimal_khr => .suboptimal,
            else => unreachable,
        };
    }

    pub fn cmdSetViewportAndScissor(self: *const Swapchain, gc: *const GraphicsContext, cmd: vk.CommandBuffer) void {
        const w: f32 = @floatFromInt(self.extent.width);
        const h: f32 = @floatFromInt(self.extent.height);

        // MoltenVK wants a normal (non-flipped) viewport; others use the classic Vulkan flip.
        const is_macos = @import("builtin").os.tag == .macos;

        var viewport = vk.Viewport{
            .x = 0,
            .y = if (is_macos) 0 else h,
            .width = w,
            .height = if (is_macos) h else -h,
            .min_depth = 0,
            .max_depth = 1,
        };

        const scissor = vk.Rect2D{
            .offset = .{ .x = 0, .y = 0 },
            .extent = self.extent,
        };

        gc.vkd.cmdSetViewport(cmd, 0, 1, @as([*]const vk.Viewport, @ptrCast(&viewport)));
        gc.vkd.cmdSetScissor(cmd, 0, 1, @as([*]const vk.Rect2D, @ptrCast(&scissor)));
    }
};

const SwapImage = struct {
    image: vk.Image,
    view: vk.ImageView,
    image_acquired: vk.Semaphore,
    render_finished: vk.Semaphore,
    frame_fence: vk.Fence,

    fn init(gc: *const GraphicsContext, image: vk.Image, format: vk.Format) !SwapImage {
        const view = try gc.vkd.createImageView(gc.dev, &.{
            .flags = .{},
            .image = image,
            .view_type = .@"2d",
            .format = format,
            .components = .{ .r = .identity, .g = .identity, .b = .identity, .a = .identity },
            .subresource_range = .{
                .aspect_mask = .{ .color_bit = true },
                .base_mip_level = 0,
                .level_count = 1,
                .base_array_layer = 0,
                .layer_count = 1,
            },
        }, null);
        errdefer gc.vkd.destroyImageView(gc.dev, view, null);

        const image_acquired = try gc.vkd.createSemaphore(gc.dev, &.{ .flags = .{} }, null);
        errdefer gc.vkd.destroySemaphore(gc.dev, image_acquired, null);

        const render_finished = try gc.vkd.createSemaphore(gc.dev, &.{ .flags = .{} }, null);
        errdefer gc.vkd.destroySemaphore(gc.dev, render_finished, null);

        const frame_fence = try gc.vkd.createFence(gc.dev, &.{ .flags = .{ .signaled_bit = true } }, null);
        errdefer gc.vkd.destroyFence(gc.dev, frame_fence, null);

        return .{
            .image = image,
            .view = view,
            .image_acquired = image_acquired,
            .render_finished = render_finished,
            .frame_fence = frame_fence,
        };
    }

    fn deinit(self: SwapImage, gc: *const GraphicsContext) void {
        self.waitForFence(gc) catch {};
        gc.vkd.destroyImageView(gc.dev, self.view, null);
        gc.vkd.destroySemaphore(gc.dev, self.image_acquired, null);
        gc.vkd.destroySemaphore(gc.dev, self.render_finished, null);
        gc.vkd.destroyFence(gc.dev, self.frame_fence, null);
    }

    fn waitForFence(self: SwapImage, gc: *const GraphicsContext) !void {
        _ = try gc.vkd.waitForFences(
            gc.dev,
            1,
            @ptrCast(&self.frame_fence),
            @enumFromInt(vk.TRUE),
            std.math.maxInt(u64),
        );
    }
};

fn buildSwapchain(
    gc: *const GraphicsContext,
    allocator: Allocator,
    old_handle: vk.SwapchainKHR,
) !Swapchain {
    const caps = try gc.vki.getPhysicalDeviceSurfaceCapabilitiesKHR(gc.pdev, gc.surface);

    // HiDPI-safe: pick from the framebuffer (pixel) size.
    const fb = gc.framebufferExtent();
    const actual_extent = chooseSwapExtent(caps, fb);
    if (actual_extent.width == 0 or actual_extent.height == 0)
        return error.InvalidSurfaceDimensions;

    const surface_format = try findSurfaceFormat(gc, allocator);
    const present_mode = try findPresentMode(gc, allocator);

    var image_count = caps.min_image_count + 1;
    if (caps.max_image_count > 0) image_count = @min(image_count, caps.max_image_count);

    const qfi = [_]u32{ gc.graphics_queue.family, gc.present_queue.family };
    const sharing_mode: vk.SharingMode = if (gc.graphics_queue.family != gc.present_queue.family) .concurrent else .exclusive;

    const handle = try gc.vkd.createSwapchainKHR(gc.dev, &.{
        .flags = .{},
        .surface = gc.surface,
        .min_image_count = image_count,
        .image_format = surface_format.format,
        .image_color_space = surface_format.color_space,
        .image_extent = actual_extent,
        .image_array_layers = 1,
        .image_usage = .{ .color_attachment_bit = true, .transfer_dst_bit = true },
        .image_sharing_mode = sharing_mode,
        .queue_family_index_count = qfi.len,
        .p_queue_family_indices = &qfi,
        .pre_transform = caps.current_transform,
        .composite_alpha = .{ .opaque_bit_khr = true },
        .present_mode = present_mode,
        .clipped = @enumFromInt(vk.TRUE),
        .old_swapchain = old_handle,
    }, null);
    errdefer gc.vkd.destroySwapchainKHR(gc.dev, handle, null);

    const swap_images = try initSwapchainImages(gc, handle, surface_format.format, allocator);
    errdefer {
        for (swap_images) |si| si.deinit(gc);
        allocator.free(swap_images);
    }

    var next_image_acquired = try gc.vkd.createSemaphore(gc.dev, &.{ .flags = .{} }, null);
    errdefer gc.vkd.destroySemaphore(gc.dev, next_image_acquired, null);

    const result = try gc.vkd.acquireNextImageKHR(
        gc.dev,
        handle,
        std.math.maxInt(u64),
        next_image_acquired,
        .null_handle,
    );
    if (result.result != .success and result.result != .suboptimal_khr)
        return error.ImageAcquireFailed;

    std.mem.swap(vk.Semaphore, &swap_images[result.image_index].image_acquired, &next_image_acquired);

    return .{
        .gc = gc,
        .allocator = allocator,
        .surface_format = surface_format,
        .present_mode = present_mode,
        .extent = actual_extent,
        .handle = handle,
        .swap_images = swap_images,
        .image_index = result.image_index,
        .next_image_acquired = next_image_acquired,
    };
}

fn initSwapchainImages(gc: *const GraphicsContext, swapchain: vk.SwapchainKHR, format: vk.Format, allocator: Allocator) ![]SwapImage {
    var count: u32 = undefined;
    _ = try gc.vkd.getSwapchainImagesKHR(gc.dev, swapchain, &count, null);
    const images = try allocator.alloc(vk.Image, count);
    defer allocator.free(images);
    _ = try gc.vkd.getSwapchainImagesKHR(gc.dev, swapchain, &count, images.ptr);

    const swap_images = try allocator.alloc(SwapImage, count);
    errdefer allocator.free(swap_images);

    var i: usize = 0;
    errdefer for (swap_images[0..i]) |si| si.deinit(gc);

    for (images) |image| {
        swap_images[i] = try SwapImage.init(gc, image, format);
        i += 1;
    }
    return swap_images;
}

fn findSurfaceFormat(gc: *const GraphicsContext, allocator: Allocator) !vk.SurfaceFormatKHR {
    const preferred = vk.SurfaceFormatKHR{ .format = .b8g8r8a8_srgb, .color_space = .srgb_nonlinear_khr };

    var count: u32 = undefined;
    _ = try gc.vki.getPhysicalDeviceSurfaceFormatsKHR(gc.pdev, gc.surface, &count, null);
    const surface_formats = try allocator.alloc(vk.SurfaceFormatKHR, count);
    defer allocator.free(surface_formats);
    _ = try gc.vki.getPhysicalDeviceSurfaceFormatsKHR(gc.pdev, gc.surface, &count, surface_formats.ptr);

    for (surface_formats) |sfmt| if (std.meta.eql(sfmt, preferred)) return preferred;
    return surface_formats[0];
}

fn findPresentMode(gc: *const GraphicsContext, allocator: Allocator) !vk.PresentModeKHR {
    var count: u32 = undefined;
    _ = try gc.vki.getPhysicalDeviceSurfacePresentModesKHR(gc.pdev, gc.surface, &count, null);
    const present_modes = try allocator.alloc(vk.PresentModeKHR, count);
    defer allocator.free(present_modes);
    _ = try gc.vki.getPhysicalDeviceSurfacePresentModesKHR(gc.pdev, gc.surface, &count, present_modes.ptr);

    const preferred = [_]vk.PresentModeKHR{ .mailbox_khr, .immediate_khr };
    for (preferred) |mode| {
        if (std.mem.indexOfScalar(vk.PresentModeKHR, present_modes, mode) != null) return mode;
    }
    return .fifo_khr;
}

/// Choose the swap extent from framebuffer pixels if the surface lets us.
fn chooseSwapExtent(caps: vk.SurfaceCapabilitiesKHR, fb: vk.Extent2D) vk.Extent2D {
    if (caps.current_extent.width != std.math.maxInt(u32)) {
        return caps.current_extent;
    }
    return .{
        .width = std.math.clamp(fb.width, caps.min_image_extent.width, caps.max_image_extent.width),
        .height = std.math.clamp(fb.height, caps.min_image_extent.height, caps.max_image_extent.height),
    };
}

<<<

`vertex.zig`: >>>

const std = @import("std");
const vk = @import("vulkan");

pub const Vertex = struct {
    pos: [3]f32, // x, y, z
    color: [3]f32, // r, g, b

    pub const binding_description = vk.VertexInputBindingDescription{
        .binding = 0,
        .stride = @sizeOf(Vertex),
        .input_rate = .vertex,
    };

    pub const attribute_description = [_]vk.VertexInputAttributeDescription{
        .{
            .binding = 0,
            .location = 0,
            // vec3 position
            .format = .r32g32b32_sfloat,
            .offset = @offsetOf(Vertex, "pos"),
        },
        .{
            .binding = 0,
            .location = 1,
            // vec3 color
            .format = .r32g32b32_sfloat,
            .offset = @offsetOf(Vertex, "color"),
        },
    };
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Layout sanity tests â€” guards against future shader / struct drift
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// test "Vertex layout matches triangle.vert expectations" {
//     // Position is a vec3
//     try std.testing.expect(Vertex.attribute_description[0].format == .r32g32b32_sfloat);
//     try std.testing.expectEqual(@offsetOf(Vertex, "pos"), Vertex.attribute_description[0].offset);

//     // Color is a vec3
//     try std.testing.expect(Vertex.attribute_description[1].format == .r32g32b32_sfloat);
//     try std.testing.expectEqual(@offsetOf(Vertex, "color"), Vertex.attribute_description[1].offset);

//     // Binding stride should be the full struct size.
//     try std.testing.expect(Vertex.binding_description.stride == @sizeOf(Vertex));
// }

test "Vertex layout matches shaders (pos, color)" {
    try std.testing.expect(@sizeOf(Vertex) == 24); // 6 * f32
    try std.testing.expect(@offsetOf(Vertex, "pos") == 0);
    try std.testing.expect(@offsetOf(Vertex, "color") == 12);

    // Binding/attribute descriptions are stable
    try std.testing.expectEqual(@as(u32, 0), Vertex.binding_description.binding);
    try std.testing.expect(@intFromEnum(Vertex.attribute_description[0].format) != 0);
    try std.testing.expect(@intFromEnum(Vertex.attribute_description[1].format) != 0);
}

<<<

`camera3d.zig`: >>>

const std = @import("std");
const math3d = @import("math3d");

// Make Vec3 visible to other modules (e.g. main.zig).
pub const Vec3 = math3d.Vec3;
const Mat4 = math3d.Mat4;

fn degToRad(deg: f32) f32 {
    const pi_f32: f32 = @floatCast(std.math.pi);
    return deg * (pi_f32 / 180.0);
}

/// Inputs for a single frame of camera control.
/// Mouse deltas are in "pixels" or whatever unit you want; caller scales appropriately.
pub const CameraInput = struct {
    move_forward: bool = false,
    move_backward: bool = false,
    move_left: bool = false,
    move_right: bool = false,
    move_up: bool = false,
    move_down: bool = false,

    look_delta_x: f32 = 0.0,
    look_delta_y: f32 = 0.0,
};

/// Right-handed FPS-style camera.
/// - World up is +Y.
/// - Forward at yaw=0, pitch=0 points down -Z.
/// - Uses radians for yaw/pitch.
pub const Camera3D = struct {
    position: Vec3,
    yaw: f32,
    pitch: f32,

    fov_y: f32,
    aspect: f32,
    near: f32,
    far: f32,

    move_speed: f32,
    look_sensitivity: f32,

    pub fn init(
        position: Vec3,
        fov_y: f32,
        aspect: f32,
        near: f32,
        far: f32,
    ) Camera3D {
        return .{
            .position = position,
            .yaw = 0.0,
            .pitch = 0.0,
            .fov_y = fov_y,
            .aspect = aspect,
            .near = near,
            .far = far,
            .move_speed = 3.0,
            .look_sensitivity = 0.0018,
        };
    }

    pub fn setAspect(self: *Camera3D, aspect: f32) void {
        self.aspect = aspect;
    }

    fn forward(self: *const Camera3D) Vec3 {
        const cp = @cos(self.pitch);
        const sp = @sin(self.pitch);
        const cy = @cos(self.yaw);
        const sy = @sin(self.yaw);

        // yaw=0, pitch=0 -> (0,0,-1)
        return Vec3.init(
            cp * sy,
            sp,
            -cp * cy,
        ).normalized();
    }

    fn right(self: *const Camera3D) Vec3 {
        const f = self.forward();
        const world_up = Vec3.init(0.0, 1.0, 0.0);
        return f.cross(world_up).normalized();
    }

    fn up(self: *const Camera3D) Vec3 {
        const r = self.right();
        const f = self.forward();
        return r.cross(f).normalized();
    }

    pub fn viewMatrix(self: *const Camera3D) Mat4 {
        const eye = self.position;
        const center = eye.add(self.forward());
        const up_vec = self.up();
        return Mat4.lookAt(eye, center, up_vec);
    }

    pub fn projMatrix(self: *const Camera3D) Mat4 {
        return Mat4.perspective(self.fov_y, self.aspect, self.near, self.far);
    }

    pub fn viewProjMatrix(self: *const Camera3D) Mat4 {
        return self.projMatrix().mul(self.viewMatrix());
    }

    /// Apply one frame of input.
    /// `dt` in seconds. `input.look_delta_*` can be raw or pre-scaled; we multiply by sensitivity.
    pub fn update(self: *Camera3D, dt: f32, input: CameraInput) void {
        // Mouse look: yaw around world up, pitch around local right.
        const look_scale = self.look_sensitivity;
        self.yaw -= input.look_delta_x * look_scale;
        self.pitch -= input.look_delta_y * look_scale;

        // Clamp pitch to avoid gimbal lock.
        const pitch_limit: f32 = degToRad(89.0);
        if (self.pitch > pitch_limit) self.pitch = pitch_limit;
        if (self.pitch < -pitch_limit) self.pitch = -pitch_limit;

        var move_dir = Vec3.zero();

        if (input.move_forward) move_dir = move_dir.add(self.forward());
        if (input.move_backward) move_dir = move_dir.sub(self.forward());
        if (input.move_right) move_dir = move_dir.add(self.right());
        if (input.move_left) move_dir = move_dir.sub(self.right());

        const world_up = Vec3.init(0.0, 1.0, 0.0);
        if (input.move_up) move_dir = move_dir.add(world_up);
        if (input.move_down) move_dir = move_dir.sub(world_up);

        if (move_dir.length() > 0.0) {
            const dir = move_dir.normalized();
            self.position = self.position.add(dir.scale(self.move_speed * dt));
        }
    }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Tests
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

test "Camera3D forward/right/up basics" {
    var cam = Camera3D.init(
        Vec3.init(0.0, 0.0, 0.0),
        degToRad(60.0),
        16.0 / 9.0,
        0.1,
        100.0,
    );

    const f = cam.forward();
    const r = cam.right();
    const u = cam.up();

    // At yaw=0, pitch=0, forward should be roughly (0, 0, -1).
    try std.testing.expectApproxEqAbs(@as(f32, 0.0), f.x, 0.001);
    try std.testing.expectApproxEqAbs(@as(f32, 0.0), f.y, 0.001);
    try std.testing.expectApproxEqAbs(@as(f32, -1.0), f.z, 0.001);

    // Right should be roughly (1, 0, 0).
    try std.testing.expectApproxEqAbs(@as(f32, 1.0), r.x, 0.001);
    try std.testing.expectApproxEqAbs(@as(f32, 0.0), r.y, 0.001);

    // Up ~ (0,1,0).
    try std.testing.expectApproxEqAbs(@as(f32, 0.0), u.x, 0.001);
    try std.testing.expectApproxEqAbs(@as(f32, 1.0), u.y, 0.001);
}

test "Camera3D simple movement" {
    var cam = Camera3D.init(
        Vec3.init(0.0, 0.0, 0.0),
        degToRad(60.0),
        16.0 / 9.0,
        0.1,
        100.0,
    );

    const dt: f32 = 1.0;
    var input = CameraInput{};
    input.move_forward = true;

    const start_pos = cam.position;
    cam.update(dt, input);

    // Moving forward at yaw=0 should reduce z.
    try std.testing.expect(cam.position.z < start_pos.z);
}

test "refAllDecls" {
    std.testing.refAllDecls(@This());
}

<<<

`frame_time.zig`: >>>

const std = @import("std");

/// Result of a single tick of the frame timer.
pub const TickResult = struct {
    /// Delta time in seconds since the previous frame.
    /// Will be 0 when the timestamp did not advance.
    dt: f64,
    /// True when an FPS sample window completed on this tick.
    fps_updated: bool,
    /// Latest FPS value. Meaningful when `fps_updated == true`,
    /// otherwise the most recent sample.
    fps: f64,
};

/// Simple, robust frame timer based on millisecond timestamps.
/// Designed to be trivial to reuse in ZGE / Zigadel demos.
pub const FrameTimer = struct {
    /// Last timestamp in milliseconds (monotonic assumption).
    last_ms: i64,
    /// Accumulated milliseconds in the current FPS window.
    accum_ms: i64 = 0,
    /// Frames counted in the current FPS window.
    frames_in_window: u32 = 0,
    /// How many milliseconds per FPS sample (usually 1000 = 1s).
    fps_sample_interval_ms: i64,
    /// Last computed FPS value.
    current_fps: f64 = 0.0,

    /// Initialize the timer with a starting millisecond timestamp and sample window.
    pub fn init(start_ms: i64, sample_interval_ms: i64) FrameTimer {
        return .{
            .last_ms = start_ms,
            .accum_ms = 0,
            .frames_in_window = 0,
            .fps_sample_interval_ms = if (sample_interval_ms > 0) sample_interval_ms else 1000,
            .current_fps = 0.0,
        };
    }

    /// Advance the timer with a new millisecond timestamp.
    /// Returns dt (seconds) and optionally a new FPS sample.
    pub fn tick(self: *FrameTimer, now_ms: i64) TickResult {
        // Non-monotonic clock or duplicate timestamp: ignore.
        if (now_ms <= self.last_ms) {
            return .{
                .dt = 0.0,
                .fps_updated = false,
                .fps = self.current_fps,
            };
        }

        const dt_ms = now_ms - self.last_ms;
        self.last_ms = now_ms;

        self.accum_ms += dt_ms;
        self.frames_in_window += 1;

        var fps_updated = false;

        if (self.accum_ms >= self.fps_sample_interval_ms and self.fps_sample_interval_ms > 0) {
            const window_s = @as(f64, @floatFromInt(self.accum_ms)) / 1000.0;
            if (window_s > 0.0) {
                self.current_fps =
                    @as(f64, @floatFromInt(self.frames_in_window)) / window_s;
            } else {
                self.current_fps = 0.0;
            }

            self.accum_ms = 0;
            self.frames_in_window = 0;
            fps_updated = true;
        }

        const dt_s = @as(f64, @floatFromInt(dt_ms)) / 1000.0;

        return .{
            .dt = dt_s,
            .fps_updated = fps_updated,
            .fps = self.current_fps,
        };
    }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Tests
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

test "FrameTimer basic progression and FPS window" {
    var timer = FrameTimer.init(0, 1000);

    // 9 frames at 100 ms â†’ 900 ms total, no FPS sample yet.
    var i: usize = 0;
    while (i < 9) : (i += 1) {
        const now_ms: i64 = @intCast((i + 1) * 100); // 100, 200, ..., 900
        const res = timer.tick(now_ms);
        try std.testing.expect(res.dt > 0.0);
        try std.testing.expect(!res.fps_updated);
    }

    // 10th frame at 1000 ms pushes us over the 1s window:
    const res10 = timer.tick(1000);
    try std.testing.expect(res10.fps_updated);

    // 10 frames over ~1.0 seconds â†’ ~10 FPS.
    const expected_fps: f64 = 10.0;
    try std.testing.expectApproxEqAbs(expected_fps, res10.fps, 0.0001);
}

test "FrameTimer handles non-monotonic timestamps" {
    var timer = FrameTimer.init(1000, 1000);

    const r1 = timer.tick(1010);
    try std.testing.expect(r1.dt > 0.0);

    // Time goes backwards: dt should be 0, and state unchanged.
    const r2 = timer.tick(900);
    try std.testing.expectEqual(@as(f64, 0.0), r2.dt);
    try std.testing.expect(!r2.fps_updated);
    try std.testing.expectEqual(r1.fps, r2.fps);
}

test "FrameTimer basic dt and fps windowing" {
    var ft = FrameTimer.init(0, 1000); // 1s FPS window
    var t = ft.tick(16);
    try std.testing.expect(t.dt > 0);
    // simulate ~16ms/frame over ~1s => ~60 fps
    var ms: i64 = 16;
    var last: i64 = 16;
    var fps_seen = false;
    while (ms < 1000) : (ms += 16) {
        t = ft.tick(ms);
        last = ms;
        if (t.fps_updated) {
            fps_seen = true;
            try std.testing.expect(t.fps > 40 and t.fps < 80);
        }
    }
    // one more tick should definitely finalize a window
    t = ft.tick(last + 16);
    try std.testing.expect(t.fps_updated or fps_seen);
}

// test "refAllDecls(frame_time)" {
//     std.testing.refAllDecls(@This());
// }

<<<

`game.zig`: >>>

const std = @import("std");

/// High-level input state, decoupled from GLFW.
/// main.zig is responsible for mapping key presses to this struct.
pub const InputState = struct {
    move_forward: bool = false,
    move_backward: bool = false,
    move_left: bool = false,
    move_right: bool = false,
    quit: bool = false,
};

/// Core game state:
/// - A player-controlled hero (WASD)
/// - An orbiting enemy
/// - Simple collision + score + hit-flash
pub const Game = struct {
    /// Hero position in a simple 2D "world" space.
    player_x: f32 = 0.0,
    player_y: f32 = 0.0,

    /// Enemy position + internal orbit phase.
    enemy_x: f32 = 0.6,
    enemy_y: f32 = 0.0,
    enemy_angle: f32 = 0.0,

    /// Number of times the hero has "tagged" the enemy.
    score: u32 = 0,

    /// Used to detect rising edge of collisions so we don't
    /// increment score every frame while overlapping.
    _was_colliding: bool = false,

    /// Time remaining for the hit-flash effect (seconds).
    hit_flash_timer: f32 = 0.0,

    const move_speed: f32 = 3.5;
    const enemy_radius: f32 = 0.75;
    const collision_radius: f32 = 0.25;
    const tau: f32 = 6.28318530717958647692;

    /// Simple "world bounds" so the hero can't leave forever.
    const world_half_width: f32 = 2.0;
    const world_half_height: f32 = 1.5;

    /// Duration of the hit-flash in seconds.
    const hit_flash_duration: f32 = 0.25;

    pub fn init() Game {
        return .{};
    }

    /// Advance the game by dt seconds with a given input snapshot.
    pub fn update(self: *Game, dt: f32, input: InputState) void {
        // â”€â”€ Hero movement (WASD) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (input.move_forward) self.player_y += move_speed * dt;
        if (input.move_backward) self.player_y -= move_speed * dt;
        if (input.move_left) self.player_x -= move_speed * dt;
        if (input.move_right) self.player_x += move_speed * dt;

        // Clamp hero to a simple axis-aligned world box.
        if (self.player_x > world_half_width) self.player_x = world_half_width;
        if (self.player_x < -world_half_width) self.player_x = -world_half_width;
        if (self.player_y > world_half_height) self.player_y = world_half_height;
        if (self.player_y < -world_half_height) self.player_y = -world_half_height;

        // â”€â”€ Enemy orbit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        self.enemy_angle += 0.7 * dt;
        if (self.enemy_angle > tau) {
            self.enemy_angle -= tau;
        }

        const math = std.math;
        self.enemy_x = math.cos(self.enemy_angle) * enemy_radius;
        self.enemy_y = math.sin(self.enemy_angle) * enemy_radius;

        // â”€â”€ Collision + score (edge-triggered) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const hit_now = self.isColliding();
        if (hit_now and !self._was_colliding) {
            self.score += 1;
            self.hit_flash_timer = hit_flash_duration;
        }
        self._was_colliding = hit_now;

        // â”€â”€ Hit-flash timer decay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (self.hit_flash_timer > 0.0) {
            self.hit_flash_timer -= dt;
            if (self.hit_flash_timer < 0.0) self.hit_flash_timer = 0.0;
        }
    }

    /// Hero â†” enemy proximity in "world" space.
    pub fn isColliding(self: *const Game) bool {
        const dx = self.player_x - self.enemy_x;
        const dy = self.player_y - self.enemy_y;
        const dist2 = dx * dx + dy * dy;
        const radius2 = collision_radius * collision_radius;
        return dist2 <= radius2;
    }

    /// Returns a 0â€“1 hit-flash intensity based on remaining flash time.
    pub fn hitFlashIntensity(self: *const Game) f32 {
        if (self.hit_flash_timer <= 0.0) return 0.0;
        return self.hit_flash_timer / hit_flash_duration;
    }

    pub fn heroPosition(self: *const Game) [2]f32 {
        return .{ self.player_x, self.player_y };
    }

    pub fn enemyPosition(self: *const Game) [2]f32 {
        return .{ self.enemy_x, self.enemy_y };
    }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Tests
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

test "Game basic movement with WASD-style input" {
    var game = Game.init();

    // No movement when no input.
    game.update(1.0, .{});
    try std.testing.expectApproxEqAbs(@as(f32, 0.0), game.player_x, 0.0001);
    try std.testing.expectApproxEqAbs(@as(f32, 0.0), game.player_y, 0.0001);

    // Move forward for 1 second.
    game.update(1.0, .{ .move_forward = true });
    try std.testing.expect(game.player_y > 0.0);
    const y_after_forward = game.player_y;

    // Move backward for 0.5 seconds; should reduce y a bit.
    game.update(0.5, .{ .move_backward = true });
    try std.testing.expect(game.player_y < y_after_forward);

    // Move right for 2 seconds; x should increase.
    game.update(2.0, .{ .move_right = true });
    try std.testing.expect(game.player_x > 0.0);
}

test "Game collision detection basic" {
    var game = Game.init();

    // Hero at origin.
    game.player_x = 0.0;
    game.player_y = 0.0;

    // Far away enemy â†’ no collision.
    game.enemy_x = 1.0;
    game.enemy_y = 0.0;
    try std.testing.expect(!game.isColliding());

    // Bring enemy close enough to collide.
    game.enemy_x = 0.1;
    game.enemy_y = 0.0;
    try std.testing.expect(game.isColliding());
}

test "refAllDecls" {
    std.testing.refAllDecls(@This());
}

<<<

`triangle.frag`: >>>

#version 450

layout(location = 0) in  vec3 vColor;
layout(location = 0) out vec4 outColor;

void main() {
    outColor = vec4(vColor, 1.0);
}

<<<

`triangle.vert`: >>>

#version 450

layout(location = 0) in vec3 inPos;    // Vertex.pos
layout(location = 1) in vec3 inColor;  // Vertex.color

// Matches Zig: extern struct { m: [16]f32 }  (column-major mat4)
layout(push_constant) uniform Push {
    mat4 VP;
} pc;

layout(location = 0) out vec3 vColor;

void main() {
    gl_Position = pc.VP * vec4(inPos, 1.0);
    vColor = inColor;
}

<<<

`vk.xml`: >>>

<?xml version="1.0" encoding="UTF-8"?>
<registry>
    <comment>
Copyright 2015-2025 The Khronos Group Inc.

SPDX-License-Identifier: Apache-2.0 OR MIT
    </comment>

    <comment>
This file, vk.xml, is the Vulkan API Registry. It is a critically important
and normative part of the Vulkan Specification, including a canonical
machine-readable definition of the API, parameter and member validation
language incorporated into the Specification and reference pages, and other
material which is registered by Khronos, such as tags used by extension and
layer authors. The authoritative public version of vk.xml is maintained in
the default branch (currently named main) of the Khronos Vulkan GitHub
project. The authoritative private version is maintained in the default
branch of the member gitlab server.
    </comment>

    <platforms comment="Vulkan platform names, reserved for use with platform- and window system-specific extensions">
        <platform name="xlib" protect="VK_USE_PLATFORM_XLIB_KHR" comment="X Window System, Xlib client library"/>
        <platform name="xlib_xrandr" protect="VK_USE_PLATFORM_XLIB_XRANDR_EXT" comment="X Window System, Xlib client library, XRandR extension"/>
        <platform name="xcb" protect="VK_USE_PLATFORM_XCB_KHR" comment="X Window System, Xcb client library"/>
        <platform name="wayland" protect="VK_USE_PLATFORM_WAYLAND_KHR" comment="Wayland display server protocol"/>
        <platform name="directfb" protect="VK_USE_PLATFORM_DIRECTFB_EXT" comment="DirectFB library"/>
        <platform name="android" protect="VK_USE_PLATFORM_ANDROID_KHR" comment="Android OS"/>
        <platform name="win32" protect="VK_USE_PLATFORM_WIN32_KHR" comment="Microsoft Win32 API (also refers to Win64 apps)"/>
        <platform name="vi" protect="VK_USE_PLATFORM_VI_NN" comment="Nintendo Vi"/>
        <platform name="ios" protect="VK_USE_PLATFORM_IOS_MVK" comment="Apple IOS"/>
        <platform name="macos" protect="VK_USE_PLATFORM_MACOS_MVK" comment="Apple MacOS"/>
        <platform name="metal" protect="VK_USE_PLATFORM_METAL_EXT" comment="Metal on CoreAnimation on Apple platforms"/>
        <platform name="fuchsia" protect="VK_USE_PLATFORM_FUCHSIA" comment="Fuchsia"/>
        <platform name="ggp" protect="VK_USE_PLATFORM_GGP" comment="Google Games Platform"/>
        <platform name="sci" protect="VK_USE_PLATFORM_SCI" comment="NVIDIA SCI"/>
        <platform name="provisional" protect="VK_ENABLE_BETA_EXTENSIONS" comment="Enable declarations for beta/provisional extensions"/>
        <platform name="screen" protect="VK_USE_PLATFORM_SCREEN_QNX" comment="QNX Screen Graphics Subsystem"/>
        <platform name="ohos" protect="VK_USE_PLATFORM_OHOS" comment="Open Harmony OS"/>
    </platforms>

    <tags comment="Vulkan vendor/author tags for extensions and layers">
        <tag name="IMG"         author="Imagination Technologies"      contact="Andrew Garrard @fluppeteer"/>
        <tag name="AMD"         author="Advanced Micro Devices, Inc."  contact="Tobias Hector @tobski"/>
        <tag name="AMDX"        author="Advanced Micro Devices, Inc."  contact="Tobias Hector @tobski"/>
        <tag name="ARM"         author="ARM Limited"                   contact="Jan-Harald Fredriksen @janharaldfredriksen-arm"/>
        <tag name="FSL"         author="Freescale Semiconductor, Inc." contact="Norbert Nopper @FslNopper"/>
        <tag name="BRCM"        author="Broadcom Corporation"          contact="Graeme Leese @gnl21"/>
        <tag name="NXP"         author="NXP Semiconductors N.V."       contact="Norbert Nopper @FslNopper"/>
        <tag name="NV"          author="NVIDIA Corporation"            contact="Daniel Koch @dgkoch"/>
        <tag name="NVX"         author="NVIDIA Corporation"            contact="Daniel Koch @dgkoch"/>
        <tag name="VIV"         author="Vivante Corporation"           contact="Yanjun Zhang gitlab:@yanjunzhang"/>
        <tag name="VSI"         author="VeriSilicon Holdings Co., Ltd." contact="Yanjun Zhang gitlab:@yanjunzhang"/>
        <tag name="KDAB"        author="KDAB"                          contact="Sean Harmer @seanharmer"/>
        <tag name="ANDROID"     author="Google LLC"                    contact="Jesse Hall @critsec"/>
        <tag name="CHROMIUM"    author="Google LLC"                    contact="Jesse Hall @critsec"/>
        <tag name="FUCHSIA"     author="Google LLC"                    contact="Craig Stout @cdotstout, Jesse Hall @critsec, John Rosasco @rosasco"/>
        <tag name="GGP"         author="Google, LLC"                   contact="Jean-Francois Roy @jfroy, Hai Nguyen @chaoticbob, Jesse Hall @critsec"/>
        <tag name="GOOGLE"      author="Google LLC"                    contact="Jesse Hall @critsec"/>
        <tag name="QCOM"        author="Qualcomm Technologies, Inc."   contact="Matthew Netsch @mnetsch"/>
        <tag name="LUNARG"      author="LunarG, Inc."                  contact="Karen Ghavam @karenghavam-lunarg"/>
        <tag name="NZXT"        author="NZXT Inc."                     contact="Jacob Kiesel @xaeroxe"/>
        <tag name="SAMSUNG"     author="Samsung Electronics Co., Ltd." contact="Ralph Potter @r-potter"/>
        <tag name="SEC"         author="Samsung Electronics Co., Ltd." contact="Ralph Potter @r-potter"/>
        <tag name="TIZEN"       author="Samsung Electronics Co., Ltd." contact="Ralph Potter @r-potter"/>
        <tag name="RENDERDOC"   author="RenderDoc (renderdoc.org)"     contact="Baldur Karlsson @baldurk"/>
        <tag name="NN"          author="Nintendo Co., Ltd."            contact="Yasuhiro Yoshioka gitlab:@yoshioka_yasuhiro"/>
        <tag name="MVK"         author="The Brenwill Workshop Ltd."    contact="Bill Hollings @billhollings"/>
        <tag name="KHR"         author="Khronos"                       contact="Ralph Potter @r-potter"/>
        <tag name="KHX"         author="Khronos"                       contact="Ralph Potter @r-potter"/>
        <tag name="EXT"         author="Multivendor"                   contact="Jon Leech @oddhack"/>
        <tag name="MESA"        author="Mesa open source project"      contact="Daniel Stone @fooishbar, David Airlie @airlied, Faith Ekstrand @gfxstrand, Hans-Kristian Arntzen @HansKristian-Work"/>
        <tag name="INTEL"       author="Intel Corporation"             contact="Slawek Grajewski @sgrajewski"/>
        <tag name="HUAWEI"      author="Huawei Technologies Co. Ltd."  contact="Pan Gao @PanGao-h, Juntao Li @Lawrenceleehw"/>
        <tag name="OHOS"        author="Huawei Technologies Co. Ltd."  contact="Weilan Chen @wchen-h"/>
        <tag name="VALVE"       author="Valve Corporation"             contact="Pierre-Loup Griffais @plagman, Joshua Ashton @Joshua-Ashton, Hans-Kristian Arntzen @HansKristian-Work"/>
        <tag name="QNX"         author="BlackBerry Limited"            contact="Mike Gorchak @mgorchak-blackberry, Aaron Ruby @aruby-blackberry"/>
        <tag name="JUICE"       author="Juice Technologies, Inc."      contact="David McCloskey @damcclos, Dean Beeler @canadacow"/>
        <tag name="FB"          author="Facebook, Inc"                 contact="Artem Bolgar @artyom17"/>
        <tag name="RASTERGRID"  author="RasterGrid Kft."               contact="Daniel Rakos @aqnuep"/>
        <tag name="MSFT"        author="Microsoft Corporation"         contact="Jesse Natalie @jenatali"/>
        <tag name="SHADY"       author="Saarland University"           contact="Hugo Devillers @hugobros3"/>
        <tag name="FREDEMMOTT"  author="Frederick Emmott"              contact="Fred Emmott @fredemmott" />
        <tag name="MTK"         author="Mediatek, Inc."                contact="Samuel Huang @shengwenhuang"/>
        <tag name="OPENXR"      author="OpenXR Working Group"          contact="Ron Bessems @rbessems"/>
    </tags>

    <types comment="Vulkan type definitions">
        <type name="vk_platform" category="include">#include "vk_platform.h"</type>

            <comment>WSI extensions</comment>

        <type category="include" name="X11/Xlib.h"/>
        <type category="include" name="X11/extensions/Xrandr.h"/>
        <type category="include" name="wayland-client.h"/>
        <type category="include" name="windows.h"/>
        <type category="include" name="xcb/xcb.h"/>
        <type category="include" name="directfb.h"/>
        <type category="include" name="zircon/types.h"/>
        <type category="include" name="ggp_c/vulkan_types.h"/>
        <type category="include" name="screen/screen.h"/>
        <type category="include" name="nvscisync.h"/>
        <type category="include" name="nvscibuf.h"/>
            <comment>
                In the current header structure, each platform's interfaces
                are confined to a platform-specific header (vulkan_xlib.h,
                vulkan_win32.h, etc.). These headers are not self-contained,
                and should not include native headers (X11/Xlib.h,
                windows.h, etc.). Code should either include vulkan.h after
                defining the appropriate VK_USE_PLATFORM_platform
                macros, or include the required native headers prior to
                explicitly including the corresponding platform header.

                To accomplish this, the dependencies of native types require
                native headers, but the XML defines the content for those
                native headers as empty. The actual native header includes
                can be restored by modifying the native header tags above
                to #include the header file in the 'name' attribute.
            </comment>

        <type requires="X11/Xlib.h" name="Display"/>
        <type requires="X11/Xlib.h" name="VisualID"/>
        <type requires="X11/Xlib.h" name="Window"/>
        <type requires="X11/extensions/Xrandr.h" name="RROutput"/>
        <type requires="wayland-client.h" name="wl_display"/>
        <type requires="wayland-client.h" name="wl_surface"/>
        <type requires="windows.h" name="HINSTANCE"/>
        <type requires="windows.h" name="HWND"/>
        <type requires="windows.h" name="HMONITOR"/>
        <type requires="windows.h" name="HANDLE"/>
        <type requires="windows.h" name="SECURITY_ATTRIBUTES"/>
        <type requires="windows.h" name="DWORD"/>
        <type requires="windows.h" name="LPCWSTR"/>
        <type requires="xcb/xcb.h" name="xcb_connection_t"/>
        <type requires="xcb/xcb.h" name="xcb_visualid_t"/>
        <type requires="xcb/xcb.h" name="xcb_window_t"/>
        <type requires="directfb.h" name="IDirectFB"/>
        <type requires="directfb.h" name="IDirectFBSurface"/>
        <type requires="zircon/types.h" name="zx_handle_t"/>
        <type requires="ggp_c/vulkan_types.h" name="GgpStreamDescriptor"/>
        <type requires="ggp_c/vulkan_types.h" name="GgpFrameToken"/>
        <type requires="screen/screen.h" name="_screen_context"/>
        <type requires="screen/screen.h" name="_screen_window"/>
        <type requires="screen/screen.h" name="_screen_buffer"/>
        <type requires="nvscisync.h" name="NvSciSyncAttrList"/>
        <type requires="nvscisync.h" name="NvSciSyncObj"/>
        <type requires="nvscisync.h" name="NvSciSyncFence"/>
        <type requires="nvscibuf.h" name="NvSciBufAttrList"/>
        <type requires="nvscibuf.h" name="NvSciBufObj"/>

        <type category="define">
#define <name>VK_MAKE_VERSION</name>(major, minor, patch) \
    ((((uint32_t)(major)) &lt;&lt; 22U) | (((uint32_t)(minor)) &lt;&lt; 12U) | ((uint32_t)(patch)))</type>
        <type category="define">
#define <name>VK_VERSION_MAJOR</name>(version) ((uint32_t)(version) &gt;&gt; 22U)</type>
        <type category="define">
#define <name>VK_VERSION_MINOR</name>(version) (((uint32_t)(version) &gt;&gt; 12U) &amp; 0x3FFU)</type>
        <type category="define">
#define <name>VK_VERSION_PATCH</name>(version) ((uint32_t)(version) &amp; 0xFFFU)</type>

        <type category="define">#define <name>VK_MAKE_API_VERSION</name>(variant, major, minor, patch) \
    ((((uint32_t)(variant)) &lt;&lt; 29U) | (((uint32_t)(major)) &lt;&lt; 22U) | (((uint32_t)(minor)) &lt;&lt; 12U) | ((uint32_t)(patch)))</type>
        <type category="define">#define <name>VK_API_VERSION_VARIANT</name>(version) ((uint32_t)(version) &gt;&gt; 29U)</type>
        <type category="define">#define <name>VK_API_VERSION_MAJOR</name>(version) (((uint32_t)(version) &gt;&gt; 22U) &amp; 0x7FU)</type>
        <type category="define">#define <name>VK_API_VERSION_MINOR</name>(version) (((uint32_t)(version) &gt;&gt; 12U) &amp; 0x3FFU)</type>
        <type category="define">#define <name>VK_API_VERSION_PATCH</name>(version) ((uint32_t)(version) &amp; 0xFFFU)</type>

        <type category="define" requires="VK_HEADER_VERSION">// Vulkan SC variant number
#define <name>VKSC_API_VARIANT</name> 1</type>

        <type category="define">
//#define <name>VK_API_VERSION</name> <type>VK_MAKE_API_VERSION</type>(0, 1, 0, 0) // Patch version should always be set to 0</type>
        <type category="define">// Vulkan 1.0 version number
#define <name>VK_API_VERSION_1_0</name> <type>VK_MAKE_API_VERSION</type>(0, 1, 0, 0)// Patch version should always be set to 0</type>
        <type category="define">// Vulkan 1.1 version number
#define <name>VK_API_VERSION_1_1</name> <type>VK_MAKE_API_VERSION</type>(0, 1, 1, 0)// Patch version should always be set to 0</type>
        <type category="define">// Vulkan 1.2 version number
#define <name>VK_API_VERSION_1_2</name> <type>VK_MAKE_API_VERSION</type>(0, 1, 2, 0)// Patch version should always be set to 0</type>
        <type category="define" requires="VK_MAKE_API_VERSION">// Vulkan 1.3 version number
#define <name>VK_API_VERSION_1_3</name> <type>VK_MAKE_API_VERSION</type>(0, 1, 3, 0)// Patch version should always be set to 0</type>
        <type category="define" requires="VK_MAKE_API_VERSION">// Vulkan 1.4 version number
#define <name>VK_API_VERSION_1_4</name> <type>VK_MAKE_API_VERSION</type>(0, 1, 4, 0)// Patch version should always be set to 0</type>
        <type category="define" requires="VKSC_API_VARIANT">// Vulkan SC 1.0 version number
#define <name>VKSC_API_VERSION_1_0</name> <type>VK_MAKE_API_VERSION</type>(VKSC_API_VARIANT, 1, 0, 0)// Patch version should always be set to 0</type>

        <type api="vulkan,vulkanbase" category="define">// Version of this file
#define <name>VK_HEADER_VERSION</name> 335</type>
        <type api="vulkan,vulkanbase" category="define" requires="VK_HEADER_VERSION">// Complete version of this file
#define <name>VK_HEADER_VERSION_COMPLETE</name> <type>VK_MAKE_API_VERSION</type>(0, 1, 4, VK_HEADER_VERSION)</type>
        <type api="vulkansc" category="define">// Version of this file
#define <name>VK_HEADER_VERSION</name> 20</type>
        <type api="vulkansc" category="define" requires="VKSC_API_VARIANT">// Complete version of this file
#define <name>VK_HEADER_VERSION_COMPLETE</name> <type>VK_MAKE_API_VERSION</type>(VKSC_API_VARIANT, 1, 0, VK_HEADER_VERSION)</type>

        <type api="vulkan,vulkanbase" category="define">
#define <name>VK_DEFINE_HANDLE</name>(object) typedef struct object##_T* object;</type>
        <type api="vulkansc" category="define" comment="Extra parenthesis are a MISRA-C requirement that exposes a bug in MSVC">
#define <name>VK_DEFINE_HANDLE</name>(object) typedef struct object##_T* (object);</type>

        <type category="define" name="VK_USE_64_BIT_PTR_DEFINES">
#ifndef VK_USE_64_BIT_PTR_DEFINES
    #if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) &amp;&amp; !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__) || (defined(__riscv) &amp;&amp; __riscv_xlen == 64)
        #define VK_USE_64_BIT_PTR_DEFINES 1
    #else
        #define VK_USE_64_BIT_PTR_DEFINES 0
    #endif
#endif</type>
        <type category="define" requires="VK_USE_64_BIT_PTR_DEFINES" name="VK_NULL_HANDLE">
#ifndef VK_DEFINE_NON_DISPATCHABLE_HANDLE
    #if (VK_USE_64_BIT_PTR_DEFINES==1)
        #if (defined(__cplusplus) &amp;&amp; (__cplusplus >= 201103L)) || (defined(_MSVC_LANG) &amp;&amp; (_MSVC_LANG >= 201103L))
            #define VK_NULL_HANDLE nullptr
        #else
            #define VK_NULL_HANDLE ((void*)0)
        #endif
    #else
        #define VK_NULL_HANDLE 0ULL
    #endif
#endif
#ifndef VK_NULL_HANDLE
    #define VK_NULL_HANDLE 0
#endif</type>
        <type api="vulkan,vulkanbase" category="define" requires="VK_NULL_HANDLE" name="VK_DEFINE_NON_DISPATCHABLE_HANDLE">
#ifndef VK_DEFINE_NON_DISPATCHABLE_HANDLE
    #if (VK_USE_64_BIT_PTR_DEFINES==1)
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
    #else
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
    #endif
#endif</type>
        <type api="vulkansc" category="define" requires="VK_NULL_HANDLE" name="VK_DEFINE_NON_DISPATCHABLE_HANDLE" comment="Extra parenthesis are a MISRA-C requirement that exposes a bug in MSVC">
#ifndef VK_DEFINE_NON_DISPATCHABLE_HANDLE
    #if (VK_USE_64_BIT_PTR_DEFINES==1)
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *(object);
    #else
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t (object);
    #endif
#endif</type>

        <type category="basetype">struct <name>ANativeWindow</name>;</type>
        <type category="basetype">struct <name>AHardwareBuffer</name>;</type>
        <type category="basetype">#ifdef __OBJC__
@class CAMetalLayer;
#else
typedef void <name>CAMetalLayer</name>;
#endif</type>
        <type category="basetype">#ifdef __OBJC__
@protocol MTLDevice;
typedef __unsafe_unretained id&lt;MTLDevice&gt; MTLDevice_id;
#else
typedef void* <name>MTLDevice_id</name>;
#endif</type>
        <type category="basetype">#ifdef __OBJC__
@protocol MTLCommandQueue;
typedef __unsafe_unretained id&lt;MTLCommandQueue&gt; MTLCommandQueue_id;
#else
typedef void* <name>MTLCommandQueue_id</name>;
#endif</type>
        <type category="basetype">#ifdef __OBJC__
@protocol MTLBuffer;
typedef __unsafe_unretained id&lt;MTLBuffer&gt; MTLBuffer_id;
#else
typedef void* <name>MTLBuffer_id</name>;
#endif</type>
        <type category="basetype">#ifdef __OBJC__
@protocol MTLTexture;
typedef __unsafe_unretained id&lt;MTLTexture&gt; MTLTexture_id;
#else
typedef void* <name>MTLTexture_id</name>;
#endif</type>
        <type category="basetype">#ifdef __OBJC__
@protocol MTLSharedEvent;
typedef __unsafe_unretained id&lt;MTLSharedEvent&gt; MTLSharedEvent_id;
#else
typedef void* <name>MTLSharedEvent_id</name>;
#endif</type>
        <type category="basetype">typedef struct __IOSurface* <name>IOSurfaceRef</name>;</type>

        <type category="basetype">typedef <type>uint32_t</type> <name>VkSampleMask</name>;</type>
        <type category="basetype">typedef <type>uint32_t</type> <name>VkBool32</name>;</type>
        <type category="basetype">typedef <type>uint32_t</type> <name>VkFlags</name>;</type>
        <type category="basetype">typedef <type>uint64_t</type> <name>VkFlags64</name>;</type>
        <type category="basetype">typedef <type>uint64_t</type> <name>VkDeviceSize</name>;</type>
        <type category="basetype">typedef <type>uint64_t</type> <name>VkDeviceAddress</name>;</type>

        <type category="basetype">typedef struct NativeWindow <name>OHNativeWindow</name>;</type>
        <type category="basetype">struct <name>OHBufferHandle</name>;</type>
        <type category="basetype">struct <name>OH_NativeBuffer</name>;</type>

            <comment>Basic C types, pulled in via vk_platform.h</comment>
        <type requires="vk_platform" name="void"/>
        <type requires="vk_platform" name="char"/>
        <type requires="vk_platform" name="float"/>
        <type requires="vk_platform" name="double"/>
        <type requires="vk_platform" name="int8_t"/>
        <type requires="vk_platform" name="uint8_t"/>
        <type requires="vk_platform" name="int16_t"/>
        <type requires="vk_platform" name="uint16_t"/>
        <type requires="vk_platform" name="uint32_t"/>
        <type requires="vk_platform" name="uint64_t"/>
        <type requires="vk_platform" name="int32_t"/>
        <type requires="vk_platform" name="int64_t"/>
        <type requires="vk_platform" name="size_t"/>
        <type name="int"/>

            <comment>Bitmask types</comment>
        <type requires="VkFramebufferCreateFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkFramebufferCreateFlags</name>;</type>
        <type requires="VkQueryPoolCreateFlagBits"        category="bitmask">typedef <type>VkFlags</type> <name>VkQueryPoolCreateFlags</name>;</type>
        <type requires="VkRenderPassCreateFlagBits"       category="bitmask">typedef <type>VkFlags</type> <name>VkRenderPassCreateFlags</name>;</type>
        <type requires="VkSamplerCreateFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkSamplerCreateFlags</name>;</type>
        <type requires="VkPipelineLayoutCreateFlagBits"   category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineLayoutCreateFlags</name>;</type>
        <type requires="VkPipelineCacheCreateFlagBits"    category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCacheCreateFlags</name>;</type>
        <type api="vulkan,vulkanbase" requires="VkPipelineDepthStencilStateCreateFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineDepthStencilStateCreateFlags</name>;</type>
        <type api="vulkansc" category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineDepthStencilStateCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineDynamicStateCreateFlags</name>;</type>
        <type api="vulkan,vulkanbase" requires="VkPipelineColorBlendStateCreateFlagBits"   category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineColorBlendStateCreateFlags</name>;</type>
        <type api="vulkansc" category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineColorBlendStateCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineMultisampleStateCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineRasterizationStateCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineViewportStateCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineTessellationStateCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineInputAssemblyStateCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineVertexInputStateCreateFlags</name>;</type>
        <type requires="VkPipelineShaderStageCreateFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineShaderStageCreateFlags</name>;</type>
        <type requires="VkDescriptorSetLayoutCreateFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorSetLayoutCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkBufferViewCreateFlags</name>;</type>
        <type requires="VkInstanceCreateFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkInstanceCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceCreateFlags</name>;</type>
        <type requires="VkDeviceQueueCreateFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceQueueCreateFlags</name>;</type>
        <type requires="VkQueueFlagBits"                  category="bitmask">typedef <type>VkFlags</type> <name>VkQueueFlags</name>;</type>
        <type requires="VkMemoryPropertyFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryPropertyFlags</name>;</type>
        <type requires="VkMemoryHeapFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryHeapFlags</name>;</type>
        <type requires="VkAccessFlagBits"                 category="bitmask">typedef <type>VkFlags</type> <name>VkAccessFlags</name>;</type>
        <type requires="VkBufferUsageFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkBufferUsageFlags</name>;</type>
        <type requires="VkBufferCreateFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkBufferCreateFlags</name>;</type>
        <type requires="VkShaderStageFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkShaderStageFlags</name>;</type>
        <type requires="VkImageUsageFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkImageUsageFlags</name>;</type>
        <type requires="VkImageCreateFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkImageCreateFlags</name>;</type>
        <type requires="VkImageViewCreateFlagBits"        category="bitmask">typedef <type>VkFlags</type> <name>VkImageViewCreateFlags</name>;</type>
        <type requires="VkPipelineCreateFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCreateFlags</name>;</type>
        <type requires="VkColorComponentFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkColorComponentFlags</name>;</type>
        <type requires="VkFenceCreateFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkFenceCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkSemaphoreCreateFlags</name>;</type>
        <type requires="VkFormatFeatureFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkFormatFeatureFlags</name>;</type>
        <type requires="VkQueryControlFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkQueryControlFlags</name>;</type>
        <type requires="VkQueryResultFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkQueryResultFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkShaderModuleCreateFlags</name>;</type>
        <type requires="VkEventCreateFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkEventCreateFlags</name>;</type>
        <type requires="VkCommandPoolCreateFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkCommandPoolCreateFlags</name>;</type>
        <type requires="VkCommandPoolResetFlagBits"       category="bitmask">typedef <type>VkFlags</type> <name>VkCommandPoolResetFlags</name>;</type>
        <type requires="VkCommandBufferResetFlagBits"     category="bitmask">typedef <type>VkFlags</type> <name>VkCommandBufferResetFlags</name>;</type>
        <type requires="VkCommandBufferUsageFlagBits"     category="bitmask">typedef <type>VkFlags</type> <name>VkCommandBufferUsageFlags</name>;</type>
        <type requires="VkQueryPipelineStatisticFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkQueryPipelineStatisticFlags</name>;</type>
        <type requires="VkMemoryMapFlagBits"              category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryMapFlags</name>;</type>
        <type requires="VkMemoryUnmapFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryUnmapFlags</name>;</type>
        <type                                             category="bitmask" name="VkMemoryUnmapFlagsKHR" alias="VkMemoryUnmapFlags"/>
        <type requires="VkImageAspectFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkImageAspectFlags</name>;</type>
        <type requires="VkSparseMemoryBindFlagBits"       category="bitmask">typedef <type>VkFlags</type> <name>VkSparseMemoryBindFlags</name>;</type>
        <type requires="VkSparseImageFormatFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkSparseImageFormatFlags</name>;</type>
        <type requires="VkSubpassDescriptionFlagBits"     category="bitmask">typedef <type>VkFlags</type> <name>VkSubpassDescriptionFlags</name>;</type>
        <type requires="VkPipelineStageFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineStageFlags</name>;</type>
        <type requires="VkSampleCountFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkSampleCountFlags</name>;</type>
        <type requires="VkAttachmentDescriptionFlagBits"  category="bitmask">typedef <type>VkFlags</type> <name>VkAttachmentDescriptionFlags</name>;</type>
        <type requires="VkStencilFaceFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkStencilFaceFlags</name>;</type>
        <type requires="VkCullModeFlagBits"               category="bitmask">typedef <type>VkFlags</type> <name>VkCullModeFlags</name>;</type>
        <type requires="VkDescriptorPoolCreateFlagBits"   category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorPoolCreateFlags</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorPoolResetFlags</name>;</type>
        <type requires="VkDependencyFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkDependencyFlags</name>;</type>
        <type requires="VkSubgroupFeatureFlagBits"        category="bitmask">typedef <type>VkFlags</type> <name>VkSubgroupFeatureFlags</name>;</type>
        <type requires="VkIndirectCommandsLayoutUsageFlagBitsNV" category="bitmask">typedef <type>VkFlags</type> <name>VkIndirectCommandsLayoutUsageFlagsNV</name>;</type>
        <type requires="VkIndirectStateFlagBitsNV"        category="bitmask">typedef <type>VkFlags</type> <name>VkIndirectStateFlagsNV</name>;</type>
        <type requires="VkGeometryFlagBitsKHR"            category="bitmask">typedef <type>VkFlags</type> <name>VkGeometryFlagsKHR</name>;</type>
        <type                                             category="bitmask" name="VkGeometryFlagsNV" alias="VkGeometryFlagsKHR"/>
        <type requires="VkGeometryInstanceFlagBitsKHR"    category="bitmask">typedef <type>VkFlags</type> <name>VkGeometryInstanceFlagsKHR</name>;</type>
        <type                                             category="bitmask" name="VkGeometryInstanceFlagsNV" alias="VkGeometryInstanceFlagsKHR"/>
        <type requires="VkClusterAccelerationStructureGeometryFlagBitsNV"     category="bitmask">typedef <type>VkFlags</type> <name>VkClusterAccelerationStructureGeometryFlagsNV</name>;</type>
        <type requires="VkClusterAccelerationStructureClusterFlagBitsNV"      category="bitmask">typedef <type>VkFlags</type> <name>VkClusterAccelerationStructureClusterFlagsNV</name>;</type>
        <type requires="VkClusterAccelerationStructureAddressResolutionFlagBitsNV"      category="bitmask">typedef <type>VkFlags</type> <name>VkClusterAccelerationStructureAddressResolutionFlagsNV</name>;</type>
        <type requires="VkBuildAccelerationStructureFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkBuildAccelerationStructureFlagsKHR</name>;</type>
        <type                                             category="bitmask" name="VkBuildAccelerationStructureFlagsNV" alias="VkBuildAccelerationStructureFlagsKHR"/>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPrivateDataSlotCreateFlags</name>;</type>
        <type                                             category="bitmask" name="VkPrivateDataSlotCreateFlagsEXT" alias="VkPrivateDataSlotCreateFlags"/>
        <type requires="VkAccelerationStructureCreateFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkAccelerationStructureCreateFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorUpdateTemplateCreateFlags</name>;</type>
        <type                                             category="bitmask" name="VkDescriptorUpdateTemplateCreateFlagsKHR" alias="VkDescriptorUpdateTemplateCreateFlags"/>
        <type requires="VkPipelineCreationFeedbackFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCreationFeedbackFlags</name>;</type>
        <type                                             category="bitmask" name="VkPipelineCreationFeedbackFlagsEXT" alias="VkPipelineCreationFeedbackFlags"/>
        <type requires="VkPerformanceCounterDescriptionFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkPerformanceCounterDescriptionFlagsKHR</name>;</type>
        <type requires="VkAcquireProfilingLockFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkAcquireProfilingLockFlagsKHR</name>;</type>
        <type requires="VkSemaphoreWaitFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkSemaphoreWaitFlags</name>;</type>
        <type                                             category="bitmask" name="VkSemaphoreWaitFlagsKHR" alias="VkSemaphoreWaitFlags"/>
        <type requires="VkPipelineCompilerControlFlagBitsAMD" category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCompilerControlFlagsAMD</name>;</type>
        <type requires="VkShaderCorePropertiesFlagBitsAMD" category="bitmask">typedef <type>VkFlags</type> <name>VkShaderCorePropertiesFlagsAMD</name>;</type>
        <type requires="VkDeviceDiagnosticsConfigFlagBitsNV" category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceDiagnosticsConfigFlagsNV</name>;</type>
        <type requires="VkRefreshObjectFlagBitsKHR"       category="bitmask">typedef <type>VkFlags</type> <name>VkRefreshObjectFlagsKHR</name>;</type>
        <type bitvalues="VkAccessFlagBits2"               category="bitmask">typedef <type>VkFlags64</type> <name>VkAccessFlags2</name>;</type>
        <type                                             category="bitmask" name="VkAccessFlags2KHR" alias="VkAccessFlags2"/>
        <type bitvalues="VkPipelineStageFlagBits2"        category="bitmask">typedef <type>VkFlags64</type> <name>VkPipelineStageFlags2</name>;</type>
        <type                                             category="bitmask" name="VkPipelineStageFlags2KHR" alias="VkPipelineStageFlags2"/>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkAccelerationStructureMotionInfoFlagsNV</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkAccelerationStructureMotionInstanceFlagsNV</name>;</type>
        <type bitvalues="VkFormatFeatureFlagBits2"        category="bitmask">typedef <type>VkFlags64</type> <name>VkFormatFeatureFlags2</name>;</type>
        <type                                             category="bitmask" name="VkFormatFeatureFlags2KHR" alias="VkFormatFeatureFlags2"/>
        <type requires="VkRenderingFlagBits"              category="bitmask">typedef <type>VkFlags</type> <name>VkRenderingFlags</name>;</type>
        <type bitvalues="VkMemoryDecompressionMethodFlagBitsEXT" category="bitmask">typedef <type>VkFlags64</type> <name>VkMemoryDecompressionMethodFlagsEXT</name>;</type>
        <type                                             category="bitmask" name="VkMemoryDecompressionMethodFlagsNV" alias="VkMemoryDecompressionMethodFlagsEXT"/>
        <type                                             category="bitmask" name="VkRenderingFlagsKHR" alias="VkRenderingFlags"/>
        <type requires="VkBuildMicromapFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkBuildMicromapFlagsEXT</name>;</type>
        <type requires="VkMicromapCreateFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkMicromapCreateFlagsEXT</name>;</type>
        <type requires="VkIndirectCommandsLayoutUsageFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkIndirectCommandsLayoutUsageFlagsEXT</name>;</type>
        <type requires="VkIndirectCommandsInputModeFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkIndirectCommandsInputModeFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDirectDriverLoadingFlagsLUNARG</name>;</type>
        <type bitvalues="VkPipelineCreateFlagBits2"       category="bitmask">typedef <type>VkFlags64</type> <name>VkPipelineCreateFlags2</name>;</type>
        <type                                             category="bitmask" name="VkPipelineCreateFlags2KHR" alias="VkPipelineCreateFlags2"/>
        <type bitvalues="VkBufferUsageFlagBits2"          category="bitmask">typedef <type>VkFlags64</type> <name>VkBufferUsageFlags2</name>;</type>
        <type                                             category="bitmask" name="VkBufferUsageFlags2KHR" alias="VkBufferUsageFlags2"/>
        <type requires="VkAddressCopyFlagBitsKHR"         category="bitmask">typedef <type>VkFlags</type> <name>VkAddressCopyFlagsKHR</name>;</type>
        <type bitvalues="VkTensorCreateFlagBitsARM"        category="bitmask">typedef <type>VkFlags64</type> <name>VkTensorCreateFlagsARM</name>;</type>
        <type bitvalues="VkTensorUsageFlagBitsARM"         category="bitmask">typedef <type>VkFlags64</type> <name>VkTensorUsageFlagsARM</name>;</type>
        <type bitvalues="VkTensorViewCreateFlagBitsARM"    category="bitmask">typedef <type>VkFlags64</type> <name>VkTensorViewCreateFlagsARM</name>;</type>
        <type bitvalues="VkDataGraphPipelineSessionCreateFlagBitsARM" category="bitmask">typedef <type>VkFlags64</type> <name>VkDataGraphPipelineSessionCreateFlagsARM</name>;</type>
        <type bitvalues="VkDataGraphPipelineDispatchFlagBitsARM" category="bitmask">typedef <type>VkFlags64</type> <name>VkDataGraphPipelineDispatchFlagsARM</name>;</type>
        <type requires="VkVideoEncodeRgbModelConversionFlagBitsVALVE" category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeRgbModelConversionFlagsVALVE</name>;</type>
        <type requires="VkVideoEncodeRgbRangeCompressionFlagBitsVALVE" category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeRgbRangeCompressionFlagsVALVE</name>;</type>
        <type requires="VkVideoEncodeRgbChromaOffsetFlagBitsVALVE" category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeRgbChromaOffsetFlagsVALVE</name>;</type>

            <comment>WSI extensions</comment>
        <type requires="VkCompositeAlphaFlagBitsKHR"      category="bitmask">typedef <type>VkFlags</type> <name>VkCompositeAlphaFlagsKHR</name>;</type>
        <type requires="VkDisplayPlaneAlphaFlagBitsKHR"   category="bitmask">typedef <type>VkFlags</type> <name>VkDisplayPlaneAlphaFlagsKHR</name>;</type>
        <type requires="VkSurfaceTransformFlagBitsKHR"    category="bitmask">typedef <type>VkFlags</type> <name>VkSurfaceTransformFlagsKHR</name>;</type>
        <type requires="VkSwapchainCreateFlagBitsKHR"     category="bitmask">typedef <type>VkFlags</type> <name>VkSwapchainCreateFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDisplayModeCreateFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDisplaySurfaceCreateFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkAndroidSurfaceCreateFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkViSurfaceCreateFlagsNN</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkWaylandSurfaceCreateFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkWin32SurfaceCreateFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkXlibSurfaceCreateFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkXcbSurfaceCreateFlagsKHR</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDirectFBSurfaceCreateFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkIOSSurfaceCreateFlagsMVK</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkMacOSSurfaceCreateFlagsMVK</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkMetalSurfaceCreateFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkImagePipeSurfaceCreateFlagsFUCHSIA</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkStreamDescriptorSurfaceCreateFlagsGGP</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkHeadlessSurfaceCreateFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkScreenSurfaceCreateFlagsQNX</name>;</type>
        <type requires="VkPeerMemoryFeatureFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkPeerMemoryFeatureFlags</name>;</type>
        <type                                             category="bitmask" name="VkPeerMemoryFeatureFlagsKHR"               alias="VkPeerMemoryFeatureFlags"/>
        <type requires="VkMemoryAllocateFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryAllocateFlags</name>;</type>
        <type                                             category="bitmask" name="VkMemoryAllocateFlagsKHR"                  alias="VkMemoryAllocateFlags"/>
        <type requires="VkDeviceGroupPresentModeFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceGroupPresentModeFlagsKHR</name>;</type>

        <type requires="VkDebugReportFlagBitsEXT"         category="bitmask">typedef <type>VkFlags</type> <name>VkDebugReportFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkCommandPoolTrimFlags</name>;</type>
        <type                                             category="bitmask" name="VkCommandPoolTrimFlagsKHR"                 alias="VkCommandPoolTrimFlags"/>
        <type requires="VkExternalMemoryHandleTypeFlagBitsNV" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalMemoryHandleTypeFlagsNV</name>;</type>
        <type requires="VkClusterAccelerationStructureIndexFormatFlagBitsNV" category="bitmask">typedef <type>VkFlags</type> <name>VkClusterAccelerationStructureIndexFormatFlagsNV</name>;</type>
        <type requires="VkExternalMemoryFeatureFlagBitsNV" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalMemoryFeatureFlagsNV</name>;</type>
        <type requires="VkExternalMemoryHandleTypeFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalMemoryHandleTypeFlags</name>;</type>
        <type                                             category="bitmask" name="VkExternalMemoryHandleTypeFlagsKHR"        alias="VkExternalMemoryHandleTypeFlags"/>
        <type requires="VkExternalMemoryFeatureFlagBits"  category="bitmask">typedef <type>VkFlags</type> <name>VkExternalMemoryFeatureFlags</name>;</type>
        <type                                             category="bitmask" name="VkExternalMemoryFeatureFlagsKHR"           alias="VkExternalMemoryFeatureFlags"/>
        <type requires="VkExternalSemaphoreHandleTypeFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalSemaphoreHandleTypeFlags</name>;</type>
        <type                                             category="bitmask" name="VkExternalSemaphoreHandleTypeFlagsKHR"     alias="VkExternalSemaphoreHandleTypeFlags"/>
        <type requires="VkExternalSemaphoreFeatureFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalSemaphoreFeatureFlags</name>;</type>
        <type                                             category="bitmask" name="VkExternalSemaphoreFeatureFlagsKHR"        alias="VkExternalSemaphoreFeatureFlags"/>
        <type requires="VkSemaphoreImportFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkSemaphoreImportFlags</name>;</type>
        <type                                             category="bitmask" name="VkSemaphoreImportFlagsKHR"                 alias="VkSemaphoreImportFlags"/>
        <type requires="VkExternalFenceHandleTypeFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalFenceHandleTypeFlags</name>;</type>
        <type                                             category="bitmask" name="VkExternalFenceHandleTypeFlagsKHR"         alias="VkExternalFenceHandleTypeFlags"/>
        <type requires="VkExternalFenceFeatureFlagBits"   category="bitmask">typedef <type>VkFlags</type> <name>VkExternalFenceFeatureFlags</name>;</type>
        <type                                             category="bitmask" name="VkExternalFenceFeatureFlagsKHR"            alias="VkExternalFenceFeatureFlags"/>
        <type requires="VkFenceImportFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkFenceImportFlags</name>;</type>
        <type                                             category="bitmask" name="VkFenceImportFlagsKHR"                     alias="VkFenceImportFlags"/>
        <type requires="VkSurfaceCounterFlagBitsEXT"      category="bitmask">typedef <type>VkFlags</type> <name>VkSurfaceCounterFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineViewportSwizzleStateCreateFlagsNV</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineDiscardRectangleStateCreateFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCoverageToColorStateCreateFlagsNV</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCoverageModulationStateCreateFlagsNV</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCoverageReductionStateCreateFlagsNV</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkValidationCacheCreateFlagsEXT</name>;</type>
        <type requires="VkDebugUtilsMessageSeverityFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkDebugUtilsMessageSeverityFlagsEXT</name>;</type>
        <type requires="VkDebugUtilsMessageTypeFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkDebugUtilsMessageTypeFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDebugUtilsMessengerCreateFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDebugUtilsMessengerCallbackDataFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceMemoryReportFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineRasterizationConservativeStateCreateFlagsEXT</name>;</type>
        <type requires="VkDescriptorBindingFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorBindingFlags</name>;</type>
        <type                                             category="bitmask" name="VkDescriptorBindingFlagsEXT"               alias="VkDescriptorBindingFlags"/>
        <type requires="VkConditionalRenderingFlagBitsEXT"  category="bitmask">typedef <type>VkFlags</type> <name>VkConditionalRenderingFlagsEXT</name>;</type>
        <type requires="VkResolveModeFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkResolveModeFlags</name>;</type>
        <type                                             category="bitmask" name="VkResolveModeFlagsKHR"                     alias="VkResolveModeFlags"/>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineRasterizationStateStreamCreateFlagsEXT</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineRasterizationDepthClipStateCreateFlagsEXT</name>;</type>
        <type requires="VkSwapchainImageUsageFlagBitsANDROID" category="bitmask">typedef <type>VkFlags</type> <name>VkSwapchainImageUsageFlagsANDROID</name>;</type>
        <type requires="VkToolPurposeFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkToolPurposeFlags</name>;</type>
        <type                                             category="bitmask" name="VkToolPurposeFlagsEXT"                     alias="VkToolPurposeFlags"/>
        <type requires="VkSubmitFlagBits"                 category="bitmask">typedef <type>VkFlags</type> <name>VkSubmitFlags</name>;</type>
        <type                                             category="bitmask" name="VkSubmitFlagsKHR"                          alias="VkSubmitFlags"/>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkImageFormatConstraintsFlagsFUCHSIA</name>;</type>
        <type requires="VkHostImageCopyFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkHostImageCopyFlags</name>;</type>
        <type                                             category="bitmask" name="VkHostImageCopyFlagsEXT"                   alias="VkHostImageCopyFlags"/>
        <type requires="VkPartitionedAccelerationStructureInstanceFlagBitsNV" category="bitmask">typedef <type>VkFlags</type> <name>VkPartitionedAccelerationStructureInstanceFlagsNV</name>;</type>
        <type requires="VkImageConstraintsInfoFlagBitsFUCHSIA"   category="bitmask">typedef <type>VkFlags</type> <name>VkImageConstraintsInfoFlagsFUCHSIA</name>;</type>
        <type requires="VkGraphicsPipelineLibraryFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkGraphicsPipelineLibraryFlagsEXT</name>;</type>
        <type requires="VkImageCompressionFlagBitsEXT"          category="bitmask">typedef <type>VkFlags</type> <name>VkImageCompressionFlagsEXT</name>;</type>
        <type requires="VkImageCompressionFixedRateFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkImageCompressionFixedRateFlagsEXT</name>;</type>
        <type requires="VkExportMetalObjectTypeFlagBitsEXT"     category="bitmask">typedef <type>VkFlags</type> <name>VkExportMetalObjectTypeFlagsEXT</name>;</type>
        <type requires="VkRenderingAttachmentFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkRenderingAttachmentFlagsKHR</name>;</type>
        <type requires="VkResolveImageFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkResolveImageFlagsKHR</name>;</type>
        <type requires="VkDeviceAddressBindingFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceAddressBindingFlagsEXT</name>;</type>
        <type requires="VkOpticalFlowGridSizeFlagBitsNV"        category="bitmask">typedef <type>VkFlags</type>   <name>VkOpticalFlowGridSizeFlagsNV</name>;</type>
        <type requires="VkOpticalFlowUsageFlagBitsNV"           category="bitmask">typedef <type>VkFlags</type>   <name>VkOpticalFlowUsageFlagsNV</name>;</type>
        <type requires="VkOpticalFlowSessionCreateFlagBitsNV"   category="bitmask">typedef <type>VkFlags</type>   <name>VkOpticalFlowSessionCreateFlagsNV</name>;</type>
        <type requires="VkOpticalFlowExecuteFlagBitsNV"         category="bitmask">typedef <type>VkFlags</type>   <name>VkOpticalFlowExecuteFlagsNV</name>;</type>
        <type requires="VkFrameBoundaryFlagBitsEXT"       category="bitmask">typedef <type>VkFlags</type> <name>VkFrameBoundaryFlagsEXT</name>;</type>
        <type requires="VkPresentScalingFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkPresentScalingFlagsKHR</name>;</type>
        <type                                        category="bitmask" name="VkPresentScalingFlagsEXT"                       alias="VkPresentScalingFlagsKHR"/>
        <type requires="VkPresentGravityFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkPresentGravityFlagsKHR</name>;</type>
        <type                                        category="bitmask" name="VkPresentGravityFlagsEXT"                       alias="VkPresentGravityFlagsKHR"/>
        <type requires="VkShaderCreateFlagBitsEXT"        category="bitmask">typedef <type>VkFlags</type> <name>VkShaderCreateFlagsEXT</name>;</type>
        <type requires="VkTileShadingRenderPassFlagBitsQCOM"   category="bitmask">typedef <type>VkFlags</type> <name>VkTileShadingRenderPassFlagsQCOM</name>;</type>
        <type bitvalues="VkPhysicalDeviceSchedulingControlsFlagBitsARM" category="bitmask">typedef <type>VkFlags64</type> <name>VkPhysicalDeviceSchedulingControlsFlagsARM</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkSurfaceCreateFlagsOHOS</name>;</type>
        <type bitvalues="VkPresentStageFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkPresentStageFlagsEXT</name>;</type>
        <type bitvalues="VkPastPresentationTimingFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkPastPresentationTimingFlagsEXT</name>;</type>
        <type bitvalues="VkPresentTimingInfoFlagBitsEXT"      category="bitmask">typedef <type>VkFlags</type> <name>VkPresentTimingInfoFlagsEXT</name>;</type>
        <type requires="VkSwapchainImageUsageFlagBitsOHOS" category="bitmask">typedef <type>VkFlags</type> <name>VkSwapchainImageUsageFlagsOHOS</name>;</type>
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPerformanceCounterDescriptionFlagsARM</name>;</type>

            <comment>Video Core extension</comment>
        <type requires="VkVideoCodecOperationFlagBitsKHR"           category="bitmask">typedef <type>VkFlags</type> <name>VkVideoCodecOperationFlagsKHR</name>;</type>
        <type requires="VkVideoCapabilityFlagBitsKHR"               category="bitmask">typedef <type>VkFlags</type> <name>VkVideoCapabilityFlagsKHR</name>;</type>
        <type requires="VkVideoSessionCreateFlagBitsKHR"            category="bitmask">typedef <type>VkFlags</type> <name>VkVideoSessionCreateFlagsKHR</name>;</type>
        <type requires="VkVideoSessionParametersCreateFlagBitsKHR"  category="bitmask">typedef <type>VkFlags</type> <name>VkVideoSessionParametersCreateFlagsKHR</name>;</type>
        <type                                                       category="bitmask">typedef <type>VkFlags</type> <name>VkVideoBeginCodingFlagsKHR</name>;</type>
        <type                                                       category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEndCodingFlagsKHR</name>;</type>
        <type requires="VkVideoCodingControlFlagBitsKHR"            category="bitmask">typedef <type>VkFlags</type> <name>VkVideoCodingControlFlagsKHR</name>;</type>

            <comment>Video Decode Core extension</comment>
        <type requires="VkVideoDecodeUsageFlagBitsKHR"              category="bitmask">typedef <type>VkFlags</type> <name>VkVideoDecodeUsageFlagsKHR</name>;</type>
        <type requires="VkVideoDecodeCapabilityFlagBitsKHR"         category="bitmask">typedef <type>VkFlags</type> <name>VkVideoDecodeCapabilityFlagsKHR</name>;</type>
        <type                                                       category="bitmask">typedef <type>VkFlags</type> <name>VkVideoDecodeFlagsKHR</name>;</type>

            <comment>Video Decode H.264 extension</comment>
        <type requires="VkVideoDecodeH264PictureLayoutFlagBitsKHR"  category="bitmask">typedef <type>VkFlags</type> <name>VkVideoDecodeH264PictureLayoutFlagsKHR</name>;</type>

            <comment>Video Encode Core extension</comment>
        <type requires="VkVideoEncodeFlagBitsKHR"                   category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeFlagsKHR</name>;</type>
        <type requires="VkVideoEncodeUsageFlagBitsKHR"              category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeUsageFlagsKHR</name>;</type>
        <type requires="VkVideoEncodeContentFlagBitsKHR"            category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeContentFlagsKHR</name>;</type>
        <type requires="VkVideoEncodeCapabilityFlagBitsKHR"         category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeCapabilityFlagsKHR</name>;</type>
        <type requires="VkVideoEncodeFeedbackFlagBitsKHR"           category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeFeedbackFlagsKHR</name>;</type>
        <type                                                       category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeRateControlFlagsKHR</name>;</type>
        <type requires="VkVideoEncodeRateControlModeFlagBitsKHR"    category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeRateControlModeFlagsKHR</name>;</type>
        <type requires="VkVideoEncodeIntraRefreshModeFlagBitsKHR"   category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeIntraRefreshModeFlagsKHR</name>;</type>
        <type requires="VkVideoChromaSubsamplingFlagBitsKHR"        category="bitmask">typedef <type>VkFlags</type> <name>VkVideoChromaSubsamplingFlagsKHR</name>;</type>
        <type requires="VkVideoComponentBitDepthFlagBitsKHR"        category="bitmask">typedef <type>VkFlags</type> <name>VkVideoComponentBitDepthFlagsKHR</name>;</type>

            <comment>Video Encode H.264 extension</comment>
        <type requires="VkVideoEncodeH264CapabilityFlagBitsKHR"             category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH264CapabilityFlagsKHR</name>;</type>
        <type requires="VkVideoEncodeH264StdFlagBitsKHR"                    category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH264StdFlagsKHR</name>;</type>
        <type requires="VkVideoEncodeH264RateControlFlagBitsKHR"            category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH264RateControlFlagsKHR</name>;</type>

            <comment>Video Encode H.265 extension</comment>
        <type requires="VkVideoEncodeH265CapabilityFlagBitsKHR"             category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH265CapabilityFlagsKHR</name>;</type>
        <type requires="VkVideoEncodeH265StdFlagBitsKHR"                    category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH265StdFlagsKHR</name>;</type>
        <type requires="VkVideoEncodeH265RateControlFlagBitsKHR"            category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH265RateControlFlagsKHR</name>;</type>
        <type requires="VkVideoEncodeH265CtbSizeFlagBitsKHR"                category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH265CtbSizeFlagsKHR</name>;</type>
        <type requires="VkVideoEncodeH265TransformBlockSizeFlagBitsKHR"     category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH265TransformBlockSizeFlagsKHR</name>;</type>

            <comment>Video Encode AV1 extension</comment>
        <type requires="VkVideoEncodeAV1CapabilityFlagBitsKHR"              category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeAV1CapabilityFlagsKHR</name>;</type>
        <type requires="VkVideoEncodeAV1StdFlagBitsKHR"                     category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeAV1StdFlagsKHR</name>;</type>
        <type requires="VkVideoEncodeAV1RateControlFlagBitsKHR"             category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeAV1RateControlFlagsKHR</name>;</type>
        <type requires="VkVideoEncodeAV1SuperblockSizeFlagBitsKHR"          category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeAV1SuperblockSizeFlagsKHR</name>;</type>

            <comment>VK_KHR_maintenance8</comment>
        <type bitvalues="VkAccessFlagBits3KHR"            category="bitmask">typedef <type>VkFlags64</type> <name>VkAccessFlags3KHR</name>;</type>

            <comment>Types which can be void pointers or class pointers, selected at compile time</comment>
        <type category="handle"                           objtypeenum="VK_OBJECT_TYPE_INSTANCE"><type>VK_DEFINE_HANDLE</type>(<name>VkInstance</name>)</type>
        <type category="handle" parent="VkInstance"       objtypeenum="VK_OBJECT_TYPE_PHYSICAL_DEVICE"><type>VK_DEFINE_HANDLE</type>(<name>VkPhysicalDevice</name>)</type>
        <type category="handle" parent="VkPhysicalDevice" objtypeenum="VK_OBJECT_TYPE_DEVICE"><type>VK_DEFINE_HANDLE</type>(<name>VkDevice</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_QUEUE"><type>VK_DEFINE_HANDLE</type>(<name>VkQueue</name>)</type>
        <type category="handle" parent="VkCommandPool"    objtypeenum="VK_OBJECT_TYPE_COMMAND_BUFFER"><type>VK_DEFINE_HANDLE</type>(<name>VkCommandBuffer</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_DEVICE_MEMORY"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDeviceMemory</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_COMMAND_POOL"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkCommandPool</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_BUFFER"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkBuffer</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_BUFFER_VIEW"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkBufferView</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_IMAGE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkImage</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_IMAGE_VIEW"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkImageView</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_SHADER_MODULE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkShaderModule</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_PIPELINE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPipeline</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_PIPELINE_LAYOUT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPipelineLayout</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_SAMPLER"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSampler</name>)</type>
        <type category="handle" parent="VkDescriptorPool" objtypeenum="VK_OBJECT_TYPE_DESCRIPTOR_SET"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorSet</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorSetLayout</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_DESCRIPTOR_POOL"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorPool</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_FENCE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkFence</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_SEMAPHORE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSemaphore</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_EVENT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkEvent</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_QUERY_POOL"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkQueryPool</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_FRAMEBUFFER"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkFramebuffer</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_RENDER_PASS"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkRenderPass</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_PIPELINE_CACHE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPipelineCache</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_PIPELINE_BINARY_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPipelineBinaryKHR</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkIndirectCommandsLayoutNV</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkIndirectCommandsLayoutEXT</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkIndirectExecutionSetEXT</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorUpdateTemplate</name>)</type>
        <type category="handle" name="VkDescriptorUpdateTemplateKHR" alias="VkDescriptorUpdateTemplate"/>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSamplerYcbcrConversion</name>)</type>
        <type category="handle" name="VkSamplerYcbcrConversionKHR"   alias="VkSamplerYcbcrConversion"/>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_VALIDATION_CACHE_EXT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkValidationCacheEXT</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkAccelerationStructureKHR</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkAccelerationStructureNV</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPerformanceConfigurationINTEL</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkBufferCollectionFUCHSIA</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDeferredOperationKHR</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_PRIVATE_DATA_SLOT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPrivateDataSlot</name>)</type>
        <type category="handle" name="VkPrivateDataSlotEXT"          alias="VkPrivateDataSlot"/>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_CU_MODULE_NVX"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkCuModuleNVX</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_CU_FUNCTION_NVX"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkCuFunctionNVX</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkOpticalFlowSessionNV</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_MICROMAP_EXT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkMicromapEXT</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_SHADER_EXT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkShaderEXT</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_TENSOR_ARM"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkTensorARM</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_TENSOR_VIEW_ARM"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkTensorViewARM</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_DATA_GRAPH_PIPELINE_SESSION_ARM"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDataGraphPipelineSessionARM</name>)</type>

            <comment>WSI extensions</comment>
        <type category="handle" parent="VkPhysicalDevice" objtypeenum="VK_OBJECT_TYPE_DISPLAY_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDisplayKHR</name>)</type>
        <type category="handle" parent="VkDisplayKHR"     objtypeenum="VK_OBJECT_TYPE_DISPLAY_MODE_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDisplayModeKHR</name>)</type>
        <type category="handle" parent="VkInstance"       objtypeenum="VK_OBJECT_TYPE_SURFACE_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSurfaceKHR</name>)</type>
        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_SWAPCHAIN_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSwapchainKHR</name>)</type>
        <type category="handle" parent="VkInstance"       objtypeenum="VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDebugReportCallbackEXT</name>)</type>
        <type category="handle" parent="VkInstance"       objtypeenum="VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDebugUtilsMessengerEXT</name>)</type>

            <comment>Video extensions</comment>
        <type category="handle" parent="VkDevice"          objtypeenum="VK_OBJECT_TYPE_VIDEO_SESSION_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkVideoSessionKHR</name>)</type>
        <type category="handle" parent="VkVideoSessionKHR" objtypeenum="VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkVideoSessionParametersKHR</name>)</type>

            <comment>VK_NV_external_sci_sync2</comment>
        <type category="handle" parent="VkDevice"          objtypeenum="VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSemaphoreSciSyncPoolNV</name>)</type>

            <comment>Types generated from corresponding enums tags below</comment>
        <type name="VkAttachmentLoadOp" category="enum"/>
        <type name="VkAttachmentStoreOp" category="enum"/>
        <type name="VkBlendFactor" category="enum"/>
        <type name="VkBlendOp" category="enum"/>
        <type name="VkBorderColor" category="enum"/>
        <type name="VkFramebufferCreateFlagBits" category="enum"/>
        <type name="VkQueryPoolCreateFlagBits" category="enum"/>
        <type name="VkRenderPassCreateFlagBits" category="enum"/>
        <type name="VkSamplerCreateFlagBits" category="enum"/>
        <type name="VkPipelineCacheHeaderVersion" category="enum"/>
        <type name="VkPipelineCacheCreateFlagBits" category="enum"/>
        <type name="VkPipelineShaderStageCreateFlagBits" category="enum"/>
        <type name="VkDescriptorSetLayoutCreateFlagBits" category="enum"/>
        <type name="VkInstanceCreateFlagBits" category="enum"/>
        <type name="VkDeviceQueueCreateFlagBits" category="enum"/>
        <type name="VkBufferCreateFlagBits" category="enum"/>
        <type name="VkBufferUsageFlagBits" category="enum"/>
        <type name="VkColorComponentFlagBits" category="enum"/>
        <type name="VkComponentSwizzle" category="enum"/>
        <type name="VkCommandPoolCreateFlagBits" category="enum"/>
        <type name="VkCommandPoolResetFlagBits" category="enum"/>
        <type name="VkCommandBufferResetFlagBits" category="enum"/>
        <type name="VkCommandBufferLevel" category="enum"/>
        <type name="VkCommandBufferUsageFlagBits" category="enum"/>
        <type name="VkCompareOp" category="enum"/>
        <type name="VkCullModeFlagBits" category="enum"/>
        <type name="VkDescriptorType" category="enum"/>
        <type name="VkDeviceCreateFlagBits" category="enum"/>
        <type name="VkDynamicState" category="enum"/>
        <type name="VkFenceCreateFlagBits" category="enum"/>
        <type name="VkPolygonMode" category="enum"/>
        <type name="VkFormat" category="enum"/>
        <type name="VkFormatFeatureFlagBits" category="enum"/>
        <type name="VkFrontFace" category="enum"/>
        <type name="VkMemoryMapFlagBits" category="enum"/>
        <type name="VkImageAspectFlagBits" category="enum"/>
        <type name="VkImageCreateFlagBits" category="enum"/>
        <type name="VkImageLayout" category="enum"/>
        <type name="VkImageTiling" category="enum"/>
        <type name="VkImageType" category="enum"/>
        <type name="VkImageUsageFlagBits" category="enum"/>
        <type name="VkImageViewCreateFlagBits" category="enum"/>
        <type name="VkImageViewType" category="enum"/>
        <type name="VkIndirectCommandsTokenTypeEXT" category="enum"/>
        <type name="VkSharingMode" category="enum"/>
        <type name="VkIndexType" category="enum"/>
        <type name="VkLogicOp" category="enum"/>
        <type name="VkMemoryHeapFlagBits" category="enum"/>
        <type name="VkAccessFlagBits" category="enum"/>
        <type name="VkMemoryPropertyFlagBits" category="enum"/>
        <type name="VkPhysicalDeviceType" category="enum"/>
        <type name="VkPipelineBindPoint" category="enum"/>
        <type name="VkPipelineCreateFlagBits" category="enum"/>
        <type name="VkPrimitiveTopology" category="enum"/>
        <type name="VkQueryControlFlagBits" category="enum"/>
        <type name="VkQueryPipelineStatisticFlagBits" category="enum"/>
        <type name="VkQueryResultFlagBits" category="enum"/>
        <type name="VkQueryType" category="enum"/>
        <type name="VkQueueFlagBits" category="enum"/>
        <type name="VkSubpassContents" category="enum"/>
        <type name="VkResult" category="enum"/>
        <type name="VkShaderStageFlagBits" category="enum"/>
        <type name="VkSparseMemoryBindFlagBits" category="enum"/>
        <type name="VkStencilFaceFlagBits" category="enum"/>
        <type name="VkStencilOp" category="enum"/>
        <type name="VkStructureType" category="enum"/>
        <type name="VkSystemAllocationScope" category="enum"/>
        <type name="VkInternalAllocationType" category="enum"/>
        <type name="VkSamplerAddressMode" category="enum"/>
        <type name="VkFilter" category="enum"/>
        <type name="VkSamplerMipmapMode" category="enum"/>
        <type name="VkVertexInputRate" category="enum"/>
        <type name="VkPipelineStageFlagBits" category="enum"/>
        <type name="VkSparseImageFormatFlagBits" category="enum"/>
        <type name="VkClusterAccelerationStructureIndexFormatFlagBitsNV" category="enum"/>
        <type name="VkClusterAccelerationStructureTypeNV" category="enum"/>
        <type name="VkClusterAccelerationStructureOpTypeNV" category="enum"/>
        <type name="VkClusterAccelerationStructureOpModeNV" category="enum"/>
        <type name="VkSampleCountFlagBits" category="enum"/>
        <type name="VkAttachmentDescriptionFlagBits" category="enum"/>
        <type name="VkDescriptorPoolCreateFlagBits" category="enum"/>
        <type name="VkDependencyFlagBits" category="enum"/>
        <type name="VkObjectType" category="enum"/>
        <type name="VkEventCreateFlagBits" category="enum"/>
        <type name="VkPipelineLayoutCreateFlagBits" category="enum"/>
        <type name="VkSemaphoreCreateFlagBits" category="enum"/>
        <type name="VkRayTracingInvocationReorderModeEXT" category="enum"/>
        <type category="enum" name="VkRayTracingInvocationReorderModeNV"           alias="VkRayTracingInvocationReorderModeEXT"/>

        <comment>Extensions</comment>
        <type name="VkIndirectCommandsLayoutUsageFlagBitsNV" category="enum"/>
        <type name="VkIndirectCommandsTokenTypeNV" category="enum"/>
        <type name="VkIndirectStateFlagBitsNV" category="enum"/>
        <type name="VkPrivateDataSlotCreateFlagBits" category="enum"/>
        <type category="enum" name="VkPrivateDataSlotCreateFlagBitsEXT"            alias="VkPrivateDataSlotCreateFlagBits"/>
        <type name="VkDescriptorUpdateTemplateType" category="enum"/>
        <type category="enum" name="VkDescriptorUpdateTemplateTypeKHR"             alias="VkDescriptorUpdateTemplateType"/>
        <type name="VkViewportCoordinateSwizzleNV" category="enum"/>
        <type name="VkDiscardRectangleModeEXT" category="enum"/>
        <type name="VkSubpassDescriptionFlagBits" category="enum"/>
        <type name="VkPointClippingBehavior" category="enum"/>
        <type category="enum" name="VkPointClippingBehaviorKHR"                    alias="VkPointClippingBehavior"/>
        <type name="VkCoverageModulationModeNV" category="enum"/>
        <type name="VkCoverageReductionModeNV" category="enum"/>
        <type name="VkValidationCacheHeaderVersionEXT" category="enum"/>
        <type name="VkShaderInfoTypeAMD" category="enum"/>
        <type name="VkQueueGlobalPriority" category="enum"/>
        <type name="VkQueueGlobalPriorityKHR" category="enum"                      alias="VkQueueGlobalPriority"/>
        <type name="VkQueueGlobalPriorityEXT" category="enum"                      alias="VkQueueGlobalPriority"/>
        <type name="VkTimeDomainKHR" category="enum"/>
        <type name="VkTimeDomainEXT" category="enum" alias="VkTimeDomainKHR"/>
        <type name="VkConservativeRasterizationModeEXT" category="enum"/>
        <type name="VkResolveModeFlagBits" category="enum"/>
        <type category="enum" name="VkResolveModeFlagBitsKHR"                      alias="VkResolveModeFlagBits"/>
        <type name="VkDescriptorBindingFlagBits" category="enum"/>
        <type category="enum" name="VkDescriptorBindingFlagBitsEXT"                alias="VkDescriptorBindingFlagBits"/>
        <type name="VkConditionalRenderingFlagBitsEXT" category="enum"/>
        <type name="VkSemaphoreType" category="enum"/>
        <type category="enum" name="VkSemaphoreTypeKHR"                            alias="VkSemaphoreType"/>
        <type name="VkGeometryFlagBitsKHR" category="enum"/>
        <type category="enum" name="VkGeometryFlagBitsNV"                          alias="VkGeometryFlagBitsKHR"/>
        <type name="VkGeometryInstanceFlagBitsKHR" category="enum"/>
        <type category="enum" name="VkGeometryInstanceFlagBitsNV"                  alias="VkGeometryInstanceFlagBitsKHR"/>
        <type name="VkClusterAccelerationStructureAddressResolutionFlagBitsNV"          category="enum"/>
        <type name="VkClusterAccelerationStructureGeometryFlagBitsNV"         category="enum"/>
        <type name="VkClusterAccelerationStructureClusterFlagBitsNV"          category="enum"/>
        <type name="VkBuildAccelerationStructureFlagBitsKHR" category="enum"/>
        <type category="enum" name="VkBuildAccelerationStructureFlagBitsNV"        alias="VkBuildAccelerationStructureFlagBitsKHR"/>
        <type name="VkAccelerationStructureCreateFlagBitsKHR" category="enum"/>
        <type name="VkBuildAccelerationStructureModeKHR" category="enum"/>
        <type name="VkCopyAccelerationStructureModeKHR" category="enum"/>
        <type category="enum" name="VkCopyAccelerationStructureModeNV"             alias="VkCopyAccelerationStructureModeKHR"/>
        <type name="VkAccelerationStructureTypeKHR" category="enum"/>
        <type category="enum" name="VkAccelerationStructureTypeNV"                 alias="VkAccelerationStructureTypeKHR"/>
        <type name="VkGeometryTypeKHR" category="enum"/>
        <type category="enum" name="VkGeometryTypeNV"                              alias="VkGeometryTypeKHR"/>
        <type name="VkRayTracingShaderGroupTypeKHR" category="enum"/>
        <type category="enum" name="VkRayTracingShaderGroupTypeNV"                 alias="VkRayTracingShaderGroupTypeKHR"/>
        <type name="VkAccelerationStructureMemoryRequirementsTypeNV" category="enum"/>
        <type name="VkAccelerationStructureBuildTypeKHR" category="enum"/>
        <type name="VkAccelerationStructureCompatibilityKHR" category="enum"/>
        <type name="VkRayTracingLssIndexingModeNV" category="enum"/>
        <type name="VkRayTracingLssPrimitiveEndCapsModeNV" category="enum"/>
        <type name="VkShaderGroupShaderKHR" category="enum"/>
        <type name="VkMemoryOverallocationBehaviorAMD" category="enum"/>
        <type name="VkDeviceDiagnosticsConfigFlagBitsNV" category="enum"/>
        <type name="VkPipelineCreationFeedbackFlagBits" category="enum"/>
        <type category="enum" name="VkPipelineCreationFeedbackFlagBitsEXT"         alias="VkPipelineCreationFeedbackFlagBits"/>
        <type name="VkPerformanceCounterScopeKHR" category="enum"/>
        <type name="VkPerformanceCounterUnitKHR" category="enum"/>
        <type name="VkPerformanceCounterStorageKHR" category="enum"/>
        <type name="VkPerformanceCounterDescriptionFlagBitsKHR" category="enum"/>
        <type name="VkAcquireProfilingLockFlagBitsKHR" category="enum"/>
        <type name="VkSemaphoreWaitFlagBits" category="enum"/>
        <type category="enum" name="VkSemaphoreWaitFlagBitsKHR"                    alias="VkSemaphoreWaitFlagBits"/>
        <type name="VkPerformanceConfigurationTypeINTEL" category="enum"/>
        <type name="VkQueryPoolSamplingModeINTEL" category="enum"/>
        <type name="VkPerformanceOverrideTypeINTEL" category="enum"/>
        <type name="VkPerformanceParameterTypeINTEL" category="enum"/>
        <type name="VkPerformanceValueTypeINTEL" category="enum"/>
        <type name="VkLineRasterizationMode" category="enum"/>
        <type name="VkLineRasterizationModeKHR" category="enum" alias="VkLineRasterizationMode"/>
        <type name="VkLineRasterizationModeEXT" category="enum" alias="VkLineRasterizationMode"/>
        <type name="VkShaderModuleCreateFlagBits" category="enum"/>
        <type name="VkPipelineCompilerControlFlagBitsAMD" category="enum"/>
        <type name="VkShaderCorePropertiesFlagBitsAMD" category="enum"/>
        <type name="VkRefreshObjectFlagBitsKHR" category="enum"/>
        <type name="VkFaultLevel" category="enum"/>
        <type name="VkFaultType" category="enum"/>
        <type name="VkFaultQueryBehavior" category="enum"/>
        <type name="VkPipelineMatchControl" category="enum"/>
        <type name="VkSciSyncClientTypeNV" category="enum"/>
        <type name="VkSciSyncPrimitiveTypeNV" category="enum"/>
        <type name="VkToolPurposeFlagBits" category="enum"/>
        <type category="enum" name="VkToolPurposeFlagBitsEXT"                      alias="VkToolPurposeFlagBits"/>
        <type name="VkFragmentShadingRateNV" category="enum"/>
        <type name="VkFragmentShadingRateTypeNV" category="enum"/>
        <type name="VkSubpassMergeStatusEXT" category="enum"/>
        <type name="VkAccessFlagBits2" category="enum"/>
        <type category="enum" name="VkAccessFlagBits2KHR"                          alias="VkAccessFlagBits2"/>
        <type name="VkPipelineStageFlagBits2" category="enum"/>
        <type category="enum" name="VkPipelineStageFlagBits2KHR"                   alias="VkPipelineStageFlagBits2"/>
        <type name="VkProvokingVertexModeEXT" category="enum"/>
        <type name="VkPipelineCacheValidationVersion" category="enum"/>
        <type name="VkImageFormatConstraintsFlagBitsFUCHSIA" category="enum"/>
        <type name="VkHostImageCopyFlagBits" category="enum"/>
        <type category="enum" name="VkHostImageCopyFlagBitsEXT"                    alias="VkHostImageCopyFlagBits"/>
        <type name="VkImageConstraintsInfoFlagBitsFUCHSIA" category="enum"/>
        <type name="VkFormatFeatureFlagBits2" category="enum"/>
        <type category="enum" name="VkFormatFeatureFlagBits2KHR"                   alias="VkFormatFeatureFlagBits2"/>
        <type name="VkRenderingFlagBits" category="enum"/>
        <type category="enum" name="VkRenderingFlagBitsKHR"                        alias="VkRenderingFlagBits"/>
        <type name="VkPipelineDepthStencilStateCreateFlagBits" category="enum"/>
        <type name="VkPipelineColorBlendStateCreateFlagBits" category="enum"/>
        <type name="VkImageCompressionFlagBitsEXT" category="enum"/>
        <type name="VkImageCompressionFixedRateFlagBitsEXT" category="enum"/>
        <type name="VkExportMetalObjectTypeFlagBitsEXT" category="enum"/>
        <type name="VkPipelineRobustnessBufferBehavior" category="enum"/>
        <type category="enum" name="VkPipelineRobustnessBufferBehaviorEXT"          alias="VkPipelineRobustnessBufferBehavior"/>
        <type name="VkPipelineRobustnessImageBehavior" category="enum"/>
        <type category="enum" name="VkPipelineRobustnessImageBehaviorEXT"           alias="VkPipelineRobustnessImageBehavior"/>
        <type name="VkRenderingAttachmentFlagBitsKHR" category="enum"/>
        <type name="VkResolveImageFlagBitsKHR" category="enum"/>
        <type name="VkDeviceAddressBindingFlagBitsEXT" category="enum"/>
        <type name="VkDeviceAddressBindingTypeEXT" category="enum"/>
        <type name="VkMicromapTypeEXT" category="enum"/>
        <type name="VkBuildMicromapModeEXT" category="enum"/>
        <type name="VkCopyMicromapModeEXT" category="enum"/>
        <type name="VkBuildMicromapFlagBitsEXT" category="enum"/>
        <type name="VkMicromapCreateFlagBitsEXT" category="enum"/>
        <type name="VkOpacityMicromapFormatEXT" category="enum"/>
        <type name="VkOpacityMicromapSpecialIndexEXT" category="enum"/>
        <type name="VkDeviceFaultVendorBinaryHeaderVersionEXT" category="enum"/>
        <type name="VkIndirectCommandsLayoutUsageFlagBitsEXT" category="enum"/>
        <type name="VkIndirectExecutionSetInfoTypeEXT" category="enum"/>
        <type name="VkIndirectCommandsInputModeFlagBitsEXT" category="enum"/>
        <type name="VkFrameBoundaryFlagBitsEXT" category="enum"/>
        <type name="VkMemoryDecompressionMethodFlagBitsEXT" category="enum"/>
        <type category="enum" name="VkMemoryDecompressionMethodFlagBitsNV"         alias="VkMemoryDecompressionMethodFlagBitsEXT"/>
        <type name="VkDepthBiasRepresentationEXT" category="enum"/>
        <type name="VkDirectDriverLoadingModeLUNARG" category="enum"/>
        <type name="VkPipelineCreateFlagBits2" category="enum"/>
        <type category="enum" name="VkPipelineCreateFlagBits2KHR"                  alias="VkPipelineCreateFlagBits2"/>
        <type name="VkBufferUsageFlagBits2" category="enum"/>
        <type category="enum" name="VkBufferUsageFlagBits2KHR"                     alias="VkBufferUsageFlagBits2"/>
        <type name="VkPartitionedAccelerationStructureOpTypeNV" category="enum"/>
        <type name="VkPartitionedAccelerationStructureInstanceFlagBitsNV" category="enum"/>
        <type name="VkAntiLagModeAMD" category="enum"/>
        <type name="VkAntiLagStageAMD" category="enum"/>
        <type name="VkDisplacementMicromapFormatNV" category="enum"/>
        <type name="VkShaderCreateFlagBitsEXT" category="enum"/>
        <type name="VkShaderCodeTypeEXT" category="enum"/>
        <type name="VkScopeKHR" category="enum"/>
        <type name="VkComponentTypeKHR" category="enum"/>
        <type category="enum" name="VkScopeNV"                                     alias="VkScopeKHR"/>
        <type category="enum" name="VkComponentTypeNV"                             alias="VkComponentTypeKHR"/>
        <type name="VkCubicFilterWeightsQCOM" category="enum"/>
        <type name="VkBlockMatchWindowCompareModeQCOM" category="enum"/>
        <type name="VkLayeredDriverUnderlyingApiMSFT" category="enum"/>
        <type name="VkPhysicalDeviceLayeredApiKHR" category="enum"/>
        <type name="VkCompressedTriangleFormatAMDX" category="enum"/>
        <type name="VkDepthClampModeEXT" category="enum"/>
        <type name="VkTileShadingRenderPassFlagBitsQCOM" category="enum"/>
        <type name="VkCooperativeVectorMatrixLayoutNV" category="enum"/>
        <type name="VkAddressCopyFlagBitsKHR" category="enum"/>
        <type name="VkTensorCreateFlagBitsARM" category="enum"/>
        <type name="VkTensorUsageFlagBitsARM" category="enum"/>
        <type name="VkTensorTilingARM" category="enum"/>
        <type name="VkTensorViewCreateFlagBitsARM" category="enum"/>
        <type name="VkDataGraphPipelineSessionCreateFlagBitsARM" category="enum"/>
        <type name="VkDataGraphPipelinePropertyARM" category="enum"/>
        <type name="VkDataGraphPipelineSessionBindPointARM" category="enum"/>
        <type name="VkDataGraphPipelineSessionBindPointTypeARM" category="enum"/>
        <type name="VkDataGraphPipelineDispatchFlagBitsARM" category="enum"/>
        <type name="VkPhysicalDeviceDataGraphProcessingEngineTypeARM" category="enum"/>
        <type name="VkPhysicalDeviceDataGraphOperationTypeARM" category="enum"/>
        <type name="VkDataGraphModelCacheTypeQCOM" category="enum"/>
        <type name="VkVideoEncodeRgbModelConversionFlagBitsVALVE" category="enum"/>
        <type name="VkVideoEncodeRgbRangeCompressionFlagBitsVALVE" category="enum"/>
        <type name="VkVideoEncodeRgbChromaOffsetFlagBitsVALVE" category="enum"/>

            <comment>WSI extensions</comment>
        <type name="VkColorSpaceKHR" category="enum"/>
        <type name="VkCompositeAlphaFlagBitsKHR" category="enum"/>
        <type name="VkDisplayPlaneAlphaFlagBitsKHR" category="enum"/>
        <type name="VkPresentModeKHR" category="enum"/>
        <type name="VkSurfaceTransformFlagBitsKHR" category="enum"/>
        <type name="VkDisplaySurfaceStereoTypeNV" category="enum"/>
        <type name="VkDebugReportFlagBitsEXT" category="enum"/>
        <type name="VkDebugReportObjectTypeEXT" category="enum"/>
        <type name="VkDeviceMemoryReportEventTypeEXT" category="enum"/>
        <type name="VkRasterizationOrderAMD" category="enum"/>
        <type name="VkExternalMemoryHandleTypeFlagBitsNV" category="enum"/>
        <type name="VkExternalMemoryFeatureFlagBitsNV" category="enum"/>
        <type name="VkValidationCheckEXT" category="enum"/>
        <type name="VkValidationFeatureEnableEXT" category="enum"/>
        <type name="VkValidationFeatureDisableEXT" category="enum"/>
        <type name="VkExternalMemoryHandleTypeFlagBits" category="enum"/>
        <type category="enum" name="VkExternalMemoryHandleTypeFlagBitsKHR"         alias="VkExternalMemoryHandleTypeFlagBits"/>
        <type name="VkExternalMemoryFeatureFlagBits" category="enum"/>
        <type category="enum" name="VkExternalMemoryFeatureFlagBitsKHR"            alias="VkExternalMemoryFeatureFlagBits"/>
        <type name="VkExternalSemaphoreHandleTypeFlagBits" category="enum"/>
        <type category="enum" name="VkExternalSemaphoreHandleTypeFlagBitsKHR"      alias="VkExternalSemaphoreHandleTypeFlagBits"/>
        <type name="VkExternalSemaphoreFeatureFlagBits" category="enum"/>
        <type category="enum" name="VkExternalSemaphoreFeatureFlagBitsKHR"         alias="VkExternalSemaphoreFeatureFlagBits"/>
        <type name="VkSemaphoreImportFlagBits" category="enum"/>
        <type category="enum" name="VkSemaphoreImportFlagBitsKHR"                  alias="VkSemaphoreImportFlagBits"/>
        <type name="VkExternalFenceHandleTypeFlagBits" category="enum"/>
        <type category="enum" name="VkExternalFenceHandleTypeFlagBitsKHR"          alias="VkExternalFenceHandleTypeFlagBits"/>
        <type name="VkExternalFenceFeatureFlagBits" category="enum"/>
        <type category="enum" name="VkExternalFenceFeatureFlagBitsKHR"             alias="VkExternalFenceFeatureFlagBits"/>
        <type name="VkFenceImportFlagBits" category="enum"/>
        <type category="enum" name="VkFenceImportFlagBitsKHR"                      alias="VkFenceImportFlagBits"/>
        <type name="VkSurfaceCounterFlagBitsEXT" category="enum"/>
        <type name="VkDisplayPowerStateEXT" category="enum"/>
        <type name="VkDeviceEventTypeEXT" category="enum"/>
        <type name="VkDisplayEventTypeEXT" category="enum"/>
        <type name="VkPeerMemoryFeatureFlagBits" category="enum"/>
        <type category="enum" name="VkPeerMemoryFeatureFlagBitsKHR"                alias="VkPeerMemoryFeatureFlagBits"/>
        <type name="VkMemoryAllocateFlagBits" category="enum"/>
        <type category="enum" name="VkMemoryAllocateFlagBitsKHR"                   alias="VkMemoryAllocateFlagBits"/>
        <type name="VkDeviceGroupPresentModeFlagBitsKHR" category="enum"/>
        <type name="VkSwapchainCreateFlagBitsKHR" category="enum"/>
        <type name="VkSubgroupFeatureFlagBits" category="enum"/>
        <type name="VkTessellationDomainOrigin" category="enum"/>
        <type category="enum" name="VkTessellationDomainOriginKHR"                 alias="VkTessellationDomainOrigin"/>
        <type name="VkSamplerYcbcrModelConversion" category="enum"/>
        <type category="enum" name="VkSamplerYcbcrModelConversionKHR"              alias="VkSamplerYcbcrModelConversion"/>
        <type name="VkSamplerYcbcrRange" category="enum"/>
        <type category="enum" name="VkSamplerYcbcrRangeKHR"                        alias="VkSamplerYcbcrRange"/>
        <type name="VkChromaLocation" category="enum"/>
        <type category="enum" name="VkChromaLocationKHR"                           alias="VkChromaLocation"/>
        <type name="VkSamplerReductionMode" category="enum"/>
        <type category="enum" name="VkSamplerReductionModeEXT"                     alias="VkSamplerReductionMode"/>
        <type name="VkBlendOverlapEXT" category="enum"/>
        <type name="VkDebugUtilsMessageSeverityFlagBitsEXT" category="enum"/>
        <type name="VkDebugUtilsMessageTypeFlagBitsEXT" category="enum"/>
        <type name="VkFullScreenExclusiveEXT" category="enum"/>
        <type name="VkShaderFloatControlsIndependence" category="enum"/>
        <type category="enum" name="VkShaderFloatControlsIndependenceKHR"          alias="VkShaderFloatControlsIndependence"/>
        <type name="VkSwapchainImageUsageFlagBitsANDROID" category="enum"/>
        <type name="VkFragmentShadingRateCombinerOpKHR" category="enum"/>
        <type name="VkSubmitFlagBits" category="enum"/>
        <type category="enum" name="VkSubmitFlagBitsKHR"                           alias="VkSubmitFlagBits"/>
        <type name="VkGraphicsPipelineLibraryFlagBitsEXT" category="enum"/>
        <type name="VkOpticalFlowGridSizeFlagBitsNV" category="enum"/>
        <type name="VkOpticalFlowUsageFlagBitsNV" category="enum"/>
        <type name="VkOpticalFlowPerformanceLevelNV" category="enum"/>
        <type name="VkOpticalFlowSessionBindingPointNV" category="enum"/>
        <type name="VkOpticalFlowSessionCreateFlagBitsNV" category="enum"/>
        <type name="VkOpticalFlowExecuteFlagBitsNV" category="enum"/>
        <type name="VkDeviceFaultAddressTypeEXT" category="enum"/>
        <type name="VkPresentScalingFlagBitsKHR" category="enum"/>
        <type name="VkPresentScalingFlagBitsEXT" category="enum"                   alias="VkPresentScalingFlagBitsKHR"/>
        <type name="VkPresentGravityFlagBitsKHR" category="enum"/>
        <type name="VkPresentGravityFlagBitsEXT" category="enum"                   alias="VkPresentGravityFlagBitsKHR"/>
        <type name="VkLayerSettingTypeEXT" category="enum"/>
        <type name="VkLatencyMarkerNV" category="enum"/>
        <type name="VkOutOfBandQueueTypeNV" category="enum"/>
        <type name="VkPhysicalDeviceSchedulingControlsFlagBitsARM" category="enum"/>
        <type name="VkMemoryUnmapFlagBits" category="enum"/>
        <type category="enum" name="VkMemoryUnmapFlagBitsKHR"                      alias="VkMemoryUnmapFlagBits"/>
        <type name="VkWaylandSurfaceCreateFlagBitsKHR" category="enum"/>
        <type name="VkPresentStageFlagBitsEXT" category="enum"/>
        <type name="VkPastPresentationTimingFlagBitsEXT" category="enum"/>
        <type name="VkPresentTimingInfoFlagBitsEXT" category="enum"/>
        <type name="VkSwapchainImageUsageFlagBitsOHOS" category="enum"/>
        <type name="VkPerformanceCounterDescriptionFlagBitsARM" category="enum"/>

            <comment>Enumerated types in the header, but not used by the API</comment>
        <type name="VkVendorId" category="enum"/>
        <type name="VkDriverId" category="enum"/>
        <type category="enum" name="VkDriverIdKHR"                                 alias="VkDriverId"/>
        <type name="VkShadingRatePaletteEntryNV" category="enum"/>
        <type name="VkCoarseSampleOrderTypeNV" category="enum"/>
        <type name="VkPipelineExecutableStatisticFormatKHR" category="enum"/>

            <comment>Video Core extensions</comment>
        <type name="VkVideoCodecOperationFlagBitsKHR" category="enum"/>
        <type name="VkVideoChromaSubsamplingFlagBitsKHR" category="enum"/>
        <type name="VkVideoComponentBitDepthFlagBitsKHR" category="enum"/>
        <type name="VkVideoCapabilityFlagBitsKHR" category="enum"/>
        <type name="VkVideoSessionCreateFlagBitsKHR" category="enum"/>
        <type name="VkVideoSessionParametersCreateFlagBitsKHR" category="enum"/>
        <type name="VkVideoCodingControlFlagBitsKHR" category="enum"/>
        <type name="VkQueryResultStatusKHR" category="enum"/>

            <comment>Video Decode extensions</comment>
        <type name="VkVideoDecodeUsageFlagBitsKHR" category="enum"/>
        <type name="VkVideoDecodeCapabilityFlagBitsKHR" category="enum"/>

            <comment>Video H.264 Decode extensions</comment>
        <type name="VkVideoDecodeH264PictureLayoutFlagBitsKHR" category="enum"/>

            <comment>Video H.265 Decode extensions</comment>

            <comment>Video Encode extensions</comment>
        <type name="VkVideoEncodeFlagBitsKHR" category="enum"/>
        <type name="VkVideoEncodeUsageFlagBitsKHR" category="enum"/>
        <type name="VkVideoEncodeContentFlagBitsKHR" category="enum"/>
        <type name="VkVideoEncodeTuningModeKHR" category="enum"/>
        <type name="VkVideoEncodeCapabilityFlagBitsKHR" category="enum"/>
        <type name="VkVideoEncodeFeedbackFlagBitsKHR" category="enum"/>
        <type name="VkVideoEncodeRateControlModeFlagBitsKHR" category="enum"/>
        <type name="VkVideoEncodeIntraRefreshModeFlagBitsKHR" category="enum"/>

           <comment>Video H.264 Encode extensions</comment>
        <type name="VkVideoEncodeH264CapabilityFlagBitsKHR"             category="enum"/>
        <type name="VkVideoEncodeH264StdFlagBitsKHR"                    category="enum"/>
        <type name="VkVideoEncodeH264RateControlFlagBitsKHR"            category="enum"/>

           <comment>Video H.265 Encode extensions</comment>
        <type name="VkVideoEncodeH265CapabilityFlagBitsKHR"             category="enum"/>
        <type name="VkVideoEncodeH265StdFlagBitsKHR"                    category="enum"/>
        <type name="VkVideoEncodeH265RateControlFlagBitsKHR"            category="enum"/>
        <type name="VkVideoEncodeH265CtbSizeFlagBitsKHR"                category="enum"/>
        <type name="VkVideoEncodeH265TransformBlockSizeFlagBitsKHR"     category="enum"/>

           <comment>Video AV1 Encode extensions</comment>
        <type name="VkVideoEncodeAV1CapabilityFlagBitsKHR"              category="enum"/>
        <type name="VkVideoEncodeAV1StdFlagBitsKHR"                     category="enum"/>
        <type name="VkVideoEncodeAV1RateControlFlagBitsKHR"             category="enum"/>
        <type name="VkVideoEncodeAV1SuperblockSizeFlagBitsKHR"          category="enum"/>
        <type name="VkVideoEncodeAV1PredictionModeKHR"                  category="enum"/>
        <type name="VkVideoEncodeAV1RateControlGroupKHR"                category="enum"/>

           <comment>VK_KHR_maintenance8</comment>
        <type name="VkAccessFlagBits3KHR" category="enum"/>

           <comment>VK_KHR_maintenance9</comment>
        <type name="VkDefaultVertexAttributeValueKHR" category="enum"/>

        <comment>The PFN_vk*Function types are used by VkAllocationCallbacks below</comment>
        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkInternalAllocationNotification</name>)(
    <type>void</type>*                                       pUserData,
    <type>size_t</type>                                      size,
    <type>VkInternalAllocationType</type>                    allocationType,
    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkInternalFreeNotification</name>)(
    <type>void</type>*                                       pUserData,
    <type>size_t</type>                                      size,
    <type>VkInternalAllocationType</type>                    allocationType,
    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
        <type category="funcpointer">typedef void* (VKAPI_PTR *<name>PFN_vkReallocationFunction</name>)(
    <type>void</type>*                                       pUserData,
    <type>void</type>*                                       pOriginal,
    <type>size_t</type>                                      size,
    <type>size_t</type>                                      alignment,
    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
        <type category="funcpointer">typedef void* (VKAPI_PTR *<name>PFN_vkAllocationFunction</name>)(
    <type>void</type>*                                       pUserData,
    <type>size_t</type>                                      size,
    <type>size_t</type>                                      alignment,
    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkFreeFunction</name>)(
    <type>void</type>*                                       pUserData,
    <type>void</type>*                                       pMemory);</type>

            <comment>The PFN_vkVoidFunction type are used by VkGet*ProcAddr below</comment>
        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkVoidFunction</name>)(void);</type>

            <comment>The PFN_vkDebugReportCallbackEXT type are used by the DEBUG_REPORT extension</comment>
        <type category="funcpointer">typedef VkBool32 (VKAPI_PTR *<name>PFN_vkDebugReportCallbackEXT</name>)(
    <type>VkDebugReportFlagsEXT</type>                       flags,
    <type>VkDebugReportObjectTypeEXT</type>                  objectType,
    <type>uint64_t</type>                                    object,
    <type>size_t</type>                                      location,
    <type>int32_t</type>                                     messageCode,
    const <type>char</type>*                                 pLayerPrefix,
    const <type>char</type>*                                 pMessage,
    <type>void</type>*                                       pUserData);</type>

            <comment>The PFN_vkDebugUtilsMessengerCallbackEXT type are used by the VK_EXT_debug_utils extension</comment>
        <type category="funcpointer" requires="VkDebugUtilsMessengerCallbackDataEXT">typedef VkBool32 (VKAPI_PTR *<name>PFN_vkDebugUtilsMessengerCallbackEXT</name>)(
    <type>VkDebugUtilsMessageSeverityFlagBitsEXT</type>           messageSeverity,
    <type>VkDebugUtilsMessageTypeFlagsEXT</type>                  messageTypes,
    const <type>VkDebugUtilsMessengerCallbackDataEXT</type>*      pCallbackData,
    <type>void</type>*                                            pUserData);</type>

            <comment>The PFN_vkFaultCallbackFunction type is used by VKSC_VERSION_1_0</comment>
        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkFaultCallbackFunction</name>)(
    <type>VkBool32</type>                                    unrecordedFaults,
    <type>uint32_t</type>                                    faultCount,
    const <type>VkFaultData</type>*                          pFaults);</type>

            <comment>The PFN_vkDeviceMemoryReportCallbackEXT type is used by the VK_EXT_device_memory_report extension</comment>
        <type category="funcpointer" requires="VkDeviceMemoryReportCallbackDataEXT">typedef void (VKAPI_PTR *<name>PFN_vkDeviceMemoryReportCallbackEXT</name>)(
    const <type>VkDeviceMemoryReportCallbackDataEXT</type>*  pCallbackData,
    <type>void</type>*                                       pUserData);</type>

            <comment>The PFN_vkGetInstanceProcAddrLUNARG type is used by the
                     VkDirectDriverLoadingInfoLUNARG structure.
                     We cannot introduce an explicit dependency on the
                     equivalent PFN_vkGetInstanceProcAddr type, even though
                     it is implicitly generated in the C header, because
                     that results in multiple definitions.</comment>
        <type category="funcpointer" requires="VkInstance">typedef PFN_vkVoidFunction (VKAPI_PTR *<name>PFN_vkGetInstanceProcAddrLUNARG</name>)(
    <type>VkInstance</type> instance, const <type>char</type>* pName);</type>

            <comment>Struct types</comment>
        <type category="struct" name="VkBaseOutStructure">
            <member><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">struct <type>VkBaseOutStructure</type>* <name>pNext</name></member>
        </type>
        <type category="struct" name="VkBaseInStructure">
            <member><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const struct <type>VkBaseInStructure</type>* <name>pNext</name></member>
        </type>
        <type category="struct" name="VkOffset2D">
            <member><type>int32_t</type>        <name>x</name></member>
            <member><type>int32_t</type>        <name>y</name></member>
        </type>
        <type category="struct" name="VkOffset3D">
            <member><type>int32_t</type>        <name>x</name></member>
            <member><type>int32_t</type>        <name>y</name></member>
            <member><type>int32_t</type>        <name>z</name></member>
        </type>
        <type category="struct" name="VkExtent2D">
            <member><type>uint32_t</type>        <name>width</name></member>
            <member><type>uint32_t</type>        <name>height</name></member>
        </type>
        <type category="struct" name="VkExtent3D">
            <member><type>uint32_t</type>        <name>width</name></member>
            <member><type>uint32_t</type>        <name>height</name></member>
            <member><type>uint32_t</type>        <name>depth</name></member>
        </type>
        <type category="struct" name="VkViewport">
            <member noautovalidity="true"><type>float</type> <name>x</name></member>
            <member noautovalidity="true"><type>float</type> <name>y</name></member>
            <member noautovalidity="true"><type>float</type> <name>width</name></member>
            <member noautovalidity="true"><type>float</type> <name>height</name></member>
            <member><type>float</type>                       <name>minDepth</name></member>
            <member><type>float</type>                       <name>maxDepth</name></member>
        </type>
        <type category="struct" name="VkRect2D">
            <member><type>VkOffset2D</type>     <name>offset</name></member>
            <member><type>VkExtent2D</type>     <name>extent</name></member>
        </type>
        <type category="struct" name="VkClearRect">
            <member><type>VkRect2D</type>       <name>rect</name></member>
            <member><type>uint32_t</type>       <name>baseArrayLayer</name></member>
            <member><type>uint32_t</type>       <name>layerCount</name></member>
        </type>
        <type category="struct" name="VkComponentMapping">
            <member><type>VkComponentSwizzle</type> <name>r</name></member>
            <member><type>VkComponentSwizzle</type> <name>g</name></member>
            <member><type>VkComponentSwizzle</type> <name>b</name></member>
            <member><type>VkComponentSwizzle</type> <name>a</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceProperties" returnedonly="true" requiredlimittype="true">
            <member limittype="noauto"><type>uint32_t</type>       <name>apiVersion</name></member>
            <member limittype="noauto"><type>uint32_t</type>       <name>driverVersion</name></member>
            <member limittype="noauto"><type>uint32_t</type>       <name>vendorID</name></member>
            <member limittype="noauto"><type>uint32_t</type>       <name>deviceID</name></member>
            <member limittype="noauto"><type>VkPhysicalDeviceType</type> <name>deviceType</name></member>
            <member limittype="noauto" len="null-terminated"><type>char</type>           <name>deviceName</name>[<enum>VK_MAX_PHYSICAL_DEVICE_NAME_SIZE</enum>]</member>
            <member limittype="noauto"><type>uint8_t</type>        <name>pipelineCacheUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
            <member limittype="struct"><type>VkPhysicalDeviceLimits</type> <name>limits</name></member>
            <member limittype="struct"><type>VkPhysicalDeviceSparseProperties</type> <name>sparseProperties</name></member>
        </type>
        <type category="struct" name="VkExtensionProperties" returnedonly="true">
            <member len="null-terminated"><type>char</type> <name>extensionName</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]<comment>extension name</comment></member>
            <member><type>uint32_t</type>                   <name>specVersion</name><comment>version of the extension specification implemented</comment></member>
        </type>
        <type category="struct" name="VkLayerProperties" returnedonly="true">
            <member len="null-terminated"><type>char</type> <name>layerName</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]<comment>layer name</comment></member>
            <member><type>uint32_t</type>                   <name>specVersion</name><comment>version of the layer specification implemented</comment></member>
            <member><type>uint32_t</type>                   <name>implementationVersion</name><comment>build or release version of the layer's library</comment></member>
            <member len="null-terminated"><type>char</type> <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]<comment>Free-form description of the layer</comment></member>
        </type>
        <type category="struct" name="VkApplicationInfo">
            <member values="VK_STRUCTURE_TYPE_APPLICATION_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
            <member optional="true" len="null-terminated">const <type>char</type>*     <name>pApplicationName</name></member>
            <member><type>uint32_t</type>        <name>applicationVersion</name></member>
            <member optional="true" len="null-terminated">const <type>char</type>*     <name>pEngineName</name></member>
            <member><type>uint32_t</type>        <name>engineVersion</name></member>
            <member><type>uint32_t</type>        <name>apiVersion</name></member>
        </type>
        <type category="struct" name="VkAllocationCallbacks">
            <member optional="true"><type>void</type>*           <name>pUserData</name></member>
            <member noautovalidity="true"><type>PFN_vkAllocationFunction</type>   <name>pfnAllocation</name></member>
            <member noautovalidity="true"><type>PFN_vkReallocationFunction</type> <name>pfnReallocation</name></member>
            <member noautovalidity="true"><type>PFN_vkFreeFunction</type>    <name>pfnFree</name></member>
            <member optional="true" noautovalidity="true"><type>PFN_vkInternalAllocationNotification</type> <name>pfnInternalAllocation</name></member>
            <member optional="true" noautovalidity="true"><type>PFN_vkInternalFreeNotification</type> <name>pfnInternalFree</name></member>
        </type>
        <type category="struct" name="VkDeviceQueueCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
            <member optional="true"><type>VkDeviceQueueCreateFlags</type>    <name>flags</name></member>
            <member><type>uint32_t</type>        <name>queueFamilyIndex</name></member>
            <member><type>uint32_t</type>        <name>queueCount</name></member>
            <member len="queueCount">const <type>float</type>*    <name>pQueuePriorities</name></member>
        </type>
        <type category="struct" name="VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
            <member optional="true"><type>VkDeviceCreateFlags</type>    <name>flags</name></member>
            <member optional="true"><type>uint32_t</type>        <name>queueCreateInfoCount</name></member>
            <member len="queueCreateInfoCount">const <type>VkDeviceQueueCreateInfo</type>* <name>pQueueCreateInfos</name></member>
            <member optional="true" deprecated="ignored"><type>uint32_t</type>               <name>enabledLayerCount</name></member>
            <member len="enabledLayerCount,null-terminated" deprecated="ignored">const <type>char</type>* const*      <name>ppEnabledLayerNames</name><comment>Ordered list of layer names to be enabled</comment></member>
            <member optional="true"><type>uint32_t</type>               <name>enabledExtensionCount</name></member>
            <member len="enabledExtensionCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledExtensionNames</name></member>
            <member optional="true">const <type>VkPhysicalDeviceFeatures</type>* <name>pEnabledFeatures</name></member>
        </type>
        <type category="struct" name="VkInstanceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
            <member optional="true"><type>VkInstanceCreateFlags</type>  <name>flags</name></member>
            <member optional="true">const <type>VkApplicationInfo</type>* <name>pApplicationInfo</name></member>
            <member optional="true"><type>uint32_t</type>               <name>enabledLayerCount</name></member>
            <member len="enabledLayerCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledLayerNames</name><comment>Ordered list of layer names to be enabled</comment></member>
            <member optional="true"><type>uint32_t</type>               <name>enabledExtensionCount</name></member>
            <member len="enabledExtensionCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledExtensionNames</name><comment>Extension names to be enabled</comment></member>
        </type>
        <type category="struct" name="VkQueueFamilyProperties" returnedonly="true" requiredlimittype="true">
            <member optional="true" limittype="bitmask"><type>VkQueueFlags</type>           <name>queueFlags</name><comment>Queue flags</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>queueCount</name></member>
            <member limittype="bits"><type>uint32_t</type>               <name>timestampValidBits</name></member>
            <member limittype="min,mul"><type>VkExtent3D</type>             <name>minImageTransferGranularity</name><comment>Minimum alignment requirement for image transfers</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMemoryProperties" returnedonly="true">
            <member><type>uint32_t</type>                                     <name>memoryTypeCount</name></member>
            <member len="memoryTypeCount"><type>VkMemoryType</type>           <name>memoryTypes</name>[<enum>VK_MAX_MEMORY_TYPES</enum>]</member>
            <member><type>uint32_t</type>                                     <name>memoryHeapCount</name></member>
            <member len="memoryHeapCount"><type>VkMemoryHeap</type>           <name>memoryHeaps</name>[<enum>VK_MAX_MEMORY_HEAPS</enum>]</member>
        </type>
        <type category="struct" name="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkDeviceSize</type>           <name>allocationSize</name><comment>Size of memory allocation</comment></member>
            <member><type>uint32_t</type>               <name>memoryTypeIndex</name><comment>Index of the of the memory type to allocate from</comment></member>
        </type>
        <type category="struct" name="VkMemoryRequirements" returnedonly="true">
            <member><type>VkDeviceSize</type>           <name>size</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>           <name>alignment</name><comment>Specified in bytes</comment></member>
            <member><type>uint32_t</type>               <name>memoryTypeBits</name><comment>Bitmask of the allowed memory type indices into memoryTypes[] for this object</comment></member>
        </type>
        <type category="struct" name="VkSparseImageFormatProperties" returnedonly="true" requiredlimittype="true">
            <member limittype="bitmask" optional="true"><type>VkImageAspectFlags</type>       <name>aspectMask</name></member>
            <member limittype="min,mul"><type>VkExtent3D</type>                                <name>imageGranularity</name></member>
            <member limittype="bitmask" optional="true"><type>VkSparseImageFormatFlags</type> <name>flags</name></member>
        </type>
        <type category="struct" name="VkSparseImageMemoryRequirements" returnedonly="true">
            <member><type>VkSparseImageFormatProperties</type> <name>formatProperties</name></member>
            <member><type>uint32_t</type>               <name>imageMipTailFirstLod</name></member>
            <member><type>VkDeviceSize</type>           <name>imageMipTailSize</name><comment>Specified in bytes, must be a multiple of sparse block size in bytes / alignment</comment></member>
            <member><type>VkDeviceSize</type>           <name>imageMipTailOffset</name><comment>Specified in bytes, must be a multiple of sparse block size in bytes / alignment</comment></member>
            <member><type>VkDeviceSize</type>           <name>imageMipTailStride</name><comment>Specified in bytes, must be a multiple of sparse block size in bytes / alignment</comment></member>
        </type>
        <type category="struct" name="VkMemoryType" returnedonly="true">
            <member optional="true"><type>VkMemoryPropertyFlags</type>  <name>propertyFlags</name><comment>Memory properties of this memory type</comment></member>
            <member><type>uint32_t</type>               <name>heapIndex</name><comment>Index of the memory heap allocations of this memory type are taken from</comment></member>
        </type>
        <type category="struct" name="VkMemoryHeap" returnedonly="true">
            <member><type>VkDeviceSize</type>           <name>size</name><comment>Available memory in the heap</comment></member>
            <member optional="true"><type>VkMemoryHeapFlags</type>      <name>flags</name><comment>Flags for the heap</comment></member>
        </type>
        <type category="struct" name="VkMappedMemoryRange">
            <member values="VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkDeviceMemory</type>         <name>memory</name><comment>Mapped memory object</comment></member>
            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Offset within the memory object where the range starts</comment></member>
            <member><type>VkDeviceSize</type>           <name>size</name><comment>Size of the range within the memory object</comment></member>
        </type>
        <type category="struct" name="VkFormatProperties" returnedonly="true" requiredlimittype="true">
            <member optional="true" limittype="bitmask"><type>VkFormatFeatureFlags</type>   <name>linearTilingFeatures</name><comment>Format features in case of linear tiling</comment></member>
            <member optional="true" limittype="bitmask"><type>VkFormatFeatureFlags</type>   <name>optimalTilingFeatures</name><comment>Format features in case of optimal tiling</comment></member>
            <member optional="true" limittype="bitmask"><type>VkFormatFeatureFlags</type>   <name>bufferFeatures</name><comment>Format features supported by buffers</comment></member>
        </type>
        <type category="struct" name="VkImageFormatProperties" returnedonly="true">
            <member><type>VkExtent3D</type>             <name>maxExtent</name><comment>max image dimensions for this resource type</comment></member>
            <member><type>uint32_t</type>               <name>maxMipLevels</name><comment>max number of mipmap levels for this resource type</comment></member>
            <member><type>uint32_t</type>               <name>maxArrayLayers</name><comment>max array size for this resource type</comment></member>
            <member optional="true"><type>VkSampleCountFlags</type>     <name>sampleCounts</name><comment>supported sample counts for this resource type</comment></member>
            <member><type>VkDeviceSize</type>           <name>maxResourceSize</name><comment>max size (in bytes) of this resource type</comment></member>
        </type>
        <type category="struct" name="VkDescriptorBufferInfo">
            <member optional="true"><type>VkBuffer</type>               <name>buffer</name><comment>Buffer used for this descriptor slot.</comment></member>
            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Base offset from buffer start in bytes to update in the descriptor set.</comment></member>
            <member><type>VkDeviceSize</type>           <name>range</name><comment>Size in bytes of the buffer resource for this descriptor update.</comment></member>
        </type>
        <type category="struct" name="VkDescriptorImageInfo">
            <member noautovalidity="true"><type>VkSampler</type>       <name>sampler</name><comment>Sampler to write to the descriptor in case it is a SAMPLER or COMBINED_IMAGE_SAMPLER descriptor. Ignored otherwise.</comment></member>
            <member noautovalidity="true"><type>VkImageView</type>     <name>imageView</name><comment>Image view to write to the descriptor in case it is a SAMPLED_IMAGE, STORAGE_IMAGE, COMBINED_IMAGE_SAMPLER, or INPUT_ATTACHMENT descriptor. Ignored otherwise.</comment></member>
            <member noautovalidity="true"><type>VkImageLayout</type>   <name>imageLayout</name><comment>Layout the image is expected to be in when accessed using this descriptor (only used if imageView is not VK_NULL_HANDLE).</comment></member>
        </type>
        <type category="struct" name="VkWriteDescriptorSet">
            <member values="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member noautovalidity="true"><type>VkDescriptorSet</type>        <name>dstSet</name><comment>Destination descriptor set</comment></member>
            <member><type>uint32_t</type>               <name>dstBinding</name><comment>Binding within the destination descriptor set to write</comment></member>
            <member><type>uint32_t</type>               <name>dstArrayElement</name><comment>Array element within the destination binding to write</comment></member>
            <member><type>uint32_t</type>               <name>descriptorCount</name><comment>Number of descriptors to write (determines the size of the array pointed by pDescriptors)</comment></member>
            <member><type>VkDescriptorType</type>       <name>descriptorType</name><comment>Descriptor type to write (determines which members of the array pointed by pDescriptors are going to be used)</comment></member>
            <member noautovalidity="true" len="descriptorCount">const <type>VkDescriptorImageInfo</type>* <name>pImageInfo</name><comment>Sampler, image view, and layout for SAMPLER, COMBINED_IMAGE_SAMPLER, {SAMPLED,STORAGE}_IMAGE, and INPUT_ATTACHMENT descriptor types.</comment></member>
            <member noautovalidity="true" len="descriptorCount">const <type>VkDescriptorBufferInfo</type>* <name>pBufferInfo</name><comment>Raw buffer, size, and offset for {UNIFORM,STORAGE}_BUFFER[_DYNAMIC] descriptor types.</comment></member>
            <member noautovalidity="true" len="descriptorCount">const <type>VkBufferView</type>*    <name>pTexelBufferView</name><comment>Buffer view to write to the descriptor for {UNIFORM,STORAGE}_TEXEL_BUFFER descriptor types.</comment></member>
        </type>
        <type category="struct" name="VkCopyDescriptorSet">
            <member values="VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkDescriptorSet</type>        <name>srcSet</name><comment>Source descriptor set</comment></member>
            <member><type>uint32_t</type>               <name>srcBinding</name><comment>Binding within the source descriptor set to copy from</comment></member>
            <member><type>uint32_t</type>               <name>srcArrayElement</name><comment>Array element within the source binding to copy from</comment></member>
            <member externsync="maybe"><type>VkDescriptorSet</type>        <name>dstSet</name><comment>Destination descriptor set</comment></member>
            <member><type>uint32_t</type>               <name>dstBinding</name><comment>Binding within the destination descriptor set to copy to</comment></member>
            <member><type>uint32_t</type>               <name>dstArrayElement</name><comment>Array element within the destination binding to copy to</comment></member>
            <member><type>uint32_t</type>               <name>descriptorCount</name><comment>Number of descriptors to write (determines the size of the array pointed by pDescriptors)</comment></member>
        </type>
        <type category="struct" name="VkBufferUsageFlags2CreateInfo" structextends="VkBufferViewCreateInfo,VkBufferCreateInfo,VkPhysicalDeviceExternalBufferInfo,VkDescriptorBufferBindingInfoEXT">
            <member values="VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
            <member><type>VkBufferUsageFlags2</type>            <name>usage</name></member>
        </type>
        <type category="struct" name="VkBufferUsageFlags2CreateInfoKHR" alias="VkBufferUsageFlags2CreateInfo"/>
        <type category="struct" name="VkBufferCreateInfo">
            <member values="VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkBufferCreateFlags</type>    <name>flags</name><comment>Buffer creation flags</comment></member>
            <member><type>VkDeviceSize</type>           <name>size</name><comment>Specified in bytes</comment></member>
            <member noautovalidity="true"><type>VkBufferUsageFlags</type>     <name>usage</name><comment>Buffer usage flags</comment></member>
            <member><type>VkSharingMode</type>          <name>sharingMode</name></member>
            <member optional="true"><type>uint32_t</type>               <name>queueFamilyIndexCount</name></member>
            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>*        <name>pQueueFamilyIndices</name></member>
        </type>
        <type category="struct" name="VkBufferViewCreateInfo">
            <member values="VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkBufferViewCreateFlags</type> <name>flags</name></member>
            <member><type>VkBuffer</type>               <name>buffer</name></member>
            <member><type>VkFormat</type>               <name>format</name><comment>Optionally specifies format of elements</comment></member>
            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>           <name>range</name><comment>View size specified in bytes</comment></member>
        </type>
        <type category="struct" name="VkImageSubresource">
            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
            <member><type>uint32_t</type>               <name>mipLevel</name></member>
            <member><type>uint32_t</type>               <name>arrayLayer</name></member>
        </type>
        <type category="struct" name="VkImageSubresourceLayers">
            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
            <member><type>uint32_t</type>               <name>mipLevel</name></member>
            <member><type>uint32_t</type>               <name>baseArrayLayer</name></member>
            <member><type>uint32_t</type>               <name>layerCount</name></member>
        </type>
        <type category="struct" name="VkImageSubresourceRange">
            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
            <member><type>uint32_t</type>               <name>baseMipLevel</name></member>
            <member><type>uint32_t</type>               <name>levelCount</name></member>
            <member><type>uint32_t</type>               <name>baseArrayLayer</name></member>
            <member><type>uint32_t</type>               <name>layerCount</name></member>
        </type>
        <type category="struct" name="VkMemoryBarrier">
            <member values="VK_STRUCTURE_TYPE_MEMORY_BARRIER"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name><comment>Memory accesses from the source of the dependency to synchronize</comment></member>
            <member optional="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name><comment>Memory accesses from the destination of the dependency to synchronize</comment></member>
        </type>
        <type category="struct" name="VkBufferMemoryBarrier">
            <member values="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member noautovalidity="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name><comment>Memory accesses from the source of the dependency to synchronize</comment></member>
            <member noautovalidity="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name><comment>Memory accesses from the destination of the dependency to synchronize</comment></member>
            <member><type>uint32_t</type>               <name>srcQueueFamilyIndex</name><comment>Queue family to transition ownership from</comment></member>
            <member><type>uint32_t</type>               <name>dstQueueFamilyIndex</name><comment>Queue family to transition ownership to</comment></member>
            <member><type>VkBuffer</type>               <name>buffer</name><comment>Buffer to sync</comment></member>
            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Offset within the buffer to sync</comment></member>
            <member><type>VkDeviceSize</type>           <name>size</name><comment>Amount of bytes to sync</comment></member>
        </type>
        <type category="struct" name="VkImageMemoryBarrier">
            <member values="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member noautovalidity="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name><comment>Memory accesses from the source of the dependency to synchronize</comment></member>
            <member noautovalidity="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name><comment>Memory accesses from the destination of the dependency to synchronize</comment></member>
            <member><type>VkImageLayout</type>          <name>oldLayout</name><comment>Current layout of the image</comment></member>
            <member><type>VkImageLayout</type>          <name>newLayout</name><comment>New layout to transition the image to</comment></member>
            <member><type>uint32_t</type>               <name>srcQueueFamilyIndex</name><comment>Queue family to transition ownership from</comment></member>
            <member><type>uint32_t</type>               <name>dstQueueFamilyIndex</name><comment>Queue family to transition ownership to</comment></member>
            <member><type>VkImage</type>                <name>image</name><comment>Image to sync</comment></member>
            <member><type>VkImageSubresourceRange</type> <name>subresourceRange</name><comment>Subresource range to sync</comment></member>
        </type>
        <type category="struct" name="VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkImageCreateFlags</type>     <name>flags</name><comment>Image creation flags</comment></member>
            <member><type>VkImageType</type>            <name>imageType</name></member>
            <member><type>VkFormat</type>               <name>format</name></member>
            <member><type>VkExtent3D</type>             <name>extent</name></member>
            <member><type>uint32_t</type>               <name>mipLevels</name></member>
            <member><type>uint32_t</type>               <name>arrayLayers</name></member>
            <member><type>VkSampleCountFlagBits</type>  <name>samples</name></member>
            <member><type>VkImageTiling</type>          <name>tiling</name></member>
            <member><type>VkImageUsageFlags</type>      <name>usage</name><comment>Image usage flags</comment></member>
            <member><type>VkSharingMode</type>          <name>sharingMode</name><comment>Cross-queue-family sharing mode</comment></member>
            <member optional="true"><type>uint32_t</type>               <name>queueFamilyIndexCount</name><comment>Number of queue families to share across</comment></member>
            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>*        <name>pQueueFamilyIndices</name><comment>Array of queue family indices to share across</comment></member>
            <member><type>VkImageLayout</type>          <name>initialLayout</name><comment>Initial image layout for all subresources</comment></member>
        </type>
        <type category="struct" name="VkSubresourceLayout">
            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>           <name>size</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>           <name>rowPitch</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>           <name>arrayPitch</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>           <name>depthPitch</name><comment>Specified in bytes</comment></member>
        </type>
        <type category="struct" name="VkImageViewCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkImageViewCreateFlags</type> <name>flags</name></member>
            <member><type>VkImage</type>                <name>image</name></member>
            <member><type>VkImageViewType</type>        <name>viewType</name></member>
            <member><type>VkFormat</type>               <name>format</name></member>
            <member><type>VkComponentMapping</type>     <name>components</name></member>
            <member><type>VkImageSubresourceRange</type> <name>subresourceRange</name></member>
        </type>
        <type category="struct" name="VkBufferCopy">
            <member><type>VkDeviceSize</type>                       <name>srcOffset</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>                       <name>dstOffset</name><comment>Specified in bytes</comment></member>
            <member noautovalidity="true"><type>VkDeviceSize</type> <name>size</name><comment>Specified in bytes</comment></member>
        </type>
        <type category="struct" name="VkSparseMemoryBind">
            <member><type>VkDeviceSize</type>           <name>resourceOffset</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>           <name>size</name><comment>Specified in bytes</comment></member>
            <member optional="true"><type>VkDeviceMemory</type>         <name>memory</name></member>
            <member><type>VkDeviceSize</type>           <name>memoryOffset</name><comment>Specified in bytes</comment></member>
            <member optional="true"><type>VkSparseMemoryBindFlags</type> <name>flags</name></member>
        </type>
        <type category="struct" name="VkSparseImageMemoryBind">
            <member><type>VkImageSubresource</type>     <name>subresource</name></member>
            <member><type>VkOffset3D</type>             <name>offset</name></member>
            <member><type>VkExtent3D</type>             <name>extent</name></member>
            <member optional="true"><type>VkDeviceMemory</type>         <name>memory</name></member>
            <member><type>VkDeviceSize</type>           <name>memoryOffset</name><comment>Specified in bytes</comment></member>
            <member optional="true"><type>VkSparseMemoryBindFlags</type> <name>flags</name></member>
        </type>
        <type category="struct" name="VkSparseBufferMemoryBindInfo">
            <member><type>VkBuffer</type> <name>buffer</name></member>
            <member><type>uint32_t</type>               <name>bindCount</name></member>
            <member len="bindCount">const <type>VkSparseMemoryBind</type>* <name>pBinds</name></member>
        </type>
        <type category="struct" name="VkSparseImageOpaqueMemoryBindInfo">
            <member><type>VkImage</type> <name>image</name></member>
            <member><type>uint32_t</type>               <name>bindCount</name></member>
            <member len="bindCount">const <type>VkSparseMemoryBind</type>* <name>pBinds</name></member>
        </type>
        <type category="struct" name="VkSparseImageMemoryBindInfo">
            <member><type>VkImage</type> <name>image</name></member>
            <member><type>uint32_t</type>               <name>bindCount</name></member>
            <member len="bindCount">const <type>VkSparseImageMemoryBind</type>* <name>pBinds</name></member>
        </type>
        <type category="struct" name="VkBindSparseInfo">
            <member values="VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>               <name>waitSemaphoreCount</name></member>
            <member len="waitSemaphoreCount">const <type>VkSemaphore</type>*     <name>pWaitSemaphores</name></member>
            <member optional="true"><type>uint32_t</type>               <name>bufferBindCount</name></member>
            <member len="bufferBindCount">const <type>VkSparseBufferMemoryBindInfo</type>* <name>pBufferBinds</name></member>
            <member optional="true"><type>uint32_t</type>               <name>imageOpaqueBindCount</name></member>
            <member len="imageOpaqueBindCount">const <type>VkSparseImageOpaqueMemoryBindInfo</type>* <name>pImageOpaqueBinds</name></member>
            <member optional="true"><type>uint32_t</type>               <name>imageBindCount</name></member>
            <member len="imageBindCount">const <type>VkSparseImageMemoryBindInfo</type>* <name>pImageBinds</name></member>
            <member optional="true"><type>uint32_t</type>               <name>signalSemaphoreCount</name></member>
            <member len="signalSemaphoreCount">const <type>VkSemaphore</type>*     <name>pSignalSemaphores</name></member>
        </type>
        <type category="struct" name="VkImageCopy">
            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>srcOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>dstOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
            <member><type>VkExtent3D</type>             <name>extent</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
        </type>
        <type category="struct" name="VkImageBlit">
            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>srcOffsets</name>[2]<comment>Specified in pixels for both compressed and uncompressed images</comment></member>
            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>dstOffsets</name>[2]<comment>Specified in pixels for both compressed and uncompressed images</comment></member>
        </type>
        <type category="struct" name="VkBufferImageCopy">
            <member><type>VkDeviceSize</type>           <name>bufferOffset</name><comment>Specified in bytes</comment></member>
            <member><type>uint32_t</type>               <name>bufferRowLength</name><comment>Specified in texels</comment></member>
            <member><type>uint32_t</type>               <name>bufferImageHeight</name></member>
            <member><type>VkImageSubresourceLayers</type> <name>imageSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>imageOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
            <member><type>VkExtent3D</type>             <name>imageExtent</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
        </type>
        <type category="struct" name="VkStridedDeviceAddressRangeKHR">
            <member optional="true"><type>VkDeviceAddress</type>    <name>address</name></member>
            <member><type>VkDeviceSize</type>                       <name>size</name></member>
            <member><type>VkDeviceSize</type>                       <name>stride</name></member>
        </type>
        <type category="struct" name="VkCopyMemoryIndirectCommandKHR">
            <member><type>VkDeviceAddress</type>                    <name>srcAddress</name></member>
            <member><type>VkDeviceAddress</type>                    <name>dstAddress</name></member>
            <member><type>VkDeviceSize</type>                       <name>size</name></member>
        </type>
        <type category="struct" name="VkCopyMemoryIndirectCommandNV" alias="VkCopyMemoryIndirectCommandKHR"/>
        <type category="struct" name="VkCopyMemoryIndirectInfoKHR">
            <member values="VK_STRUCTURE_TYPE_COPY_MEMORY_INDIRECT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                 <name>pNext</name></member>
            <member><type>VkAddressCopyFlagsKHR</type>                       <name>srcCopyFlags</name></member>
            <member><type>VkAddressCopyFlagsKHR</type>                       <name>dstCopyFlags</name></member>
            <member><type>uint32_t</type>                                    <name>copyCount</name></member>
            <member><type>VkStridedDeviceAddressRangeKHR</type>              <name>copyAddressRange</name></member>
        </type>
        <type category="struct" name="VkCopyMemoryToImageIndirectCommandKHR">
            <member><type>VkDeviceAddress</type>                            <name>srcAddress</name></member>
            <member><type>uint32_t</type>                                   <name>bufferRowLength</name></member>
            <member><type>uint32_t</type>                                   <name>bufferImageHeight</name></member>
            <member><type>VkImageSubresourceLayers</type>                   <name>imageSubresource</name></member>
            <member><type>VkOffset3D</type>                                 <name>imageOffset</name></member>
            <member><type>VkExtent3D</type>                                 <name>imageExtent</name></member>
        </type>
        <type category="struct" name="VkCopyMemoryToImageIndirectCommandNV" alias="VkCopyMemoryToImageIndirectCommandKHR"/>
        <type category="struct" name="VkCopyMemoryToImageIndirectInfoKHR">
            <member values="VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INDIRECT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                 <name>pNext</name></member>
            <member><type>VkAddressCopyFlagsKHR</type>                       <name>srcCopyFlags</name></member>
            <member><type>uint32_t</type>                                    <name>copyCount</name></member>
            <member><type>VkStridedDeviceAddressRangeKHR</type>              <name>copyAddressRange</name></member>
            <member><type>VkImage</type>                                     <name>dstImage</name></member>
            <member><type>VkImageLayout</type>                               <name>dstImageLayout</name></member>
            <member len="copyCount">const <type>VkImageSubresourceLayers</type>* <name>pImageSubresources</name></member>
        </type>
        <type category="struct" name="VkImageResolve">
            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>srcOffset</name></member>
            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>dstOffset</name></member>
            <member><type>VkExtent3D</type>             <name>extent</name></member>
        </type>
        <type category="struct" name="VkShaderModuleCreateInfo" structextends="VkPipelineShaderStageCreateInfo,VkDataGraphPipelineCreateInfoARM">
            <member values="VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true" optional="true">const <type>void</type>*            <name>pNext</name><comment>noautovalidity because this structure can be either an explicit parameter, or passed in a pNext chain</comment></member>
            <member optional="true"><type>VkShaderModuleCreateFlags</type> <name>flags</name></member>
            <member><type>size_t</type>                 <name>codeSize</name><comment>Specified in bytes</comment></member>
            <member len="latexmath:[\textrm{codeSize} \over 4]" altlen="codeSize / 4">const <type>uint32_t</type>*            <name>pCode</name><comment>Binary code of size codeSize</comment></member>
        </type>
        <type category="struct" name="VkDescriptorSetLayoutBinding">
            <member><type>uint32_t</type>               <name>binding</name><comment>Binding number for this entry</comment></member>
            <member><type>VkDescriptorType</type>       <name>descriptorType</name><comment>Type of the descriptors in this binding</comment></member>
            <member optional="true"><type>uint32_t</type> <name>descriptorCount</name><comment>Number of descriptors in this binding</comment></member>
            <member noautovalidity="true"><type>VkShaderStageFlags</type>     <name>stageFlags</name><comment>Shader stages this binding is visible to</comment></member>
            <member noautovalidity="true" optional="true" len="descriptorCount">const <type>VkSampler</type>*       <name>pImmutableSamplers</name><comment>Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains count number of elements)</comment></member>
        </type>
        <type category="struct" name="VkDescriptorSetLayoutCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkDescriptorSetLayoutCreateFlags</type>    <name>flags</name></member>
            <member optional="true"><type>uint32_t</type>               <name>bindingCount</name><comment>Number of bindings in the descriptor set layout</comment></member>
            <member len="bindingCount">const <type>VkDescriptorSetLayoutBinding</type>* <name>pBindings</name><comment>Array of descriptor set layout bindings</comment></member>
        </type>
        <type category="struct" name="VkDescriptorPoolSize">
            <member><type>VkDescriptorType</type>       <name>type</name></member>
            <member><type>uint32_t</type>               <name>descriptorCount</name></member>
        </type>
        <type category="struct" name="VkDescriptorPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkDescriptorPoolCreateFlags</type>  <name>flags</name></member>
            <member><type>uint32_t</type>               <name>maxSets</name></member>
            <member optional="true"><type>uint32_t</type>               <name>poolSizeCount</name></member>
            <member len="poolSizeCount">const <type>VkDescriptorPoolSize</type>* <name>pPoolSizes</name></member>
        </type>
        <type category="struct" name="VkDescriptorSetAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member externsync="true"><type>VkDescriptorPool</type>       <name>descriptorPool</name></member>
            <member><type>uint32_t</type>               <name>descriptorSetCount</name></member>
            <member len="descriptorSetCount">const <type>VkDescriptorSetLayout</type>* <name>pSetLayouts</name></member>
        </type>
        <type category="struct" name="VkSpecializationMapEntry">
            <member><type>uint32_t</type>                     <name>constantID</name><comment>The SpecConstant ID specified in the BIL</comment></member>
            <member><type>uint32_t</type>                     <name>offset</name><comment>Offset of the value in the data block</comment></member>
            <member noautovalidity="true"><type>size_t</type> <name>size</name><comment>Size in bytes of the SpecConstant</comment></member>
        </type>
        <type category="struct" name="VkSpecializationInfo">
            <member optional="true"><type>uint32_t</type>               <name>mapEntryCount</name><comment>Number of entries in the map</comment></member>
            <member len="mapEntryCount">const <type>VkSpecializationMapEntry</type>* <name>pMapEntries</name><comment>Array of map entries</comment></member>
            <member optional="true"><type>size_t</type>                 <name>dataSize</name><comment>Size in bytes of pData</comment></member>
            <member len="dataSize">const <type>void</type>*            <name>pData</name><comment>Pointer to SpecConstant data</comment></member>
        </type>
        <type category="struct" name="VkPipelineShaderStageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineShaderStageCreateFlags</type>    <name>flags</name></member>
            <member><type>VkShaderStageFlagBits</type>  <name>stage</name><comment>Shader stage</comment></member>
            <member optional="true"><type>VkShaderModule</type> <name>module</name><comment>Module containing entry point</comment></member>
            <member api="vulkan,vulkanbase" len="null-terminated">const <type>char</type>* <name>pName</name><comment>Null-terminated entry point name</comment></member>
            <member api="vulkansc" optional="true" len="null-terminated">const <type>char</type>* <name>pName</name><comment>Null-terminated entry point name</comment></member>
            <member optional="true">const <type>VkSpecializationInfo</type>* <name>pSpecializationInfo</name></member>
        </type>
        <type category="struct" name="VkComputePipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member noautovalidity="true" optional="true"><type>VkPipelineCreateFlags</type>  <name>flags</name><comment>Pipeline creation flags</comment></member>
            <member><type>VkPipelineShaderStageCreateInfo</type> <name>stage</name></member>
            <member><type>VkPipelineLayout</type>       <name>layout</name><comment>Interface layout of the pipeline</comment></member>
            <member noautovalidity="true" optional="true"><type>VkPipeline</type>      <name>basePipelineHandle</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of</comment></member>
            <member><type>int32_t</type>                <name>basePipelineIndex</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of</comment></member>
        </type>
        <type category="struct" name="VkComputePipelineIndirectBufferInfoNV" structextends="VkComputePipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*       <name>pNext</name></member>
            <member><type>VkDeviceAddress</type>                   <name>deviceAddress</name></member>
            <member><type>VkDeviceSize</type>                      <name>size</name></member>
            <member optional="true"><type>VkDeviceAddress</type>   <name>pipelineDeviceAddressCaptureReplay</name></member>
        </type>
        <type category="struct" name="VkPipelineCreateFlags2CreateInfo" structextends="VkComputePipelineCreateInfo,VkGraphicsPipelineCreateInfo,VkRayTracingPipelineCreateInfoNV,VkRayTracingPipelineCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineCreateFlags2</type> <name>flags</name></member>
        </type>
        <type category="struct" name="VkPipelineCreateFlags2CreateInfoKHR" alias="VkPipelineCreateFlags2CreateInfo"/>
        <type category="struct" name="VkVertexInputBindingDescription">
            <member><type>uint32_t</type>               <name>binding</name><comment>Vertex buffer binding id</comment></member>
            <member><type>uint32_t</type>               <name>stride</name><comment>Distance between vertices in bytes (0 = no advancement)</comment></member>
            <member><type>VkVertexInputRate</type>      <name>inputRate</name><comment>The rate at which the vertex data is consumed</comment></member>
        </type>
        <type category="struct" name="VkVertexInputAttributeDescription">
            <member><type>uint32_t</type>               <name>location</name><comment>location of the shader vertex attrib</comment></member>
            <member><type>uint32_t</type>               <name>binding</name><comment>Vertex buffer binding id</comment></member>
            <member><type>VkFormat</type>               <name>format</name><comment>format of source data</comment></member>
            <member><type>uint32_t</type>               <name>offset</name><comment>Offset of first element in bytes from base of vertex</comment></member>
        </type>
        <type category="struct" name="VkPipelineVertexInputStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineVertexInputStateCreateFlags</type>    <name>flags</name></member>
            <member optional="true"><type>uint32_t</type>               <name>vertexBindingDescriptionCount</name><comment>number of bindings</comment></member>
            <member len="vertexBindingDescriptionCount">const <type>VkVertexInputBindingDescription</type>* <name>pVertexBindingDescriptions</name></member>
            <member optional="true"><type>uint32_t</type>               <name>vertexAttributeDescriptionCount</name><comment>number of attributes</comment></member>
            <member len="vertexAttributeDescriptionCount">const <type>VkVertexInputAttributeDescription</type>* <name>pVertexAttributeDescriptions</name></member>
        </type>
        <type category="struct" name="VkPipelineInputAssemblyStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineInputAssemblyStateCreateFlags</type>    <name>flags</name></member>
            <member><type>VkPrimitiveTopology</type>    <name>topology</name></member>
            <member><type>VkBool32</type>               <name>primitiveRestartEnable</name></member>
        </type>
        <type category="struct" name="VkPipelineTessellationStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineTessellationStateCreateFlags</type>    <name>flags</name></member>
            <member><type>uint32_t</type>               <name>patchControlPoints</name></member>
        </type>
        <type category="struct" name="VkPipelineViewportStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineViewportStateCreateFlags</type>    <name>flags</name></member>
            <member optional="true"><type>uint32_t</type>               <name>viewportCount</name></member>
            <member noautovalidity="true" optional="true" len="viewportCount">const <type>VkViewport</type>*      <name>pViewports</name></member>
            <member optional="true"><type>uint32_t</type>               <name>scissorCount</name></member>
            <member noautovalidity="true" optional="true" len="scissorCount">const <type>VkRect2D</type>*        <name>pScissors</name></member>
        </type>
        <type category="struct" name="VkPipelineRasterizationStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member optional="true"><type>VkPipelineRasterizationStateCreateFlags</type>    <name>flags</name></member>
            <member><type>VkBool32</type>               <name>depthClampEnable</name></member>
            <member><type>VkBool32</type>               <name>rasterizerDiscardEnable</name></member>
            <member><type>VkPolygonMode</type>          <name>polygonMode</name><comment>optional (GL45)</comment></member>
            <member optional="true"><type>VkCullModeFlags</type>        <name>cullMode</name></member>
            <member><type>VkFrontFace</type>            <name>frontFace</name></member>
            <member><type>VkBool32</type>               <name>depthBiasEnable</name></member>
            <member><type>float</type>                  <name>depthBiasConstantFactor</name></member>
            <member><type>float</type>                  <name>depthBiasClamp</name></member>
            <member><type>float</type>                  <name>depthBiasSlopeFactor</name></member>
            <member><type>float</type>                  <name>lineWidth</name></member>
        </type>
        <type category="struct" name="VkPipelineMultisampleStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineMultisampleStateCreateFlags</type>    <name>flags</name></member>
            <member><type>VkSampleCountFlagBits</type>  <name>rasterizationSamples</name><comment>Number of samples used for rasterization</comment></member>
            <member><type>VkBool32</type>               <name>sampleShadingEnable</name><comment>optional (GL45)</comment></member>
            <member><type>float</type>                  <name>minSampleShading</name><comment>optional (GL45)</comment></member>
            <member noautovalidity="true" optional="true" len="latexmath:[\lceil{\mathit{rasterizationSamples} \over 32}\rceil]" altlen="(rasterizationSamples + 31) / 32">const <type>VkSampleMask</type>*    <name>pSampleMask</name><comment>Array of sampleMask words</comment></member>
            <member><type>VkBool32</type>               <name>alphaToCoverageEnable</name></member>
            <member><type>VkBool32</type>               <name>alphaToOneEnable</name></member>
        </type>
        <type category="struct" name="VkPipelineColorBlendAttachmentState">
            <member><type>VkBool32</type>               <name>blendEnable</name></member>
            <member><type>VkBlendFactor</type>          <name>srcColorBlendFactor</name></member>
            <member><type>VkBlendFactor</type>          <name>dstColorBlendFactor</name></member>
            <member><type>VkBlendOp</type>              <name>colorBlendOp</name></member>
            <member><type>VkBlendFactor</type>          <name>srcAlphaBlendFactor</name></member>
            <member><type>VkBlendFactor</type>          <name>dstAlphaBlendFactor</name></member>
            <member><type>VkBlendOp</type>              <name>alphaBlendOp</name></member>
            <member optional="true"><type>VkColorComponentFlags</type>  <name>colorWriteMask</name></member>
        </type>
        <type category="struct" name="VkPipelineColorBlendStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineColorBlendStateCreateFlags</type>    <name>flags</name></member>
            <member><type>VkBool32</type>               <name>logicOpEnable</name></member>
            <member noautovalidity="true"><type>VkLogicOp</type>              <name>logicOp</name></member>
            <member optional="true"><type>uint32_t</type>               <name>attachmentCount</name><comment># of pAttachments</comment></member>
            <member optional="true" len="attachmentCount">const <type>VkPipelineColorBlendAttachmentState</type>* <name>pAttachments</name></member>
            <member><type>float</type>                  <name>blendConstants</name>[4]</member>
        </type>
        <type category="struct" name="VkPipelineDynamicStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineDynamicStateCreateFlags</type>    <name>flags</name></member>
            <member optional="true"><type>uint32_t</type>               <name>dynamicStateCount</name></member>
            <member len="dynamicStateCount">const <type>VkDynamicState</type>*  <name>pDynamicStates</name></member>
        </type>
        <type category="struct" name="VkStencilOpState">
            <member><type>VkStencilOp</type>            <name>failOp</name></member>
            <member><type>VkStencilOp</type>            <name>passOp</name></member>
            <member><type>VkStencilOp</type>            <name>depthFailOp</name></member>
            <member><type>VkCompareOp</type>            <name>compareOp</name></member>
            <member><type>uint32_t</type>               <name>compareMask</name></member>
            <member><type>uint32_t</type>               <name>writeMask</name></member>
            <member><type>uint32_t</type>               <name>reference</name></member>
        </type>
        <type category="struct" name="VkPipelineDepthStencilStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineDepthStencilStateCreateFlags</type>    <name>flags</name></member>
            <member><type>VkBool32</type>               <name>depthTestEnable</name></member>
            <member><type>VkBool32</type>               <name>depthWriteEnable</name></member>
            <member><type>VkCompareOp</type>            <name>depthCompareOp</name></member>
            <member><type>VkBool32</type>               <name>depthBoundsTestEnable</name><comment>optional (depth_bounds_test)</comment></member>
            <member><type>VkBool32</type>               <name>stencilTestEnable</name></member>
            <member><type>VkStencilOpState</type>       <name>front</name></member>
            <member><type>VkStencilOpState</type>       <name>back</name></member>
            <member><type>float</type>                  <name>minDepthBounds</name></member>
            <member><type>float</type>                  <name>maxDepthBounds</name></member>
        </type>
        <type category="struct" name="VkGraphicsPipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member noautovalidity="true" optional="true"><type>VkPipelineCreateFlags</type>  <name>flags</name><comment>Pipeline creation flags</comment></member>
            <member noautovalidity="true" optional="true"><type>uint32_t</type> <name>stageCount</name></member>
            <member api="vulkan,vulkanbase" noautovalidity="true" len="stageCount" optional="true">const <type>VkPipelineShaderStageCreateInfo</type>* <name>pStages</name><comment>One entry for each active shader stage</comment></member>
            <member api="vulkansc" noautovalidity="true" len="stageCount">const <type>VkPipelineShaderStageCreateInfo</type>* <name>pStages</name><comment>One entry for each active shader stage</comment></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineVertexInputStateCreateInfo</type>* <name>pVertexInputState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineInputAssemblyStateCreateInfo</type>* <name>pInputAssemblyState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineTessellationStateCreateInfo</type>* <name>pTessellationState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineViewportStateCreateInfo</type>* <name>pViewportState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineRasterizationStateCreateInfo</type>* <name>pRasterizationState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineMultisampleStateCreateInfo</type>* <name>pMultisampleState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineDepthStencilStateCreateInfo</type>* <name>pDepthStencilState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineColorBlendStateCreateInfo</type>* <name>pColorBlendState</name></member>
            <member optional="true">const <type>VkPipelineDynamicStateCreateInfo</type>* <name>pDynamicState</name></member>
            <member noautovalidity="true" optional="true"><type>VkPipelineLayout</type>       <name>layout</name><comment>Interface layout of the pipeline</comment></member>
            <member noautovalidity="true" optional="true"><type>VkRenderPass</type>           <name>renderPass</name></member>
            <member noautovalidity="true"><type>uint32_t</type>               <name>subpass</name></member>
            <member noautovalidity="true" optional="true"><type>VkPipeline</type>      <name>basePipelineHandle</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of</comment></member>
            <member><type>int32_t</type>                <name>basePipelineIndex</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of</comment></member>
        </type>
        <type category="struct" name="VkPipelineCacheCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineCacheCreateFlags</type>    <name>flags</name></member>
            <member api="vulkan,vulkanbase" optional="true"><type>size_t</type>           <name>initialDataSize</name><comment>Size of initial data to populate cache, in bytes</comment></member>
            <member api="vulkansc"><type>size_t</type>                         <name>initialDataSize</name><comment>Size of initial data to populate cache, in bytes</comment></member>
            <member len="initialDataSize">const <type>void</type>*            <name>pInitialData</name><comment>Initial data to populate cache</comment></member>
        </type>
        <type category="struct" name="VkPipelineCacheHeaderVersionOne">
            <comment>The fields in this structure are non-normative since structure packing is implementation-defined in C. The specification defines the normative layout.</comment>
            <member><type>uint32_t</type>               <name>headerSize</name></member>
            <member><type>VkPipelineCacheHeaderVersion</type> <name>headerVersion</name></member>
            <member><type>uint32_t</type>               <name>vendorID</name></member>
            <member><type>uint32_t</type>               <name>deviceID</name></member>
            <member><type>uint8_t</type>                <name>pipelineCacheUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
        </type>
        <type category="struct" name="VkPipelineCacheStageValidationIndexEntry">
            <comment>The fields in this structure are non-normative since structure packing is implementation-defined in C. The specification defines the normative layout.</comment>
            <member><type>uint64_t</type>               <name>codeSize</name></member>
            <member><type>uint64_t</type>               <name>codeOffset</name></member>
        </type>
        <type category="struct" name="VkPipelineCacheSafetyCriticalIndexEntry">
            <comment>The fields in this structure are non-normative since structure packing is implementation-defined in C. The specification defines the normative layout.</comment>
            <member><type>uint8_t</type>                <name>pipelineIdentifier</name>[<enum>VK_UUID_SIZE</enum>]</member>
            <member><type>uint64_t</type>               <name>pipelineMemorySize</name></member>
            <member><type>uint64_t</type>               <name>jsonSize</name></member>
            <member><type>uint64_t</type>               <name>jsonOffset</name></member>
            <member><type>uint32_t</type>               <name>stageIndexCount</name></member>
            <member><type>uint32_t</type>               <name>stageIndexStride</name></member>
            <member><type>uint64_t</type>               <name>stageIndexOffset</name></member>
        </type>
        <type category="struct" name="VkPipelineCacheHeaderVersionSafetyCriticalOne">
            <comment>The fields in this structure are non-normative since structure packing is implementation-defined in C. The specification defines the normative layout.</comment>
            <member><type>VkPipelineCacheHeaderVersionOne</type>        <name>headerVersionOne</name></member>
            <member><type>VkPipelineCacheValidationVersion</type>       <name>validationVersion</name></member>
            <member><type>uint32_t</type>                               <name>implementationData</name></member>
            <member><type>uint32_t</type>                               <name>pipelineIndexCount</name></member>
            <member><type>uint32_t</type>                               <name>pipelineIndexStride</name></member>
            <member><type>uint64_t</type>                               <name>pipelineIndexOffset</name></member>
        </type>
        <type category="struct" name="VkPipelineCacheHeaderVersionDataGraphQCOM">
            <comment>The fields in this structure are non-normative since structure packing is implementation-defined in C. The specification defines the normative layout.</comment>
            <member><type>uint32_t</type>                      <name>headerSize</name></member>
            <member><type>VkPipelineCacheHeaderVersion</type>  <name>headerVersion</name></member>
            <member><type>VkDataGraphModelCacheTypeQCOM</type> <name>cacheType</name></member>
            <member><type>uint32_t</type>                      <name>cacheVersion</name></member>
            <member><type>uint32_t</type>                      <name>toolchainVersion</name>[<enum>VK_DATA_GRAPH_MODEL_TOOLCHAIN_VERSION_LENGTH_QCOM</enum>]</member>
        </type>
        <type category="struct" name="VkPushConstantRange">
            <member><type>VkShaderStageFlags</type>     <name>stageFlags</name><comment>Which stages use the range</comment></member>
            <member><type>uint32_t</type>               <name>offset</name><comment>Start of the range, in bytes</comment></member>
            <member><type>uint32_t</type>               <name>size</name><comment>Size of the range, in bytes</comment></member>
        </type>
        <type category="struct" name="VkPipelineBinaryCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                           <name>pNext</name></member>
            <member optional="true">const <type>VkPipelineBinaryKeysAndDataKHR</type>* <name>pKeysAndDataInfo</name></member>
            <member optional="true"><type>VkPipeline</type>                            <name>pipeline</name></member>
            <member optional="true">const <type>VkPipelineCreateInfoKHR</type>*         <name>pPipelineCreateInfo</name></member>
        </type>
        <type category="struct" name="VkPipelineBinaryHandlesInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
            <member optional="false,true"><type>uint32_t</type>                                 <name>pipelineBinaryCount</name></member>
            <member optional="true" len="pipelineBinaryCount"><type>VkPipelineBinaryKHR</type>* <name>pPipelineBinaries</name></member>
        </type>
        <type category="struct" name="VkPipelineBinaryDataKHR">
            <member><type>size_t</type>                               <name>dataSize</name></member>
            <member len="dataSize"><type>void</type>*                 <name>pData</name></member>
        </type>
        <type category="struct" name="VkPipelineBinaryKeysAndDataKHR">
            <member><type>uint32_t</type>                                           <name>binaryCount</name></member>
            <member len="binaryCount">const <type>VkPipelineBinaryKeyKHR</type>*    <name>pPipelineBinaryKeys</name></member>
            <member len="binaryCount">const <type>VkPipelineBinaryDataKHR</type>*   <name>pPipelineBinaryData</name></member>
        </type>
        <type category="struct" name="VkPipelineBinaryKeyKHR">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*          <name>pNext</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>keySize</name></member>
            <member><type>uint8_t</type>                        <name>key</name>[<enum>VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR</enum>]</member>
        </type>
        <type category="struct" name="VkPipelineBinaryInfoKHR" structextends="VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkRayTracingPipelineCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                         <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                                                            <name>binaryCount</name></member>
            <member len="binaryCount">const <type>VkPipelineBinaryKHR</type>*                        <name>pPipelineBinaries</name></member>
        </type>
        <type category="struct" name="VkReleaseCapturedPipelineDataInfoKHR">
            <member values="VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*          <name>pNext</name></member>
            <member externsync="true"><type>VkPipeline</type>    <name>pipeline</name></member>
        </type>
        <type category="struct" name="VkPipelineBinaryDataInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*          <name>pNext</name></member>
            <member><type>VkPipelineBinaryKHR</type>    <name>pipelineBinary</name></member>
        </type>
        <type category="struct" name="VkPipelineCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true" optional="true"><type>void</type>*          <name>pNext</name></member>
        </type>
        <type category="struct" name="VkPipelineLayoutCreateInfo" structextends="VkBindDescriptorSetsInfo,VkPushConstantsInfo,VkPushDescriptorSetInfo,VkPushDescriptorSetWithTemplateInfo,VkSetDescriptorBufferOffsetsInfoEXT,VkBindDescriptorBufferEmbeddedSamplersInfoEXT,VkIndirectCommandsLayoutCreateInfoEXT">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineLayoutCreateFlags</type>    <name>flags</name></member>
            <member optional="true"><type>uint32_t</type>               <name>setLayoutCount</name><comment>Number of descriptor sets interfaced by the pipeline</comment></member>
            <member optional="false,true" len="setLayoutCount">const <type>VkDescriptorSetLayout</type>* <name>pSetLayouts</name><comment>Array of setCount number of descriptor set layout objects defining the layout of the</comment></member>
            <member optional="true"><type>uint32_t</type>               <name>pushConstantRangeCount</name><comment>Number of push-constant ranges used by the pipeline</comment></member>
            <member len="pushConstantRangeCount">const <type>VkPushConstantRange</type>* <name>pPushConstantRanges</name><comment>Array of pushConstantRangeCount number of ranges used by various shader stages</comment></member>
        </type>
        <type category="struct" name="VkSamplerCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkSamplerCreateFlags</type>   <name>flags</name></member>
            <member><type>VkFilter</type>               <name>magFilter</name><comment>Filter mode for magnification</comment></member>
            <member><type>VkFilter</type>               <name>minFilter</name><comment>Filter mode for minifiation</comment></member>
            <member><type>VkSamplerMipmapMode</type>    <name>mipmapMode</name><comment>Mipmap selection mode</comment></member>
            <member><type>VkSamplerAddressMode</type>   <name>addressModeU</name></member>
            <member><type>VkSamplerAddressMode</type>   <name>addressModeV</name></member>
            <member><type>VkSamplerAddressMode</type>   <name>addressModeW</name></member>
            <member><type>float</type>                  <name>mipLodBias</name></member>
            <member><type>VkBool32</type>               <name>anisotropyEnable</name></member>
            <member><type>float</type>                  <name>maxAnisotropy</name></member>
            <member><type>VkBool32</type>               <name>compareEnable</name></member>
            <member noautovalidity="true"><type>VkCompareOp</type>            <name>compareOp</name></member>
            <member><type>float</type>                  <name>minLod</name></member>
            <member><type>float</type>                  <name>maxLod</name></member>
            <member noautovalidity="true"><type>VkBorderColor</type>          <name>borderColor</name></member>
            <member><type>VkBool32</type>               <name>unnormalizedCoordinates</name></member>
        </type>
        <type category="struct" name="VkCommandPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkCommandPoolCreateFlags</type>   <name>flags</name><comment>Command pool creation flags</comment></member>
            <member><type>uint32_t</type>               <name>queueFamilyIndex</name></member>
        </type>
        <type category="struct" name="VkCommandBufferAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member externsync="true"><type>VkCommandPool</type>          <name>commandPool</name></member>
            <member><type>VkCommandBufferLevel</type>   <name>level</name></member>
            <member><type>uint32_t</type>               <name>commandBufferCount</name></member>
        </type>
        <type category="struct" name="VkCommandBufferInheritanceInfo">
            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true" noautovalidity="true"><type>VkRenderPass</type>    <name>renderPass</name><comment>Render pass for secondary command buffers</comment></member>
            <member><type>uint32_t</type>               <name>subpass</name></member>
            <member optional="true" noautovalidity="true"><type>VkFramebuffer</type>   <name>framebuffer</name><comment>Framebuffer for secondary command buffers</comment></member>
            <member><type>VkBool32</type>               <name>occlusionQueryEnable</name><comment>Whether this secondary command buffer may be executed during an occlusion query</comment></member>
            <member optional="true" noautovalidity="true"><type>VkQueryControlFlags</type>    <name>queryFlags</name><comment>Query flags used by this secondary command buffer, if executed during an occlusion query</comment></member>
            <member optional="true" noautovalidity="true"><type>VkQueryPipelineStatisticFlags</type> <name>pipelineStatistics</name><comment>Pipeline statistics that may be counted for this secondary command buffer</comment></member>
        </type>
        <type category="struct" name="VkCommandBufferBeginInfo">
            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkCommandBufferUsageFlags</type>  <name>flags</name><comment>Command buffer usage flags</comment></member>
            <member optional="true" noautovalidity="true">const <type>VkCommandBufferInheritanceInfo</type>*       <name>pInheritanceInfo</name><comment>Pointer to inheritance info for secondary command buffers</comment></member>
        </type>
        <type category="struct" name="VkRenderPassBeginInfo">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkRenderPass</type>           <name>renderPass</name></member>
            <member><type>VkFramebuffer</type>          <name>framebuffer</name></member>
            <member><type>VkRect2D</type>               <name>renderArea</name></member>
            <member optional="true"><type>uint32_t</type>               <name>clearValueCount</name></member>
            <member len="clearValueCount" noautovalidity="true">const <type>VkClearValue</type>*    <name>pClearValues</name></member>
        </type>
        <type category="union" name="VkClearColorValue" comment="// Union allowing specification of floating-point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.">
            <member><type>float</type>                  <name>float32</name>[4]</member>
            <member><type>int32_t</type>                <name>int32</name>[4]</member>
            <member><type>uint32_t</type>               <name>uint32</name>[4]</member>
        </type>
        <type category="struct" name="VkClearDepthStencilValue">
            <member><type>float</type>                  <name>depth</name></member>
            <member><type>uint32_t</type>               <name>stencil</name></member>
        </type>
        <type category="union" name="VkClearValue" comment="// Union allowing specification of color or depth and stencil values. Actual value selected is based on attachment being cleared.">
            <member noautovalidity="true"><type>VkClearColorValue</type>      <name>color</name></member>
            <member><type>VkClearDepthStencilValue</type> <name>depthStencil</name></member>
        </type>
        <type category="struct" name="VkClearAttachment">
            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
            <member><type>uint32_t</type>               <name>colorAttachment</name></member>
            <member noautovalidity="true"><type>VkClearValue</type>           <name>clearValue</name></member>
        </type>
        <type category="struct" name="VkAttachmentDescription">
            <member optional="true"><type>VkAttachmentDescriptionFlags</type> <name>flags</name></member>
            <member><type>VkFormat</type>               <name>format</name></member>
            <member><type>VkSampleCountFlagBits</type>  <name>samples</name></member>
            <member><type>VkAttachmentLoadOp</type>     <name>loadOp</name><comment>Load operation for color or depth data</comment></member>
            <member><type>VkAttachmentStoreOp</type>    <name>storeOp</name><comment>Store operation for color or depth data</comment></member>
            <member><type>VkAttachmentLoadOp</type>     <name>stencilLoadOp</name><comment>Load operation for stencil data</comment></member>
            <member><type>VkAttachmentStoreOp</type>    <name>stencilStoreOp</name><comment>Store operation for stencil data</comment></member>
            <member><type>VkImageLayout</type>          <name>initialLayout</name></member>
            <member><type>VkImageLayout</type>          <name>finalLayout</name></member>
        </type>
        <type category="struct" name="VkAttachmentReference">
            <member><type>uint32_t</type>               <name>attachment</name></member>
            <member><type>VkImageLayout</type>          <name>layout</name></member>
        </type>
        <type category="struct" name="VkSubpassDescription">
            <member optional="true"><type>VkSubpassDescriptionFlags</type> <name>flags</name></member>
            <member><type>VkPipelineBindPoint</type>    <name>pipelineBindPoint</name><comment>Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now</comment></member>
            <member optional="true"><type>uint32_t</type>               <name>inputAttachmentCount</name></member>
            <member len="inputAttachmentCount">const <type>VkAttachmentReference</type>* <name>pInputAttachments</name></member>
            <member optional="true"><type>uint32_t</type>               <name>colorAttachmentCount</name></member>
            <member len="colorAttachmentCount">const <type>VkAttachmentReference</type>* <name>pColorAttachments</name></member>
            <member optional="true" len="colorAttachmentCount">const <type>VkAttachmentReference</type>* <name>pResolveAttachments</name></member>
            <member optional="true">const <type>VkAttachmentReference</type>* <name>pDepthStencilAttachment</name></member>
            <member optional="true"><type>uint32_t</type>               <name>preserveAttachmentCount</name></member>
            <member len="preserveAttachmentCount">const <type>uint32_t</type>* <name>pPreserveAttachments</name></member>
        </type>
        <type category="struct" name="VkSubpassDependency">
            <member><type>uint32_t</type>               <name>srcSubpass</name></member>
            <member><type>uint32_t</type>               <name>dstSubpass</name></member>
            <member optional="true"><type>VkPipelineStageFlags</type>   <name>srcStageMask</name></member>
            <member optional="true"><type>VkPipelineStageFlags</type>   <name>dstStageMask</name></member>
            <member optional="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name><comment>Memory accesses from the source of the dependency to synchronize</comment></member>
            <member optional="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name><comment>Memory accesses from the destination of the dependency to synchronize</comment></member>
            <member optional="true"><type>VkDependencyFlags</type>      <name>dependencyFlags</name></member>
        </type>
        <type category="struct" name="VkRenderPassCreateInfo">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkRenderPassCreateFlags</type> <name>flags</name></member>
            <member optional="true"><type>uint32_t</type>   <name>attachmentCount</name></member>
            <member len="attachmentCount">const <type>VkAttachmentDescription</type>* <name>pAttachments</name></member>
            <member><type>uint32_t</type>               <name>subpassCount</name></member>
            <member len="subpassCount">const <type>VkSubpassDescription</type>* <name>pSubpasses</name></member>
            <member optional="true"><type>uint32_t</type>       <name>dependencyCount</name></member>
            <member len="dependencyCount">const <type>VkSubpassDependency</type>* <name>pDependencies</name></member>
        </type>
        <type category="struct" name="VkEventCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkEventCreateFlags</type>     <name>flags</name><comment>Event creation flags</comment></member>
        </type>
        <type category="struct" name="VkFenceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkFenceCreateFlags</type>     <name>flags</name><comment>Fence creation flags</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFeatures">
            <member><type>VkBool32</type>               <name>robustBufferAccess</name><comment>out of bounds buffer accesses are well defined</comment></member>
            <member><type>VkBool32</type>               <name>fullDrawIndexUint32</name><comment>full 32-bit range of indices for indexed draw calls</comment></member>
            <member><type>VkBool32</type>               <name>imageCubeArray</name><comment>image views which are arrays of cube maps</comment></member>
            <member><type>VkBool32</type>               <name>independentBlend</name><comment>blending operations are controlled per-attachment</comment></member>
            <member><type>VkBool32</type>               <name>geometryShader</name><comment>geometry stage</comment></member>
            <member><type>VkBool32</type>               <name>tessellationShader</name><comment>tessellation control and evaluation stage</comment></member>
            <member><type>VkBool32</type>               <name>sampleRateShading</name><comment>per-sample shading and interpolation</comment></member>
            <member><type>VkBool32</type>               <name>dualSrcBlend</name><comment>blend operations which take two sources</comment></member>
            <member><type>VkBool32</type>               <name>logicOp</name><comment>logic operations</comment></member>
            <member><type>VkBool32</type>               <name>multiDrawIndirect</name><comment>multi draw indirect</comment></member>
            <member><type>VkBool32</type>               <name>drawIndirectFirstInstance</name><comment>indirect drawing can use non-zero firstInstance</comment></member>
            <member><type>VkBool32</type>               <name>depthClamp</name><comment>depth clamping</comment></member>
            <member><type>VkBool32</type>               <name>depthBiasClamp</name><comment>depth bias clamping</comment></member>
            <member><type>VkBool32</type>               <name>fillModeNonSolid</name><comment>point and wireframe fill modes</comment></member>
            <member><type>VkBool32</type>               <name>depthBounds</name><comment>depth bounds test</comment></member>
            <member><type>VkBool32</type>               <name>wideLines</name><comment>lines with width greater than 1</comment></member>
            <member><type>VkBool32</type>               <name>largePoints</name><comment>points with size greater than 1</comment></member>
            <member><type>VkBool32</type>               <name>alphaToOne</name><comment>the fragment alpha component can be forced to maximum representable alpha value</comment></member>
            <member><type>VkBool32</type>               <name>multiViewport</name><comment>viewport arrays</comment></member>
            <member><type>VkBool32</type>               <name>samplerAnisotropy</name><comment>anisotropic sampler filtering</comment></member>
            <member><type>VkBool32</type>               <name>textureCompressionETC2</name><comment>ETC texture compression formats</comment></member>
            <member><type>VkBool32</type>               <name>textureCompressionASTC_LDR</name><comment>ASTC LDR texture compression formats</comment></member>
            <member><type>VkBool32</type>               <name>textureCompressionBC</name><comment>BC1-7 texture compressed formats</comment></member>
            <member><type>VkBool32</type>               <name>occlusionQueryPrecise</name><comment>precise occlusion queries returning actual sample counts</comment></member>
            <member><type>VkBool32</type>               <name>pipelineStatisticsQuery</name><comment>pipeline statistics query</comment></member>
            <member><type>VkBool32</type>               <name>vertexPipelineStoresAndAtomics</name><comment>stores and atomic ops on storage buffers and images are supported in vertex, tessellation, and geometry stages</comment></member>
            <member><type>VkBool32</type>               <name>fragmentStoresAndAtomics</name><comment>stores and atomic ops on storage buffers and images are supported in the fragment stage</comment></member>
            <member><type>VkBool32</type>               <name>shaderTessellationAndGeometryPointSize</name><comment>tessellation and geometry stages can export point size</comment></member>
            <member><type>VkBool32</type>               <name>shaderImageGatherExtended</name><comment>image gather with runtime values and independent offsets</comment></member>
            <member><type>VkBool32</type>               <name>shaderStorageImageExtendedFormats</name><comment>the extended set of formats can be used for storage images</comment></member>
            <member><type>VkBool32</type>               <name>shaderStorageImageMultisample</name><comment>multisample images can be used for storage images</comment></member>
            <member><type>VkBool32</type>               <name>shaderStorageImageReadWithoutFormat</name><comment>read from storage image does not require format qualifier</comment></member>
            <member><type>VkBool32</type>               <name>shaderStorageImageWriteWithoutFormat</name><comment>write to storage image does not require format qualifier</comment></member>
            <member><type>VkBool32</type>               <name>shaderUniformBufferArrayDynamicIndexing</name><comment>arrays of uniform buffers can be accessed with dynamically uniform indices</comment></member>
            <member><type>VkBool32</type>               <name>shaderSampledImageArrayDynamicIndexing</name><comment>arrays of sampled images can be accessed with dynamically uniform indices</comment></member>
            <member><type>VkBool32</type>               <name>shaderStorageBufferArrayDynamicIndexing</name><comment>arrays of storage buffers can be accessed with dynamically uniform indices</comment></member>
            <member><type>VkBool32</type>               <name>shaderStorageImageArrayDynamicIndexing</name><comment>arrays of storage images can be accessed with dynamically uniform indices</comment></member>
            <member><type>VkBool32</type>               <name>shaderClipDistance</name><comment>clip distance in shaders</comment></member>
            <member><type>VkBool32</type>               <name>shaderCullDistance</name><comment>cull distance in shaders</comment></member>
            <member><type>VkBool32</type>               <name>shaderFloat64</name><comment>64-bit floats (doubles) in shaders</comment></member>
            <member><type>VkBool32</type>               <name>shaderInt64</name><comment>64-bit integers in shaders</comment></member>
            <member><type>VkBool32</type>               <name>shaderInt16</name><comment>16-bit integers in shaders</comment></member>
            <member><type>VkBool32</type>               <name>shaderResourceResidency</name><comment>shader can use texture operations that return resource residency information (requires sparseNonResident support)</comment></member>
            <member><type>VkBool32</type>               <name>shaderResourceMinLod</name><comment>shader can use texture operations that specify minimum resource LOD</comment></member>
            <member><type>VkBool32</type>               <name>sparseBinding</name><comment>Sparse resources support: Resource memory can be managed at opaque page level rather than object level</comment></member>
            <member><type>VkBool32</type>               <name>sparseResidencyBuffer</name><comment>Sparse resources support: GPU can access partially resident buffers </comment></member>
            <member><type>VkBool32</type>               <name>sparseResidencyImage2D</name><comment>Sparse resources support: GPU can access partially resident 2D (non-MSAA non-depth/stencil) images </comment></member>
            <member><type>VkBool32</type>               <name>sparseResidencyImage3D</name><comment>Sparse resources support: GPU can access partially resident 3D images </comment></member>
            <member><type>VkBool32</type>               <name>sparseResidency2Samples</name><comment>Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples</comment></member>
            <member><type>VkBool32</type>               <name>sparseResidency4Samples</name><comment>Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples</comment></member>
            <member><type>VkBool32</type>               <name>sparseResidency8Samples</name><comment>Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples</comment></member>
            <member><type>VkBool32</type>               <name>sparseResidency16Samples</name><comment>Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples</comment></member>
            <member><type>VkBool32</type>               <name>sparseResidencyAliased</name><comment>Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in)</comment></member>
            <member><type>VkBool32</type>               <name>variableMultisampleRate</name><comment>multisample rate must be the same for all pipelines in a subpass</comment></member>
            <member><type>VkBool32</type>               <name>inheritedQueries</name><comment>Queries may be inherited from primary to secondary command buffers</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSparseProperties" returnedonly="true" requiredlimittype="true">
            <member limittype="max"><type>VkBool32</type>             <name>residencyStandard2DBlockShape</name><comment>Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard sparse image block shapes (based on pixel format)</comment></member>
            <member limittype="max"><type>VkBool32</type>             <name>residencyStandard2DMultisampleBlockShape</name><comment>Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard sparse image block shapes (based on pixel format)</comment></member>
            <member limittype="max"><type>VkBool32</type>             <name>residencyStandard3DBlockShape</name><comment>Sparse resources support: GPU will access all 3D sparse resources using the standard sparse image block shapes (based on pixel format)</comment></member>
            <member limittype="min"><type>VkBool32</type>             <name>residencyAlignedMipSize</name><comment>Sparse resources support: Images with mip level dimensions that are NOT a multiple of the sparse image block dimensions will be placed in the mip tail</comment></member>
            <member limittype="max"><type>VkBool32</type>             <name>residencyNonResidentStrict</name><comment>Sparse resources support: GPU can consistently access non-resident regions of a resource, all reads return as if data is 0, writes are discarded</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceLimits" returnedonly="true" requiredlimittype="true">
                <comment>resource maximum sizes</comment>
            <member limittype="max"><type>uint32_t</type>               <name>maxImageDimension1D</name><comment>max 1D image dimension</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxImageDimension2D</name><comment>max 2D image dimension</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxImageDimension3D</name><comment>max 3D image dimension</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxImageDimensionCube</name><comment>max cube map image dimension</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxImageArrayLayers</name><comment>max layers for image arrays</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxTexelBufferElements</name><comment>max texel buffer size (fstexels)</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxUniformBufferRange</name><comment>max uniform buffer range (bytes)</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxStorageBufferRange</name><comment>max storage buffer range (bytes)</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxPushConstantsSize</name><comment>max size of the push constants pool (bytes)</comment></member>
                <comment>memory limits</comment>
            <member limittype="max"><type>uint32_t</type>               <name>maxMemoryAllocationCount</name><comment>max number of device memory allocations supported</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxSamplerAllocationCount</name><comment>max number of samplers that can be allocated on a device</comment></member>
            <member limittype="min,mul"><type>VkDeviceSize</type>           <name>bufferImageGranularity</name><comment>Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage</comment></member>
            <member limittype="max"><type>VkDeviceSize</type>           <name>sparseAddressSpaceSize</name><comment>Total address space available for sparse allocations (bytes)</comment></member>
                <comment>descriptor set limits</comment>
            <member limittype="max"><type>uint32_t</type>               <name>maxBoundDescriptorSets</name><comment>max number of descriptors sets that can be bound to a pipeline</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorSamplers</name><comment>max number of samplers allowed per-stage in a descriptor set</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUniformBuffers</name><comment>max number of uniform buffers allowed per-stage in a descriptor set</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorStorageBuffers</name><comment>max number of storage buffers allowed per-stage in a descriptor set</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorSampledImages</name><comment>max number of sampled images allowed per-stage in a descriptor set</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorStorageImages</name><comment>max number of storage images allowed per-stage in a descriptor set</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorInputAttachments</name><comment>max number of input attachments allowed per-stage in a descriptor set</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageResources</name><comment>max number of resources allowed by a single stage</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetSamplers</name><comment>max number of samplers allowed in all stages in a descriptor set</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUniformBuffers</name><comment>max number of uniform buffers allowed in all stages in a descriptor set</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUniformBuffersDynamic</name><comment>max number of dynamic uniform buffers allowed in all stages in a descriptor set</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetStorageBuffers</name><comment>max number of storage buffers allowed in all stages in a descriptor set</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetStorageBuffersDynamic</name><comment>max number of dynamic storage buffers allowed in all stages in a descriptor set</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetSampledImages</name><comment>max number of sampled images allowed in all stages in a descriptor set</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetStorageImages</name><comment>max number of storage images allowed in all stages in a descriptor set</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetInputAttachments</name><comment>max number of input attachments allowed in all stages in a descriptor set</comment></member>
                <comment>vertex stage limits</comment>
            <member limittype="max"><type>uint32_t</type>               <name>maxVertexInputAttributes</name><comment>max number of vertex input attribute slots</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxVertexInputBindings</name><comment>max number of vertex input binding slots</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxVertexInputAttributeOffset</name><comment>max vertex input attribute offset added to vertex buffer offset</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxVertexInputBindingStride</name><comment>max vertex input binding stride</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxVertexOutputComponents</name><comment>max number of output components written by vertex shader</comment></member>
                <comment>tessellation control stage limits</comment>
            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationGenerationLevel</name><comment>max level supported by tessellation primitive generator</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationPatchSize</name><comment>max patch size (vertices)</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationControlPerVertexInputComponents</name><comment>max number of input components per-vertex in TCS</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationControlPerVertexOutputComponents</name><comment>max number of output components per-vertex in TCS</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationControlPerPatchOutputComponents</name><comment>max number of output components per-patch in TCS</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationControlTotalOutputComponents</name><comment>max total number of per-vertex and per-patch output components in TCS</comment></member>
                <comment>tessellation evaluation stage limits</comment>
            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationEvaluationInputComponents</name><comment>max number of input components per vertex in TES</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationEvaluationOutputComponents</name><comment>max number of output components per vertex in TES</comment></member>
                <comment>geometry stage limits</comment>
            <member limittype="max"><type>uint32_t</type>               <name>maxGeometryShaderInvocations</name><comment>max invocation count supported in geometry shader</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxGeometryInputComponents</name><comment>max number of input components read in geometry stage</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxGeometryOutputComponents</name><comment>max number of output components written in geometry stage</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxGeometryOutputVertices</name><comment>max number of vertices that can be emitted in geometry stage</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxGeometryTotalOutputComponents</name><comment>max total number of components (all vertices) written in geometry stage</comment></member>
                <comment>fragment stage limits</comment>
            <member limittype="max"><type>uint32_t</type>               <name>maxFragmentInputComponents</name><comment>max number of input components read in fragment stage</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxFragmentOutputAttachments</name><comment>max number of output attachments written in fragment stage</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxFragmentDualSrcAttachments</name><comment>max number of output attachments written when using dual source blending</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxFragmentCombinedOutputResources</name><comment>max total number of storage buffers, storage images and output buffers</comment></member>
                <comment>compute stage limits</comment>
            <member limittype="max"><type>uint32_t</type>               <name>maxComputeSharedMemorySize</name><comment>max total storage size of work group local storage (bytes)</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxComputeWorkGroupCount</name>[3]<comment>max num of compute work groups that may be dispatched by a single command (x,y,z)</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxComputeWorkGroupInvocations</name><comment>max total compute invocations in a single local work group</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxComputeWorkGroupSize</name>[3]<comment>max local size of a compute work group (x,y,z)</comment></member>
            <member limittype="bits"><type>uint32_t</type>              <name>subPixelPrecisionBits</name><comment>number bits of subpixel precision in screen x and y</comment></member>
            <member limittype="bits"><type>uint32_t</type>              <name>subTexelPrecisionBits</name><comment>number bits of precision for selecting texel weights</comment></member>
            <member limittype="bits"><type>uint32_t</type>              <name>mipmapPrecisionBits</name><comment>number bits of precision for selecting mipmap weights</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDrawIndexedIndexValue</name><comment>max index value for indexed draw calls (for 32-bit indices)</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDrawIndirectCount</name><comment>max draw count for indirect drawing calls</comment></member>
            <member limittype="max"><type>float</type>                  <name>maxSamplerLodBias</name><comment>max absolute sampler LOD bias</comment></member>
            <member limittype="max"><type>float</type>                  <name>maxSamplerAnisotropy</name><comment>max degree of sampler anisotropy</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxViewports</name><comment>max number of active viewports</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxViewportDimensions</name>[2]<comment>max viewport dimensions (x,y)</comment></member>
            <member limittype="range"><type>float</type>                <name>viewportBoundsRange</name>[2]<comment>viewport bounds range (min,max)</comment></member>
            <member limittype="bits"><type>uint32_t</type>              <name>viewportSubPixelBits</name><comment>number bits of subpixel precision for viewport</comment></member>
            <member limittype="max,pot"><type>size_t</type>             <name>minMemoryMapAlignment</name><comment>min required alignment of pointers returned by MapMemory (bytes)</comment></member>
            <member limittype="min,pot"><type>VkDeviceSize</type>       <name>minTexelBufferOffsetAlignment</name><comment>min required alignment for texel buffer offsets (bytes) </comment></member>
            <member limittype="min,pot"><type>VkDeviceSize</type>       <name>minUniformBufferOffsetAlignment</name><comment>min required alignment for uniform buffer sizes and offsets (bytes)</comment></member>
            <member limittype="min,pot"><type>VkDeviceSize</type>       <name>minStorageBufferOffsetAlignment</name><comment>min required alignment for storage buffer offsets (bytes)</comment></member>
            <member limittype="min"><type>int32_t</type>                <name>minTexelOffset</name><comment>min texel offset for OpTextureSampleOffset</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxTexelOffset</name><comment>max texel offset for OpTextureSampleOffset</comment></member>
            <member limittype="min"><type>int32_t</type>                <name>minTexelGatherOffset</name><comment>min texel offset for OpTextureGatherOffset</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxTexelGatherOffset</name><comment>max texel offset for OpTextureGatherOffset</comment></member>
            <member limittype="min"><type>float</type>                  <name>minInterpolationOffset</name><comment>furthest negative offset for interpolateAtOffset</comment></member>
            <member limittype="max"><type>float</type>                  <name>maxInterpolationOffset</name><comment>furthest positive offset for interpolateAtOffset</comment></member>
            <member limittype="bits"><type>uint32_t</type>              <name>subPixelInterpolationOffsetBits</name><comment>number of subpixel bits for interpolateAtOffset</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxFramebufferWidth</name><comment>max width for a framebuffer</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxFramebufferHeight</name><comment>max height for a framebuffer</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxFramebufferLayers</name><comment>max layer count for a layered framebuffer</comment></member>
            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>framebufferColorSampleCounts</name><comment>supported color sample counts for a framebuffer</comment></member>
            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>framebufferDepthSampleCounts</name><comment>supported depth sample counts for a framebuffer</comment></member>
            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>framebufferStencilSampleCounts</name><comment>supported stencil sample counts for a framebuffer</comment></member>
            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>framebufferNoAttachmentsSampleCounts</name><comment>supported sample counts for a subpass which uses no attachments</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxColorAttachments</name><comment>max number of color attachments per subpass</comment></member>
            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageColorSampleCounts</name><comment>supported color sample counts for a non-integer sampled image</comment></member>
            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageIntegerSampleCounts</name><comment>supported sample counts for an integer image</comment></member>
            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageDepthSampleCounts</name><comment>supported depth sample counts for a sampled image</comment></member>
            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageStencilSampleCounts</name><comment>supported stencil sample counts for a sampled image</comment></member>
            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>storageImageSampleCounts</name><comment>supported sample counts for a storage image</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxSampleMaskWords</name><comment>max number of sample mask words</comment></member>
            <member limittype="max"><type>VkBool32</type>               <name>timestampComputeAndGraphics</name><comment>timestamps on graphics and compute queues</comment></member>
            <member limittype="min,mul"><type>float</type>              <name>timestampPeriod</name><comment>number of nanoseconds it takes for timestamp query value to increment by 1</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxClipDistances</name><comment>max number of clip distances</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxCullDistances</name><comment>max number of cull distances</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxCombinedClipAndCullDistances</name><comment>max combined number of user clipping</comment></member>
            <member limittype="max"><type>uint32_t</type>               <name>discreteQueuePriorities</name><comment>distinct queue priorities available </comment></member>
            <member limittype="range"><type>float</type>                <name>pointSizeRange</name>[2]<comment>range (min,max) of supported point sizes</comment></member>
            <member limittype="range"><type>float</type>                <name>lineWidthRange</name>[2]<comment>range (min,max) of supported line widths</comment></member>
            <member limittype="min,mul"><type>float</type>              <name>pointSizeGranularity</name><comment>granularity of supported point sizes</comment></member>
            <member limittype="min,mul"><type>float</type>              <name>lineWidthGranularity</name><comment>granularity of supported line widths</comment></member>
            <member limittype="max"><type>VkBool32</type>               <name>strictLines</name><comment>line rasterization follows preferred rules</comment></member>
            <member limittype="max"><type>VkBool32</type>               <name>standardSampleLocations</name><comment>supports standard sample locations for all supported sample counts</comment></member>
            <member limittype="min,pot"><type>VkDeviceSize</type>       <name>optimalBufferCopyOffsetAlignment</name><comment>optimal offset of buffer copies</comment></member>
            <member limittype="min,pot"><type>VkDeviceSize</type>       <name>optimalBufferCopyRowPitchAlignment</name><comment>optimal pitch of buffer copies</comment></member>
            <member limittype="min,pot"><type>VkDeviceSize</type>       <name>nonCoherentAtomSize</name><comment>minimum size and alignment for non-coherent host-mapped device memory access</comment></member>
        </type>
        <type category="struct" name="VkSemaphoreCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkSemaphoreCreateFlags</type> <name>flags</name><comment>Semaphore creation flags</comment></member>
        </type>
        <type category="struct" name="VkQueryPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkQueryPoolCreateFlags</type> <name>flags</name></member>
            <member><type>VkQueryType</type>            <name>queryType</name></member>
            <member><type>uint32_t</type>               <name>queryCount</name></member>
            <member optional="true" noautovalidity="true"><type>VkQueryPipelineStatisticFlags</type> <name>pipelineStatistics</name><comment>Optional</comment></member>
        </type>
        <type category="struct" name="VkFramebufferCreateInfo">
            <member values="VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkFramebufferCreateFlags</type>    <name>flags</name></member>
            <member><type>VkRenderPass</type>                           <name>renderPass</name></member>
            <member optional="true"><type>uint32_t</type>               <name>attachmentCount</name></member>
            <member noautovalidity="true" len="attachmentCount">const <type>VkImageView</type>*     <name>pAttachments</name></member>
            <member><type>uint32_t</type>               <name>width</name></member>
            <member><type>uint32_t</type>               <name>height</name></member>
            <member><type>uint32_t</type>               <name>layers</name></member>
        </type>
        <type category="struct" name="VkDrawIndirectCommand">
            <member><type>uint32_t</type>                       <name>vertexCount</name></member>
            <member><type>uint32_t</type>                       <name>instanceCount</name></member>
            <member><type>uint32_t</type>                       <name>firstVertex</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>firstInstance</name></member>
        </type>
        <type category="struct" name="VkDrawIndexedIndirectCommand">
            <member><type>uint32_t</type>                       <name>indexCount</name></member>
            <member><type>uint32_t</type>                       <name>instanceCount</name></member>
            <member><type>uint32_t</type>                       <name>firstIndex</name></member>
            <member><type>int32_t</type>                        <name>vertexOffset</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>firstInstance</name></member>
        </type>
        <type category="struct" name="VkDispatchIndirectCommand">
            <member noautovalidity="true"><type>uint32_t</type> <name>x</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>y</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>z</name></member>
        </type>
        <type category="struct" name="VkMultiDrawInfoEXT">
            <member><type>uint32_t</type> <name>firstVertex</name></member>
            <member><type>uint32_t</type> <name>vertexCount</name></member>
        </type>
        <type category="struct" name="VkMultiDrawIndexedInfoEXT">
            <member><type>uint32_t</type> <name>firstIndex</name></member>
            <member><type>uint32_t</type> <name>indexCount</name></member>
            <member><type>int32_t</type> <name>vertexOffset</name></member>
        </type>
        <type category="struct" name="VkSubmitInfo">
            <member values="VK_STRUCTURE_TYPE_SUBMIT_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>       <name>waitSemaphoreCount</name></member>
            <member len="waitSemaphoreCount">const <type>VkSemaphore</type>*     <name>pWaitSemaphores</name></member>
            <member optional="false,true" len="waitSemaphoreCount">const <type>VkPipelineStageFlags</type>*           <name>pWaitDstStageMask</name></member>
            <member optional="true"><type>uint32_t</type>       <name>commandBufferCount</name></member>
            <member len="commandBufferCount">const <type>VkCommandBuffer</type>*     <name>pCommandBuffers</name></member>
            <member optional="true"><type>uint32_t</type>       <name>signalSemaphoreCount</name></member>
            <member len="signalSemaphoreCount">const <type>VkSemaphore</type>*     <name>pSignalSemaphores</name></member>
        </type>
            <comment>WSI extensions</comment>
        <type category="struct" name="VkDisplayPropertiesKHR" returnedonly="true">
            <member><type>VkDisplayKHR</type>                     <name>display</name><comment>Handle of the display object</comment></member>
            <member len="null-terminated">const <type>char</type>*                      <name>displayName</name><comment>Name of the display</comment></member>
            <member><type>VkExtent2D</type>                       <name>physicalDimensions</name><comment>In millimeters?</comment></member>
            <member><type>VkExtent2D</type>                       <name>physicalResolution</name><comment>Max resolution for CRT?</comment></member>
            <member optional="true"><type>VkSurfaceTransformFlagsKHR</type>       <name>supportedTransforms</name><comment>one or more bits from VkSurfaceTransformFlagsKHR</comment></member>
            <member><type>VkBool32</type>                         <name>planeReorderPossible</name><comment>VK_TRUE if the overlay plane's z-order can be changed on this display.</comment></member>
            <member><type>VkBool32</type>                         <name>persistentContent</name><comment>VK_TRUE if this is a "smart" display that supports self-refresh/internal buffering.</comment></member>
        </type>
        <type category="struct" name="VkDisplayPlanePropertiesKHR" returnedonly="true">
            <member><type>VkDisplayKHR</type>                     <name>currentDisplay</name><comment>Display the plane is currently associated with.  Will be VK_NULL_HANDLE if the plane is not in use.</comment></member>
            <member><type>uint32_t</type>                         <name>currentStackIndex</name><comment>Current z-order of the plane.</comment></member>
        </type>
        <type category="struct" name="VkDisplayModeParametersKHR">
            <member><type>VkExtent2D</type>                       <name>visibleRegion</name><comment>Visible scanout region.</comment></member>
            <member noautovalidity="true"><type>uint32_t</type>   <name>refreshRate</name><comment>Number of times per second the display is updated.</comment></member>
        </type>
        <type category="struct" name="VkDisplayModePropertiesKHR" returnedonly="true">
            <member><type>VkDisplayModeKHR</type>                 <name>displayMode</name><comment>Handle of this display mode.</comment></member>
            <member><type>VkDisplayModeParametersKHR</type>       <name>parameters</name><comment>The parameters this mode uses.</comment></member>
        </type>
        <type category="struct" name="VkDisplayModeCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkDisplayModeCreateFlagsKHR</type>      <name>flags</name></member>
            <member><type>VkDisplayModeParametersKHR</type>       <name>parameters</name><comment>The parameters this mode uses.</comment></member>
        </type>
        <type category="struct" name="VkDisplayPlaneCapabilitiesKHR" returnedonly="true">
            <member optional="true"><type>VkDisplayPlaneAlphaFlagsKHR</type>      <name>supportedAlpha</name><comment>Types of alpha blending supported, if any.</comment></member>
            <member><type>VkOffset2D</type>                       <name>minSrcPosition</name><comment>Does the plane have any position and extent restrictions?</comment></member>
            <member><type>VkOffset2D</type>                       <name>maxSrcPosition</name></member>
            <member><type>VkExtent2D</type>                       <name>minSrcExtent</name></member>
            <member><type>VkExtent2D</type>                       <name>maxSrcExtent</name></member>
            <member><type>VkOffset2D</type>                       <name>minDstPosition</name></member>
            <member><type>VkOffset2D</type>                       <name>maxDstPosition</name></member>
            <member><type>VkExtent2D</type>                       <name>minDstExtent</name></member>
            <member><type>VkExtent2D</type>                       <name>maxDstExtent</name></member>
        </type>
        <type category="struct" name="VkDisplaySurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkDisplaySurfaceCreateFlagsKHR</type>   <name>flags</name></member>
            <member><type>VkDisplayModeKHR</type>                 <name>displayMode</name><comment>The mode to use when displaying this surface</comment></member>
            <member><type>uint32_t</type>                         <name>planeIndex</name><comment>The plane on which this surface appears.  Must be between 0 and the value returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pPropertyCount.</comment></member>
            <member><type>uint32_t</type>                         <name>planeStackIndex</name><comment>The z-order of the plane.</comment></member>
            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>transform</name><comment>Transform to apply to the images as part of the scanout operation</comment></member>
            <member><type>float</type>                            <name>globalAlpha</name><comment>Global alpha value.  Must be between 0 and 1, inclusive.  Ignored if alphaMode is not VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR</comment></member>
            <member><type>VkDisplayPlaneAlphaFlagBitsKHR</type>   <name>alphaMode</name><comment>The type of alpha blending to use. Must be one of the bits from VkDisplayPlaneCapabilitiesKHR::supportedAlpha for this display plane</comment></member>
            <member><type>VkExtent2D</type>                       <name>imageExtent</name><comment>size of the images to use with this surface</comment></member>
        </type>
        <type category="struct" name="VkDisplaySurfaceStereoCreateInfoNV" structextends="VkDisplaySurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
            <member><type>VkDisplaySurfaceStereoTypeNV</type>     <name>stereoType</name><comment>The 3D stereo type to use when presenting this surface.</comment></member>
        </type>
        <type category="struct" name="VkDisplayPresentInfoKHR" structextends="VkPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkRect2D</type>                         <name>srcRect</name><comment>Rectangle within the presentable image to read pixel data from when presenting to the display.</comment></member>
            <member><type>VkRect2D</type>                         <name>dstRect</name><comment>Rectangle within the current display mode's visible region to display srcRectangle in.</comment></member>
            <member><type>VkBool32</type>                         <name>persistent</name><comment>For smart displays, use buffered mode.  If the display properties member "persistentMode" is VK_FALSE, this member must always be VK_FALSE.</comment></member>
        </type>
        <type category="struct" name="VkSurfaceCapabilitiesKHR" returnedonly="true">
            <member><type>uint32_t</type>                         <name>minImageCount</name><comment>Supported minimum number of images for the surface</comment></member>
            <member><type>uint32_t</type>                         <name>maxImageCount</name><comment>Supported maximum number of images for the surface, 0 for unlimited</comment></member>
            <member><type>VkExtent2D</type>                       <name>currentExtent</name><comment>Current image width and height for the surface, (0, 0) if undefined</comment></member>
            <member><type>VkExtent2D</type>                       <name>minImageExtent</name><comment>Supported minimum image width and height for the surface</comment></member>
            <member><type>VkExtent2D</type>                       <name>maxImageExtent</name><comment>Supported maximum image width and height for the surface</comment></member>
            <member><type>uint32_t</type>                         <name>maxImageArrayLayers</name><comment>Supported maximum number of image layers for the surface</comment></member>
            <member><type>VkSurfaceTransformFlagsKHR</type>       <name>supportedTransforms</name><comment>1 or more bits representing the transforms supported</comment></member>
            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>currentTransform</name><comment>The surface's current transform relative to the device's natural orientation</comment></member>
            <member><type>VkCompositeAlphaFlagsKHR</type>         <name>supportedCompositeAlpha</name><comment>1 or more bits representing the alpha compositing modes supported</comment></member>
            <member><type>VkImageUsageFlags</type>                <name>supportedUsageFlags</name><comment>Supported image usage flags for the surface</comment></member>
        </type>
        <type category="struct" name="VkAndroidSurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
            <member optional="true"><type>VkAndroidSurfaceCreateFlagsKHR</type> <name>flags</name></member>
            <member noautovalidity="true">struct <type>ANativeWindow</type>*    <name>window</name></member>
        </type>
        <type category="struct" name="VkViSurfaceCreateInfoNN">
            <member values="VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkViSurfaceCreateFlagsNN</type>   <name>flags</name></member>
            <member noautovalidity="true"><type>void</type>*                            <name>window</name></member>
        </type>
        <type category="struct" name="VkWaylandSurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkWaylandSurfaceCreateFlagsKHR</type>   <name>flags</name></member>
            <member noautovalidity="true">struct <type>wl_display</type>*               <name>display</name></member>
            <member noautovalidity="true">struct <type>wl_surface</type>*               <name>surface</name></member>
        </type>
        <type category="struct" name="VkWin32SurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkWin32SurfaceCreateFlagsKHR</type>   <name>flags</name></member>
            <member><type>HINSTANCE</type>                        <name>hinstance</name></member>
            <member><type>HWND</type>                             <name>hwnd</name></member>
        </type>
        <type category="struct" name="VkXlibSurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkXlibSurfaceCreateFlagsKHR</type>   <name>flags</name></member>
            <member noautovalidity="true"><type>Display</type>*                         <name>dpy</name></member>
            <member><type>Window</type>                           <name>window</name></member>
        </type>
        <type category="struct" name="VkXcbSurfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkXcbSurfaceCreateFlagsKHR</type>   <name>flags</name></member>
            <member noautovalidity="true"><type>xcb_connection_t</type>*                <name>connection</name></member>
            <member><type>xcb_window_t</type>                     <name>window</name></member>
        </type>
        <type category="struct" name="VkDirectFBSurfaceCreateInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkDirectFBSurfaceCreateFlagsEXT</type>   <name>flags</name></member>
            <member noautovalidity="true"><type>IDirectFB</type>*                       <name>dfb</name></member>
            <member noautovalidity="true"><type>IDirectFBSurface</type>*                <name>surface</name></member>
        </type>
        <type category="struct" name="VkImagePipeSurfaceCreateInfoFUCHSIA">
            <member values="VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkImagePipeSurfaceCreateFlagsFUCHSIA</type>   <name>flags</name></member>
            <member><type>zx_handle_t</type>                      <name>imagePipeHandle</name></member>
        </type>
        <type category="struct" name="VkStreamDescriptorSurfaceCreateInfoGGP">
            <member values="VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkStreamDescriptorSurfaceCreateFlagsGGP</type> <name>flags</name></member>
            <member><type>GgpStreamDescriptor</type>              <name>streamDescriptor</name></member>
        </type>
        <type category="struct" name="VkScreenSurfaceCreateInfoQNX">
            <member values="VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkScreenSurfaceCreateFlagsQNX</type>    <name>flags</name></member>
            <member noautovalidity="true">struct <type>_screen_context</type>*    <name>context</name></member>
            <member noautovalidity="true">struct <type>_screen_window</type>*     <name>window</name></member>
        </type>
        <type category="struct" name="VkSurfaceFormatKHR" returnedonly="true">
            <member><type>VkFormat</type>                         <name>format</name><comment>Supported pair of rendering format</comment></member>
            <member><type>VkColorSpaceKHR</type>                  <name>colorSpace</name><comment>and color space for the surface</comment></member>
        </type>
        <type category="struct" name="VkSwapchainCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkSwapchainCreateFlagsKHR</type>        <name>flags</name></member>
            <member externsync="true"><type>VkSurfaceKHR</type>                     <name>surface</name><comment>The swapchain's target surface</comment></member>
            <member><type>uint32_t</type>                         <name>minImageCount</name><comment>Minimum number of presentation images the application needs</comment></member>
            <member><type>VkFormat</type>                         <name>imageFormat</name><comment>Format of the presentation images</comment></member>
            <member><type>VkColorSpaceKHR</type>                  <name>imageColorSpace</name><comment>Colorspace of the presentation images</comment></member>
            <member><type>VkExtent2D</type>                       <name>imageExtent</name><comment>Dimensions of the presentation images</comment></member>
            <member><type>uint32_t</type>                         <name>imageArrayLayers</name><comment>Determines the number of views for multiview/stereo presentation</comment></member>
            <member><type>VkImageUsageFlags</type>                <name>imageUsage</name><comment>Bits indicating how the presentation images will be used</comment></member>
            <member><type>VkSharingMode</type>                    <name>imageSharingMode</name><comment>Sharing mode used for the presentation images</comment></member>
            <member optional="true"><type>uint32_t</type>         <name>queueFamilyIndexCount</name><comment>Number of queue families having access to the images in case of concurrent sharing mode</comment></member>
            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>*                  <name>pQueueFamilyIndices</name><comment>Array of queue family indices having access to the images in case of concurrent sharing mode</comment></member>
            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>preTransform</name><comment>The transform, relative to the device's natural orientation, applied to the image content prior to presentation</comment></member>
            <member><type>VkCompositeAlphaFlagBitsKHR</type>      <name>compositeAlpha</name><comment>The alpha blending mode used when compositing this surface with other surfaces in the window system</comment></member>
            <member><type>VkPresentModeKHR</type>                 <name>presentMode</name><comment>Which presentation mode to use for presents on this swap chain</comment></member>
            <member><type>VkBool32</type>                         <name>clipped</name><comment>Specifies whether presentable images may be affected by window clip regions</comment></member>
            <member api="vulkan,vulkanbase" optional="true" externsync="true"><type>VkSwapchainKHR</type>       <name>oldSwapchain</name><comment>Existing swap chain to replace, if any</comment></member>
            <member api="vulkansc" noautovalidity="true" optional="true"><type>VkSwapchainKHR</type> <name>oldSwapchain</name><comment>Existing swap chain to replace, if any</comment></member>
        </type>
        <type category="struct" name="VkPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*  <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>         <name>waitSemaphoreCount</name><comment>Number of semaphores to wait for before presenting</comment></member>
            <member len="waitSemaphoreCount" externsync="true">const <type>VkSemaphore</type>* <name>pWaitSemaphores</name><comment>Semaphores to wait for before presenting</comment></member>
            <member><type>uint32_t</type>                         <name>swapchainCount</name><comment>Number of swapchains to present in this call</comment></member>
            <member len="swapchainCount" externsync="true">const <type>VkSwapchainKHR</type>* <name>pSwapchains</name><comment>Swapchains to present an image from</comment></member>
            <member len="swapchainCount">const <type>uint32_t</type>* <name>pImageIndices</name><comment>Indices of which presentable images to present</comment></member>
            <member optional="true" len="swapchainCount"><type>VkResult</type>* <name>pResults</name><comment>Optional (i.e. if non-NULL) VkResult for each swapchain</comment></member>
        </type>
        <type category="struct" name="VkDebugReportCallbackCreateInfoEXT" structextends="VkInstanceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkDebugReportFlagsEXT</type>            <name>flags</name><comment>Indicates which events call this callback</comment></member>
            <member><type>PFN_vkDebugReportCallbackEXT</type>     <name>pfnCallback</name><comment>Function pointer of a callback function</comment></member>
            <member optional="true"><type>void</type>*            <name>pUserData</name><comment>Data provided to callback function</comment></member>
        </type>
        <type category="struct" name="VkValidationFlagsEXT" structextends="VkInstanceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT"><type>VkStructureType</type>                  <name>sType</name><comment>Must be VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT</comment></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>disabledValidationCheckCount</name><comment>Number of validation checks to disable</comment></member>
            <member len="disabledValidationCheckCount">const <type>VkValidationCheckEXT</type>* <name>pDisabledValidationChecks</name><comment>Validation checks to disable</comment></member>
        </type>
        <type category="struct" name="VkValidationFeaturesEXT" structextends="VkInstanceCreateInfo,VkShaderModuleCreateInfo,VkShaderCreateInfoEXT">
            <member values="VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT"><type>VkStructureType</type>  <name>sType</name><comment>Must be VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT</comment></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                         <name>enabledValidationFeatureCount</name><comment>Number of validation features to enable</comment></member>
            <member len="enabledValidationFeatureCount">const <type>VkValidationFeatureEnableEXT</type>* <name>pEnabledValidationFeatures</name><comment>Validation features to enable</comment></member>
            <member optional="true"><type>uint32_t</type>                         <name>disabledValidationFeatureCount</name><comment>Number of validation features to disable</comment></member>
            <member len="disabledValidationFeatureCount">const <type>VkValidationFeatureDisableEXT</type>* <name>pDisabledValidationFeatures</name><comment>Validation features to disable</comment></member>
        </type>
        <type category="struct" name="VkLayerSettingsCreateInfoEXT" allowduplicate="true" structextends="VkInstanceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT"><type>VkStructureType</type>  <name>sType</name><comment>Must be VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT</comment></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                         <name>settingCount</name><comment>Number of settings to configure</comment></member>
            <member len="settingCount">const <type>VkLayerSettingEXT</type>* <name>pSettings</name><comment>Validation features to enable</comment></member>
        </type>
        <type category="struct" name="VkLayerSettingEXT">
            <member len="null-terminated">const <type>char</type>* <name>pLayerName</name></member>
            <member len="null-terminated">const <type>char</type>* <name>pSettingName</name></member>
            <member><type>VkLayerSettingTypeEXT</type>       <name>type</name><comment>The type of the object</comment></member>
            <member optional="true"><type>uint32_t</type>                         <name>valueCount</name><comment>Number of values of the setting</comment></member>
            <member noautovalidity="true" len="valueCount">const <type>void</type>* <name>pValues</name><comment>Values to pass for a setting</comment></member>
        </type>
        <type category="struct" name="VkApplicationParametersEXT" allowduplicate="true" structextends="VkApplicationInfo,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
            <member><type>uint32_t</type>                           <name>vendorID</name></member>
            <member optional="true"><type>uint32_t</type>           <name>deviceID</name></member>
            <member><type>uint32_t</type>                           <name>key</name></member>
            <member><type>uint64_t</type>                           <name>value</name></member>
        </type>
        <type category="struct" name="VkPipelineRasterizationStateRasterizationOrderAMD" structextends="VkPipelineRasterizationStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkRasterizationOrderAMD</type>          <name>rasterizationOrder</name><comment>Rasterization order to use for the pipeline</comment></member>
        </type>
        <type category="struct" name="VkDebugMarkerObjectNameInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDebugReportObjectTypeEXT</type>       <name>objectType</name><comment>The type of the object</comment></member>
            <member objecttype="objectType" externsync="true"><type>uint64_t</type>                         <name>object</name><comment>The handle of the object, cast to uint64_t</comment></member>
            <member len="null-terminated">const <type>char</type>* <name>pObjectName</name><comment>Name to apply to the object</comment></member>
        </type>
        <type category="struct" name="VkDebugMarkerObjectTagInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDebugReportObjectTypeEXT</type>       <name>objectType</name><comment>The type of the object</comment></member>
            <member objecttype="objectType" externsync="true"><type>uint64_t</type>                         <name>object</name><comment>The handle of the object, cast to uint64_t</comment></member>
            <member><type>uint64_t</type>                         <name>tagName</name><comment>The name of the tag to set on the object</comment></member>
            <member><type>size_t</type>                           <name>tagSize</name><comment>The length in bytes of the tag data</comment></member>
            <member len="tagSize">const <type>void</type>*        <name>pTag</name><comment>Tag data to attach to the object</comment></member>
        </type>
        <type category="struct" name="VkDebugMarkerMarkerInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member len="null-terminated">const <type>char</type>* <name>pMarkerName</name><comment>Name of the debug marker</comment></member>
            <member><type>float</type>            <name>color</name>[4]<comment>Optional color for debug marker</comment></member>
        </type>
        <type category="struct" name="VkDedicatedAllocationImageCreateInfoNV" structextends="VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>dedicatedAllocation</name><comment>Whether this image uses a dedicated allocation</comment></member>
        </type>
        <type category="struct" name="VkDedicatedAllocationBufferCreateInfoNV" structextends="VkBufferCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>dedicatedAllocation</name><comment>Whether this buffer uses a dedicated allocation</comment></member>
        </type>
        <type category="struct" name="VkDedicatedAllocationMemoryAllocateInfoNV" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkImage</type>          <name>image</name><comment>Image that this allocation will be bound to</comment></member>
            <member optional="true"><type>VkBuffer</type>         <name>buffer</name><comment>Buffer that this allocation will be bound to</comment></member>
        </type>
        <type category="struct" name="VkExternalImageFormatPropertiesNV" returnedonly="true">
            <member><type>VkImageFormatProperties</type>          <name>imageFormatProperties</name></member>
            <member optional="true"><type>VkExternalMemoryFeatureFlagsNV</type>   <name>externalMemoryFeatures</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>exportFromImportedHandleTypes</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>compatibleHandleTypes</name></member>
        </type>
        <type category="struct" name="VkExternalMemoryImageCreateInfoNV" structextends="VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleTypes</name></member>
        </type>
        <type category="struct" name="VkExportMemoryAllocateInfoNV" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleTypes</name></member>
        </type>
        <type category="struct" name="VkImportMemoryWin32HandleInfoNV" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleType</name></member>
            <member optional="true"><type>HANDLE</type>                           <name>handle</name></member>
        </type>
        <type category="struct" name="VkExportMemoryWin32HandleInfoNV" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true">const <type>SECURITY_ATTRIBUTES</type>*       <name>pAttributes</name></member>
            <member optional="true"><type>DWORD</type>                            <name>dwAccess</name></member>
        </type>
        <type category="struct" name="VkExportMemorySciBufInfoNV" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                 <name>pNext</name></member>
            <member><type>NvSciBufAttrList</type>                            <name>pAttributes</name></member>
        </type>
        <type category="struct" name="VkImportMemorySciBufInfoNV" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkExternalMemoryHandleTypeFlagBits</type>     <name>handleType</name></member>
            <member><type>NvSciBufObj</type>                            <name>handle</name></member>
        </type>
        <type category="struct" name="VkMemoryGetSciBufInfoNV">
            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkDeviceMemory</type>                         <name>memory</name></member>
            <member><type>VkExternalMemoryHandleTypeFlagBits</type>     <name>handleType</name></member>
        </type>
        <type category="struct" name="VkMemorySciBufPropertiesNV">
            <member values="VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>uint32_t</type>                               <name>memoryTypeBits</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalMemorySciBufFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                       <name>pNext</name></member>
            <member><type>VkBool32</type>                                    <name>sciBufImport</name></member>
            <member><type>VkBool32</type>                                    <name>sciBufExport</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalSciBufFeaturesNV"  alias="VkPhysicalDeviceExternalMemorySciBufFeaturesNV"/>
        <type category="struct" name="VkWin32KeyedMutexAcquireReleaseInfoNV" structextends="VkSubmitInfo,VkSubmitInfo2">
            <member values="VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                         <name>acquireCount</name></member>
            <member len="acquireCount">const <type>VkDeviceMemory</type>*            <name>pAcquireSyncs</name></member>
            <member len="acquireCount">const <type>uint64_t</type>*                  <name>pAcquireKeys</name></member>
            <member len="acquireCount">const <type>uint32_t</type>*                  <name>pAcquireTimeoutMilliseconds</name></member>
            <member optional="true"><type>uint32_t</type>                         <name>releaseCount</name></member>
            <member len="releaseCount">const <type>VkDeviceMemory</type>*            <name>pReleaseSyncs</name></member>
            <member len="releaseCount">const <type>uint64_t</type>*                  <name>pReleaseKeys</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member featurelink="deviceGeneratedCommandsNV"><type>VkBool32</type>                       <name>deviceGeneratedCommands</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*          <name>pNext</name></member>
            <member><type>VkBool32</type>                       <name>deviceGeneratedCompute</name></member>
            <member><type>VkBool32</type>                       <name>deviceGeneratedComputePipelines</name></member>
            <member><type>VkBool32</type>                       <name>deviceGeneratedComputeCaptureReplay</name></member>
        </type>
        <type category="struct" name="VkDevicePrivateDataCreateInfo" allowduplicate="true" structextends="VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
            <member><type>uint32_t</type>                               <name>privateDataSlotRequestCount</name></member>
        </type>
        <type category="struct" name="VkDevicePrivateDataCreateInfoEXT" alias="VkDevicePrivateDataCreateInfo"/>
        <type category="struct" name="VkPrivateDataSlotCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
            <member><type>VkPrivateDataSlotCreateFlags</type>        <name>flags</name></member>
        </type>
        <type category="struct" name="VkPrivateDataSlotCreateInfoEXT" alias="VkPrivateDataSlotCreateInfo"/>
        <type category="struct" name="VkPhysicalDevicePrivateDataFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                  <name>pNext</name></member>
            <member><type>VkBool32</type>                               <name>privateData</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePrivateDataFeaturesEXT" alias="VkPhysicalDevicePrivateDataFeatures"/>
        <type category="struct" name="VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>         <name>maxGraphicsShaderGroupCount</name></member>
            <member limittype="max"><type>uint32_t</type>         <name>maxIndirectSequenceCount</name></member>
            <member limittype="max"><type>uint32_t</type>         <name>maxIndirectCommandsTokenCount</name></member>
            <member limittype="max"><type>uint32_t</type>         <name>maxIndirectCommandsStreamCount</name></member>
            <member limittype="max"><type>uint32_t</type>         <name>maxIndirectCommandsTokenOffset</name></member>
            <member limittype="max"><type>uint32_t</type>         <name>maxIndirectCommandsStreamStride</name></member>
            <member limittype="min"><type>uint32_t</type>         <name>minSequencesCountBufferOffsetAlignment</name></member>
            <member limittype="min"><type>uint32_t</type>         <name>minSequencesIndexBufferOffsetAlignment</name></member>
            <member limittype="min"><type>uint32_t</type>         <name>minIndirectCommandsBufferOffsetAlignment</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceClusterAccelerationStructureFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member><type>VkBool32</type>                                       <name>clusterAccelerationStructure</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceClusterAccelerationStructurePropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*    <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>                       <name>maxVerticesPerCluster</name></member>
            <member limittype="max"><type>uint32_t</type>                       <name>maxTrianglesPerCluster</name></member>
            <member limittype="min"><type>uint32_t</type>                       <name>clusterScratchByteAlignment</name></member>
            <member limittype="min"><type>uint32_t</type>                       <name>clusterByteAlignment</name></member>
            <member limittype="min"><type>uint32_t</type>                       <name>clusterTemplateByteAlignment</name></member>
            <member limittype="min"><type>uint32_t</type>                       <name>clusterBottomLevelByteAlignment</name></member>
            <member limittype="min"><type>uint32_t</type>                       <name>clusterTemplateBoundsByteAlignment</name></member>
            <member limittype="max"><type>uint32_t</type>                       <name>maxClusterGeometryIndex</name></member>
        </type>
        <type category="struct" name="VkStridedDeviceAddressNV">
            <member><type>VkDeviceAddress</type>                    <name>startAddress</name></member>
            <member><type>VkDeviceSize</type>                       <name>strideInBytes</name><comment>Specified in bytes</comment></member>
        </type>
        <type category="struct" name="VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV" structextends="VkRayTracingPipelineCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                           <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>allowClusterAccelerationStructure</name></member>
        </type>
        <type category="struct" name="VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV">
            <comment>The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.</comment>
            <member><type>uint32_t</type>                           <name>geometryIndex</name>:24</member>
            <member><type>uint32_t</type>                           <name>reserved</name>:5</member>
            <member><type>uint32_t</type>                           <name>geometryFlags</name>:3</member>
        </type>
        <type category="struct" name="VkClusterAccelerationStructureMoveObjectsInfoNV">
            <member><type>VkDeviceAddress</type>                    <name>srcAccelerationStructure</name></member>
        </type>
        <type category="struct" name="VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV">
            <member><type>uint32_t</type>                           <name>clusterReferencesCount</name></member>
            <member><type>uint32_t</type>                           <name>clusterReferencesStride</name></member>
            <member><type>VkDeviceAddress</type>                    <name>clusterReferences</name></member>
        </type>
        <type category="struct" name="VkClusterAccelerationStructureGetTemplateIndicesInfoNV">
            <member><type>VkDeviceAddress</type>                    <name>clusterTemplateAddress</name></member>
        </type>
        <type category="struct" name="VkClusterAccelerationStructureBuildTriangleClusterInfoNV">
            <comment>The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.</comment>
            <member><type>uint32_t</type>                                       <name>clusterID</name></member>
            <member optional="true"><type>VkClusterAccelerationStructureClusterFlagsNV</type> <name>clusterFlags</name></member>
            <member><type>uint32_t</type>                                       <name>triangleCount</name>:9</member>
            <member><type>uint32_t</type>                                       <name>vertexCount</name>:9</member>
            <member><type>uint32_t</type>                                       <name>positionTruncateBitCount</name>:6</member>
            <member><type>uint32_t</type>                                       <name>indexType</name>:4</member>
            <member><type>uint32_t</type>                                       <name>opacityMicromapIndexType</name>:4</member>
            <member><type>VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV</type> <name>baseGeometryIndexAndGeometryFlags</name></member>
            <member><type>uint16_t</type>                                       <name>indexBufferStride</name></member>
            <member><type>uint16_t</type>                                       <name>vertexBufferStride</name></member>
            <member><type>uint16_t</type>                                       <name>geometryIndexAndFlagsBufferStride</name></member>
            <member><type>uint16_t</type>                                       <name>opacityMicromapIndexBufferStride</name></member>
            <member><type>VkDeviceAddress</type>                                <name>indexBuffer</name></member>
            <member><type>VkDeviceAddress</type>                                <name>vertexBuffer</name></member>
            <member><type>VkDeviceAddress</type>                                <name>geometryIndexAndFlagsBuffer</name></member>
            <member><type>VkDeviceAddress</type>                                <name>opacityMicromapArray</name></member>
            <member><type>VkDeviceAddress</type>                                <name>opacityMicromapIndexBuffer</name></member>
        </type>
        <type category="struct" name="VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV">
            <comment>The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.</comment>
            <member><type>uint32_t</type>                                       <name>clusterID</name></member>
            <member optional="true"><type>VkClusterAccelerationStructureClusterFlagsNV</type> <name>clusterFlags</name></member>
            <member><type>uint32_t</type>                                       <name>triangleCount</name>:9</member>
            <member><type>uint32_t</type>                                       <name>vertexCount</name>:9</member>
            <member><type>uint32_t</type>                                       <name>positionTruncateBitCount</name>:6</member>
            <member><type>uint32_t</type>                                       <name>indexType</name>:4</member>
            <member><type>uint32_t</type>                                       <name>opacityMicromapIndexType</name>:4</member>
            <member><type>VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV</type> <name>baseGeometryIndexAndGeometryFlags</name></member>
            <member><type>uint16_t</type>                                       <name>indexBufferStride</name></member>
            <member><type>uint16_t</type>                                       <name>vertexBufferStride</name></member>
            <member><type>uint16_t</type>                                       <name>geometryIndexAndFlagsBufferStride</name></member>
            <member><type>uint16_t</type>                                       <name>opacityMicromapIndexBufferStride</name></member>
            <member><type>VkDeviceAddress</type>                                <name>indexBuffer</name></member>
            <member><type>VkDeviceAddress</type>                                <name>vertexBuffer</name></member>
            <member><type>VkDeviceAddress</type>                                <name>geometryIndexAndFlagsBuffer</name></member>
            <member><type>VkDeviceAddress</type>                                <name>opacityMicromapArray</name></member>
            <member><type>VkDeviceAddress</type>                                <name>opacityMicromapIndexBuffer</name></member>
            <member><type>VkDeviceAddress</type>                                <name>instantiationBoundingBoxLimit</name></member>
        </type>
        <type category="struct" name="VkClusterAccelerationStructureInstantiateClusterInfoNV">
            <member><type>uint32_t</type>                                       <name>clusterIdOffset</name></member>
            <member><type>uint32_t</type>                                       <name>geometryIndexOffset</name>:24</member>
            <member><type>uint32_t</type>                                       <name>reserved</name>:8</member>
            <member><type>VkDeviceAddress</type>                                <name>clusterTemplateAddress</name></member>
            <member><type>VkStridedDeviceAddressNV</type>                       <name>vertexBuffer</name></member>
        </type>
        <type category="struct" name="VkClusterAccelerationStructureClustersBottomLevelInputNV">
            <member values="VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member><type>uint32_t</type>                                       <name>maxTotalClusterCount</name></member>
            <member><type>uint32_t</type>                                       <name>maxClusterCountPerAccelerationStructure</name></member>
        </type>
        <type category="struct" name="VkClusterAccelerationStructureTriangleClusterInputNV">
            <member values="VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member><type>VkFormat</type>                                       <name>vertexFormat</name></member>
            <member><type>uint32_t</type>                                       <name>maxGeometryIndexValue</name></member>
            <member><type>uint32_t</type>                                       <name>maxClusterUniqueGeometryCount</name></member>
            <member><type>uint32_t</type>                                       <name>maxClusterTriangleCount</name></member>
            <member><type>uint32_t</type>                                       <name>maxClusterVertexCount</name></member>
            <member><type>uint32_t</type>                                       <name>maxTotalTriangleCount</name></member>
            <member><type>uint32_t</type>                                       <name>maxTotalVertexCount</name></member>
            <member><type>uint32_t</type>                                       <name>minPositionTruncateBitCount</name></member>
        </type>
        <type category="struct" name="VkClusterAccelerationStructureMoveObjectsInputNV">
            <member values="VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member><type>VkClusterAccelerationStructureTypeNV</type>           <name>type</name></member>
            <member><type>VkBool32</type>                                       <name>noMoveOverlap</name></member>
            <member><type>VkDeviceSize</type>                                   <name>maxMovedBytes</name></member>
        </type>
        <type category="union" name="VkClusterAccelerationStructureOpInputNV">
            <member selection="VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV"><type>VkClusterAccelerationStructureClustersBottomLevelInputNV</type>*     <name>pClustersBottomLevel</name></member>
            <member selection="VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV,VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV,VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV,VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV"><type>VkClusterAccelerationStructureTriangleClusterInputNV</type>*         <name>pTriangleClusters</name></member>
            <member selection="VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV"><type>VkClusterAccelerationStructureMoveObjectsInputNV</type>*             <name>pMoveObjects</name></member>
        </type>
        <type category="struct" name="VkClusterAccelerationStructureInputInfoNV">
            <member values="VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member><type>uint32_t</type>                                       <name>maxAccelerationStructureCount</name></member>
            <member optional="true"><type>VkBuildAccelerationStructureFlagsKHR</type>           <name>flags</name></member>
            <member><type>VkClusterAccelerationStructureOpTypeNV</type>        <name>opType</name></member>
            <member><type>VkClusterAccelerationStructureOpModeNV</type>        <name>opMode</name></member>
            <member selector="opType"><type>VkClusterAccelerationStructureOpInputNV</type>       <name>opInput</name></member>
        </type>
        <type category="struct" name="VkClusterAccelerationStructureCommandsInfoNV">
            <member values="VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member><type>VkClusterAccelerationStructureInputInfoNV</type>      <name>input</name></member>
            <member><type>VkDeviceAddress</type>                                <name>dstImplicitData</name></member>
            <member><type>VkDeviceAddress</type>                                <name>scratchData</name></member>
            <member><type>VkStridedDeviceAddressRegionKHR</type>                <name>dstAddressesArray</name></member>
            <member><type>VkStridedDeviceAddressRegionKHR</type>                <name>dstSizesArray</name></member>
            <member><type>VkStridedDeviceAddressRegionKHR</type>                <name>srcInfosArray</name></member>
            <member><type>VkDeviceAddress</type>                                <name>srcInfosCount</name></member>
            <member optional="true"><type>VkClusterAccelerationStructureAddressResolutionFlagsNV</type> <name>addressResolutionFlags</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMultiDrawPropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>         <name>maxMultiDrawCount</name></member>
        </type>
        <type category="struct" name="VkGraphicsShaderGroupCreateInfoNV">
            <member values="VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
            <member><type>uint32_t</type>                                                   <name>stageCount</name></member>
            <member len="stageCount">const <type>VkPipelineShaderStageCreateInfo</type>*    <name>pStages</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineVertexInputStateCreateInfo</type>*                <name>pVertexInputState</name></member>
            <member noautovalidity="true" optional="true">const <type>VkPipelineTessellationStateCreateInfo</type>*               <name>pTessellationState</name></member>
        </type>
        <type category="struct" name="VkGraphicsPipelineShaderGroupsCreateInfoNV" structextends="VkGraphicsPipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                                   <name>groupCount</name></member>
            <member len="groupCount">const <type>VkGraphicsShaderGroupCreateInfoNV</type>*  <name>pGroups</name></member>
            <member optional="true"><type>uint32_t</type>                                   <name>pipelineCount</name></member>
            <member len="pipelineCount">const <type>VkPipeline</type>*                      <name>pPipelines</name></member>
        </type>
        <type category="struct" name="VkBindShaderGroupIndirectCommandNV">
            <member><type>uint32_t</type>         <name>groupIndex</name></member>
        </type>
        <type category="struct" name="VkBindIndexBufferIndirectCommandNV">
            <member><type>VkDeviceAddress</type>  <name>bufferAddress</name></member>
            <member><type>uint32_t</type>         <name>size</name></member>
            <member><type>VkIndexType</type>      <name>indexType</name></member>
        </type>
        <type category="struct" name="VkBindVertexBufferIndirectCommandNV">
            <member><type>VkDeviceAddress</type>  <name>bufferAddress</name></member>
            <member><type>uint32_t</type>         <name>size</name></member>
            <member><type>uint32_t</type>         <name>stride</name></member>
        </type>
        <type category="struct" name="VkSetStateFlagsIndirectCommandNV">
            <member><type>uint32_t</type>          <name>data</name></member>
        </type>
        <type category="struct" name="VkIndirectCommandsStreamNV">
            <member><type>VkBuffer</type>      <name>buffer</name></member>
            <member><type>VkDeviceSize</type>  <name>offset</name></member>
        </type>
        <type category="struct" name="VkIndirectCommandsLayoutTokenNV">
            <member values="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
            <member><type>VkIndirectCommandsTokenTypeNV</type>  <name>tokenType</name></member>
            <member><type>uint32_t</type>                       <name>stream</name></member>
            <member><type>uint32_t</type>                       <name>offset</name></member>
            <member><type>uint32_t</type>                                <name>vertexBindingUnit</name></member>
            <member><type>VkBool32</type>                                <name>vertexDynamicStride</name></member>
            <member optional="true"><type>VkPipelineLayout</type>        <name>pushconstantPipelineLayout</name></member>
            <member optional="true"><type>VkShaderStageFlags</type>      <name>pushconstantShaderStageFlags</name></member>
            <member><type>uint32_t</type>                                <name>pushconstantOffset</name></member>
            <member><type>uint32_t</type>                                <name>pushconstantSize</name></member>
            <member optional="true"><type>VkIndirectStateFlagsNV</type>  <name>indirectStateFlags</name></member>
            <member optional="true"><type>uint32_t</type>                <name>indexTypeCount</name></member>
            <member len="indexTypeCount">const <type>VkIndexType</type>* <name>pIndexTypes</name></member>
            <member len="indexTypeCount">const <type>uint32_t</type>*    <name>pIndexTypeValues</name></member>
        </type>
        <type category="struct" name="VkIndirectCommandsLayoutCreateInfoNV">
            <member values="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                             <name>pNext</name></member>
            <member optional="true"><type>VkIndirectCommandsLayoutUsageFlagsNV</type>    <name>flags</name></member>
            <member><type>VkPipelineBindPoint</type>                     <name>pipelineBindPoint</name></member>
            <member><type>uint32_t</type>                                <name>tokenCount</name></member>
            <member len="tokenCount">const <type>VkIndirectCommandsLayoutTokenNV</type>*  <name>pTokens</name></member>
            <member><type>uint32_t</type>                                <name>streamCount</name></member>
            <member len="streamCount">const <type>uint32_t</type>*       <name>pStreamStrides</name></member>
        </type>
        <type category="struct" name="VkGeneratedCommandsInfoNV">
            <member values="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
            <member><type>VkPipelineBindPoint</type>                <name>pipelineBindPoint</name></member>
            <member optional="true"><type>VkPipeline</type>         <name>pipeline</name></member>
            <member><type>VkIndirectCommandsLayoutNV</type>         <name>indirectCommandsLayout</name></member>
            <member><type>uint32_t</type>                           <name>streamCount</name></member>
            <member len="streamCount">const <type>VkIndirectCommandsStreamNV</type>*  <name>pStreams</name></member>
            <member><type>uint32_t</type>                           <name>sequencesCount</name></member>
            <member><type>VkBuffer</type>                           <name>preprocessBuffer</name></member>
            <member><type>VkDeviceSize</type>                       <name>preprocessOffset</name></member>
            <member><type>VkDeviceSize</type>                       <name>preprocessSize</name></member>
            <member optional="true"><type>VkBuffer</type>           <name>sequencesCountBuffer</name></member>
            <member><type>VkDeviceSize</type>                       <name>sequencesCountOffset</name></member>
            <member optional="true"><type>VkBuffer</type>           <name>sequencesIndexBuffer</name></member>
            <member><type>VkDeviceSize</type>                       <name>sequencesIndexOffset</name></member>
        </type>
        <type category="struct" name="VkGeneratedCommandsMemoryRequirementsInfoNV">
            <member values="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                 <name>pNext</name></member>
            <member><type>VkPipelineBindPoint</type>         <name>pipelineBindPoint</name></member>
            <member optional="true"><type>VkPipeline</type>  <name>pipeline</name></member>
            <member><type>VkIndirectCommandsLayoutNV</type>  <name>indirectCommandsLayout</name></member>
            <member><type>uint32_t</type>                    <name>maxSequencesCount</name></member>
        </type>
        <type category="struct" name="VkPipelineIndirectDeviceAddressInfoNV">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*   <name>pNext</name></member>
            <member><type>VkPipelineBindPoint</type>           <name>pipelineBindPoint</name></member>
            <member><type>VkPipeline</type>                    <name>pipeline</name></member>
        </type>
        <type category="struct" name="VkBindPipelineIndirectCommandNV">
            <member><type>VkDeviceAddress</type>               <name>pipelineAddress</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFeatures2" structextends="VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkPhysicalDeviceFeatures</type>         <name>features</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFeatures2KHR"                            alias="VkPhysicalDeviceFeatures2"/>
        <type category="struct" name="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="struct"><type>VkPhysicalDeviceProperties</type>       <name>properties</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceProperties2KHR"                          alias="VkPhysicalDeviceProperties2"/>
        <type category="struct" name="VkFormatProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="struct"><type>VkFormatProperties</type>               <name>formatProperties</name></member>
        </type>
        <type category="struct" name="VkFormatProperties2KHR"                                  alias="VkFormatProperties2"/>
        <type category="struct" name="VkImageFormatProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkImageFormatProperties</type>          <name>imageFormatProperties</name></member>
        </type>
        <type category="struct" name="VkImageFormatProperties2KHR"                             alias="VkImageFormatProperties2"/>
        <type category="struct" name="VkPhysicalDeviceImageFormatInfo2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkFormat</type>                         <name>format</name></member>
            <member><type>VkImageType</type>                      <name>type</name></member>
            <member><type>VkImageTiling</type>                    <name>tiling</name></member>
            <member><type>VkImageUsageFlags</type>                <name>usage</name></member>
            <member optional="true"><type>VkImageCreateFlags</type> <name>flags</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImageFormatInfo2KHR"                     alias="VkPhysicalDeviceImageFormatInfo2"/>
        <type category="struct" name="VkQueueFamilyProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="struct"><type>VkQueueFamilyProperties</type>       <name>queueFamilyProperties</name></member>
        </type>
        <type category="struct" name="VkQueueFamilyProperties2KHR"                             alias="VkQueueFamilyProperties2"/>
        <type category="struct" name="VkPhysicalDeviceMemoryProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkPhysicalDeviceMemoryProperties</type> <name>memoryProperties</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMemoryProperties2KHR"                    alias="VkPhysicalDeviceMemoryProperties2"/>
        <type category="struct" name="VkSparseImageFormatProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="struct"><type>VkSparseImageFormatProperties</type> <name>properties</name></member>
        </type>
        <type category="struct" name="VkSparseImageFormatProperties2KHR"                       alias="VkSparseImageFormatProperties2"/>
        <type category="struct" name="VkPhysicalDeviceSparseImageFormatInfo2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkFormat</type>                         <name>format</name></member>
            <member><type>VkImageType</type>                      <name>type</name></member>
            <member><type>VkSampleCountFlagBits</type>            <name>samples</name></member>
            <member><type>VkImageUsageFlags</type>                <name>usage</name></member>
            <member><type>VkImageTiling</type>                    <name>tiling</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSparseImageFormatInfo2KHR"               alias="VkPhysicalDeviceSparseImageFormatInfo2"/>
        <type category="struct" name="VkPhysicalDevicePushDescriptorProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxPushDescriptors</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePushDescriptorPropertiesKHR" alias="VkPhysicalDevicePushDescriptorProperties"/>
        <type category="struct" name="VkConformanceVersion">
            <member><type>uint8_t</type>                          <name>major</name></member>
            <member><type>uint8_t</type>                          <name>minor</name></member>
            <member><type>uint8_t</type>                          <name>subminor</name></member>
            <member><type>uint8_t</type>                          <name>patch</name></member>
        </type>
        <type category="struct" name="VkConformanceVersionKHR"                                 alias="VkConformanceVersion"/>
        <type category="struct" name="VkPhysicalDeviceDriverProperties" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="exact"><type>VkDriverId</type>                  <name>driverID</name></member>
            <member limittype="exact" len="null-terminated"><type>char</type>  <name>driverName</name>[<enum>VK_MAX_DRIVER_NAME_SIZE</enum>]</member>
            <member limittype="exact" len="null-terminated"><type>char</type>  <name>driverInfo</name>[<enum>VK_MAX_DRIVER_INFO_SIZE</enum>]</member>
            <member limittype="exact"><type>VkConformanceVersion</type>        <name>conformanceVersion</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDriverPropertiesKHR"                     alias="VkPhysicalDeviceDriverProperties"/>
        <type category="struct" name="VkPresentRegionsKHR" structextends="VkPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>swapchainCount</name><comment>Copy of VkPresentInfoKHR::swapchainCount</comment></member>
            <member len="swapchainCount" optional="true">const <type>VkPresentRegionKHR</type>*   <name>pRegions</name><comment>The regions that have changed</comment></member>
        </type>
        <type category="struct" name="VkPresentRegionKHR">
            <member optional="true"><type>uint32_t</type>         <name>rectangleCount</name><comment>Number of rectangles in pRectangles</comment></member>
            <member optional="true" len="rectangleCount">const <type>VkRectLayerKHR</type>*   <name>pRectangles</name><comment>Array of rectangles that have changed in a swapchain's image(s)</comment></member>
        </type>
        <type category="struct" name="VkRectLayerKHR">
            <member><type>VkOffset2D</type>                       <name>offset</name><comment>upper-left corner of a rectangle that has not changed, in pixels of a presentation images</comment></member>
            <member noautovalidity="true"><type>VkExtent2D</type> <name>extent</name><comment>Dimensions of a rectangle that has not changed, in pixels of a presentation images</comment></member>
            <member><type>uint32_t</type>                         <name>layer</name><comment>Layer of a swapchain's image(s), for stereoscopic-3D images</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVariablePointersFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>variablePointersStorageBuffer</name></member>
            <member><type>VkBool32</type>                         <name>variablePointers</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVariablePointersFeaturesKHR"             alias="VkPhysicalDeviceVariablePointersFeatures"/>
        <type category="struct" name="VkPhysicalDeviceVariablePointerFeaturesKHR"              alias="VkPhysicalDeviceVariablePointersFeatures"/>
        <type category="struct" name="VkPhysicalDeviceVariablePointerFeatures"                 alias="VkPhysicalDeviceVariablePointersFeatures"/>
        <type category="struct" name="VkExternalMemoryProperties" returnedonly="true">
            <member><type>VkExternalMemoryFeatureFlags</type>  <name>externalMemoryFeatures</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlags</type> <name>exportFromImportedHandleTypes</name></member>
            <member><type>VkExternalMemoryHandleTypeFlags</type> <name>compatibleHandleTypes</name></member>
        </type>
        <type category="struct" name="VkExternalMemoryPropertiesKHR"                           alias="VkExternalMemoryProperties"/>
        <type category="struct" name="VkPhysicalDeviceExternalImageFormatInfo"  structextends="VkPhysicalDeviceImageFormatInfo2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalImageFormatInfoKHR"              alias="VkPhysicalDeviceExternalImageFormatInfo"/>
        <type category="struct" name="VkExternalImageFormatProperties" returnedonly="true" structextends="VkImageFormatProperties2">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkExternalMemoryProperties</type> <name>externalMemoryProperties</name></member>
        </type>
        <type category="struct" name="VkExternalImageFormatPropertiesKHR"                      alias="VkExternalImageFormatProperties"/>
        <type category="struct" name="VkPhysicalDeviceExternalBufferInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkBufferCreateFlags</type> <name>flags</name></member>
            <member optional="true" noautovalidity="true"><type>VkBufferUsageFlags</type> <name>usage</name></member>
            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalBufferInfoKHR"                   alias="VkPhysicalDeviceExternalBufferInfo"/>
        <type category="struct" name="VkExternalBufferProperties" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkExternalMemoryProperties</type>    <name>externalMemoryProperties</name></member>
        </type>
        <type category="struct" name="VkExternalBufferPropertiesKHR"                           alias="VkExternalBufferProperties"/>
        <type category="struct" name="VkPhysicalDeviceIDProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member limittype="noauto"><type>uint8_t</type>                     <name>deviceUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
            <member limittype="noauto"><type>uint8_t</type>                     <name>driverUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
            <member limittype="noauto"><type>uint8_t</type>                     <name>deviceLUID</name>[<enum>VK_LUID_SIZE</enum>]</member>
            <member limittype="noauto"><type>uint32_t</type>                    <name>deviceNodeMask</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>deviceLUIDValid</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceIDPropertiesKHR"                         alias="VkPhysicalDeviceIDProperties"/>
        <type category="struct" name="VkExternalMemoryImageCreateInfo" structextends="VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlags</type> <name>handleTypes</name></member>
        </type>
        <type category="struct" name="VkExternalMemoryImageCreateInfoKHR"                      alias="VkExternalMemoryImageCreateInfo"/>
        <type category="struct" name="VkExternalMemoryBufferCreateInfo" structextends="VkBufferCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlags</type> <name>handleTypes</name></member>
        </type>
        <type category="struct" name="VkExternalMemoryBufferCreateInfoKHR"                     alias="VkExternalMemoryBufferCreateInfo"/>
        <type category="struct" name="VkExportMemoryAllocateInfo" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlags</type> <name>handleTypes</name></member>
        </type>
        <type category="struct" name="VkExportMemoryAllocateInfoKHR"                           alias="VkExportMemoryAllocateInfo"/>
        <type category="struct" name="VkImportMemoryWin32HandleInfoKHR" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
            <member optional="true"><type>HANDLE</type>           <name>handle</name></member>
            <member optional="true"><type>LPCWSTR</type>          <name>name</name></member>
        </type>
        <type category="struct" name="VkExportMemoryWin32HandleInfoKHR" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true">const <type>SECURITY_ATTRIBUTES</type>* <name>pAttributes</name></member>
            <member><type>DWORD</type>                            <name>dwAccess</name></member>
            <member><type>LPCWSTR</type>                          <name>name</name></member>
        </type>
        <type category="struct" name="VkImportMemoryZirconHandleInfoFUCHSIA" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
            <member optional="true"><type>zx_handle_t</type>           <name>handle</name></member>
        </type>
        <type category="struct" name="VkMemoryZirconHandlePropertiesFUCHSIA" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>memoryTypeBits</name></member>
        </type>
        <type category="struct" name="VkMemoryGetZirconHandleInfoFUCHSIA">
            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkMemoryWin32HandlePropertiesKHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>memoryTypeBits</name></member>
        </type>
        <type category="struct" name="VkMemoryGetWin32HandleInfoKHR">
            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkImportMemoryFdInfoKHR" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
            <member><type>int</type>                              <name>fd</name></member>
        </type>
        <type category="struct" name="VkMemoryFdPropertiesKHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>memoryTypeBits</name></member>
        </type>
        <type category="struct" name="VkMemoryGetFdInfoKHR">
            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkWin32KeyedMutexAcquireReleaseInfoKHR" structextends="VkSubmitInfo,VkSubmitInfo2">
            <member values="VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>         <name>acquireCount</name></member>
            <member len="acquireCount">const <type>VkDeviceMemory</type>* <name>pAcquireSyncs</name></member>
            <member len="acquireCount">const <type>uint64_t</type>* <name>pAcquireKeys</name></member>
            <member len="acquireCount">const <type>uint32_t</type>* <name>pAcquireTimeouts</name></member>
            <member optional="true"><type>uint32_t</type>         <name>releaseCount</name></member>
            <member len="releaseCount">const <type>VkDeviceMemory</type>* <name>pReleaseSyncs</name></member>
            <member len="releaseCount">const <type>uint64_t</type>* <name>pReleaseKeys</name></member>
        </type>
        <type category="struct" name="VkImportMemoryMetalHandleInfoEXT" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
            <member optional="true"><type>void</type>*           <name>handle</name></member>
        </type>
        <type category="struct" name="VkMemoryMetalHandlePropertiesEXT" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>memoryTypeBits</name></member>
        </type>
        <type category="struct" name="VkMemoryGetMetalHandleInfoEXT">
            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalSemaphoreInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalSemaphoreInfoKHR"                alias="VkPhysicalDeviceExternalSemaphoreInfo"/>
        <type category="struct" name="VkExternalSemaphoreProperties" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkExternalSemaphoreHandleTypeFlags</type> <name>exportFromImportedHandleTypes</name></member>
            <member><type>VkExternalSemaphoreHandleTypeFlags</type> <name>compatibleHandleTypes</name></member>
            <member optional="true"><type>VkExternalSemaphoreFeatureFlags</type> <name>externalSemaphoreFeatures</name></member>
        </type>
        <type category="struct" name="VkExternalSemaphorePropertiesKHR"                        alias="VkExternalSemaphoreProperties"/>
        <type category="struct" name="VkExportSemaphoreCreateInfo" structextends="VkSemaphoreCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalSemaphoreHandleTypeFlags</type> <name>handleTypes</name></member>
        </type>
        <type category="struct" name="VkExportSemaphoreCreateInfoKHR"                          alias="VkExportSemaphoreCreateInfo"/>
        <type category="struct" name="VkImportSemaphoreWin32HandleInfoKHR">
            <member values="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member externsync="true"><type>VkSemaphore</type>    <name>semaphore</name></member>
            <member optional="true"><type>VkSemaphoreImportFlags</type> <name>flags</name></member>
            <member noautovalidity="true"><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
            <member optional="true"><type>HANDLE</type>           <name>handle</name></member>
            <member optional="true"><type>LPCWSTR</type>          <name>name</name></member>
        </type>
        <type category="struct" name="VkExportSemaphoreWin32HandleInfoKHR" structextends="VkSemaphoreCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true">const <type>SECURITY_ATTRIBUTES</type>*       <name>pAttributes</name></member>
            <member><type>DWORD</type>                            <name>dwAccess</name></member>
            <member><type>LPCWSTR</type>                          <name>name</name></member>
        </type>
        <type category="struct" name="VkD3D12FenceSubmitInfoKHR" structextends="VkSubmitInfo">
            <member values="VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>         <name>waitSemaphoreValuesCount</name></member>
            <member optional="true" len="waitSemaphoreValuesCount">const <type>uint64_t</type>* <name>pWaitSemaphoreValues</name></member>
            <member optional="true"><type>uint32_t</type>         <name>signalSemaphoreValuesCount</name></member>
            <member optional="true" len="signalSemaphoreValuesCount">const <type>uint64_t</type>* <name>pSignalSemaphoreValues</name></member>
        </type>
        <type category="struct" name="VkSemaphoreGetWin32HandleInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkSemaphore</type>                      <name>semaphore</name></member>
            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkImportSemaphoreFdInfoKHR">
            <member values="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member externsync="true"><type>VkSemaphore</type>    <name>semaphore</name></member>
            <member optional="true"><type>VkSemaphoreImportFlags</type> <name>flags</name></member>
            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
            <member><type>int</type>                              <name>fd</name></member>
        </type>
        <type category="struct" name="VkSemaphoreGetFdInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkSemaphore</type>                      <name>semaphore</name></member>
            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkImportSemaphoreZirconHandleInfoFUCHSIA">
            <member values="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member externsync="true"><type>VkSemaphore</type>    <name>semaphore</name></member>
            <member optional="true"><type>VkSemaphoreImportFlags</type> <name>flags</name></member>
            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
            <member><type>zx_handle_t</type>                              <name>zirconHandle</name></member>
        </type>
        <type category="struct" name="VkSemaphoreGetZirconHandleInfoFUCHSIA">
            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkSemaphore</type>                      <name>semaphore</name></member>
            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalFenceInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkExternalFenceHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalFenceInfoKHR"                    alias="VkPhysicalDeviceExternalFenceInfo"/>
        <type category="struct" name="VkExternalFenceProperties" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkExternalFenceHandleTypeFlags</type> <name>exportFromImportedHandleTypes</name></member>
            <member><type>VkExternalFenceHandleTypeFlags</type> <name>compatibleHandleTypes</name></member>
            <member optional="true"><type>VkExternalFenceFeatureFlags</type> <name>externalFenceFeatures</name></member>
        </type>
        <type category="struct" name="VkExternalFencePropertiesKHR"                            alias="VkExternalFenceProperties"/>
        <type category="struct" name="VkExportFenceCreateInfo" structextends="VkFenceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalFenceHandleTypeFlags</type> <name>handleTypes</name></member>
        </type>
        <type category="struct" name="VkExportFenceCreateInfoKHR"                              alias="VkExportFenceCreateInfo"/>
        <type category="struct" name="VkImportFenceWin32HandleInfoKHR">
            <member values="VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                        <name>pNext</name></member>
            <member externsync="true"><type>VkFence</type>                          <name>fence</name></member>
            <member optional="true"><type>VkFenceImportFlags</type>              <name>flags</name></member>
            <member noautovalidity="true"><type>VkExternalFenceHandleTypeFlagBits</type>  <name>handleType</name></member>
            <member optional="true"><type>HANDLE</type>                             <name>handle</name></member>
            <member optional="true"><type>LPCWSTR</type>                            <name>name</name></member>
        </type>
        <type category="struct" name="VkExportFenceWin32HandleInfoKHR" structextends="VkFenceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                <name>pNext</name></member>
            <member optional="true">const <type>SECURITY_ATTRIBUTES</type>* <name>pAttributes</name></member>
            <member><type>DWORD</type>                                      <name>dwAccess</name></member>
            <member><type>LPCWSTR</type>                                    <name>name</name></member>
        </type>
        <type category="struct" name="VkFenceGetWin32HandleInfoKHR">
            <member values="VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
            <member><type>VkFence</type>                                <name>fence</name></member>
            <member><type>VkExternalFenceHandleTypeFlagBits</type>   <name>handleType</name></member>
        </type>
        <type category="struct" name="VkImportFenceFdInfoKHR">
            <member values="VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
            <member externsync="true"><type>VkFence</type>              <name>fence</name></member>
            <member optional="true"><type>VkFenceImportFlags</type>  <name>flags</name></member>
            <member><type>VkExternalFenceHandleTypeFlagBits</type>   <name>handleType</name></member>
            <member><type>int</type>                                    <name>fd</name></member>
        </type>
        <type category="struct" name="VkFenceGetFdInfoKHR">
            <member values="VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
            <member><type>VkFence</type>                                <name>fence</name></member>
            <member><type>VkExternalFenceHandleTypeFlagBits</type>   <name>handleType</name></member>
        </type>
        <type category="struct" name="VkExportFenceSciSyncInfoNV" structextends="VkFenceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>NvSciSyncAttrList</type>                      <name>pAttributes</name></member>
        </type>
        <type category="struct" name="VkImportFenceSciSyncInfoNV">
            <member values="VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member externsync="true"><type>VkFence</type>              <name>fence</name></member>
            <member><type>VkExternalFenceHandleTypeFlagBits</type>      <name>handleType</name></member>
            <member><type>void</type>*                                  <name>handle</name></member>
        </type>
        <type category="struct" name="VkFenceGetSciSyncInfoNV">
            <member values="VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkFence</type>                                <name>fence</name></member>
            <member><type>VkExternalFenceHandleTypeFlagBits</type>      <name>handleType</name></member>
        </type>
        <type category="struct" name="VkExportSemaphoreSciSyncInfoNV" structextends="VkSemaphoreCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>NvSciSyncAttrList</type>                      <name>pAttributes</name></member>
        </type>
        <type category="struct" name="VkImportSemaphoreSciSyncInfoNV">
            <member values="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member externsync="true"><type>VkSemaphore</type>          <name>semaphore</name></member>
            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type>  <name>handleType</name></member>
            <member><type>void</type>*                                  <name>handle</name></member>
        </type>
        <type category="struct" name="VkSemaphoreGetSciSyncInfoNV">
            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkSemaphore</type>                            <name>semaphore</name></member>
            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type>  <name>handleType</name></member>
        </type>
        <type category="struct" name="VkSciSyncAttributesInfoNV">
            <member values="VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkSciSyncClientTypeNV</type>                  <name>clientType</name></member>
            <member><type>VkSciSyncPrimitiveTypeNV</type>               <name>primitiveType</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalSciSyncFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member><type>VkBool32</type>                               <name>sciSyncFence</name></member>
            <member><type>VkBool32</type>                               <name>sciSyncSemaphore</name></member>
            <member><type>VkBool32</type>                               <name>sciSyncImport</name></member>
            <member><type>VkBool32</type>                               <name>sciSyncExport</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalSciSync2FeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member featurelink="sciSyncFence2"><type>VkBool32</type>   <name>sciSyncFence</name></member>
            <member><type>VkBool32</type>                               <name>sciSyncSemaphore2</name></member>
            <member featurelink="sciSyncImport2"><type>VkBool32</type>  <name>sciSyncImport</name></member>
            <member featurelink="sciSyncExport2"><type>VkBool32</type>  <name>sciSyncExport</name></member>
        </type>
        <type category="struct" name="VkSemaphoreSciSyncPoolCreateInfoNV">
            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>NvSciSyncObj</type>                           <name>handle</name></member>
        </type>
        <type category="struct" name="VkSemaphoreSciSyncCreateInfoNV" structextends="VkSemaphoreCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkSemaphoreSciSyncPoolNV</type>               <name>semaphorePool</name></member>
            <member>const <type>NvSciSyncFence</type>*                  <name>pFence</name></member>
        </type>
        <type category="struct" name="VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV" allowduplicate="true" structextends="VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_SEMAPHORE_SCI_SYNC_POOL_RESERVATION_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>uint32_t</type>                               <name>semaphoreSciSyncPoolRequestCount</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMultiviewFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>multiview</name><comment>Multiple views in a render pass</comment></member>
            <member><type>VkBool32</type>                         <name>multiviewGeometryShader</name><comment>Multiple views in a render pass w/ geometry shader</comment></member>
            <member><type>VkBool32</type>                         <name>multiviewTessellationShader</name><comment>Multiple views in a render pass w/ tessellation shader</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMultiviewFeaturesKHR"                    alias="VkPhysicalDeviceMultiviewFeatures"/>
        <type category="struct" name="VkPhysicalDeviceMultiviewProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxMultiviewViewCount</name><comment>max number of views in a subpass</comment></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxMultiviewInstanceIndex</name><comment>max instance index for a draw in a multiview subpass</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMultiviewPropertiesKHR"                  alias="VkPhysicalDeviceMultiviewProperties"/>
        <type category="struct" name="VkRenderPassMultiviewCreateInfo" structextends="VkRenderPassCreateInfo">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO"><type>VkStructureType</type>        <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>               <name>subpassCount</name></member>
            <member len="subpassCount">const <type>uint32_t</type>*     <name>pViewMasks</name></member>
            <member optional="true"><type>uint32_t</type>               <name>dependencyCount</name></member>
            <member len="dependencyCount">const <type>int32_t</type>*   <name>pViewOffsets</name></member>
            <member optional="true"><type>uint32_t</type>               <name>correlationMaskCount</name></member>
            <member len="correlationMaskCount">const <type>uint32_t</type>* <name>pCorrelationMasks</name></member>
        </type>
        <type category="struct" name="VkRenderPassMultiviewCreateInfoKHR"                      alias="VkRenderPassMultiviewCreateInfo"/>
        <type category="struct" name="VkSurfaceCapabilities2EXT" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>minImageCount</name><comment>Supported minimum number of images for the surface</comment></member>
            <member><type>uint32_t</type>                         <name>maxImageCount</name><comment>Supported maximum number of images for the surface, 0 for unlimited</comment></member>
            <member><type>VkExtent2D</type>                       <name>currentExtent</name><comment>Current image width and height for the surface, (0, 0) if undefined</comment></member>
            <member><type>VkExtent2D</type>                       <name>minImageExtent</name><comment>Supported minimum image width and height for the surface</comment></member>
            <member><type>VkExtent2D</type>                       <name>maxImageExtent</name><comment>Supported maximum image width and height for the surface</comment></member>
            <member><type>uint32_t</type>                         <name>maxImageArrayLayers</name><comment>Supported maximum number of image layers for the surface</comment></member>
            <member><type>VkSurfaceTransformFlagsKHR</type>       <name>supportedTransforms</name><comment>1 or more bits representing the transforms supported</comment></member>
            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>currentTransform</name><comment>The surface's current transform relative to the device's natural orientation</comment></member>
            <member><type>VkCompositeAlphaFlagsKHR</type>         <name>supportedCompositeAlpha</name><comment>1 or more bits representing the alpha compositing modes supported</comment></member>
            <member><type>VkImageUsageFlags</type>                <name>supportedUsageFlags</name><comment>Supported image usage flags for the surface</comment></member>
            <member optional="true"><type>VkSurfaceCounterFlagsEXT</type> <name>supportedSurfaceCounters</name></member>
        </type>
        <type category="struct" name="VkDisplayPowerInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDisplayPowerStateEXT</type>           <name>powerState</name></member>
        </type>
        <type category="struct" name="VkDeviceEventInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDeviceEventTypeEXT</type>             <name>deviceEvent</name></member>
        </type>
        <type category="struct" name="VkDisplayEventInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDisplayEventTypeEXT</type>            <name>displayEvent</name></member>
        </type>
        <type category="struct" name="VkSwapchainCounterCreateInfoEXT" structextends="VkSwapchainCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkSurfaceCounterFlagsEXT</type>         <name>surfaceCounters</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceGroupProperties" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>physicalDeviceCount</name></member>
            <member len="physicalDeviceCount"><type>VkPhysicalDevice</type>       <name>physicalDevices</name>[<enum>VK_MAX_DEVICE_GROUP_SIZE</enum>]</member>
            <member><type>VkBool32</type>                         <name>subsetAllocation</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceGroupPropertiesKHR"                      alias="VkPhysicalDeviceGroupProperties"/>
        <type category="struct" name="VkMemoryAllocateFlagsInfo" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkMemoryAllocateFlags</type> <name>flags</name></member>
            <member><type>uint32_t</type>                         <name>deviceMask</name></member>
        </type>
        <type category="struct" name="VkMemoryAllocateFlagsInfoKHR"                            alias="VkMemoryAllocateFlagsInfo"/>
        <type category="struct" name="VkBindBufferMemoryInfo">
            <member values="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member externsync="true"><type>VkBuffer</type>                         <name>buffer</name></member>
            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
            <member><type>VkDeviceSize</type>                     <name>memoryOffset</name></member>
        </type>
        <type category="struct" name="VkBindBufferMemoryInfoKHR"                               alias="VkBindBufferMemoryInfo"/>
        <type category="struct" name="VkBindBufferMemoryDeviceGroupInfo" structextends="VkBindBufferMemoryInfo">
            <member values="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>         <name>deviceIndexCount</name></member>
            <member len="deviceIndexCount">const <type>uint32_t</type>*  <name>pDeviceIndices</name></member>
        </type>
        <type category="struct" name="VkBindBufferMemoryDeviceGroupInfoKHR"                    alias="VkBindBufferMemoryDeviceGroupInfo"/>
        <type category="struct" name="VkBindImageMemoryInfo">
            <member values="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member externsync="true"><type>VkImage</type>                          <name>image</name></member>
            <member noautovalidity="true"><type>VkDeviceMemory</type>                   <name>memory</name></member>
            <member><type>VkDeviceSize</type>                     <name>memoryOffset</name></member>
        </type>
        <type category="struct" name="VkBindImageMemoryInfoKHR"                                alias="VkBindImageMemoryInfo"/>
        <type category="struct" name="VkBindImageMemoryDeviceGroupInfo" structextends="VkBindImageMemoryInfo">
            <member values="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>         <name>deviceIndexCount</name></member>
            <member len="deviceIndexCount">const <type>uint32_t</type>*  <name>pDeviceIndices</name></member>
            <member optional="true"><type>uint32_t</type>         <name>splitInstanceBindRegionCount</name></member>
            <member len="splitInstanceBindRegionCount">const <type>VkRect2D</type>*  <name>pSplitInstanceBindRegions</name></member>
        </type>
        <type category="struct" name="VkBindImageMemoryDeviceGroupInfoKHR"                     alias="VkBindImageMemoryDeviceGroupInfo"/>
        <type category="struct" name="VkDeviceGroupRenderPassBeginInfo" structextends="VkRenderPassBeginInfo,VkRenderingInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>deviceMask</name></member>
            <member optional="true"><type>uint32_t</type>         <name>deviceRenderAreaCount</name></member>
            <member len="deviceRenderAreaCount">const <type>VkRect2D</type>*  <name>pDeviceRenderAreas</name></member>
        </type>
        <type category="struct" name="VkDeviceGroupRenderPassBeginInfoKHR"                     alias="VkDeviceGroupRenderPassBeginInfo"/>
        <type category="struct" name="VkDeviceGroupCommandBufferBeginInfo" structextends="VkCommandBufferBeginInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>deviceMask</name></member>
        </type>
        <type category="struct" name="VkDeviceGroupCommandBufferBeginInfoKHR"                  alias="VkDeviceGroupCommandBufferBeginInfo"/>
        <type category="struct" name="VkDeviceGroupSubmitInfo" structextends="VkSubmitInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>         <name>waitSemaphoreCount</name></member>
            <member len="waitSemaphoreCount">const <type>uint32_t</type>*    <name>pWaitSemaphoreDeviceIndices</name></member>
            <member optional="true"><type>uint32_t</type>         <name>commandBufferCount</name></member>
            <member len="commandBufferCount">const <type>uint32_t</type>*    <name>pCommandBufferDeviceMasks</name></member>
            <member optional="true"><type>uint32_t</type>         <name>signalSemaphoreCount</name></member>
            <member len="signalSemaphoreCount">const <type>uint32_t</type>*  <name>pSignalSemaphoreDeviceIndices</name></member>
        </type>
        <type category="struct" name="VkDeviceGroupSubmitInfoKHR"                              alias="VkDeviceGroupSubmitInfo"/>
        <type category="struct" name="VkDeviceGroupBindSparseInfo" structextends="VkBindSparseInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>resourceDeviceIndex</name></member>
            <member><type>uint32_t</type>                         <name>memoryDeviceIndex</name></member>
        </type>
        <type category="struct" name="VkDeviceGroupBindSparseInfoKHR"                          alias="VkDeviceGroupBindSparseInfo"/>
        <type category="struct" name="VkDeviceGroupPresentCapabilitiesKHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>presentMask</name>[<enum>VK_MAX_DEVICE_GROUP_SIZE</enum>]</member>
            <member><type>VkDeviceGroupPresentModeFlagsKHR</type> <name>modes</name></member>
        </type>
        <type category="struct" name="VkImageSwapchainCreateInfoKHR" structextends="VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkSwapchainKHR</type>   <name>swapchain</name></member>
        </type>
        <type category="struct" name="VkBindImageMemorySwapchainInfoKHR" structextends="VkBindImageMemoryInfo">
            <member values="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></member>
            <member><type>uint32_t</type>                         <name>imageIndex</name></member>
        </type>
        <type category="struct" name="VkAcquireNextImageInfoKHR">
            <member values="VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></member>
            <member><type>uint64_t</type>                         <name>timeout</name></member>
            <member optional="true" externsync="true"><type>VkSemaphore</type> <name>semaphore</name></member>
            <member optional="true" externsync="true"><type>VkFence</type> <name>fence</name></member>
            <member><type>uint32_t</type>                         <name>deviceMask</name></member>
        </type>
        <type category="struct" name="VkDeviceGroupPresentInfoKHR" structextends="VkPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>         <name>swapchainCount</name></member>
            <member len="swapchainCount">const <type>uint32_t</type>* <name>pDeviceMasks</name></member>
            <member><type>VkDeviceGroupPresentModeFlagBitsKHR</type> <name>mode</name></member>
        </type>
        <type category="struct" name="VkDeviceGroupDeviceCreateInfo" structextends="VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                         <name>physicalDeviceCount</name></member>
            <member len="physicalDeviceCount">const <type>VkPhysicalDevice</type>*  <name>pPhysicalDevices</name></member>
        </type>
        <type category="struct" name="VkDeviceGroupDeviceCreateInfoKHR"                        alias="VkDeviceGroupDeviceCreateInfo"/>
        <type category="struct" name="VkDeviceGroupSwapchainCreateInfoKHR" structextends="VkSwapchainCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDeviceGroupPresentModeFlagsKHR</type>                         <name>modes</name></member>
        </type>
        <type category="struct" name="VkDescriptorUpdateTemplateEntry">
            <member><type>uint32_t</type>                         <name>dstBinding</name><comment>Binding within the destination descriptor set to write</comment></member>
            <member><type>uint32_t</type>                         <name>dstArrayElement</name><comment>Array element within the destination binding to write</comment></member>
            <member><type>uint32_t</type>                         <name>descriptorCount</name><comment>Number of descriptors to write</comment></member>
            <member><type>VkDescriptorType</type>                 <name>descriptorType</name><comment>Descriptor type to write</comment></member>
            <member><type>size_t</type>                           <name>offset</name><comment>Offset into pData where the descriptors to update are stored</comment></member>
            <member><type>size_t</type>                           <name>stride</name><comment>Stride between two descriptors in pData when writing more than one descriptor</comment></member>
        </type>
        <type category="struct" name="VkDescriptorUpdateTemplateEntryKHR"                      alias="VkDescriptorUpdateTemplateEntry"/>
        <type category="struct" name="VkDescriptorUpdateTemplateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                               <name>pNext</name></member>
            <member optional="true"><type>VkDescriptorUpdateTemplateCreateFlags</type>    <name>flags</name></member>
            <member><type>uint32_t</type>                 <name>descriptorUpdateEntryCount</name><comment>Number of descriptor update entries to use for the update template</comment></member>
            <member len="descriptorUpdateEntryCount">const <type>VkDescriptorUpdateTemplateEntry</type>* <name>pDescriptorUpdateEntries</name><comment>Descriptor update entries for the template</comment></member>
            <member><type>VkDescriptorUpdateTemplateType</type> <name>templateType</name></member>
            <member noautovalidity="true"><type>VkDescriptorSetLayout</type> <name>descriptorSetLayout</name></member>
            <member noautovalidity="true"><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></member>
            <member noautovalidity="true"><type>VkPipelineLayout</type> <name>pipelineLayout</name><comment>If used for push descriptors, this is the only allowed layout</comment></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>set</name></member>
        </type>
        <type category="struct" name="VkDescriptorUpdateTemplateCreateInfoKHR"                 alias="VkDescriptorUpdateTemplateCreateInfo"/>
        <type category="struct" name="VkXYColorEXT" comment="Chromaticity coordinate">
            <member><type>float</type>   <name>x</name></member>
            <member><type>float</type>   <name>y</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePresentIdFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>presentId</name><comment>Present ID in VkPresentInfoKHR</comment></member>
        </type>
        <type category="struct" name="VkPresentIdKHR" structextends="VkPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PRESENT_ID_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>swapchainCount</name><comment>Copy of VkPresentInfoKHR::swapchainCount</comment></member>
            <member len="swapchainCount" optional="true">const <type>uint64_t</type>* <name>pPresentIds</name><comment>Present ID values for each swapchain</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePresentId2FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>presentId2</name><comment>Present ID2 in VkPresentInfoKHR</comment></member>
        </type>
        <type category="struct" name="VkPresentId2KHR" structextends="VkPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>swapchainCount</name><comment>Copy of VkPresentInfoKHR::swapchainCount</comment></member>
            <member len="swapchainCount" optional="true">const <type>uint64_t</type>* <name>pPresentIds</name><comment>Present ID values for each swapchain</comment></member>
        </type>
        <type category="struct" name="VkPresentWait2InfoKHR">
            <member values="VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*           <name>pNext</name></member>
            <member><type>uint64_t</type>                              <name>presentId</name></member>
            <member><type>uint64_t</type>                              <name>timeout</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePresentWaitFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>presentWait</name><comment>vkWaitForPresentKHR is supported</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePresentWait2FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>presentWait2</name><comment>vkWaitForPresent2KHR is supported</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePresentTimingFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_TIMING_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>presentTiming</name><comment>vkGetPastPresentationTimingEXT is supported</comment></member>
            <member><type>VkBool32</type>                         <name>presentAtAbsoluteTime</name><comment>Absolute time can be used to specify present time</comment></member>
            <member><type>VkBool32</type>                         <name>presentAtRelativeTime</name><comment>Relative time can be used to specify present duration</comment></member>
        </type>
        <type category="struct" name="VkPresentTimingSurfaceCapabilitiesEXT" structextends="VkSurfaceCapabilities2KHR">
            <member values="VK_STRUCTURE_TYPE_PRESENT_TIMING_SURFACE_CAPABILITIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>presentTimingSupported</name><comment>presentation timings of the surface can be queried using vkGetPastPresentationTimingEXT</comment></member>
            <member><type>VkBool32</type>                         <name>presentAtAbsoluteTimeSupported</name><comment>surface can be presented using absolute times</comment></member>
            <member><type>VkBool32</type>                         <name>presentAtRelativeTimeSupported</name><comment>surface can be presented using relative times</comment></member>
            <member><type>VkPresentStageFlagsEXT</type>           <name>presentStageQueries</name><comment>present stages that can be queried</comment></member>
        </type>
        <type category="struct" name="VkSwapchainTimingPropertiesEXT">
            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_TIMING_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>uint64_t</type>                         <name>refreshDuration</name><comment>Number of nanoseconds from the start of one refresh cycle to the next</comment></member>
            <member><type>uint64_t</type>                         <name>refreshInterval</name><comment>Interval in nanoseconds between refresh cycles durations</comment></member>
        </type>
        <type category="struct" name="VkSwapchainTimeDomainPropertiesEXT">
            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_TIME_DOMAIN_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                  <name>pNext</name></member>
            <member><type>uint32_t</type>                                               <name>timeDomainCount</name></member>
            <member optional="true" len="timeDomainCount"><type>VkTimeDomainKHR</type>* <name>pTimeDomains</name><comment>Available time domains to use with the swapchain</comment></member>
            <member optional="true" len="timeDomainCount"><type>uint64_t</type>*        <name>pTimeDomainIds</name><comment>Unique identifier for a time domain</comment></member>
        </type>
        <type category="struct" name="VkPresentStageTimeEXT">
            <member><type>VkPresentStageFlagsEXT</type>           <name>stage</name></member>
            <member><type>uint64_t</type>                         <name>time</name><comment>Time in nanoseconds of the associated stage</comment></member>
        </type>
        <type category="struct" name="VkPastPresentationTimingInfoEXT">
            <member values="VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkPastPresentationTimingFlagsEXT</type> <name>flags</name></member>
            <member externsync="true"><type>VkSwapchainKHR</type>                 <name>swapchain</name></member>
        </type>
        <type category="struct" name="VkPastPresentationTimingPropertiesEXT">
            <member values="VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*  <name>pNext</name></member>
            <member><type>uint64_t</type>               <name>timingPropertiesCounter</name></member>
            <member><type>uint64_t</type>               <name>timeDomainsCounter</name></member>
            <member><type>uint32_t</type>               <name>presentationTimingCount</name></member>
            <member len="presentationTimingCount"><type>VkPastPresentationTimingEXT</type>* <name>pPresentationTimings</name></member>
        </type>
        <type category="struct" name="VkPastPresentationTimingEXT">
            <member values="VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>uint64_t</type>                         <name>presentId</name><comment>Application-provided identifier, previously given to vkQueuePresentKHR</comment></member>
            <member><type>uint64_t</type>                         <name>targetTime</name><comment>Application-provided present time</comment></member>
            <member><type>uint32_t</type>                         <name>presentStageCount</name><comment>Number of present stages results available in pPresentStages</comment></member>
            <member len="presentStageCount"><type>VkPresentStageTimeEXT</type>*           <name>pPresentStages</name><comment>Reported timings for each present stage</comment></member>
            <member><type>VkTimeDomainKHR</type>                  <name>timeDomain</name><comment>Time domain of the present stages</comment></member>
            <member><type>uint64_t</type>                         <name>timeDomainId</name><comment>Time domain id of the present stages</comment></member>
            <member><type>VkBool32</type>                         <name>reportComplete</name><comment>VK_TRUE if all the present stages have been reported</comment></member>
        </type>
        <type category="struct" name="VkPresentTimingsInfoEXT" structextends="VkPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PRESENT_TIMINGS_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>swapchainCount</name><comment>Copy of VkPresentInfoKHR::swapchainCount</comment></member>
            <member len="swapchainCount" optional="true">const <type>VkPresentTimingInfoEXT</type>* <name>pTimingInfos</name><comment>Present timing details for each swapchain</comment></member>
        </type>
        <type category="struct" name="VkPresentTimingInfoEXT">
            <member values="VK_STRUCTURE_TYPE_PRESENT_TIMING_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                  <name>pNext</name></member>
            <member optional="true"><type>VkPresentTimingInfoFlagsEXT</type>  <name>flags</name></member>
            <member><type>uint64_t</type>                                     <name>targetTime</name></member>
            <member><type>uint64_t</type>                                     <name>timeDomainId</name><comment>Time domain to interpret the target present time and collect present stages timings with</comment></member>
            <member optional="true"><type>VkPresentStageFlagsEXT</type>       <name>presentStageQueries</name><comment>Present stages to collect timing information for</comment></member>
            <member optional="true"><type>VkPresentStageFlagsEXT</type>       <name>targetTimeDomainPresentStage</name><comment>Target stage-local time domain's stage</comment></member>
        </type>
        <type category="struct" name="VkSwapchainCalibratedTimestampInfoEXT" structextends="VkCalibratedTimestampInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_CALIBRATED_TIMESTAMP_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
            <member externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></member>
            <member><type>VkPresentStageFlagsEXT</type>           <name>presentStage</name></member>
            <member><type>uint64_t</type>                         <name>timeDomainId</name></member>
        </type>
        <type category="struct" name="VkHdrMetadataEXT">
                <comment>Display primary in chromaticity coordinates</comment>
            <member values="VK_STRUCTURE_TYPE_HDR_METADATA_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
                <comment> From SMPTE 2086</comment>
            <member noautovalidity="true"><type>VkXYColorEXT</type>   <name>displayPrimaryRed</name><comment>Display primary's Red</comment></member>
            <member noautovalidity="true"><type>VkXYColorEXT</type>   <name>displayPrimaryGreen</name><comment>Display primary's Green</comment></member>
            <member noautovalidity="true"><type>VkXYColorEXT</type>   <name>displayPrimaryBlue</name><comment>Display primary's Blue</comment></member>
            <member noautovalidity="true"><type>VkXYColorEXT</type>   <name>whitePoint</name><comment>Display primary's Blue</comment></member>
            <member noautovalidity="true"><type>float</type>          <name>maxLuminance</name><comment>Display maximum luminance</comment></member>
            <member noautovalidity="true"><type>float</type>          <name>minLuminance</name><comment>Display minimum luminance</comment></member>
                <comment> From CTA 861.3</comment>
            <member noautovalidity="true"><type>float</type>          <name>maxContentLightLevel</name><comment>Content maximum luminance</comment></member>
            <member noautovalidity="true"><type>float</type>          <name>maxFrameAverageLightLevel</name></member>
        </type>
        <type category="struct" name="VkHdrVividDynamicMetadataHUAWEI" structextends="VkHdrMetadataEXT">
            <member values="VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                         <name>pNext</name></member>
            <member><type>size_t</type>                                     <name>dynamicMetadataSize</name><comment>Specified in bytes</comment></member>
            <member len="dynamicMetadataSize">const <type>void</type>*   <name>pDynamicMetadata</name><comment>Binary code of size dynamicMetadataSize</comment></member>
        </type>
        <type category="struct" name="VkDisplayNativeHdrSurfaceCapabilitiesAMD" returnedonly="true" structextends="VkSurfaceCapabilities2KHR">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*          <name>pNext</name></member>
            <member><type>VkBool32</type>       <name>localDimmingSupport</name></member>
        </type>
        <type category="struct" name="VkSwapchainDisplayNativeHdrCreateInfoAMD" structextends="VkSwapchainCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>       <name>localDimmingEnable</name></member>
        </type>
        <type category="struct" name="VkRefreshCycleDurationGOOGLE" returnedonly="true">
            <member><type>uint64_t</type>                         <name>refreshDuration</name><comment>Number of nanoseconds from the start of one refresh cycle to the next</comment></member>
        </type>
        <type category="struct" name="VkPastPresentationTimingGOOGLE" returnedonly="true">
            <member><type>uint32_t</type>                         <name>presentID</name><comment>Application-provided identifier, previously given to vkQueuePresentKHR</comment></member>
            <member><type>uint64_t</type>                         <name>desiredPresentTime</name><comment>Earliest time an image should have been presented, previously given to vkQueuePresentKHR</comment></member>
            <member><type>uint64_t</type>                         <name>actualPresentTime</name><comment>Time the image was actually displayed</comment></member>
            <member><type>uint64_t</type>                         <name>earliestPresentTime</name><comment>Earliest time the image could have been displayed</comment></member>
            <member><type>uint64_t</type>                         <name>presentMargin</name><comment>How early vkQueuePresentKHR was processed vs. how soon it needed to be and make earliestPresentTime</comment></member>
        </type>
        <type category="struct" name="VkPresentTimesInfoGOOGLE" structextends="VkPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>swapchainCount</name><comment>Copy of VkPresentInfoKHR::swapchainCount</comment></member>
            <member len="swapchainCount" optional="true">const <type>VkPresentTimeGOOGLE</type>*   <name>pTimes</name><comment>The earliest times to present images</comment></member>
        </type>
        <type category="struct" name="VkPresentTimeGOOGLE">
            <member><type>uint32_t</type>                         <name>presentID</name><comment>Application-provided identifier</comment></member>
            <member><type>uint64_t</type>                         <name>desiredPresentTime</name><comment>Earliest time an image should be presented</comment></member>
        </type>
        <type category="struct" name="VkIOSSurfaceCreateInfoMVK">
            <member values="VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
            <member optional="true"><type>VkIOSSurfaceCreateFlagsMVK</type>     <name>flags</name></member>
            <member noautovalidity="true">const <type>void</type>*                                    <name>pView</name></member>
        </type>
        <type category="struct" name="VkMacOSSurfaceCreateInfoMVK">
            <member values="VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
            <member optional="true"><type>VkMacOSSurfaceCreateFlagsMVK</type>   <name>flags</name></member>
            <member noautovalidity="true">const <type>void</type>*                                    <name>pView</name></member>
        </type>
        <type category="struct" name="VkMetalSurfaceCreateInfoEXT">
            <member values="VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
            <member optional="true"><type>VkMetalSurfaceCreateFlagsEXT</type>   <name>flags</name></member>
            <member noautovalidity="true">const <type>CAMetalLayer</type>*      <name>pLayer</name></member>
        </type>
        <type category="struct" name="VkViewportWScalingNV">
            <member><type>float</type>          <name>xcoeff</name></member>
            <member><type>float</type>          <name>ycoeff</name></member>
        </type>
        <type category="struct" name="VkPipelineViewportWScalingStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkBool32</type>               <name>viewportWScalingEnable</name></member>
            <member><type>uint32_t</type>               <name>viewportCount</name></member>
            <member noautovalidity="true" optional="true" len="viewportCount">const <type>VkViewportWScalingNV</type>*      <name>pViewportWScalings</name></member>
        </type>
        <type category="struct" name="VkViewportSwizzleNV">
            <member><type>VkViewportCoordinateSwizzleNV</type>          <name>x</name></member>
            <member><type>VkViewportCoordinateSwizzleNV</type>          <name>y</name></member>
            <member><type>VkViewportCoordinateSwizzleNV</type>          <name>z</name></member>
            <member><type>VkViewportCoordinateSwizzleNV</type>          <name>w</name></member>
        </type>
        <type category="struct" name="VkPipelineViewportSwizzleStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineViewportSwizzleStateCreateFlagsNV</type>    <name>flags</name></member>
            <member><type>uint32_t</type>               <name>viewportCount</name></member>
            <member len="viewportCount">const <type>VkViewportSwizzleNV</type>*      <name>pViewportSwizzles</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDiscardRectanglePropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDiscardRectangles</name><comment>max number of active discard rectangles</comment></member>
        </type>
        <type category="struct" name="VkPipelineDiscardRectangleStateCreateInfoEXT" structextends="VkGraphicsPipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                       <name>pNext</name></member>
            <member optional="true"><type>VkPipelineDiscardRectangleStateCreateFlagsEXT</type>     <name>flags</name></member>
            <member><type>VkDiscardRectangleModeEXT</type>                                         <name>discardRectangleMode</name></member>
            <member optional="true"><type>uint32_t</type>                                          <name>discardRectangleCount</name></member>
            <member noautovalidity="true" len="discardRectangleCount">const <type>VkRect2D</type>* <name>pDiscardRectangles</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>perViewPositionAllComponents</name></member>
        </type>
        <type category="struct" name="VkInputAttachmentAspectReference">
            <member><type>uint32_t</type>                        <name>subpass</name></member>
            <member><type>uint32_t</type>                        <name>inputAttachmentIndex</name></member>
            <member><type>VkImageAspectFlags</type>              <name>aspectMask</name></member>
        </type>
        <type category="struct" name="VkInputAttachmentAspectReferenceKHR"                     alias="VkInputAttachmentAspectReference"/>
        <type category="struct" name="VkRenderPassInputAttachmentAspectCreateInfo" structextends="VkRenderPassCreateInfo">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                     <name>pNext</name></member>
            <member><type>uint32_t</type>                        <name>aspectReferenceCount</name></member>
            <member len="aspectReferenceCount">const <type>VkInputAttachmentAspectReference</type>* <name>pAspectReferences</name></member>
        </type>
        <type category="struct" name="VkRenderPassInputAttachmentAspectCreateInfoKHR"          alias="VkRenderPassInputAttachmentAspectCreateInfo"/>
        <type category="struct" name="VkPhysicalDeviceSurfaceInfo2KHR">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member noautovalidity="true" optional="true"><type>VkSurfaceKHR</type> <name>surface</name></member>
        </type>
        <type category="struct" name="VkSurfaceCapabilities2KHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*   <name>pNext</name></member>
            <member><type>VkSurfaceCapabilitiesKHR</type> <name>surfaceCapabilities</name></member>
        </type>
        <type category="struct" name="VkSurfaceFormat2KHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkSurfaceFormatKHR</type> <name>surfaceFormat</name></member>
        </type>
        <type category="struct" name="VkDisplayProperties2KHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkDisplayPropertiesKHR</type> <name>displayProperties</name></member>
        </type>
        <type category="struct" name="VkDisplayPlaneProperties2KHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkDisplayPlanePropertiesKHR</type> <name>displayPlaneProperties</name></member>
        </type>
        <type category="struct" name="VkDisplayModeProperties2KHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkDisplayModePropertiesKHR</type> <name>displayModeProperties</name></member>
        </type>
        <type category="struct" name="VkDisplayModeStereoPropertiesNV" structextends="VkDisplayModeProperties2KHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type>                    <name>hdmi3DSupported</name><comment>Whether this mode supports HDMI 3D stereo rendering.</comment></member>
        </type>
        <type category="struct" name="VkDisplayPlaneInfo2KHR">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member externsync="true"><type>VkDisplayModeKHR</type> <name>mode</name></member>
            <member><type>uint32_t</type> <name>planeIndex</name></member>
        </type>
        <type category="struct" name="VkDisplayPlaneCapabilities2KHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkDisplayPlaneCapabilitiesKHR</type> <name>capabilities</name></member>
        </type>
        <type category="struct" name="VkSharedPresentSurfaceCapabilitiesKHR" returnedonly="true" structextends="VkSurfaceCapabilities2KHR">
            <member values="VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member optional="true"><type>VkImageUsageFlags</type> <name>sharedPresentSupportedUsageFlags</name><comment>Supported image usage flags if swapchain created using a shared present mode</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDevice16BitStorageFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>storageBuffer16BitAccess</name><comment>16-bit integer/floating-point variables supported in BufferBlock</comment></member>
            <member><type>VkBool32</type>                         <name>uniformAndStorageBuffer16BitAccess</name><comment>16-bit integer/floating-point variables supported in BufferBlock and Block</comment></member>
            <member><type>VkBool32</type>                         <name>storagePushConstant16</name><comment>16-bit integer/floating-point variables supported in PushConstant</comment></member>
            <member><type>VkBool32</type>                         <name>storageInputOutput16</name><comment>16-bit integer/floating-point variables supported in shader inputs and outputs</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDevice16BitStorageFeaturesKHR"                 alias="VkPhysicalDevice16BitStorageFeatures"/>
        <type category="struct" name="VkPhysicalDeviceSubgroupProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                   <name>pNext</name></member>
            <member limittype="max,pot" noautovalidity="true"><type>uint32_t</type>                     <name>subgroupSize</name><comment>The size of a subgroup for this queue.</comment></member>
            <member limittype="bitmask" noautovalidity="true"><type>VkShaderStageFlags</type>            <name>supportedStages</name><comment>Bitfield of what shader stages support subgroup operations</comment></member>
            <member limittype="bitmask" noautovalidity="true"><type>VkSubgroupFeatureFlags</type>        <name>supportedOperations</name><comment>Bitfield of what subgroup operations are supported.</comment></member>
            <member limittype="max" noautovalidity="true"><type>VkBool32</type>                 <name>quadOperationsInAllStages</name><comment>Flag to specify whether quad operations are available in all stages.</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member noautovalidity="true"><type>VkBool32</type> <name>shaderSubgroupExtendedTypes</name><comment>Flag to specify whether subgroup operations with extended types are supported</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR"  alias="VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures"/>
        <type category="struct" name="VkBufferMemoryRequirementsInfo2">
            <member values="VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                          <name>pNext</name></member>
            <member><type>VkBuffer</type>                                                             <name>buffer</name></member>
        </type>
        <type category="struct" name="VkBufferMemoryRequirementsInfo2KHR"                      alias="VkBufferMemoryRequirementsInfo2"/>
        <type category="struct" name="VkDeviceBufferMemoryRequirements">
            <member values="VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                           <name>pNext</name></member>
            <member>const <type>VkBufferCreateInfo</type>*                                                             <name>pCreateInfo</name></member>
        </type>
        <type category="struct" name="VkDeviceBufferMemoryRequirementsKHR" alias="VkDeviceBufferMemoryRequirements"/>
        <type category="struct" name="VkImageMemoryRequirementsInfo2">
            <member values="VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                          <name>pNext</name></member>
            <member><type>VkImage</type>                                                              <name>image</name></member>
        </type>
        <type category="struct" name="VkImageMemoryRequirementsInfo2KHR"                       alias="VkImageMemoryRequirementsInfo2"/>
        <type category="struct" name="VkImageSparseMemoryRequirementsInfo2">
            <member values="VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                          <name>pNext</name></member>
            <member><type>VkImage</type>                                                              <name>image</name></member>
        </type>
        <type category="struct" name="VkImageSparseMemoryRequirementsInfo2KHR"                 alias="VkImageSparseMemoryRequirementsInfo2"/>
        <type category="struct" name="VkDeviceImageMemoryRequirements">
            <member values="VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                          <name>pNext</name></member>
            <member>const <type>VkImageCreateInfo</type>*                                                             <name>pCreateInfo</name></member>
            <member optional="true"><type>VkImageAspectFlagBits</type>                                                <name>planeAspect</name></member>
        </type>
        <type category="struct" name="VkDeviceImageMemoryRequirementsKHR" alias="VkDeviceImageMemoryRequirements"/>
        <type category="struct" name="VkMemoryRequirements2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkMemoryRequirements</type>                                                 <name>memoryRequirements</name></member>
        </type>
        <type category="struct" name="VkMemoryRequirements2KHR"                                alias="VkMemoryRequirements2"/>
        <type category="struct" name="VkSparseImageMemoryRequirements2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                       <name>pNext</name></member>
            <member><type>VkSparseImageMemoryRequirements</type>                                      <name>memoryRequirements</name></member>
        </type>
        <type category="struct" name="VkSparseImageMemoryRequirements2KHR"                     alias="VkSparseImageMemoryRequirements2"/>
        <type category="struct" name="VkPhysicalDevicePointClippingProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="exact"><type>VkPointClippingBehavior</type>     <name>pointClippingBehavior</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePointClippingPropertiesKHR"              alias="VkPhysicalDevicePointClippingProperties"/>
        <type category="struct" name="VkMemoryDedicatedRequirements" returnedonly="true" structextends="VkMemoryRequirements2">
            <member values="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>prefersDedicatedAllocation</name></member>
            <member><type>VkBool32</type>                         <name>requiresDedicatedAllocation</name></member>
        </type>
        <type category="struct" name="VkMemoryDedicatedRequirementsKHR"                        alias="VkMemoryDedicatedRequirements"/>
        <type category="struct" name="VkMemoryDedicatedAllocateInfo" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkImage</type>          <name>image</name><comment>Image that this allocation will be bound to</comment></member>
            <member optional="true"><type>VkBuffer</type>         <name>buffer</name><comment>Buffer that this allocation will be bound to</comment></member>
        </type>
        <type category="struct" name="VkMemoryDedicatedAllocateInfoKHR"                        alias="VkMemoryDedicatedAllocateInfo"/>
        <type category="struct" name="VkImageViewUsageCreateInfo" structextends="VkImageViewCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkImageUsageFlags</type> <name>usage</name></member>
        </type>
        <type category="struct" name="VkImageViewSlicedCreateInfoEXT" structextends="VkImageViewCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type> <name>sliceOffset</name></member>
            <member><type>uint32_t</type> <name>sliceCount</name></member>
        </type>
        <type category="struct" name="VkImageViewUsageCreateInfoKHR"                           alias="VkImageViewUsageCreateInfo"/>
        <type category="struct" name="VkPipelineTessellationDomainOriginStateCreateInfo" structextends="VkPipelineTessellationStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkTessellationDomainOrigin</type>    <name>domainOrigin</name></member>
        </type>
        <type category="struct" name="VkPipelineTessellationDomainOriginStateCreateInfoKHR"    alias="VkPipelineTessellationDomainOriginStateCreateInfo"/>
        <type category="struct" name="VkSamplerYcbcrConversionInfo" structextends="VkSamplerCreateInfo,VkImageViewCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkSamplerYcbcrConversion</type>      <name>conversion</name></member>
        </type>
        <type category="struct" name="VkSamplerYcbcrConversionInfoKHR"                         alias="VkSamplerYcbcrConversionInfo"/>
        <type category="struct" name="VkSamplerYcbcrConversionCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkFormat</type>                         <name>format</name></member>
            <member><type>VkSamplerYcbcrModelConversion</type> <name>ycbcrModel</name></member>
            <member><type>VkSamplerYcbcrRange</type>           <name>ycbcrRange</name></member>
            <member><type>VkComponentMapping</type>               <name>components</name></member>
            <member><type>VkChromaLocation</type>              <name>xChromaOffset</name></member>
            <member><type>VkChromaLocation</type>              <name>yChromaOffset</name></member>
            <member><type>VkFilter</type>                         <name>chromaFilter</name></member>
            <member><type>VkBool32</type>                         <name>forceExplicitReconstruction</name></member>
        </type>
        <type category="struct" name="VkSamplerYcbcrConversionCreateInfoKHR"                   alias="VkSamplerYcbcrConversionCreateInfo"/>
        <type category="struct" name="VkBindImagePlaneMemoryInfo" structextends="VkBindImageMemoryInfo">
            <member values="VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkImageAspectFlagBits</type>            <name>planeAspect</name></member>
        </type>
        <type category="struct" name="VkBindImagePlaneMemoryInfoKHR"                           alias="VkBindImagePlaneMemoryInfo"/>
        <type category="struct" name="VkImagePlaneMemoryRequirementsInfo" structextends="VkImageMemoryRequirementsInfo2">
            <member values="VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkImageAspectFlagBits</type>            <name>planeAspect</name></member>
        </type>
        <type category="struct" name="VkImagePlaneMemoryRequirementsInfoKHR"                   alias="VkImagePlaneMemoryRequirementsInfo"/>
        <type category="struct" name="VkPhysicalDeviceSamplerYcbcrConversionFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>samplerYcbcrConversion</name><comment>Sampler color conversion supported</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR"       alias="VkPhysicalDeviceSamplerYcbcrConversionFeatures"/>
        <type category="struct" name="VkSamplerYcbcrConversionImageFormatProperties" returnedonly="true" structextends="VkImageFormatProperties2">
            <member values="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>combinedImageSamplerDescriptorCount</name></member>
        </type>
        <type category="struct" name="VkSamplerYcbcrConversionImageFormatPropertiesKHR"        alias="VkSamplerYcbcrConversionImageFormatProperties"/>
        <type category="struct" name="VkTextureLODGatherFormatPropertiesAMD" returnedonly="true" structextends="VkImageFormatProperties2">
            <member values="VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>supportsTextureGatherLODBiasAMD</name></member>
        </type>
        <type category="struct" name="VkConditionalRenderingBeginInfoEXT">
            <member values="VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkBuffer</type>                         <name>buffer</name></member>
            <member><type>VkDeviceSize</type>                     <name>offset</name></member>
            <member optional="true"><type>VkConditionalRenderingFlagsEXT</type>    <name>flags</name></member>
        </type>
        <type category="struct" name="VkProtectedSubmitInfo" structextends="VkSubmitInfo">
            <member values="VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                     <name>pNext</name></member>
            <member><type>VkBool32</type>                        <name>protectedSubmit</name><comment>Submit protected command buffers</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceProtectedMemoryFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>protectedMemory</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceProtectedMemoryProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member limittype="exact"><type>VkBool32</type>                            <name>protectedNoFault</name></member>
        </type>
        <type category="struct" name="VkDeviceQueueInfo2">
            <member values="VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
            <member optional="true"><type>VkDeviceQueueCreateFlags</type>            <name>flags</name></member>
            <member><type>uint32_t</type>                            <name>queueFamilyIndex</name></member>
            <member><type>uint32_t</type>                            <name>queueIndex</name></member>
        </type>
        <type category="struct" name="VkPipelineCoverageToColorStateCreateInfoNV" structextends="VkPipelineMultisampleStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                                      <name>pNext</name></member>
            <member optional="true"><type>VkPipelineCoverageToColorStateCreateFlagsNV</type>                    <name>flags</name></member>
            <member><type>VkBool32</type>                         <name>coverageToColorEnable</name></member>
            <member optional="true"><type>uint32_t</type>         <name>coverageToColorLocation</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSamplerFilterMinmaxProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>filterMinmaxSingleComponentFormats</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>filterMinmaxImageComponentMapping</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT" alias="VkPhysicalDeviceSamplerFilterMinmaxProperties"/>
        <type category="struct" name="VkSampleLocationEXT">
            <member><type>float</type>                            <name>x</name></member>
            <member><type>float</type>                            <name>y</name></member>
        </type>
        <type category="struct" name="VkSampleLocationsInfoEXT" structextends="VkImageMemoryBarrier,VkImageMemoryBarrier2">
            <member values="VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
            <member noautovalidity="true"><type>VkSampleCountFlagBits</type>  <name>sampleLocationsPerPixel</name></member>
            <member><type>VkExtent2D</type>                             <name>sampleLocationGridSize</name></member>
            <member optional="true"><type>uint32_t</type>               <name>sampleLocationsCount</name></member>
            <member len="sampleLocationsCount">const <type>VkSampleLocationEXT</type>* <name>pSampleLocations</name></member>
        </type>
        <type category="struct" name="VkAttachmentSampleLocationsEXT">
            <member><type>uint32_t</type>                         <name>attachmentIndex</name></member>
            <member><type>VkSampleLocationsInfoEXT</type>         <name>sampleLocationsInfo</name></member>
        </type>
        <type category="struct" name="VkSubpassSampleLocationsEXT">
            <member><type>uint32_t</type>                         <name>subpassIndex</name></member>
            <member><type>VkSampleLocationsInfoEXT</type>         <name>sampleLocationsInfo</name></member>
        </type>
        <type category="struct" name="VkRenderPassSampleLocationsBeginInfoEXT" structextends="VkRenderPassBeginInfo">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>         <name>attachmentInitialSampleLocationsCount</name></member>
            <member len="attachmentInitialSampleLocationsCount">const <type>VkAttachmentSampleLocationsEXT</type>* <name>pAttachmentInitialSampleLocations</name></member>
            <member optional="true"><type>uint32_t</type>         <name>postSubpassSampleLocationsCount</name></member>
            <member len="postSubpassSampleLocationsCount">const <type>VkSubpassSampleLocationsEXT</type>* <name>pPostSubpassSampleLocations</name></member>
        </type>
        <type category="struct" name="VkPipelineSampleLocationsStateCreateInfoEXT" structextends="VkPipelineMultisampleStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>sampleLocationsEnable</name></member>
            <member><type>VkSampleLocationsInfoEXT</type>         <name>sampleLocationsInfo</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSampleLocationsPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="bitmask"><type>VkSampleCountFlags</type>               <name>sampleLocationSampleCounts</name></member>
            <member limittype="max"><type>VkExtent2D</type>                       <name>maxSampleLocationGridSize</name></member>
            <member limittype="range"><type>float</type>                            <name>sampleLocationCoordinateRange</name>[2]</member>
            <member limittype="bits"><type>uint32_t</type>                         <name>sampleLocationSubPixelBits</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>variableSampleLocations</name></member>
        </type>
        <type category="struct" name="VkMultisamplePropertiesEXT" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkExtent2D</type>                       <name>maxSampleLocationGridSize</name></member>
        </type>
        <type category="struct" name="VkSamplerReductionModeCreateInfo" structextends="VkSamplerCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkSamplerReductionMode</type>           <name>reductionMode</name></member>
        </type>
        <type category="struct" name="VkSamplerReductionModeCreateInfoEXT" alias="VkSamplerReductionModeCreateInfo"/>
        <type category="struct" name="VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>advancedBlendCoherentOperations</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMultiDrawFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*                     <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>multiDraw</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>advancedBlendMaxColorAttachments</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>advancedBlendIndependentBlend</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>advancedBlendNonPremultipliedSrcColor</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>advancedBlendNonPremultipliedDstColor</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>advancedBlendCorrelatedOverlap</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>advancedBlendAllOperations</name></member>
        </type>
        <type category="struct" name="VkPipelineColorBlendAdvancedStateCreateInfoEXT" structextends="VkPipelineColorBlendStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>               <name>srcPremultiplied</name></member>
            <member><type>VkBool32</type>               <name>dstPremultiplied</name></member>
            <member><type>VkBlendOverlapEXT</type>      <name>blendOverlap</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceInlineUniformBlockFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*  <name>pNext</name></member>
            <member><type>VkBool32</type>               <name>inlineUniformBlock</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingInlineUniformBlockUpdateAfterBind</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceInlineUniformBlockFeaturesEXT" alias="VkPhysicalDeviceInlineUniformBlockFeatures"/>
        <type category="struct" name="VkPhysicalDeviceInlineUniformBlockProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxInlineUniformBlockSize</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorInlineUniformBlocks</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetInlineUniformBlocks</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindInlineUniformBlocks</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceInlineUniformBlockPropertiesEXT" alias="VkPhysicalDeviceInlineUniformBlockProperties"/>
        <type category="struct" name="VkWriteDescriptorSetInlineUniformBlock" structextends="VkWriteDescriptorSet">
            <member values="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type>                    <name>dataSize</name></member>
            <member len="dataSize">const <type>void</type>*  <name>pData</name></member>
        </type>
        <type category="struct" name="VkWriteDescriptorSetInlineUniformBlockEXT" alias="VkWriteDescriptorSetInlineUniformBlock"/>
        <type category="struct" name="VkDescriptorPoolInlineUniformBlockCreateInfo" structextends="VkDescriptorPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type>                    <name>maxInlineUniformBlockBindings</name></member>
        </type>
        <type category="struct" name="VkDescriptorPoolInlineUniformBlockCreateInfoEXT" alias="VkDescriptorPoolInlineUniformBlockCreateInfo"/>
        <type category="struct" name="VkPipelineCoverageModulationStateCreateInfoNV" structextends="VkPipelineMultisampleStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                                      <name>pNext</name></member>
            <member optional="true"><type>VkPipelineCoverageModulationStateCreateFlagsNV</type>                   <name>flags</name></member>
            <member><type>VkCoverageModulationModeNV</type>                                                       <name>coverageModulationMode</name></member>
            <member><type>VkBool32</type>                                                                         <name>coverageModulationTableEnable</name></member>
            <member optional="true"><type>uint32_t</type>                                                         <name>coverageModulationTableCount</name></member>
            <member noautovalidity="true" optional="true" len="coverageModulationTableCount">const <type>float</type>* <name>pCoverageModulationTable</name></member>
        </type>
        <type category="struct" name="VkImageFormatListCreateInfo" structextends="VkImageCreateInfo,VkSwapchainCreateInfoKHR,VkPhysicalDeviceImageFormatInfo2">
            <member values="VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>               <name>viewFormatCount</name></member>
            <member len="viewFormatCount">const <type>VkFormat</type>*  <name>pViewFormats</name></member>
        </type>
        <type category="struct" name="VkImageFormatListCreateInfoKHR"                          alias="VkImageFormatListCreateInfo"/>
        <type category="struct" name="VkValidationCacheCreateInfoEXT">
            <member values="VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkValidationCacheCreateFlagsEXT</type>    <name>flags</name></member>
            <member optional="true"><type>size_t</type>                 <name>initialDataSize</name></member>
            <member len="initialDataSize">const <type>void</type>*            <name>pInitialData</name></member>
        </type>
        <type category="struct" name="VkShaderModuleValidationCacheCreateInfoEXT" structextends="VkShaderModuleCreateInfo,VkPipelineShaderStageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkValidationCacheEXT</type>    <name>validationCache</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMaintenance3Properties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxPerSetDescriptors</name></member>
            <member limittype="max"><type>VkDeviceSize</type>                     <name>maxMemoryAllocationSize</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMaintenance3PropertiesKHR"               alias="VkPhysicalDeviceMaintenance3Properties"/>
        <type category="struct" name="VkPhysicalDeviceMaintenance4Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                                         <name>maintenance4</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMaintenance4FeaturesKHR" alias="VkPhysicalDeviceMaintenance4Features"/>
        <type category="struct" name="VkPhysicalDeviceMaintenance4Properties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="max"><type>VkDeviceSize</type>                     <name>maxBufferSize</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMaintenance4PropertiesKHR" alias="VkPhysicalDeviceMaintenance4Properties"/>
        <type category="struct" name="VkPhysicalDeviceMaintenance5Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                                         <name>maintenance5</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMaintenance5FeaturesKHR" alias="VkPhysicalDeviceMaintenance5Features"/>
        <type category="struct" name="VkPhysicalDeviceMaintenance5Properties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>earlyFragmentMultisampleCoverageAfterSampleCounting</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>earlyFragmentSampleMaskTestBeforeSampleCounting</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>depthStencilSwizzleOneSupport</name></member>
            <member limittype="exact"><type>VkBool32</type>                       <name>polygonModePointSize</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>nonStrictSinglePixelWideLinesUseParallelogram</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>nonStrictWideLinesUseParallelogram</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMaintenance5PropertiesKHR" alias="VkPhysicalDeviceMaintenance5Properties"/>
        <type category="struct" name="VkPhysicalDeviceMaintenance6Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                                         <name>maintenance6</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMaintenance6FeaturesKHR" alias="VkPhysicalDeviceMaintenance6Features"/>
        <type category="struct" name="VkPhysicalDeviceMaintenance6Properties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>blockTexelViewCompatibleMultipleLayers</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxCombinedImageSamplerDescriptorCount</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>fragmentShadingRateClampCombinerInputs</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMaintenance6PropertiesKHR" alias="VkPhysicalDeviceMaintenance6Properties"/>
        <type category="struct" name="VkPhysicalDeviceMaintenance7FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                                         <name>maintenance7</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMaintenance7PropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>robustFragmentShadingRateAttachmentAccess</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>separateDepthStencilAttachmentAccess</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetTotalUniformBuffersDynamic</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetTotalStorageBuffersDynamic</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetTotalBuffersDynamic</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindTotalBuffersDynamic</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceLayeredApiPropertiesListKHR" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="noauto" optional="true"><type>uint32_t</type>      <name>layeredApiCount</name></member>
            <member limittype="struct" optional="true" len="layeredApiCount"><type>VkPhysicalDeviceLayeredApiPropertiesKHR</type>* <name>pLayeredApis</name><comment>Output list of layered implementations underneath the physical device</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceLayeredApiPropertiesKHR" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="noauto"><type>uint32_t</type>                      <name>vendorID</name></member>
            <member limittype="noauto"><type>uint32_t</type>                      <name>deviceID</name></member>
            <member limittype="noauto"><type>VkPhysicalDeviceLayeredApiKHR</type> <name>layeredAPI</name></member>
            <member limittype="noauto"><type>char</type>                          <name>deviceName</name>[<enum>VK_MAX_PHYSICAL_DEVICE_NAME_SIZE</enum>]</member>
        </type>
        <type category="struct" name="VkPhysicalDeviceLayeredApiVulkanPropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceLayeredApiPropertiesKHR" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="noauto"><type>VkPhysicalDeviceProperties2</type>   <name>properties</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMaintenance8FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                                         <name>maintenance8</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMaintenance9FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                                         <name>maintenance9</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMaintenance9PropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>                           <name>image2DViewOf3DSparse</name></member>
            <member limittype="exact"><type>VkDefaultVertexAttributeValueKHR</type> <name>defaultVertexAttributeValue</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMaintenance10PropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="exact"><type>VkBool32</type>                       <name>rgba4OpaqueBlackSwizzled</name></member>
            <member limittype="exact"><type>VkBool32</type>                       <name>resolveSrgbFormatAppliesTransferFunction</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>resolveSrgbFormatSupportsTransferFunctionControl</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMaintenance10FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                                         <name>maintenance10</name></member>
        </type>
        <type category="struct" name="VkQueueFamilyOwnershipTransferPropertiesKHR" returnedonly="true" structextends="VkQueueFamilyProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                                                     <name>pNext</name></member>
            <member limittype="bitmask"><type>uint32_t</type>                                                              <name>optimalImageTransferToQueueFamilies</name></member>
        </type>
        <type category="struct" name="VkRenderingAreaInfo">
            <member values="VK_STRUCTURE_TYPE_RENDERING_AREA_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
            <member><type>uint32_t</type>                                                                   <name>viewMask</name></member>
            <member optional="true"><type>uint32_t</type>                                                   <name>colorAttachmentCount</name></member>
            <member noautovalidity="true" len="colorAttachmentCount">const <type>VkFormat</type>*           <name>pColorAttachmentFormats</name></member>
            <member noautovalidity="true"><type>VkFormat</type>                                             <name>depthAttachmentFormat</name></member>
            <member noautovalidity="true"><type>VkFormat</type>                                             <name>stencilAttachmentFormat</name></member>
        </type>
        <type category="struct" name="VkRenderingAreaInfoKHR" alias="VkRenderingAreaInfo"/>
        <type category="struct" name="VkDescriptorSetLayoutSupport" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>         <name>supported</name></member>
        </type>
        <type category="struct" name="VkDescriptorSetLayoutSupportKHR"                         alias="VkDescriptorSetLayoutSupport"/>
        <type category="struct" name="VkPhysicalDeviceShaderDrawParametersFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>shaderDrawParameters</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderDrawParameterFeatures"             alias="VkPhysicalDeviceShaderDrawParametersFeatures"/>
        <type category="struct" name="VkPhysicalDeviceShaderFloat16Int8Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>shaderFloat16</name><comment>16-bit floats (halfs) in shaders</comment></member>
            <member><type>VkBool32</type>                         <name>shaderInt8</name><comment>8-bit integers in shaders</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderFloat16Int8FeaturesKHR"            alias="VkPhysicalDeviceShaderFloat16Int8Features"/>
        <type category="struct" name="VkPhysicalDeviceFloat16Int8FeaturesKHR"                  alias="VkPhysicalDeviceShaderFloat16Int8Features"/>
        <type category="struct" name="VkPhysicalDeviceFloatControlsProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="exact"><type>VkShaderFloatControlsIndependence</type> <name>denormBehaviorIndependence</name></member>
            <member limittype="exact"><type>VkShaderFloatControlsIndependence</type> <name>roundingModeIndependence</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>shaderSignedZeroInfNanPreserveFloat16</name><comment>An implementation can preserve signed zero, nan, inf</comment></member>
            <member limittype="max"><type>VkBool32</type>                         <name>shaderSignedZeroInfNanPreserveFloat32</name><comment>An implementation can preserve signed zero, nan, inf</comment></member>
            <member limittype="max"><type>VkBool32</type>                         <name>shaderSignedZeroInfNanPreserveFloat64</name><comment>An implementation can preserve signed zero, nan, inf</comment></member>
            <member limittype="max"><type>VkBool32</type>                         <name>shaderDenormPreserveFloat16</name><comment>An implementation can preserve  denormals</comment></member>
            <member limittype="max"><type>VkBool32</type>                         <name>shaderDenormPreserveFloat32</name><comment>An implementation can preserve  denormals</comment></member>
            <member limittype="max"><type>VkBool32</type>                         <name>shaderDenormPreserveFloat64</name><comment>An implementation can preserve  denormals</comment></member>
            <member limittype="max"><type>VkBool32</type>                         <name>shaderDenormFlushToZeroFloat16</name><comment>An implementation can flush to zero  denormals</comment></member>
            <member limittype="max"><type>VkBool32</type>                         <name>shaderDenormFlushToZeroFloat32</name><comment>An implementation can flush to zero  denormals</comment></member>
            <member limittype="max"><type>VkBool32</type>                         <name>shaderDenormFlushToZeroFloat64</name><comment>An implementation can flush to zero  denormals</comment></member>
            <member limittype="max"><type>VkBool32</type>                         <name>shaderRoundingModeRTEFloat16</name><comment>An implementation can support RTE</comment></member>
            <member limittype="max"><type>VkBool32</type>                         <name>shaderRoundingModeRTEFloat32</name><comment>An implementation can support RTE</comment></member>
            <member limittype="max"><type>VkBool32</type>                         <name>shaderRoundingModeRTEFloat64</name><comment>An implementation can support RTE</comment></member>
            <member limittype="max"><type>VkBool32</type>                         <name>shaderRoundingModeRTZFloat16</name><comment>An implementation can support RTZ</comment></member>
            <member limittype="max"><type>VkBool32</type>                         <name>shaderRoundingModeRTZFloat32</name><comment>An implementation can support RTZ</comment></member>
            <member limittype="max"><type>VkBool32</type>                         <name>shaderRoundingModeRTZFloat64</name><comment>An implementation can support RTZ</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFloatControlsPropertiesKHR"              alias="VkPhysicalDeviceFloatControlsProperties"/>
        <type category="struct" name="VkPhysicalDeviceHostQueryResetFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>hostQueryReset</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceHostQueryResetFeaturesEXT"               alias="VkPhysicalDeviceHostQueryResetFeatures"/>
        <type category="struct" name="VkNativeBufferUsage2ANDROID">
            <member><type>uint64_t</type> <name>consumer</name></member>
            <member><type>uint64_t</type> <name>producer</name></member>
        </type>
        <type category="struct" name="VkNativeBufferANDROID" structextends="VkImageCreateInfo,VkBindImageMemoryInfo">
            <member values="VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member>const <type>void</type>* <name>handle</name></member>
            <member><type>int</type> <name>stride</name></member>
            <member><type>int</type> <name>format</name></member>
            <member><type>int</type> <name>usage</name></member>
            <member><type>VkNativeBufferUsage2ANDROID</type> <name>usage2</name></member>
        </type>
        <type category="struct" name="VkSwapchainImageCreateInfoANDROID" structextends="VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkSwapchainImageUsageFlagsANDROID</type> <name>usage</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePresentationPropertiesANDROID" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type> <name>sharedImage</name></member>
        </type>
        <type category="struct" name="VkShaderResourceUsageAMD" returnedonly="true">
            <member><type>uint32_t</type> <name>numUsedVgprs</name></member>
            <member><type>uint32_t</type> <name>numUsedSgprs</name></member>
            <member><type>uint32_t</type> <name>ldsSizePerLocalWorkGroup</name></member>
            <member><type>size_t</type> <name>ldsUsageSizeInBytes</name></member>
            <member><type>size_t</type> <name>scratchMemUsageInBytes</name></member>
        </type>
        <type category="struct" name="VkShaderStatisticsInfoAMD" returnedonly="true">
            <member><type>VkShaderStageFlags</type> <name>shaderStageMask</name></member>
            <member><type>VkShaderResourceUsageAMD</type> <name>resourceUsage</name></member>
            <member><type>uint32_t</type> <name>numPhysicalVgprs</name></member>
            <member><type>uint32_t</type> <name>numPhysicalSgprs</name></member>
            <member><type>uint32_t</type> <name>numAvailableVgprs</name></member>
            <member><type>uint32_t</type> <name>numAvailableSgprs</name></member>
            <member><type>uint32_t</type> <name>computeWorkGroupSize</name>[3]</member>
        </type>
        <type category="struct" name="VkDeviceQueueGlobalPriorityCreateInfo" structextends="VkDeviceQueueCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
            <member><type>VkQueueGlobalPriority</type>          <name>globalPriority</name></member>
        </type>
        <type category="struct" name="VkDeviceQueueGlobalPriorityCreateInfoKHR" alias="VkDeviceQueueGlobalPriorityCreateInfo"/>
        <type category="struct" name="VkDeviceQueueGlobalPriorityCreateInfoEXT" alias="VkDeviceQueueGlobalPriorityCreateInfo"/>
        <type category="struct" name="VkPhysicalDeviceGlobalPriorityQueryFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type>                    <name>globalPriorityQuery</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR" alias="VkPhysicalDeviceGlobalPriorityQueryFeatures"/>
        <type category="struct" name="VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT" alias="VkPhysicalDeviceGlobalPriorityQueryFeatures"/>
        <type category="struct" name="VkQueueFamilyGlobalPriorityProperties" structextends="VkQueueFamilyProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                            <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>                                         <name>priorityCount</name></member>
            <member limittype="bitmask" len="priorityCount"><type>VkQueueGlobalPriority</type> <name>priorities</name>[<enum>VK_MAX_GLOBAL_PRIORITY_SIZE</enum>]</member>
        </type>
        <type category="struct" name="VkQueueFamilyGlobalPriorityPropertiesKHR" alias="VkQueueFamilyGlobalPriorityProperties"/>
        <type category="struct" name="VkQueueFamilyGlobalPriorityPropertiesEXT" alias="VkQueueFamilyGlobalPriorityProperties"/>
        <type category="struct" name="VkDebugUtilsObjectNameInfoEXT" structextends="VkPipelineShaderStageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
            <member><type>VkObjectType</type>                                           <name>objectType</name></member>
            <member objecttype="objectType"><type>uint64_t</type>                       <name>objectHandle</name></member>
            <member optional="true" len="null-terminated">const <type>char</type>*      <name>pObjectName</name></member>
        </type>
        <type category="struct" name="VkDebugUtilsObjectTagInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
            <member><type>VkObjectType</type>                           <name>objectType</name></member>
            <member objecttype="objectType" externsync="true"><type>uint64_t</type>                               <name>objectHandle</name></member>
            <member><type>uint64_t</type>                               <name>tagName</name></member>
            <member><type>size_t</type>                                 <name>tagSize</name></member>
            <member len="tagSize">const <type>void</type>*              <name>pTag</name></member>
        </type>
        <type category="struct" name="VkDebugUtilsLabelEXT">
            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
            <member len="null-terminated">const <type>char</type>*      <name>pLabelName</name></member>
            <member><type>float</type>                  <name>color</name>[4]</member>
        </type>
        <type category="struct" name="VkDebugUtilsMessengerCreateInfoEXT" allowduplicate="true" structextends="VkInstanceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                          <name>pNext</name></member>
            <member optional="true"><type>VkDebugUtilsMessengerCreateFlagsEXT</type>  <name>flags</name></member>
            <member><type>VkDebugUtilsMessageSeverityFlagsEXT</type>                  <name>messageSeverity</name></member>
            <member><type>VkDebugUtilsMessageTypeFlagsEXT</type>                      <name>messageType</name></member>
            <member><type>PFN_vkDebugUtilsMessengerCallbackEXT</type>                 <name>pfnUserCallback</name></member>
            <member optional="true"><type>void</type>*                                <name>pUserData</name></member>
        </type>
        <type category="struct" name="VkDebugUtilsMessengerCallbackDataEXT">
            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                        <name>pNext</name></member>
            <member optional="true"><type>VkDebugUtilsMessengerCallbackDataFlagsEXT</type>                          <name>flags</name></member>
            <member optional="true" len="null-terminated">const <type>char</type>*                                  <name>pMessageIdName</name></member>
            <member><type>int32_t</type>                                                            <name>messageIdNumber</name></member>
            <member optional="true" len="null-terminated">const <type>char</type>*                                  <name>pMessage</name></member>
            <member optional="true"><type>uint32_t</type>                                                           <name>queueLabelCount</name></member>
            <member len="queueLabelCount">const <type>VkDebugUtilsLabelEXT</type>*                  <name>pQueueLabels</name></member>
            <member optional="true"><type>uint32_t</type>                                                           <name>cmdBufLabelCount</name></member>
            <member len="cmdBufLabelCount">const <type>VkDebugUtilsLabelEXT</type>*                 <name>pCmdBufLabels</name></member>
            <member optional="true"><type>uint32_t</type>                                                           <name>objectCount</name></member>
            <member len="objectCount">const <type>VkDebugUtilsObjectNameInfoEXT</type>*             <name>pObjects</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDeviceMemoryReportFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type>                    <name>deviceMemoryReport</name></member>
        </type>
        <type category="struct" name="VkDeviceDeviceMemoryReportCreateInfoEXT" allowduplicate="true" structextends="VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*         <name>pNext</name></member>
            <member><type>VkDeviceMemoryReportFlagsEXT</type>        <name>flags</name></member>
            <member><type>PFN_vkDeviceMemoryReportCallbackEXT</type> <name>pfnUserCallback</name></member>
            <member><type>void</type>*                               <name>pUserData</name></member>
        </type>
        <type category="struct" name="VkDeviceMemoryReportCallbackDataEXT" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkDeviceMemoryReportFlagsEXT</type>     <name>flags</name></member>
            <member><type>VkDeviceMemoryReportEventTypeEXT</type> <name>type</name></member>
            <member><type>uint64_t</type>                         <name>memoryObjectId</name></member>
            <member><type>VkDeviceSize</type>                     <name>size</name></member>
            <member><type>VkObjectType</type>                     <name>objectType</name></member>
            <member objecttype="objectType"><type>uint64_t</type> <name>objectHandle</name></member>
            <member><type>uint32_t</type>                         <name>heapIndex</name></member>
        </type>
        <type category="struct" name="VkImportMemoryHostPointerInfoEXT" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
            <member><type>void</type>* <name>pHostPointer</name></member>
        </type>
        <type category="struct" name="VkMemoryHostPointerPropertiesEXT" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type> <name>memoryTypeBits</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalMemoryHostPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member limittype="min,pot"><type>VkDeviceSize</type> <name>minImportedHostPointerAlignment</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceConservativeRasterizationPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member limittype="exact"><type>float</type>                 <name>primitiveOverestimationSize</name><comment>The size in pixels the primitive is enlarged at each edge during conservative rasterization</comment></member>
            <member limittype="max"><type>float</type>                      <name>maxExtraPrimitiveOverestimationSize</name><comment>The maximum additional overestimation the client can specify in the pipeline state</comment></member>
            <member limittype="min,mul"><type>float</type>                   <name>extraPrimitiveOverestimationSizeGranularity</name><comment>The granularity of extra overestimation sizes the implementations supports between 0 and maxExtraOverestimationSize</comment></member>
            <member limittype="max"><type>VkBool32</type>                <name>primitiveUnderestimation</name><comment>true if the implementation supports conservative rasterization underestimation mode</comment></member>
            <member limittype="max"><type>VkBool32</type>                <name>conservativePointAndLineRasterization</name><comment>true if conservative rasterization also applies to points and lines</comment></member>
            <member limittype="exact"><type>VkBool32</type>              <name>degenerateTrianglesRasterized</name><comment>true if degenerate triangles (those with zero area after snap) are rasterized</comment></member>
            <member limittype="exact"><type>VkBool32</type>              <name>degenerateLinesRasterized</name><comment>true if degenerate lines (those with zero length after snap) are rasterized</comment></member>
            <member limittype="max"><type>VkBool32</type>                <name>fullyCoveredFragmentShaderInputVariable</name><comment>true if the implementation supports the FullyCoveredEXT SPIR-V builtin fragment shader input variable</comment></member>
            <member limittype="max"><type>VkBool32</type>                <name>conservativeRasterizationPostDepthCoverage</name><comment>true if the implementation supports both conservative rasterization and post depth coverage sample coverage mask</comment></member>
        </type>
        <type category="struct" name="VkCalibratedTimestampInfoKHR">
            <member values="VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkTimeDomainKHR</type>                        <name>timeDomain</name></member>
        </type>
        <type category="struct" name="VkCalibratedTimestampInfoEXT" alias="VkCalibratedTimestampInfoKHR"/>
        <type category="struct" name="VkPhysicalDeviceShaderCorePropertiesAMD" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member limittype="exact"><type>uint32_t</type> <name>shaderEngineCount</name><comment>number of shader engines</comment></member>
            <member limittype="exact"><type>uint32_t</type> <name>shaderArraysPerEngineCount</name><comment>number of shader arrays</comment></member>
            <member limittype="exact"><type>uint32_t</type> <name>computeUnitsPerShaderArray</name><comment>number of physical CUs per shader array</comment></member>
            <member limittype="exact"><type>uint32_t</type> <name>simdPerComputeUnit</name><comment>number of SIMDs per compute unit</comment></member>
            <member limittype="exact"><type>uint32_t</type> <name>wavefrontsPerSimd</name><comment>number of wavefront slots in each SIMD</comment></member>
            <member limittype="max"><type>uint32_t</type>      <name>wavefrontSize</name><comment>maximum number of threads per wavefront</comment></member>
            <member limittype="exact"><type>uint32_t</type> <name>sgprsPerSimd</name><comment>number of physical SGPRs per SIMD</comment></member>
            <member limittype="min"><type>uint32_t</type>      <name>minSgprAllocation</name><comment>minimum number of SGPRs that can be allocated by a wave</comment></member>
            <member limittype="max"><type>uint32_t</type>      <name>maxSgprAllocation</name><comment>number of available SGPRs</comment></member>
            <member limittype="min,mul"><type>uint32_t</type>   <name>sgprAllocationGranularity</name><comment>SGPRs are allocated in groups of this size</comment></member>
            <member limittype="exact"><type>uint32_t</type> <name>vgprsPerSimd</name><comment>number of physical VGPRs per SIMD</comment></member>
            <member limittype="min"><type>uint32_t</type>      <name>minVgprAllocation</name><comment>minimum number of VGPRs that can be allocated by a wave</comment></member>
            <member limittype="max"><type>uint32_t</type>      <name>maxVgprAllocation</name><comment>number of available VGPRs</comment></member>
            <member limittype="min,mul"><type>uint32_t</type>   <name>vgprAllocationGranularity</name><comment>VGPRs are allocated in groups of this size</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderCoreProperties2AMD" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name><comment>Pointer to next structure</comment></member>
            <member limittype="bitmask"><type>VkShaderCorePropertiesFlagsAMD</type> <name>shaderCoreFeatures</name><comment>features supported by the shader core</comment></member>
            <member limittype="max"><type>uint32_t</type> <name>activeComputeUnitCount</name><comment>number of active compute units across all shader engines/arrays</comment></member>
        </type>
        <type category="struct" name="VkPipelineRasterizationConservativeStateCreateInfoEXT" structextends="VkPipelineRasterizationStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                                      <name>pNext</name></member>
            <member optional="true"><type>VkPipelineRasterizationConservativeStateCreateFlagsEXT</type>           <name>flags</name><comment>Reserved</comment></member>
            <member><type>VkConservativeRasterizationModeEXT</type>                                               <name>conservativeRasterizationMode</name><comment>Conservative rasterization mode</comment></member>
            <member><type>float</type>                                                                            <name>extraPrimitiveOverestimationSize</name><comment>Extra overestimation to add to the primitive</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDescriptorIndexingFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>               <name>shaderInputAttachmentArrayDynamicIndexing</name></member>
            <member><type>VkBool32</type>               <name>shaderUniformTexelBufferArrayDynamicIndexing</name></member>
            <member><type>VkBool32</type>               <name>shaderStorageTexelBufferArrayDynamicIndexing</name></member>
            <member><type>VkBool32</type>               <name>shaderUniformBufferArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>               <name>shaderSampledImageArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>               <name>shaderStorageBufferArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>               <name>shaderStorageImageArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>               <name>shaderInputAttachmentArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>               <name>shaderUniformTexelBufferArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>               <name>shaderStorageTexelBufferArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingUniformBufferUpdateAfterBind</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingSampledImageUpdateAfterBind</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingStorageImageUpdateAfterBind</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingStorageBufferUpdateAfterBind</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingUniformTexelBufferUpdateAfterBind</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingStorageTexelBufferUpdateAfterBind</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingUpdateUnusedWhilePending</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingPartiallyBound</name></member>
            <member><type>VkBool32</type>               <name>descriptorBindingVariableDescriptorCount</name></member>
            <member><type>VkBool32</type>               <name>runtimeDescriptorArray</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"           alias="VkPhysicalDeviceDescriptorIndexingFeatures"/>
        <type category="struct" name="VkPhysicalDeviceDescriptorIndexingProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxUpdateAfterBindDescriptorsInAllPools</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>shaderUniformBufferArrayNonUniformIndexingNative</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>shaderSampledImageArrayNonUniformIndexingNative</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>shaderStorageBufferArrayNonUniformIndexingNative</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>shaderStorageImageArrayNonUniformIndexingNative</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>shaderInputAttachmentArrayNonUniformIndexingNative</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>robustBufferAccessUpdateAfterBind</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>quadDivergentImplicitLod</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindSamplers</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindUniformBuffers</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindStorageBuffers</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindSampledImages</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindStorageImages</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindInputAttachments</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageUpdateAfterBindResources</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindSamplers</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindUniformBuffers</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindUniformBuffersDynamic</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindStorageBuffers</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindStorageBuffersDynamic</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindSampledImages</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindStorageImages</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindInputAttachments</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDescriptorIndexingPropertiesEXT"         alias="VkPhysicalDeviceDescriptorIndexingProperties"/>
        <type category="struct" name="VkDescriptorSetLayoutBindingFlagsCreateInfo" structextends="VkDescriptorSetLayoutCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                        <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                                           <name>bindingCount</name></member>
            <member len="bindingCount" optional="false,true">const <type>VkDescriptorBindingFlags</type>* <name>pBindingFlags</name></member>
        </type>
        <type category="struct" name="VkDescriptorSetLayoutBindingFlagsCreateInfoEXT"          alias="VkDescriptorSetLayoutBindingFlagsCreateInfo"/>
        <type category="struct" name="VkDescriptorSetVariableDescriptorCountAllocateInfo" structextends="VkDescriptorSetAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>               <name>descriptorSetCount</name></member>
            <member len="descriptorSetCount">const <type>uint32_t</type>* <name>pDescriptorCounts</name></member>
        </type>
        <type category="struct" name="VkDescriptorSetVariableDescriptorCountAllocateInfoEXT"   alias="VkDescriptorSetVariableDescriptorCountAllocateInfo"/>
        <type category="struct" name="VkDescriptorSetVariableDescriptorCountLayoutSupport" structextends="VkDescriptorSetLayoutSupport" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>uint32_t</type>         <name>maxVariableDescriptorCount</name></member>
        </type>
        <type category="struct" name="VkDescriptorSetVariableDescriptorCountLayoutSupportEXT"  alias="VkDescriptorSetVariableDescriptorCountLayoutSupport"/>
        <type category="struct" name="VkAttachmentDescription2">
            <member values="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkAttachmentDescriptionFlags</type> <name>flags</name></member>
            <member><type>VkFormat</type>                                     <name>format</name></member>
            <member><type>VkSampleCountFlagBits</type>                        <name>samples</name></member>
            <member><type>VkAttachmentLoadOp</type>                           <name>loadOp</name><comment>Load operation for color or depth data</comment></member>
            <member><type>VkAttachmentStoreOp</type>                          <name>storeOp</name><comment>Store operation for color or depth data</comment></member>
            <member><type>VkAttachmentLoadOp</type>                           <name>stencilLoadOp</name><comment>Load operation for stencil data</comment></member>
            <member><type>VkAttachmentStoreOp</type>                          <name>stencilStoreOp</name><comment>Store operation for stencil data</comment></member>
            <member><type>VkImageLayout</type>                                <name>initialLayout</name></member>
            <member><type>VkImageLayout</type>                                <name>finalLayout</name></member>
        </type>
        <type category="struct" name="VkAttachmentDescription2KHR"                             alias="VkAttachmentDescription2"/>
        <type category="struct" name="VkAttachmentReference2">
            <member values="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type>                          <name>attachment</name></member>
            <member><type>VkImageLayout</type>                     <name>layout</name></member>
            <member noautovalidity="true"><type>VkImageAspectFlags</type> <name>aspectMask</name></member>
        </type>
        <type category="struct" name="VkAttachmentReference2KHR"                               alias="VkAttachmentReference2"/>
        <type category="struct" name="VkSubpassDescription2">
            <member values="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                           <name>pNext</name></member>
            <member optional="true"><type>VkSubpassDescriptionFlags</type>                   <name>flags</name></member>
            <member><type>VkPipelineBindPoint</type>                                         <name>pipelineBindPoint</name></member>
            <member><type>uint32_t</type>                                                    <name>viewMask</name></member>
            <member optional="true"><type>uint32_t</type>                                    <name>inputAttachmentCount</name></member>
            <member len="inputAttachmentCount">const <type>VkAttachmentReference2</type>*    <name>pInputAttachments</name></member>
            <member optional="true"><type>uint32_t</type>                                    <name>colorAttachmentCount</name></member>
            <member len="colorAttachmentCount">const <type>VkAttachmentReference2</type>*    <name>pColorAttachments</name></member>
            <member optional="true" len="colorAttachmentCount">const <type>VkAttachmentReference2</type>* <name>pResolveAttachments</name></member>
            <member optional="true">const <type>VkAttachmentReference2</type>*               <name>pDepthStencilAttachment</name></member>
            <member optional="true"><type>uint32_t</type>                                    <name>preserveAttachmentCount</name></member>
            <member len="preserveAttachmentCount">const <type>uint32_t</type>*               <name>pPreserveAttachments</name></member>
        </type>
        <type category="struct" name="VkSubpassDescription2KHR"                                alias="VkSubpassDescription2"/>
        <type category="struct" name="VkSubpassDependency2">
            <member values="VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type>                          <name>srcSubpass</name></member>
            <member><type>uint32_t</type>                          <name>dstSubpass</name></member>
            <member optional="true"><type>VkPipelineStageFlags</type> <name>srcStageMask</name></member>
            <member optional="true"><type>VkPipelineStageFlags</type> <name>dstStageMask</name></member>
            <member optional="true"><type>VkAccessFlags</type>     <name>srcAccessMask</name></member>
            <member optional="true"><type>VkAccessFlags</type>     <name>dstAccessMask</name></member>
            <member optional="true"><type>VkDependencyFlags</type> <name>dependencyFlags</name></member>
            <member><type>int32_t</type>                           <name>viewOffset</name></member>
        </type>
        <type category="struct" name="VkSubpassDependency2KHR"                                 alias="VkSubpassDependency2"/>
        <type category="struct" name="VkRenderPassCreateInfo2">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                              <name>pNext</name></member>
            <member optional="true"><type>VkRenderPassCreateFlags</type>                  <name>flags</name></member>
            <member optional="true"><type>uint32_t</type>                                 <name>attachmentCount</name></member>
            <member len="attachmentCount">const <type>VkAttachmentDescription2</type>*    <name>pAttachments</name></member>
            <member><type>uint32_t</type>                                                 <name>subpassCount</name></member>
            <member len="subpassCount">const <type>VkSubpassDescription2</type>*          <name>pSubpasses</name></member>
            <member optional="true"><type>uint32_t</type>                                 <name>dependencyCount</name></member>
            <member len="dependencyCount">const <type>VkSubpassDependency2</type>*        <name>pDependencies</name></member>
            <member optional="true"><type>uint32_t</type>                                 <name>correlatedViewMaskCount</name></member>
            <member len="correlatedViewMaskCount">const <type>uint32_t</type>*            <name>pCorrelatedViewMasks</name></member>
        </type>
        <type category="struct" name="VkRenderPassCreateInfo2KHR"                              alias="VkRenderPassCreateInfo2"/>
        <type category="struct" name="VkSubpassBeginInfo">
            <member values="VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkSubpassContents</type>      <name>contents</name></member>
        </type>
        <type category="struct" name="VkSubpassBeginInfoKHR"                                   alias="VkSubpassBeginInfo"/>
        <type category="struct" name="VkSubpassEndInfo">
            <member values="VK_STRUCTURE_TYPE_SUBPASS_END_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
        </type>
        <type category="struct" name="VkSubpassEndInfoKHR"                                     alias="VkSubpassEndInfo"/>
        <type category="struct" name="VkPhysicalDeviceTimelineSemaphoreFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member><type>VkBool32</type>               <name>timelineSemaphore</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceTimelineSemaphoreFeaturesKHR"            alias="VkPhysicalDeviceTimelineSemaphoreFeatures"/>
        <type category="struct" name="VkPhysicalDeviceTimelineSemaphoreProperties" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member limittype="max"><type>uint64_t</type>               <name>maxTimelineSemaphoreValueDifference</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceTimelineSemaphorePropertiesKHR"          alias="VkPhysicalDeviceTimelineSemaphoreProperties"/>
        <type category="struct" name="VkSemaphoreTypeCreateInfo" structextends="VkSemaphoreCreateInfo,VkPhysicalDeviceExternalSemaphoreInfo">
            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkSemaphoreType</type>        <name>semaphoreType</name></member>
            <member><type>uint64_t</type>               <name>initialValue</name></member>
        </type>
        <type category="struct" name="VkSemaphoreTypeCreateInfoKHR"                            alias="VkSemaphoreTypeCreateInfo"/>
        <type category="struct" name="VkTimelineSemaphoreSubmitInfo" structextends="VkSubmitInfo,VkBindSparseInfo">
            <member values="VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>         <name>waitSemaphoreValueCount</name></member>
            <member optional="true" len="waitSemaphoreValueCount">const <type>uint64_t</type>* <name>pWaitSemaphoreValues</name></member>
            <member optional="true"><type>uint32_t</type>         <name>signalSemaphoreValueCount</name></member>
            <member optional="true" len="signalSemaphoreValueCount">const <type>uint64_t</type>* <name>pSignalSemaphoreValues</name></member>
        </type>
        <type category="struct" name="VkTimelineSemaphoreSubmitInfoKHR"                        alias="VkTimelineSemaphoreSubmitInfo"/>
        <type category="struct" name="VkSemaphoreWaitInfo">
            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkSemaphoreWaitFlags</type> <name>flags</name></member>
            <member><type>uint32_t</type>               <name>semaphoreCount</name></member>
            <member len="semaphoreCount">const <type>VkSemaphore</type>* <name>pSemaphores</name></member>
            <member len="semaphoreCount">const <type>uint64_t</type>*    <name>pValues</name></member>
        </type>
        <type category="struct" name="VkSemaphoreWaitInfoKHR"                                  alias="VkSemaphoreWaitInfo"/>
        <type category="struct" name="VkSemaphoreSignalInfo">
            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkSemaphore</type>            <name>semaphore</name></member>
            <member><type>uint64_t</type>               <name>value</name></member>
        </type>
        <type category="struct" name="VkSemaphoreSignalInfoKHR"                                alias="VkSemaphoreSignalInfo"/>
        <type category="struct" name="VkVertexInputBindingDivisorDescription">
            <member><type>uint32_t</type>          <name>binding</name></member>
            <member><type>uint32_t</type>          <name>divisor</name></member>
        </type>
        <type category="struct" name="VkVertexInputBindingDivisorDescriptionKHR" alias="VkVertexInputBindingDivisorDescription"/>
        <type category="struct" name="VkVertexInputBindingDivisorDescriptionEXT" alias="VkVertexInputBindingDivisorDescription"/>
        <type category="struct" name="VkPipelineVertexInputDivisorStateCreateInfo" structextends="VkPipelineVertexInputStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
            <member><type>uint32_t</type>                            <name>vertexBindingDivisorCount</name></member>
            <member len="vertexBindingDivisorCount">const <type>VkVertexInputBindingDivisorDescription</type>*         <name>pVertexBindingDivisors</name></member>
        </type>
        <type category="struct" name="VkPipelineVertexInputDivisorStateCreateInfoKHR" alias="VkPipelineVertexInputDivisorStateCreateInfo"/>
        <type category="struct" name="VkPipelineVertexInputDivisorStateCreateInfoEXT" alias="VkPipelineVertexInputDivisorStateCreateInfo"/>
        <type category="struct" name="VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxVertexAttribDivisor</name><comment>max value of vertex attribute divisor</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVertexAttributeDivisorProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxVertexAttribDivisor</name><comment>max value of vertex attribute divisor</comment></member>
            <member limittype="max"><type>VkBool32</type>               <name>supportsNonZeroFirstInstance</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR" alias="VkPhysicalDeviceVertexAttributeDivisorProperties"/>
        <type category="struct" name="VkPhysicalDevicePCIBusInfoPropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member limittype="noauto"><type>uint32_t</type>               <name>pciDomain</name></member>
            <member limittype="noauto"><type>uint32_t</type>               <name>pciBus</name></member>
            <member limittype="noauto"><type>uint32_t</type>               <name>pciDevice</name></member>
            <member limittype="noauto"><type>uint32_t</type>               <name>pciFunction</name></member>
        </type>
        <type category="struct" name="VkImportAndroidHardwareBufferInfoANDROID" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
            <member>struct <type>AHardwareBuffer</type>*            <name>buffer</name></member>
        </type>
        <type category="struct" name="VkAndroidHardwareBufferUsageANDROID" structextends="VkImageFormatProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member><type>uint64_t</type>                           <name>androidHardwareBufferUsage</name></member>
        </type>
        <type category="struct" name="VkAndroidHardwareBufferPropertiesANDROID" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member><type>VkDeviceSize</type>                       <name>allocationSize</name></member>
            <member><type>uint32_t</type>                           <name>memoryTypeBits</name></member>
        </type>
        <type category="struct" name="VkMemoryGetAndroidHardwareBufferInfoANDROID">
            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
            <member><type>VkDeviceMemory</type>                     <name>memory</name></member>
        </type>
        <type category="struct" name="VkAndroidHardwareBufferFormatPropertiesANDROID" structextends="VkAndroidHardwareBufferPropertiesANDROID" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member><type>VkFormat</type>                           <name>format</name></member>
            <member><type>uint64_t</type>                           <name>externalFormat</name></member>
            <member><type>VkFormatFeatureFlags</type>               <name>formatFeatures</name></member>
            <member><type>VkComponentMapping</type>                 <name>samplerYcbcrConversionComponents</name></member>
            <member><type>VkSamplerYcbcrModelConversion</type>      <name>suggestedYcbcrModel</name></member>
            <member><type>VkSamplerYcbcrRange</type>                <name>suggestedYcbcrRange</name></member>
            <member><type>VkChromaLocation</type>                   <name>suggestedXChromaOffset</name></member>
            <member><type>VkChromaLocation</type>                   <name>suggestedYChromaOffset</name></member>
        </type>
        <type category="struct" name="VkCommandBufferInheritanceConditionalRenderingInfoEXT" structextends="VkCommandBufferInheritanceInfo">
            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>conditionalRenderingEnable</name><comment>Whether this secondary command buffer may be executed during an active conditional rendering</comment></member>
        </type>
        <type category="struct" name="VkExternalFormatANDROID" structextends="VkImageCreateInfo,VkSamplerYcbcrConversionCreateInfo,VkAttachmentDescription2,VkGraphicsPipelineCreateInfo,VkCommandBufferInheritanceInfo">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member><type>uint64_t</type>                           <name>externalFormat</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevice8BitStorageFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>storageBuffer8BitAccess</name><comment>8-bit integer variables supported in StorageBuffer</comment></member>
            <member><type>VkBool32</type>                         <name>uniformAndStorageBuffer8BitAccess</name><comment>8-bit integer variables supported in StorageBuffer and Uniform</comment></member>
            <member><type>VkBool32</type>                         <name>storagePushConstant8</name><comment>8-bit integer variables supported in PushConstant</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDevice8BitStorageFeaturesKHR"                  alias="VkPhysicalDevice8BitStorageFeatures"/>
        <type category="struct" name="VkPhysicalDeviceConditionalRenderingFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>conditionalRendering</name></member>
            <member><type>VkBool32</type>                           <name>inheritedConditionalRendering</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVulkanMemoryModelFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>vulkanMemoryModel</name></member>
            <member><type>VkBool32</type>                         <name>vulkanMemoryModelDeviceScope</name></member>
            <member><type>VkBool32</type>                         <name>vulkanMemoryModelAvailabilityVisibilityChains</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVulkanMemoryModelFeaturesKHR"            alias="VkPhysicalDeviceVulkanMemoryModelFeatures"/>
        <type category="struct" name="VkPhysicalDeviceShaderAtomicInt64Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>shaderBufferInt64Atomics</name></member>
            <member><type>VkBool32</type>                            <name>shaderSharedInt64Atomics</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderAtomicInt64FeaturesKHR"            alias="VkPhysicalDeviceShaderAtomicInt64Features"/>
        <type category="struct" name="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>shaderBufferFloat32Atomics</name></member>
            <member><type>VkBool32</type>                            <name>shaderBufferFloat32AtomicAdd</name></member>
            <member><type>VkBool32</type>                            <name>shaderBufferFloat64Atomics</name></member>
            <member><type>VkBool32</type>                            <name>shaderBufferFloat64AtomicAdd</name></member>
            <member><type>VkBool32</type>                            <name>shaderSharedFloat32Atomics</name></member>
            <member><type>VkBool32</type>                            <name>shaderSharedFloat32AtomicAdd</name></member>
            <member><type>VkBool32</type>                            <name>shaderSharedFloat64Atomics</name></member>
            <member><type>VkBool32</type>                            <name>shaderSharedFloat64AtomicAdd</name></member>
            <member><type>VkBool32</type>                            <name>shaderImageFloat32Atomics</name></member>
            <member><type>VkBool32</type>                            <name>shaderImageFloat32AtomicAdd</name></member>
            <member><type>VkBool32</type>                            <name>sparseImageFloat32Atomics</name></member>
            <member><type>VkBool32</type>                            <name>sparseImageFloat32AtomicAdd</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>shaderBufferFloat16Atomics</name></member>
            <member><type>VkBool32</type>                            <name>shaderBufferFloat16AtomicAdd</name></member>
            <member><type>VkBool32</type>                            <name>shaderBufferFloat16AtomicMinMax</name></member>
            <member><type>VkBool32</type>                            <name>shaderBufferFloat32AtomicMinMax</name></member>
            <member><type>VkBool32</type>                            <name>shaderBufferFloat64AtomicMinMax</name></member>
            <member><type>VkBool32</type>                            <name>shaderSharedFloat16Atomics</name></member>
            <member><type>VkBool32</type>                            <name>shaderSharedFloat16AtomicAdd</name></member>
            <member><type>VkBool32</type>                            <name>shaderSharedFloat16AtomicMinMax</name></member>
            <member><type>VkBool32</type>                            <name>shaderSharedFloat32AtomicMinMax</name></member>
            <member><type>VkBool32</type>                            <name>shaderSharedFloat64AtomicMinMax</name></member>
            <member><type>VkBool32</type>                            <name>shaderImageFloat32AtomicMinMax</name></member>
            <member><type>VkBool32</type>                            <name>sparseImageFloat32AtomicMinMax</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVertexAttributeDivisorFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>vertexAttributeInstanceRateDivisor</name></member>
            <member><type>VkBool32</type>                           <name>vertexAttributeInstanceRateZeroDivisor</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR" alias="VkPhysicalDeviceVertexAttributeDivisorFeatures"/>
        <type category="struct" name="VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT" alias="VkPhysicalDeviceVertexAttributeDivisorFeatures"/>
        <type category="struct" name="VkQueueFamilyCheckpointPropertiesNV" structextends="VkQueueFamilyProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*           <name>pNext</name></member>
            <member limittype="bitmask"><type>VkPipelineStageFlags</type> <name>checkpointExecutionStageMask</name></member>
        </type>
        <type category="struct" name="VkCheckpointDataNV" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member><type>VkPipelineStageFlagBits</type>   <name>stage</name></member>
            <member noautovalidity="true"><type>void</type>* <name>pCheckpointMarker</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDepthStencilResolveProperties" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                <name>pNext</name></member>
            <member limittype="bitmask"><type>VkResolveModeFlags</type>                   <name>supportedDepthResolveModes</name><comment>supported depth resolve modes</comment></member>
            <member limittype="bitmask"><type>VkResolveModeFlags</type>                   <name>supportedStencilResolveModes</name><comment>supported stencil resolve modes</comment></member>
            <member limittype="max"><type>VkBool32</type>                             <name>independentResolveNone</name><comment>depth and stencil resolve modes can be set independently if one of them is none</comment></member>
            <member limittype="max"><type>VkBool32</type>                             <name>independentResolve</name><comment>depth and stencil resolve modes can be set independently</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDepthStencilResolvePropertiesKHR"        alias="VkPhysicalDeviceDepthStencilResolveProperties"/>
        <type category="struct" name="VkSubpassDescriptionDepthStencilResolve" structextends="VkSubpassDescription2">
            <member values="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                              <name>pNext</name></member>
            <member noautovalidity="true"><type>VkResolveModeFlagBits</type>              <name>depthResolveMode</name><comment>depth resolve mode</comment></member>
            <member noautovalidity="true"><type>VkResolveModeFlagBits</type>              <name>stencilResolveMode</name><comment>stencil resolve mode</comment></member>
            <member optional="true">const <type>VkAttachmentReference2</type>*            <name>pDepthStencilResolveAttachment</name><comment>depth/stencil resolve attachment</comment></member>
        </type>
        <type category="struct" name="VkSubpassDescriptionDepthStencilResolveKHR"              alias="VkSubpassDescriptionDepthStencilResolve"/>
        <type category="struct" name="VkImageViewASTCDecodeModeEXT" structextends="VkImageViewCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkFormat</type>                         <name>decodeMode</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceASTCDecodeFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>decodeModeSharedExponent</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceTransformFeedbackFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member><type>VkBool32</type>               <name>transformFeedback</name></member>
            <member><type>VkBool32</type>               <name>geometryStreams</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceTransformFeedbackPropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxTransformFeedbackStreams</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxTransformFeedbackBuffers</name></member>
            <member limittype="max"><type>VkDeviceSize</type>           <name>maxTransformFeedbackBufferSize</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxTransformFeedbackStreamDataSize</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxTransformFeedbackBufferDataSize</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxTransformFeedbackBufferDataStride</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>transformFeedbackQueries</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>transformFeedbackStreamsLinesTriangles</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>transformFeedbackRasterizationStreamSelect</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>transformFeedbackDraw</name></member>
        </type>
        <type category="struct" name="VkPipelineRasterizationStateStreamCreateInfoEXT" structextends="VkPipelineRasterizationStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                                      <name>pNext</name></member>
            <member optional="true"><type>VkPipelineRasterizationStateStreamCreateFlagsEXT</type>                 <name>flags</name></member>
            <member><type>uint32_t</type>                                                                         <name>rasterizationStream</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                       <name>representativeFragmentTest</name></member>
        </type>
        <type category="struct" name="VkPipelineRepresentativeFragmentTestStateCreateInfoNV" structextends="VkGraphicsPipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>       <name>representativeFragmentTestEnable</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExclusiveScissorFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>exclusiveScissor</name></member>
        </type>
        <type category="struct" name="VkPipelineViewportExclusiveScissorStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                       <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                                          <name>exclusiveScissorCount</name></member>
            <member noautovalidity="true" len="exclusiveScissorCount">const <type>VkRect2D</type>* <name>pExclusiveScissors</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCornerSampledImageFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>cornerSampledImage</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>computeDerivativeGroupQuads</name></member>
            <member><type>VkBool32</type>                         <name>computeDerivativeGroupLinear</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceComputeShaderDerivativesFeaturesNV" alias="VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR"/>
        <type category="struct" name="VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>meshAndTaskShaderDerivatives</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV"   alias="VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR"/>
        <type category="struct" name="VkPhysicalDeviceShaderImageFootprintFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>imageFootprint</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>dedicatedAllocationImageAliasing</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>indirectMemoryCopy</name></member>
            <member><type>VkBool32</type>                         <name>indirectMemoryToImageCopy</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCopyMemoryIndirectFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>indirectCopy</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*     <name>pNext</name></member>
            <member limittype="bitmask" noautovalidity="true"><type>VkQueueFlags</type>        <name>supportedQueues</name><comment>Bitmask of VkQueueFlagBits indicating the family of queues that support indirect copy</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCopyMemoryIndirectPropertiesNV" alias="VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR"/>
        <type category="struct" name="VkPhysicalDeviceMemoryDecompressionFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*       <name>pNext</name></member>
            <member><type>VkBool32</type>                    <name>memoryDecompression</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMemoryDecompressionFeaturesNV" alias="VkPhysicalDeviceMemoryDecompressionFeaturesEXT"/>
        <type category="struct" name="VkPhysicalDeviceMemoryDecompressionPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*     <name>pNext</name></member>
            <member limittype="bitmask"><type>VkMemoryDecompressionMethodFlagsEXT</type>    <name>decompressionMethods</name></member>
            <member limittype="max"><type>uint64_t</type>             <name>maxDecompressionIndirectCount</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMemoryDecompressionPropertiesNV" alias="VkPhysicalDeviceMemoryDecompressionPropertiesEXT"/>
        <type category="struct" name="VkShadingRatePaletteNV">
            <member><type>uint32_t</type>                                                               <name>shadingRatePaletteEntryCount</name></member>
            <member len="shadingRatePaletteEntryCount">const <type>VkShadingRatePaletteEntryNV</type>*  <name>pShadingRatePaletteEntries</name></member>
        </type>
        <type category="struct" name="VkPipelineViewportShadingRateImageStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                             <name>pNext</name></member>
            <member><type>VkBool32</type>                                                                <name>shadingRateImageEnable</name></member>
            <member optional="true"><type>uint32_t</type>                                                <name>viewportCount</name></member>
            <member noautovalidity="true" len="viewportCount">const <type>VkShadingRatePaletteNV</type>* <name>pShadingRatePalettes</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShadingRateImageFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>shadingRateImage</name></member>
            <member><type>VkBool32</type>                            <name>shadingRateCoarseSampleOrder</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShadingRateImagePropertiesNV" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member limittype="exact"><type>VkExtent2D</type>                     <name>shadingRateTexelSize</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>shadingRatePaletteSize</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>shadingRateMaxCoarseSamples</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceInvocationMaskFeaturesHUAWEI" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>invocationMask</name></member>
        </type>
        <type category="struct" name="VkCoarseSampleLocationNV">
            <member><type>uint32_t</type>                            <name>pixelX</name></member>
            <member><type>uint32_t</type>                            <name>pixelY</name></member>
            <member><type>uint32_t</type>                            <name>sample</name></member>
        </type>
        <type category="struct" name="VkCoarseSampleOrderCustomNV">
            <member><type>VkShadingRatePaletteEntryNV</type>         <name>shadingRate</name></member>
            <member><type>uint32_t</type>                            <name>sampleCount</name></member>
            <member><type>uint32_t</type>                            <name>sampleLocationCount</name></member>
            <member len="sampleLocationCount">const <type>VkCoarseSampleLocationNV</type>* <name>pSampleLocations</name></member>
        </type>
        <type category="struct" name="VkPipelineViewportCoarseSampleOrderStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                            <name>pNext</name></member>
            <member><type>VkCoarseSampleOrderTypeNV</type>                                              <name>sampleOrderType</name></member>
            <member optional="true"><type>uint32_t</type>                                               <name>customSampleOrderCount</name></member>
            <member len="customSampleOrderCount">const <type>VkCoarseSampleOrderCustomNV</type>*        <name>pCustomSampleOrders</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMeshShaderFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member featurelink="taskShaderNV"><type>VkBool32</type>                            <name>taskShader</name></member>
            <member featurelink="meshShaderNV"><type>VkBool32</type>                            <name>meshShader</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMeshShaderPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxDrawMeshTasksCount</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskWorkGroupInvocations</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskWorkGroupSize</name>[3]</member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskTotalMemorySize</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskOutputCount</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshWorkGroupInvocations</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshWorkGroupSize</name>[3]</member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshTotalMemorySize</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshOutputVertices</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshOutputPrimitives</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshMultiviewViewCount</name></member>
            <member limittype="min,mul"><type>uint32_t</type>                         <name>meshOutputPerVertexGranularity</name></member>
            <member limittype="min,mul"><type>uint32_t</type>                         <name>meshOutputPerPrimitiveGranularity</name></member>
        </type>
        <type category="struct" name="VkDrawMeshTasksIndirectCommandNV">
            <member><type>uint32_t</type>               <name>taskCount</name></member>
            <member><type>uint32_t</type>               <name>firstTask</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMeshShaderFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>taskShader</name></member>
            <member><type>VkBool32</type>                            <name>meshShader</name></member>
            <member><type>VkBool32</type>                            <name>multiviewMeshShader</name></member>
            <member><type>VkBool32</type>                            <name>primitiveFragmentShadingRateMeshShader</name></member>
            <member><type>VkBool32</type>                            <name>meshShaderQueries</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMeshShaderPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskWorkGroupTotalCount</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskWorkGroupCount</name>[3]</member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskWorkGroupInvocations</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskWorkGroupSize</name>[3]</member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskPayloadSize</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskSharedMemorySize</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskPayloadAndSharedMemorySize</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshWorkGroupTotalCount</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshWorkGroupCount</name>[3]</member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshWorkGroupInvocations</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshWorkGroupSize</name>[3]</member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshSharedMemorySize</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshPayloadAndSharedMemorySize</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshOutputMemorySize</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshPayloadAndOutputMemorySize</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshOutputComponents</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshOutputVertices</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshOutputPrimitives</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshOutputLayers</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshMultiviewViewCount</name></member>
            <member limittype="noauto"><type>uint32_t</type>                         <name>meshOutputPerVertexGranularity</name></member>
            <member limittype="noauto"><type>uint32_t</type>                         <name>meshOutputPerPrimitiveGranularity</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxPreferredTaskWorkGroupInvocations</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxPreferredMeshWorkGroupInvocations</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>prefersLocalInvocationVertexOutput</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>prefersLocalInvocationPrimitiveOutput</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>prefersCompactVertexOutput</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>prefersCompactPrimitiveOutput</name></member>
        </type>
        <type category="struct" name="VkDrawMeshTasksIndirectCommandEXT">
            <member noautovalidity="true"><type>uint32_t</type> <name>groupCountX</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>groupCountY</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>groupCountZ</name></member>
        </type>
        <type category="struct" name="VkRayTracingShaderGroupCreateInfoNV">
            <member values="VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkRayTracingShaderGroupTypeKHR</type> <name>type</name></member>
            <member><type>uint32_t</type>               <name>generalShader</name></member>
            <member><type>uint32_t</type>               <name>closestHitShader</name></member>
            <member><type>uint32_t</type>               <name>anyHitShader</name></member>
            <member><type>uint32_t</type>               <name>intersectionShader</name></member>
        </type>
        <type category="struct" name="VkRayTracingShaderGroupCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkRayTracingShaderGroupTypeKHR</type> <name>type</name></member>
            <member><type>uint32_t</type>               <name>generalShader</name></member>
            <member><type>uint32_t</type>               <name>closestHitShader</name></member>
            <member><type>uint32_t</type>               <name>anyHitShader</name></member>
            <member><type>uint32_t</type>               <name>intersectionShader</name></member>
            <member optional="true">const <type>void</type>* <name>pShaderGroupCaptureReplayHandle</name></member>
        </type>
        <type category="struct" name="VkRayTracingPipelineCreateInfoNV">
            <member values="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member noautovalidity="true" optional="true"><type>VkPipelineCreateFlags</type>  <name>flags</name><comment>Pipeline creation flags</comment></member>
            <member><type>uint32_t</type>               <name>stageCount</name></member>
            <member len="stageCount">const <type>VkPipelineShaderStageCreateInfo</type>* <name>pStages</name><comment>One entry for each active shader stage</comment></member>
            <member><type>uint32_t</type>               <name>groupCount</name></member>
            <member len="groupCount">const <type>VkRayTracingShaderGroupCreateInfoNV</type>* <name>pGroups</name></member>
            <member><type>uint32_t</type>               <name>maxRecursionDepth</name></member>
            <member><type>VkPipelineLayout</type>       <name>layout</name><comment>Interface layout of the pipeline</comment></member>
            <member noautovalidity="true" optional="true"><type>VkPipeline</type>      <name>basePipelineHandle</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of</comment></member>
            <member><type>int32_t</type>                <name>basePipelineIndex</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of</comment></member>
        </type>
        <type category="struct" name="VkRayTracingPipelineCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member noautovalidity="true" optional="true"><type>VkPipelineCreateFlags</type>  <name>flags</name><comment>Pipeline creation flags</comment></member>
            <member optional="true"><type>uint32_t</type> <name>stageCount</name></member>
            <member len="stageCount">const <type>VkPipelineShaderStageCreateInfo</type>* <name>pStages</name><comment>One entry for each active shader stage</comment></member>
            <member optional="true"><type>uint32_t</type> <name>groupCount</name></member>
            <member len="groupCount">const <type>VkRayTracingShaderGroupCreateInfoKHR</type>* <name>pGroups</name></member>
            <member><type>uint32_t</type>               <name>maxPipelineRayRecursionDepth</name></member>
            <member optional="true">const <type>VkPipelineLibraryCreateInfoKHR</type>* <name>pLibraryInfo</name></member>
            <member optional="true">const <type>VkRayTracingPipelineInterfaceCreateInfoKHR</type>* <name>pLibraryInterface</name></member>
            <member optional="true">const <type>VkPipelineDynamicStateCreateInfo</type>* <name>pDynamicState</name></member>
            <member><type>VkPipelineLayout</type>       <name>layout</name><comment>Interface layout of the pipeline</comment></member>
            <member noautovalidity="true" optional="true"><type>VkPipeline</type>      <name>basePipelineHandle</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of</comment></member>
            <member><type>int32_t</type>                <name>basePipelineIndex</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of</comment></member>
        </type>
        <type category="struct" name="VkGeometryTrianglesNV">
            <member values="VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member optional="true"><type>VkBuffer</type>   <name>vertexData</name></member>
            <member><type>VkDeviceSize</type>               <name>vertexOffset</name></member>
            <member><type>uint32_t</type>                   <name>vertexCount</name></member>
            <member><type>VkDeviceSize</type>               <name>vertexStride</name></member>
            <member><type>VkFormat</type>                   <name>vertexFormat</name></member>
            <member optional="true"><type>VkBuffer</type>   <name>indexData</name></member>
            <member><type>VkDeviceSize</type>               <name>indexOffset</name></member>
            <member><type>uint32_t</type>                   <name>indexCount</name></member>
            <member><type>VkIndexType</type>                <name>indexType</name></member>
            <member optional="true"><type>VkBuffer</type>   <name>transformData</name><comment>Optional reference to array of floats representing a 3x4 row major affine transformation matrix.</comment></member>
            <member><type>VkDeviceSize</type>               <name>transformOffset</name></member>
        </type>
        <type category="struct" name="VkGeometryAABBNV">
            <member values="VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member optional="true"><type>VkBuffer</type>   <name>aabbData</name></member>
            <member><type>uint32_t</type>                   <name>numAABBs</name></member>
            <member><type>uint32_t</type>                   <name>stride</name><comment>Stride in bytes between AABBs</comment></member>
            <member><type>VkDeviceSize</type>               <name>offset</name><comment>Offset in bytes of the first AABB in aabbData</comment></member>
        </type>
        <type category="struct" name="VkGeometryDataNV">
            <member><type>VkGeometryTrianglesNV</type>                  <name>triangles</name></member>
            <member><type>VkGeometryAABBNV</type>                       <name>aabbs</name></member>
        </type>
        <type category="struct" name="VkGeometryNV">
            <member values="VK_STRUCTURE_TYPE_GEOMETRY_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                   <name>pNext</name></member>
            <member><type>VkGeometryTypeKHR</type>                  <name>geometryType</name></member>
            <member><type>VkGeometryDataNV</type>                              <name>geometry</name></member>
            <member optional="true"><type>VkGeometryFlagsKHR</type> <name>flags</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureInfoNV">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
            <member><type>VkAccelerationStructureTypeNV</type>         <name>type</name></member>
            <member optional="true"><type>VkBuildAccelerationStructureFlagsNV</type> <name>flags</name></member>
            <member optional="true"><type>uint32_t</type>               <name>instanceCount</name></member>
            <member optional="true"><type>uint32_t</type>               <name>geometryCount</name></member>
            <member len="geometryCount">const <type>VkGeometryNV</type>* <name>pGeometries</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureCreateInfoNV">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
            <member><type>VkDeviceSize</type>                           <name>compactedSize</name></member>
            <member><type>VkAccelerationStructureInfoNV</type>          <name>info</name></member>
        </type>
        <type category="struct" name="VkBindAccelerationStructureMemoryInfoNV">
            <member values="VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
            <member><type>VkAccelerationStructureNV</type>       <name>accelerationStructure</name></member>
            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
            <member><type>VkDeviceSize</type>                     <name>memoryOffset</name></member>
            <member optional="true"><type>uint32_t</type>         <name>deviceIndexCount</name></member>
            <member len="deviceIndexCount">const <type>uint32_t</type>*  <name>pDeviceIndices</name></member>
        </type>
        <type category="struct" name="VkWriteDescriptorSetAccelerationStructureKHR" structextends="VkWriteDescriptorSet">
            <member values="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>accelerationStructureCount</name></member>
            <member optional="false,true" len="accelerationStructureCount">const <type>VkAccelerationStructureKHR</type>* <name>pAccelerationStructures</name></member>
        </type>
        <type category="struct" name="VkWriteDescriptorSetAccelerationStructureNV" structextends="VkWriteDescriptorSet">
            <member values="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>accelerationStructureCount</name></member>
            <member optional="false,true" len="accelerationStructureCount">const <type>VkAccelerationStructureNV</type>* <name>pAccelerationStructures</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureMemoryRequirementsInfoNV">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                          <name>pNext</name></member>
            <member><type>VkAccelerationStructureMemoryRequirementsTypeNV</type>                     <name>type</name></member>
            <member><type>VkAccelerationStructureNV</type>                                           <name>accelerationStructure</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceAccelerationStructureFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>accelerationStructure</name></member>
            <member><type>VkBool32</type>                         <name>accelerationStructureCaptureReplay</name></member>
            <member><type>VkBool32</type>                         <name>accelerationStructureIndirectBuild</name></member>
            <member><type>VkBool32</type>                         <name>accelerationStructureHostCommands</name></member>
            <member><type>VkBool32</type>                         <name>descriptorBindingAccelerationStructureUpdateAfterBind</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRayTracingPipelineFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>rayTracingPipeline</name></member>
            <member><type>VkBool32</type>                         <name>rayTracingPipelineShaderGroupHandleCaptureReplay</name></member>
            <member><type>VkBool32</type>                         <name>rayTracingPipelineShaderGroupHandleCaptureReplayMixed</name></member>
            <member><type>VkBool32</type>                         <name>rayTracingPipelineTraceRaysIndirect</name></member>
            <member><type>VkBool32</type>                         <name>rayTraversalPrimitiveCulling</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRayQueryFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>rayQuery</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceAccelerationStructurePropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member limittype="max"><type>uint64_t</type>                         <name>maxGeometryCount</name></member>
            <member limittype="max"><type>uint64_t</type>                         <name>maxInstanceCount</name></member>
            <member limittype="max"><type>uint64_t</type>                         <name>maxPrimitiveCount</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageDescriptorAccelerationStructures</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageDescriptorUpdateAfterBindAccelerationStructures</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetAccelerationStructures</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindAccelerationStructures</name></member>
            <member limittype="min"><type>uint32_t</type>                         <name>minAccelerationStructureScratchOffsetAlignment</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRayTracingPipelinePropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member limittype="exact"><type>uint32_t</type>                    <name>shaderGroupHandleSize</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxRayRecursionDepth</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxShaderGroupStride</name></member>
            <member limittype="exact"><type>uint32_t</type>                    <name>shaderGroupBaseAlignment</name></member>
            <member limittype="exact"><type>uint32_t</type>                    <name>shaderGroupHandleCaptureReplaySize</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxRayDispatchInvocationCount</name></member>
            <member limittype="min,pot"><type>uint32_t</type>                      <name>shaderGroupHandleAlignment</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxRayHitAttributeSize</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRayTracingPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="exact"><type>uint32_t</type>                    <name>shaderGroupHandleSize</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxRecursionDepth</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxShaderGroupStride</name></member>
            <member limittype="exact"><type>uint32_t</type>                    <name>shaderGroupBaseAlignment</name></member>
            <member limittype="max"><type>uint64_t</type>                         <name>maxGeometryCount</name></member>
            <member limittype="max"><type>uint64_t</type>                         <name>maxInstanceCount</name></member>
            <member limittype="max"><type>uint64_t</type>                         <name>maxTriangleCount</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetAccelerationStructures</name></member>
        </type>
        <type category="struct" name="VkStridedDeviceAddressRegionKHR">
            <member optional="true"><type>VkDeviceAddress</type>  <name>deviceAddress</name></member>
            <member><type>VkDeviceSize</type>                     <name>stride</name></member>
            <member><type>VkDeviceSize</type>                     <name>size</name></member>
        </type>
        <type category="struct" name="VkTraceRaysIndirectCommandKHR">
            <member><type>uint32_t</type>               <name>width</name></member>
            <member><type>uint32_t</type>               <name>height</name></member>
            <member><type>uint32_t</type>               <name>depth</name></member>
        </type>
        <type category="struct" name="VkTraceRaysIndirectCommand2KHR">
            <member><type>VkDeviceAddress</type>        <name>raygenShaderRecordAddress</name></member>
            <member><type>VkDeviceSize</type>           <name>raygenShaderRecordSize</name></member>
            <member><type>VkDeviceAddress</type>        <name>missShaderBindingTableAddress</name></member>
            <member><type>VkDeviceSize</type>           <name>missShaderBindingTableSize</name></member>
            <member><type>VkDeviceSize</type>           <name>missShaderBindingTableStride</name></member>
            <member><type>VkDeviceAddress</type>        <name>hitShaderBindingTableAddress</name></member>
            <member><type>VkDeviceSize</type>           <name>hitShaderBindingTableSize</name></member>
            <member><type>VkDeviceSize</type>           <name>hitShaderBindingTableStride</name></member>
            <member><type>VkDeviceAddress</type>        <name>callableShaderBindingTableAddress</name></member>
            <member><type>VkDeviceSize</type>           <name>callableShaderBindingTableSize</name></member>
            <member><type>VkDeviceSize</type>           <name>callableShaderBindingTableStride</name></member>
            <member><type>uint32_t</type>               <name>width</name></member>
            <member><type>uint32_t</type>               <name>height</name></member>
            <member><type>uint32_t</type>               <name>depth</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>rayTracingMaintenance1</name></member>
            <member><type>VkBool32</type>                         <name>rayTracingPipelineTraceRaysIndirect2</name></member>
        </type>
        <type category="struct" name="VkDrmFormatModifierPropertiesListEXT" returnedonly="true" structextends="VkFormatProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member limittype="noauto" optional="true"><type>uint32_t</type> <name>drmFormatModifierCount</name></member>
            <member limittype="struct" optional="true" len="drmFormatModifierCount"><type>VkDrmFormatModifierPropertiesEXT</type>* <name>pDrmFormatModifierProperties</name></member>
        </type>
        <type category="struct" name="VkDrmFormatModifierPropertiesEXT" returnedonly="true" requiredlimittype="true">
            <member limittype="exact"><type>uint64_t</type>               <name>drmFormatModifier</name></member>
            <member limittype="exact"><type>uint32_t</type>               <name>drmFormatModifierPlaneCount</name></member>
            <member limittype="bitmask"><type>VkFormatFeatureFlags</type> <name>drmFormatModifierTilingFeatures</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImageDrmFormatModifierInfoEXT" structextends="VkPhysicalDeviceImageFormatInfo2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint64_t</type> <name>drmFormatModifier</name></member>
            <member><type>VkSharingMode</type> <name>sharingMode</name></member>
            <member optional="true"><type>uint32_t</type> <name>queueFamilyIndexCount</name></member>
            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>* <name>pQueueFamilyIndices</name></member>
        </type>
        <type category="struct" name="VkImageDrmFormatModifierListCreateInfoEXT" structextends="VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type> <name>drmFormatModifierCount</name></member>
            <member len="drmFormatModifierCount">const <type>uint64_t</type>* <name>pDrmFormatModifiers</name></member>
        </type>
        <type category="struct" name="VkImageDrmFormatModifierExplicitCreateInfoEXT" structextends="VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint64_t</type> <name>drmFormatModifier</name></member>
            <member><type>uint32_t</type> <name>drmFormatModifierPlaneCount</name></member>
            <member len="drmFormatModifierPlaneCount">const <type>VkSubresourceLayout</type>* <name>pPlaneLayouts</name></member>
        </type>
        <type category="struct" name="VkImageDrmFormatModifierPropertiesEXT" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member><type>uint64_t</type> <name>drmFormatModifier</name></member>
        </type>
        <type category="struct" name="VkImageStencilUsageCreateInfo" structextends="VkImageCreateInfo,VkPhysicalDeviceImageFormatInfo2">
            <member values="VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkImageUsageFlags</type> <name>stencilUsage</name></member>
        </type>
        <type category="struct" name="VkImageStencilUsageCreateInfoEXT"                        alias="VkImageStencilUsageCreateInfo"/>
        <type category="struct" name="VkDeviceMemoryOverallocationCreateInfoAMD"  structextends="VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkMemoryOverallocationBehaviorAMD</type> <name>overallocationBehavior</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentDensityMapFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>fragmentDensityMap</name></member>
            <member><type>VkBool32</type>                         <name>fragmentDensityMapDynamic</name></member>
            <member><type>VkBool32</type>                         <name>fragmentDensityMapNonSubsampledImages</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentDensityMap2FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>fragmentDensityMapDeferred</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>fragmentDensityMapOffset</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM" alias="VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT"/>
        <type category="struct" name="VkPhysicalDeviceFragmentDensityMapPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="min"><type>VkExtent2D</type>                       <name>minFragmentDensityTexelSize</name></member>
            <member limittype="max"><type>VkExtent2D</type>                       <name>maxFragmentDensityTexelSize</name></member>
            <member limittype="max"><type>VkBool32</type>                         <name>fragmentDensityInvocations</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentDensityMap2PropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member limittype="exact"><type>VkBool32</type>                  <name>subsampledLoads</name></member>
            <member limittype="exact"><type>VkBool32</type>                  <name>subsampledCoarseReconstructionEarlyAccess</name></member>
            <member limittype="max"><type>uint32_t</type>                       <name>maxSubsampledArrayLayers</name></member>
            <member limittype="max"><type>uint32_t</type>                       <name>maxDescriptorSetSubsampledSamplers</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="min,mul"><type>VkExtent2D</type>                       <name>fragmentDensityOffsetGranularity</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM" alias="VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT"/>
        <type category="struct" name="VkRenderPassFragmentDensityMapCreateInfoEXT" structextends="VkRenderPassCreateInfo,VkRenderPassCreateInfo2">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkAttachmentReference</type>            <name>fragmentDensityMapAttachment</name></member>
        </type>
        <type category="struct" name="VkRenderPassFragmentDensityMapOffsetEndInfoEXT" structextends="VkSubpassEndInfo,VkRenderingEndInfoKHR">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                           <name>fragmentDensityOffsetCount</name></member>
            <member len="fragmentDensityOffsetCount">const <type>VkOffset2D</type>* <name>pFragmentDensityOffsets</name></member>
        </type>
        <type category="struct" name="VkSubpassFragmentDensityMapOffsetEndInfoQCOM" alias="VkRenderPassFragmentDensityMapOffsetEndInfoEXT"/>
        <type category="struct" name="VkPhysicalDeviceScalarBlockLayoutFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>scalarBlockLayout</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceScalarBlockLayoutFeaturesEXT"            alias="VkPhysicalDeviceScalarBlockLayoutFeatures"/>
        <type category="struct" name="VkSurfaceProtectedCapabilitiesKHR" structextends="VkSurfaceCapabilities2KHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type> <name>supportsProtected</name><comment>Represents if surface can be protected</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceUniformBufferStandardLayoutFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>uniformBufferStandardLayout</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR"  alias="VkPhysicalDeviceUniformBufferStandardLayoutFeatures"/>
        <type category="struct" name="VkPhysicalDeviceDepthClipEnableFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member><type>VkBool32</type>               <name>depthClipEnable</name></member>
        </type>
        <type category="struct" name="VkPipelineRasterizationDepthClipStateCreateInfoEXT" structextends="VkPipelineRasterizationStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                                 <name>pNext</name></member>
            <member optional="true"><type>VkPipelineRasterizationDepthClipStateCreateFlagsEXT</type>         <name>flags</name><comment>Reserved</comment></member>
            <member><type>VkBool32</type>                                                                    <name>depthClipEnable</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMemoryBudgetPropertiesEXT" structextends="VkPhysicalDeviceMemoryProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkDeviceSize</type>                       <name>heapBudget</name>[<enum>VK_MAX_MEMORY_HEAPS</enum>]</member>
            <member><type>VkDeviceSize</type>                       <name>heapUsage</name>[<enum>VK_MAX_MEMORY_HEAPS</enum>]</member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMemoryPriorityFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>memoryPriority</name></member>
        </type>
        <type category="struct" name="VkMemoryPriorityAllocateInfoEXT" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
            <member><type>float</type>                              <name>priority</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>pageableDeviceLocalMemory</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceBufferDeviceAddressFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>bufferDeviceAddress</name></member>
            <member><type>VkBool32</type>                           <name>bufferDeviceAddressCaptureReplay</name></member>
            <member><type>VkBool32</type>                           <name>bufferDeviceAddressMultiDevice</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceBufferDeviceAddressFeaturesKHR"          alias="VkPhysicalDeviceBufferDeviceAddressFeatures"/>
        <type category="struct" name="VkPhysicalDeviceBufferDeviceAddressFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member featurelink="bufferDeviceAddressEXT"><type>VkBool32</type>                           <name>bufferDeviceAddress</name></member>
            <member featurelink="bufferDeviceAddressCaptureReplayEXT"><type>VkBool32</type>              <name>bufferDeviceAddressCaptureReplay</name></member>
            <member featurelink="bufferDeviceAddressMultiDeviceEXT"><type>VkBool32</type>                <name>bufferDeviceAddressMultiDevice</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceBufferAddressFeaturesEXT"                alias="VkPhysicalDeviceBufferDeviceAddressFeaturesEXT"/>
        <type category="struct" name="VkBufferDeviceAddressInfo">
            <member values="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
            <member><type>VkBuffer</type>                                               <name>buffer</name></member>
        </type>
        <type category="struct" name="VkBufferDeviceAddressInfoKHR"                            alias="VkBufferDeviceAddressInfo"/>
        <type category="struct" name="VkBufferDeviceAddressInfoEXT"                            alias="VkBufferDeviceAddressInfo"/>
        <type category="struct" name="VkBufferOpaqueCaptureAddressCreateInfo" structextends="VkBufferCreateInfo">
            <member values="VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint64_t</type>                         <name>opaqueCaptureAddress</name></member>
        </type>
        <type category="struct" name="VkBufferOpaqueCaptureAddressCreateInfoKHR"               alias="VkBufferOpaqueCaptureAddressCreateInfo"/>
        <type category="struct" name="VkBufferDeviceAddressCreateInfoEXT" structextends="VkBufferCreateInfo">
            <member values="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkDeviceAddress</type>                  <name>deviceAddress</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImageViewImageFormatInfoEXT" structextends="VkPhysicalDeviceImageFormatInfo2">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkImageViewType</type>                  <name>imageViewType</name></member>
        </type>
        <type category="struct" name="VkFilterCubicImageViewImageFormatPropertiesEXT" returnedonly="true" structextends="VkImageFormatProperties2">
            <member values="VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>filterCubic</name><comment>The combinations of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT</comment></member>
            <member><type>VkBool32</type>                         <name>filterCubicMinmax</name><comment>The combination of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT and ReductionMode of Min or Max</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImagelessFramebufferFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                    <name>pNext</name></member>
            <member><type>VkBool32</type>                                 <name>imagelessFramebuffer</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImagelessFramebufferFeaturesKHR"         alias="VkPhysicalDeviceImagelessFramebufferFeatures"/>
        <type category="struct" name="VkFramebufferAttachmentsCreateInfo" structextends="VkFramebufferCreateInfo">
            <member values="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                              <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                 <name>attachmentImageInfoCount</name></member>
            <member len="attachmentImageInfoCount">const <type>VkFramebufferAttachmentImageInfo</type>* <name>pAttachmentImageInfos</name></member>
        </type>
        <type category="struct" name="VkFramebufferAttachmentsCreateInfoKHR"                   alias="VkFramebufferAttachmentsCreateInfo"/>
        <type category="struct" name="VkFramebufferAttachmentImageInfo">
            <member values="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                              <name>pNext</name></member>
            <member optional="true"><type>VkImageCreateFlags</type>       <name>flags</name><comment>Image creation flags</comment></member>
            <member><type>VkImageUsageFlags</type>                        <name>usage</name><comment>Image usage flags</comment></member>
            <member><type>uint32_t</type>                                 <name>width</name></member>
            <member><type>uint32_t</type>                                 <name>height</name></member>
            <member><type>uint32_t</type>                                 <name>layerCount</name></member>
            <member optional="true"><type>uint32_t</type>                 <name>viewFormatCount</name></member>
            <member len="viewFormatCount">const <type>VkFormat</type>*    <name>pViewFormats</name></member>
        </type>
        <type category="struct" name="VkFramebufferAttachmentImageInfoKHR"                     alias="VkFramebufferAttachmentImageInfo"/>
        <type category="struct" name="VkRenderPassAttachmentBeginInfo" structextends="VkRenderPassBeginInfo">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                              <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                 <name>attachmentCount</name></member>
            <member len="attachmentCount">const <type>VkImageView</type>* <name>pAttachments</name></member>
        </type>
        <type category="struct" name="VkRenderPassAttachmentBeginInfoKHR"                      alias="VkRenderPassAttachmentBeginInfo"/>
        <type category="struct" name="VkPhysicalDeviceTextureCompressionASTCHDRFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*  <name>pNext</name></member>
            <member><type>VkBool32</type>               <name>textureCompressionASTC_HDR</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT" alias="VkPhysicalDeviceTextureCompressionASTCHDRFeatures"/>
        <type category="struct" name="VkPhysicalDeviceCooperativeMatrixFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member featurelink="cooperativeMatrixNV"><type>VkBool32</type>                             <name>cooperativeMatrix</name></member>
            <member featurelink="cooperativeMatrixRobustBufferAccessNV"><type>VkBool32</type>           <name>cooperativeMatrixRobustBufferAccess</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCooperativeMatrixPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member limittype="bitmask"><type>VkShaderStageFlags</type>                  <name>cooperativeMatrixSupportedStages</name></member>
        </type>
        <type category="struct" name="VkCooperativeMatrixPropertiesNV" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member><type>uint32_t</type>                            <name>MSize</name></member>
            <member><type>uint32_t</type>                            <name>NSize</name></member>
            <member><type>uint32_t</type>                            <name>KSize</name></member>
            <member><type>VkComponentTypeNV</type>                   <name>AType</name></member>
            <member><type>VkComponentTypeNV</type>                   <name>BType</name></member>
            <member><type>VkComponentTypeNV</type>                   <name>CType</name></member>
            <member><type>VkComponentTypeNV</type>                   <name>DType</name></member>
            <member><type>VkScopeNV</type>                           <name>scope</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceYcbcrImageArraysFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>ycbcrImageArrays</name></member>
        </type>
        <type category="struct" name="VkImageViewHandleInfoNVX">
            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkImageView</type>                         <name>imageView</name></member>
            <member><type>VkDescriptorType</type>                    <name>descriptorType</name></member>
            <member optional="true"><type>VkSampler</type>           <name>sampler</name></member>
        </type>
        <type category="struct" name="VkImageViewAddressPropertiesNVX" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member><type>VkDeviceAddress</type>    <name>deviceAddress</name></member>
            <member><type>VkDeviceSize</type>       <name>size</name></member>
        </type>
        <type category="struct" name="VkPresentFrameTokenGGP" structextends="VkPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>GgpFrameToken</type>                    <name>frameToken</name></member>
        </type>
        <type category="struct" name="VkPipelineCreationFeedback" returnedonly="true">
            <member><type>VkPipelineCreationFeedbackFlags</type>     <name>flags</name></member>
            <member><type>uint64_t</type>                            <name>duration</name></member>
        </type>
        <type category="struct" name="VkPipelineCreationFeedbackEXT" alias="VkPipelineCreationFeedback"/>
        <type category="struct" name="VkPipelineCreationFeedbackCreateInfo" structextends="VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkRayTracingPipelineCreateInfoNV,VkRayTracingPipelineCreateInfoKHR,VkExecutionGraphPipelineCreateInfoAMDX,VkDataGraphPipelineCreateInfoARM">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*         <name>pNext</name></member>
            <member><type>VkPipelineCreationFeedback</type>*         <name>pPipelineCreationFeedback</name><comment>Output pipeline creation feedback.</comment></member>
            <member optional="true"><type>uint32_t</type>            <name>pipelineStageCreationFeedbackCount</name></member>
            <member len="pipelineStageCreationFeedbackCount"><type>VkPipelineCreationFeedback</type>* <name>pPipelineStageCreationFeedbacks</name><comment>One entry for each shader stage specified in the parent Vk*PipelineCreateInfo struct</comment></member>
        </type>
        <type category="struct" name="VkPipelineCreationFeedbackCreateInfoEXT" alias="VkPipelineCreationFeedbackCreateInfo"/>
        <type category="struct" name="VkSurfaceFullScreenExclusiveInfoEXT" structextends="VkPhysicalDeviceSurfaceInfo2KHR,VkSwapchainCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkFullScreenExclusiveEXT</type>         <name>fullScreenExclusive</name></member>
        </type>
        <type category="struct" name="VkSurfaceFullScreenExclusiveWin32InfoEXT" structextends="VkPhysicalDeviceSurfaceInfo2KHR,VkSwapchainCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
            <member><type>HMONITOR</type>         <name>hmonitor</name></member>
        </type>
        <type category="struct" name="VkSurfaceCapabilitiesFullScreenExclusiveEXT" structextends="VkSurfaceCapabilities2KHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>         <name>fullScreenExclusiveSupported</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePresentBarrierFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>presentBarrier</name></member>
        </type>
        <type category="struct" name="VkSurfaceCapabilitiesPresentBarrierNV" structextends="VkSurfaceCapabilities2KHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>       <name>presentBarrierSupported</name></member>
        </type>
        <type category="struct" name="VkSwapchainPresentBarrierCreateInfoNV" structextends="VkSwapchainCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>    <name>presentBarrierEnable</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePerformanceQueryFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*      <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>performanceCounterQueryPools</name><comment>performance counters supported in query pools</comment></member>
            <member><type>VkBool32</type>                         <name>performanceCounterMultipleQueryPools</name><comment>performance counters from multiple query pools can be accessed in the same primary command buffer</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePerformanceQueryPropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member limittype="max" noautovalidity="true"><type>VkBool32</type> <name>allowCommandBufferQueryCopies</name><comment>Flag to specify whether performance queries are allowed to be used in vkCmdCopyQueryPoolResults</comment></member>
        </type>
        <type category="struct" name="VkPerformanceCounterKHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member><type>VkPerformanceCounterUnitKHR</type>        <name>unit</name></member>
            <member><type>VkPerformanceCounterScopeKHR</type>       <name>scope</name></member>
            <member><type>VkPerformanceCounterStorageKHR</type>     <name>storage</name></member>
            <member><type>uint8_t</type> <name>uuid</name>[<enum>VK_UUID_SIZE</enum>]</member>
        </type>
        <type category="struct" name="VkPerformanceCounterDescriptionKHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                   <name>pNext</name></member>
            <member optional="true"><type>VkPerformanceCounterDescriptionFlagsKHR</type> <name>flags</name></member>
            <member len="null-terminated"><type>char</type>              <name>name</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
            <member len="null-terminated"><type>char</type>              <name>category</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
            <member len="null-terminated"><type>char</type>              <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
        </type>
        <type category="struct" name="VkQueryPoolPerformanceCreateInfoKHR" structextends="VkQueryPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                             <name>pNext</name></member>
            <member><type>uint32_t</type>                                <name>queueFamilyIndex</name></member>
            <member><type>uint32_t</type>                                <name>counterIndexCount</name></member>
            <member len="counterIndexCount">const <type>uint32_t</type>* <name>pCounterIndices</name></member>
        </type>
        <type category="union" name="VkPerformanceCounterResultKHR" comment="// Union of all the possible return types a counter result could return">
            <member><type>int32_t</type>  <name>int32</name></member>
            <member><type>int64_t</type>  <name>int64</name></member>
            <member><type>uint32_t</type> <name>uint32</name></member>
            <member><type>uint64_t</type> <name>uint64</name></member>
            <member><type>float</type>    <name>float32</name></member>
            <member><type>double</type>   <name>float64</name></member>
        </type>
        <type category="struct" name="VkAcquireProfilingLockInfoKHR">
            <member values="VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkAcquireProfilingLockFlagsKHR</type> <name>flags</name><comment>Acquire profiling lock flags</comment></member>
            <member><type>uint64_t</type> <name>timeout</name></member>
        </type>
        <type category="struct" name="VkPerformanceQuerySubmitInfoKHR" structextends="VkSubmitInfo,VkSubmitInfo2">
            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*         <name>pNext</name></member>
            <member><type>uint32_t</type>            <name>counterPassIndex</name><comment>Index for which counter pass to submit</comment></member>
        </type>
        <type category="struct" name="VkPerformanceQueryReservationInfoKHR" allowduplicate="true" structextends="VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*         <name>pNext</name></member>
            <member><type>uint32_t</type>            <name>maxPerformanceQueriesPerPool</name><comment>Maximum number of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR queries in a query pool</comment></member>
        </type>
        <type category="struct" name="VkHeadlessSurfaceCreateInfoEXT">
            <member values="VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkHeadlessSurfaceCreateFlagsEXT</type>   <name>flags</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCoverageReductionModeFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                       <name>coverageReductionMode</name></member>
        </type>
        <type category="struct" name="VkPipelineCoverageReductionStateCreateInfoNV" structextends="VkPipelineMultisampleStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                        <name>pNext</name></member>
            <member optional="true"><type>VkPipelineCoverageReductionStateCreateFlagsNV</type>      <name>flags</name></member>
            <member><type>VkCoverageReductionModeNV</type>                                          <name>coverageReductionMode</name></member>
        </type>
        <type category="struct" name="VkFramebufferMixedSamplesCombinationNV" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                      <name>pNext</name></member>
            <member><type>VkCoverageReductionModeNV</type>  <name>coverageReductionMode</name></member>
            <member><type>VkSampleCountFlagBits</type>      <name>rasterizationSamples</name></member>
            <member><type>VkSampleCountFlags</type>         <name>depthStencilSamples</name></member>
            <member><type>VkSampleCountFlags</type>         <name>colorSamples</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>shaderIntegerFunctions2</name></member>
        </type>
        <type category="union" name="VkPerformanceValueDataINTEL">
            <member selection="VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL"><type>uint32_t</type>                           <name>value32</name></member>
            <member selection="VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL"><type>uint64_t</type>                           <name>value64</name></member>
            <member selection="VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL"><type>float</type>                               <name>valueFloat</name></member>
            <member selection="VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL"><type>VkBool32</type>                             <name>valueBool</name></member>
            <member selection="VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL" len="null-terminated">const <type>char</type>*  <name>valueString</name></member>
        </type>
        <type category="struct" name="VkPerformanceValueINTEL" returnedonly="true">
            <member><type>VkPerformanceValueTypeINTEL</type>        <name>type</name></member>
            <member selector="type" noautovalidity="true"><type>VkPerformanceValueDataINTEL</type>        <name>data</name></member>
        </type>
        <type category="struct" name="VkInitializePerformanceApiInfoINTEL">
            <member values="VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
            <member optional="true"><type>void</type>*               <name>pUserData</name></member>
        </type>
        <type category="struct" name="VkQueryPoolPerformanceQueryCreateInfoINTEL" structextends="VkQueryPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
            <member><type>VkQueryPoolSamplingModeINTEL</type>        <name>performanceCountersSampling</name></member>
        </type>
        <type category="struct" name="VkQueryPoolCreateInfoINTEL"                              alias="VkQueryPoolPerformanceQueryCreateInfoINTEL"/>
        <type category="struct" name="VkPerformanceMarkerInfoINTEL">
            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
            <member><type>uint64_t</type>                            <name>marker</name></member>
        </type>
        <type category="struct" name="VkPerformanceStreamMarkerInfoINTEL">
            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
            <member><type>uint32_t</type>                            <name>marker</name></member>
        </type>
        <type category="struct" name="VkPerformanceOverrideInfoINTEL">
            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
            <member><type>VkPerformanceOverrideTypeINTEL</type>      <name>type</name></member>
            <member><type>VkBool32</type>                            <name>enable</name></member>
            <member><type>uint64_t</type>                            <name>parameter</name></member>
        </type>
        <type category="struct" name="VkPerformanceConfigurationAcquireInfoINTEL">
            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
            <member><type>VkPerformanceConfigurationTypeINTEL</type> <name>type</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderClockFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>shaderSubgroupClock</name></member>
            <member><type>VkBool32</type>                            <name>shaderDeviceClock</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceIndexTypeUint8Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>indexTypeUint8</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceIndexTypeUint8FeaturesKHR" alias="VkPhysicalDeviceIndexTypeUint8Features"/>
        <type category="struct" name="VkPhysicalDeviceIndexTypeUint8FeaturesEXT"  alias="VkPhysicalDeviceIndexTypeUint8Features"/>
        <type category="struct" name="VkPhysicalDeviceShaderSMBuiltinsPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>                       <name>shaderSMCount</name></member>
            <member limittype="max"><type>uint32_t</type>                       <name>shaderWarpsPerSM</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderSMBuiltinsFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                       <name>shaderSMBuiltins</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name><comment>Pointer to next structure</comment></member>
            <member><type>VkBool32</type>               <name>fragmentShaderSampleInterlock</name></member>
            <member><type>VkBool32</type>               <name>fragmentShaderPixelInterlock</name></member>
            <member><type>VkBool32</type>               <name>fragmentShaderShadingRateInterlock</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                       <name>separateDepthStencilLayouts</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR"  alias="VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures"/>
        <type category="struct" name="VkAttachmentReferenceStencilLayout" structextends="VkAttachmentReference2">
            <member values="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkImageLayout</type>                  <name>stencilLayout</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                     <name>primitiveTopologyListRestart</name></member>
            <member><type>VkBool32</type>                     <name>primitiveTopologyPatchListRestart</name></member>
        </type>
        <type category="struct" name="VkAttachmentReferenceStencilLayoutKHR"                   alias="VkAttachmentReferenceStencilLayout"/>
        <type category="struct" name="VkAttachmentDescriptionStencilLayout" structextends="VkAttachmentDescription2">
            <member values="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkImageLayout</type>                  <name>stencilInitialLayout</name></member>
            <member><type>VkImageLayout</type>                  <name>stencilFinalLayout</name></member>
        </type>
        <type category="struct" name="VkAttachmentDescriptionStencilLayoutKHR"                 alias="VkAttachmentDescriptionStencilLayout"/>
        <type category="struct" name="VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member><type>VkBool32</type>           <name>pipelineExecutableInfo</name></member>
        </type>
        <type category="struct" name="VkPipelineInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
            <member><type>VkPipeline</type>         <name>pipeline</name></member>
        </type>
        <type category="struct" name="VkPipelineInfoEXT" alias="VkPipelineInfoKHR"/>
        <type category="struct" name="VkPipelineExecutablePropertiesKHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member><type>VkShaderStageFlags</type>                 <name>stages</name></member>
            <member len="null-terminated"><type>char</type>         <name>name</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
            <member len="null-terminated"><type>char</type>         <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
            <member><type>uint32_t</type>                           <name>subgroupSize</name></member>
        </type>
        <type category="struct" name="VkPipelineExecutableInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
            <member><type>VkPipeline</type>         <name>pipeline</name></member>
            <member><type>uint32_t</type>           <name>executableIndex</name></member>
        </type>
        <type category="union" name="VkPipelineExecutableStatisticValueKHR" returnedonly="true">
            <member selection="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR"><type>VkBool32</type>           <name>b32</name></member>
            <member selection="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR"><type>int64_t</type>            <name>i64</name></member>
            <member selection="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR"><type>uint64_t</type>           <name>u64</name></member>
            <member selection="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR"><type>double</type>             <name>f64</name></member>
        </type>
        <type category="struct" name="VkPipelineExecutableStatisticKHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member len="null-terminated"><type>char</type>             <name>name</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
            <member len="null-terminated"><type>char</type>             <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
            <member><type>VkPipelineExecutableStatisticFormatKHR</type> <name>format</name></member>
            <member selector="format" noautovalidity="true"><type>VkPipelineExecutableStatisticValueKHR</type>  <name>value</name></member>
        </type>
        <type category="struct" name="VkPipelineExecutableInternalRepresentationKHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                <name>pNext</name></member>
            <member len="null-terminated"><type>char</type>           <name>name</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
            <member len="null-terminated"><type>char</type>           <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
            <member><type>VkBool32</type>                             <name>isText</name></member>
            <member><type>size_t</type>                               <name>dataSize</name></member>
            <member optional="true" len="dataSize"><type>void</type>* <name>pData</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*      <name>pNext</name></member>
            <member><type>VkBool32</type>                   <name>shaderDemoteToHelperInvocation</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT" alias="VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures"/>
        <type category="struct" name="VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>texelBufferAlignment</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceTexelBufferAlignmentProperties" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member limittype="min,pot"><type>VkDeviceSize</type>                       <name>storageTexelBufferOffsetAlignmentBytes</name></member>
            <member limittype="exact"><type>VkBool32</type>                         <name>storageTexelBufferOffsetSingleTexelAlignment</name></member>
            <member limittype="min,pot"><type>VkDeviceSize</type>                       <name>uniformTexelBufferOffsetAlignmentBytes</name></member>
            <member limittype="exact"><type>VkBool32</type>                         <name>uniformTexelBufferOffsetSingleTexelAlignment</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT" alias="VkPhysicalDeviceTexelBufferAlignmentProperties"/>
        <type category="struct" name="VkPhysicalDeviceSubgroupSizeControlFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*  <name>pNext</name></member>
            <member><type>VkBool32</type>               <name>subgroupSizeControl</name></member>
            <member><type>VkBool32</type>               <name>computeFullSubgroups</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSubgroupSizeControlFeaturesEXT" alias="VkPhysicalDeviceSubgroupSizeControlFeatures"/>
        <type category="struct" name="VkPhysicalDeviceSubgroupSizeControlProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member limittype="min,pot" noautovalidity="true"><type>uint32_t</type> <name>minSubgroupSize</name><comment>The minimum subgroup size supported by this device</comment></member>
            <member limittype="max,pot" noautovalidity="true"><type>uint32_t</type> <name>maxSubgroupSize</name><comment>The maximum subgroup size supported by this device</comment></member>
            <member limittype="max" noautovalidity="true"><type>uint32_t</type> <name>maxComputeWorkgroupSubgroups</name><comment>The maximum number of subgroups supported in a workgroup</comment></member>
            <member limittype="bitmask"><type>VkShaderStageFlags</type>         <name>requiredSubgroupSizeStages</name><comment>The shader stages that support specifying a subgroup size</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSubgroupSizeControlPropertiesEXT" alias="VkPhysicalDeviceSubgroupSizeControlProperties"/>
        <type category="struct" name="VkPipelineShaderStageRequiredSubgroupSizeCreateInfo" structextends="VkPipelineShaderStageCreateInfo,VkShaderCreateInfoEXT">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*  <name>pNext</name></member>
            <member><type>uint32_t</type>                     <name>requiredSubgroupSize</name></member>
        </type>
        <type category="struct" name="VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT" alias="VkPipelineShaderStageRequiredSubgroupSizeCreateInfo"/>
        <type category="struct" name="VkShaderRequiredSubgroupSizeCreateInfoEXT" alias="VkPipelineShaderStageRequiredSubgroupSizeCreateInfo"/>
        <type category="struct" name="VkSubpassShadingPipelineCreateInfoHUAWEI" structextends="VkComputePipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member><type>VkRenderPass</type>           <name>renderPass</name></member>
            <member><type>uint32_t</type>               <name>subpass</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSubpassShadingPropertiesHUAWEI" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member limittype="max,pot"><type>uint32_t</type>               <name>maxSubpassShadingWorkgroupSizeAspectRatio</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member limittype="max,pot"><type>uint32_t</type>           <name>maxWorkGroupCount</name>[3]</member>
            <member limittype="max,pot"><type>uint32_t</type>           <name>maxWorkGroupSize</name>[3]</member>
            <member limittype="max"><type>uint32_t</type>               <name>maxOutputClusterCount</name></member>
            <member limittype="exact"><type>VkDeviceSize</type>         <name>indirectBufferOffsetAlignment</name></member>
        </type>
        <type category="struct" name="VkMemoryOpaqueCaptureAddressAllocateInfo" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                   <name>pNext</name></member>
            <member><type>uint64_t</type>                      <name>opaqueCaptureAddress</name></member>
        </type>
        <type category="struct" name="VkMemoryOpaqueCaptureAddressAllocateInfoKHR"             alias="VkMemoryOpaqueCaptureAddressAllocateInfo"/>
        <type category="struct" name="VkDeviceMemoryOpaqueCaptureAddressInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
        </type>
        <type category="struct" name="VkDeviceMemoryOpaqueCaptureAddressInfoKHR"               alias="VkDeviceMemoryOpaqueCaptureAddressInfo"/>
        <type category="struct" name="VkPhysicalDeviceLineRasterizationFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>rectangularLines</name></member>
            <member><type>VkBool32</type>                           <name>bresenhamLines</name></member>
            <member><type>VkBool32</type>                           <name>smoothLines</name></member>
            <member><type>VkBool32</type>                           <name>stippledRectangularLines</name></member>
            <member><type>VkBool32</type>                           <name>stippledBresenhamLines</name></member>
            <member><type>VkBool32</type>                           <name>stippledSmoothLines</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceLineRasterizationFeaturesKHR" alias="VkPhysicalDeviceLineRasterizationFeatures"/>
        <type category="struct" name="VkPhysicalDeviceLineRasterizationFeaturesEXT" alias="VkPhysicalDeviceLineRasterizationFeatures"/>
        <type category="struct" name="VkPhysicalDeviceLineRasterizationProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member limittype="bits"><type>uint32_t</type>                            <name>lineSubPixelPrecisionBits</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceLineRasterizationPropertiesKHR" alias="VkPhysicalDeviceLineRasterizationProperties"/>
        <type category="struct" name="VkPhysicalDeviceLineRasterizationPropertiesEXT" alias="VkPhysicalDeviceLineRasterizationProperties"/>
        <type category="struct" name="VkPipelineRasterizationLineStateCreateInfo" structextends="VkPipelineRasterizationStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                      <name>pNext</name></member>
            <member><type>VkLineRasterizationMode</type>                                          <name>lineRasterizationMode</name></member>
            <member><type>VkBool32</type>                                                         <name>stippledLineEnable</name></member>
            <member><type>uint32_t</type>                                                         <name>lineStippleFactor</name></member>
            <member><type>uint16_t</type>                                                         <name>lineStipplePattern</name></member>
        </type>
        <type category="struct" name="VkPipelineRasterizationLineStateCreateInfoKHR" alias="VkPipelineRasterizationLineStateCreateInfo"/>
        <type category="struct" name="VkPipelineRasterizationLineStateCreateInfoEXT" alias="VkPipelineRasterizationLineStateCreateInfo"/>
        <type category="struct" name="VkPhysicalDevicePipelineCreationCacheControlFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type>              <name>pipelineCreationCacheControl</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT" alias="VkPhysicalDevicePipelineCreationCacheControlFeatures"/>
        <type category="struct" name="VkPhysicalDeviceVulkan11Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>storageBuffer16BitAccess</name><comment>16-bit integer/floating-point variables supported in BufferBlock</comment></member>
            <member><type>VkBool32</type>                         <name>uniformAndStorageBuffer16BitAccess</name><comment>16-bit integer/floating-point variables supported in BufferBlock and Block</comment></member>
            <member><type>VkBool32</type>                         <name>storagePushConstant16</name><comment>16-bit integer/floating-point variables supported in PushConstant</comment></member>
            <member><type>VkBool32</type>                         <name>storageInputOutput16</name><comment>16-bit integer/floating-point variables supported in shader inputs and outputs</comment></member>
            <member><type>VkBool32</type>                         <name>multiview</name><comment>Multiple views in a render pass</comment></member>
            <member><type>VkBool32</type>                         <name>multiviewGeometryShader</name><comment>Multiple views in a render pass w/ geometry shader</comment></member>
            <member><type>VkBool32</type>                         <name>multiviewTessellationShader</name><comment>Multiple views in a render pass w/ tessellation shader</comment></member>
            <member><type>VkBool32</type>                         <name>variablePointersStorageBuffer</name></member>
            <member><type>VkBool32</type>                         <name>variablePointers</name></member>
            <member><type>VkBool32</type>                         <name>protectedMemory</name></member>
            <member><type>VkBool32</type>                         <name>samplerYcbcrConversion</name><comment>Sampler color conversion supported</comment></member>
            <member><type>VkBool32</type>                         <name>shaderDrawParameters</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVulkan11Properties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*      <name>pNext</name></member>
            <member limittype="exact"><type>uint8_t</type>                          <name>deviceUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
            <member limittype="exact"><type>uint8_t</type>                          <name>driverUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
            <member limittype="exact"><type>uint8_t</type>                          <name>deviceLUID</name>[<enum>VK_LUID_SIZE</enum>]</member>
            <member limittype="exact"><type>uint32_t</type>                         <name>deviceNodeMask</name></member>
            <member limittype="exact"><type>VkBool32</type>                         <name>deviceLUIDValid</name></member>
            <member limittype="max,pot" noautovalidity="true"><type>uint32_t</type>                      <name>subgroupSize</name><comment>The size of a subgroup for this queue.</comment></member>
            <member limittype="bitmask" noautovalidity="true"><type>VkShaderStageFlags</type>            <name>subgroupSupportedStages</name><comment>Bitfield of what shader stages support subgroup operations</comment></member>
            <member limittype="bitmask" noautovalidity="true"><type>VkSubgroupFeatureFlags</type>        <name>subgroupSupportedOperations</name><comment>Bitfield of what subgroup operations are supported.</comment></member>
            <member limittype="max" noautovalidity="true"><type>VkBool32</type>                          <name>subgroupQuadOperationsInAllStages</name><comment>Flag to specify whether quad operations are available in all stages.</comment></member>
            <member limittype="exact"><type>VkPointClippingBehavior</type>        <name>pointClippingBehavior</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxMultiviewViewCount</name><comment>max number of views in a subpass</comment></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxMultiviewInstanceIndex</name><comment>max instance index for a draw in a multiview subpass</comment></member>
            <member limittype="exact"><type>VkBool32</type>                       <name>protectedNoFault</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxPerSetDescriptors</name></member>
            <member limittype="max"><type>VkDeviceSize</type>                     <name>maxMemoryAllocationSize</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVulkan12Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>samplerMirrorClampToEdge</name></member>
            <member><type>VkBool32</type>                         <name>drawIndirectCount</name></member>
            <member><type>VkBool32</type>                         <name>storageBuffer8BitAccess</name><comment>8-bit integer variables supported in StorageBuffer</comment></member>
            <member><type>VkBool32</type>                         <name>uniformAndStorageBuffer8BitAccess</name><comment>8-bit integer variables supported in StorageBuffer and Uniform</comment></member>
            <member><type>VkBool32</type>                         <name>storagePushConstant8</name><comment>8-bit integer variables supported in PushConstant</comment></member>
            <member><type>VkBool32</type>                         <name>shaderBufferInt64Atomics</name></member>
            <member><type>VkBool32</type>                         <name>shaderSharedInt64Atomics</name></member>
            <member><type>VkBool32</type>                         <name>shaderFloat16</name><comment>16-bit floats (halfs) in shaders</comment></member>
            <member><type>VkBool32</type>                         <name>shaderInt8</name><comment>8-bit integers in shaders</comment></member>
            <member><type>VkBool32</type>                         <name>descriptorIndexing</name></member>
            <member><type>VkBool32</type>                         <name>shaderInputAttachmentArrayDynamicIndexing</name></member>
            <member><type>VkBool32</type>                         <name>shaderUniformTexelBufferArrayDynamicIndexing</name></member>
            <member><type>VkBool32</type>                         <name>shaderStorageTexelBufferArrayDynamicIndexing</name></member>
            <member><type>VkBool32</type>                         <name>shaderUniformBufferArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>                         <name>shaderSampledImageArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>                         <name>shaderStorageBufferArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>                         <name>shaderStorageImageArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>                         <name>shaderInputAttachmentArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>                         <name>shaderUniformTexelBufferArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>                         <name>shaderStorageTexelBufferArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>                         <name>descriptorBindingUniformBufferUpdateAfterBind</name></member>
            <member><type>VkBool32</type>                         <name>descriptorBindingSampledImageUpdateAfterBind</name></member>
            <member><type>VkBool32</type>                         <name>descriptorBindingStorageImageUpdateAfterBind</name></member>
            <member><type>VkBool32</type>                         <name>descriptorBindingStorageBufferUpdateAfterBind</name></member>
            <member><type>VkBool32</type>                         <name>descriptorBindingUniformTexelBufferUpdateAfterBind</name></member>
            <member><type>VkBool32</type>                         <name>descriptorBindingStorageTexelBufferUpdateAfterBind</name></member>
            <member><type>VkBool32</type>                         <name>descriptorBindingUpdateUnusedWhilePending</name></member>
            <member><type>VkBool32</type>                         <name>descriptorBindingPartiallyBound</name></member>
            <member><type>VkBool32</type>                         <name>descriptorBindingVariableDescriptorCount</name></member>
            <member><type>VkBool32</type>                         <name>runtimeDescriptorArray</name></member>
            <member><type>VkBool32</type>                         <name>samplerFilterMinmax</name></member>
            <member><type>VkBool32</type>                         <name>scalarBlockLayout</name></member>
            <member><type>VkBool32</type>                         <name>imagelessFramebuffer</name></member>
            <member><type>VkBool32</type>                         <name>uniformBufferStandardLayout</name></member>
            <member><type>VkBool32</type>                         <name>shaderSubgroupExtendedTypes</name></member>
            <member><type>VkBool32</type>                         <name>separateDepthStencilLayouts</name></member>
            <member><type>VkBool32</type>                         <name>hostQueryReset</name></member>
            <member><type>VkBool32</type>                         <name>timelineSemaphore</name></member>
            <member><type>VkBool32</type>                         <name>bufferDeviceAddress</name></member>
            <member><type>VkBool32</type>                         <name>bufferDeviceAddressCaptureReplay</name></member>
            <member><type>VkBool32</type>                         <name>bufferDeviceAddressMultiDevice</name></member>
            <member><type>VkBool32</type>                         <name>vulkanMemoryModel</name></member>
            <member><type>VkBool32</type>                         <name>vulkanMemoryModelDeviceScope</name></member>
            <member><type>VkBool32</type>                         <name>vulkanMemoryModelAvailabilityVisibilityChains</name></member>
            <member><type>VkBool32</type>                         <name>shaderOutputViewportIndex</name></member>
            <member><type>VkBool32</type>                         <name>shaderOutputLayer</name></member>
            <member><type>VkBool32</type>                         <name>subgroupBroadcastDynamicId</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVulkan12Properties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member limittype="noauto"><type>VkDriverId</type>                       <name>driverID</name></member>
            <member limittype="noauto" len="null-terminated"><type>char</type>       <name>driverName</name>[<enum>VK_MAX_DRIVER_NAME_SIZE</enum>]</member>
            <member limittype="noauto" len="null-terminated"><type>char</type>       <name>driverInfo</name>[<enum>VK_MAX_DRIVER_INFO_SIZE</enum>]</member>
            <member limittype="noauto"><type>VkConformanceVersion</type>             <name>conformanceVersion</name></member>
            <member limittype="exact"><type>VkShaderFloatControlsIndependence</type> <name>denormBehaviorIndependence</name></member>
            <member limittype="exact"><type>VkShaderFloatControlsIndependence</type> <name>roundingModeIndependence</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderSignedZeroInfNanPreserveFloat16</name><comment>An implementation can preserve signed zero, nan, inf</comment></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderSignedZeroInfNanPreserveFloat32</name><comment>An implementation can preserve signed zero, nan, inf</comment></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderSignedZeroInfNanPreserveFloat64</name><comment>An implementation can preserve signed zero, nan, inf</comment></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderDenormPreserveFloat16</name><comment>An implementation can preserve  denormals</comment></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderDenormPreserveFloat32</name><comment>An implementation can preserve  denormals</comment></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderDenormPreserveFloat64</name><comment>An implementation can preserve  denormals</comment></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderDenormFlushToZeroFloat16</name><comment>An implementation can flush to zero  denormals</comment></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderDenormFlushToZeroFloat32</name><comment>An implementation can flush to zero  denormals</comment></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderDenormFlushToZeroFloat64</name><comment>An implementation can flush to zero  denormals</comment></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderRoundingModeRTEFloat16</name><comment>An implementation can support RTE</comment></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderRoundingModeRTEFloat32</name><comment>An implementation can support RTE</comment></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderRoundingModeRTEFloat64</name><comment>An implementation can support RTE</comment></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderRoundingModeRTZFloat16</name><comment>An implementation can support RTZ</comment></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderRoundingModeRTZFloat32</name><comment>An implementation can support RTZ</comment></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderRoundingModeRTZFloat64</name><comment>An implementation can support RTZ</comment></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxUpdateAfterBindDescriptorsInAllPools</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderUniformBufferArrayNonUniformIndexingNative</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderSampledImageArrayNonUniformIndexingNative</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderStorageBufferArrayNonUniformIndexingNative</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderStorageImageArrayNonUniformIndexingNative</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>shaderInputAttachmentArrayNonUniformIndexingNative</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>robustBufferAccessUpdateAfterBind</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>quadDivergentImplicitLod</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxPerStageDescriptorUpdateAfterBindSamplers</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxPerStageDescriptorUpdateAfterBindUniformBuffers</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxPerStageDescriptorUpdateAfterBindStorageBuffers</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxPerStageDescriptorUpdateAfterBindSampledImages</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxPerStageDescriptorUpdateAfterBindStorageImages</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxPerStageDescriptorUpdateAfterBindInputAttachments</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxPerStageUpdateAfterBindResources</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxDescriptorSetUpdateAfterBindSamplers</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxDescriptorSetUpdateAfterBindUniformBuffers</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxDescriptorSetUpdateAfterBindUniformBuffersDynamic</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxDescriptorSetUpdateAfterBindStorageBuffers</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxDescriptorSetUpdateAfterBindStorageBuffersDynamic</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxDescriptorSetUpdateAfterBindSampledImages</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxDescriptorSetUpdateAfterBindStorageImages</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxDescriptorSetUpdateAfterBindInputAttachments</name></member>
            <member limittype="bitmask"><type>VkResolveModeFlags</type>              <name>supportedDepthResolveModes</name><comment>supported depth resolve modes</comment></member>
            <member limittype="bitmask"><type>VkResolveModeFlags</type>              <name>supportedStencilResolveModes</name><comment>supported stencil resolve modes</comment></member>
            <member limittype="max"><type>VkBool32</type>                            <name>independentResolveNone</name><comment>depth and stencil resolve modes can be set independently if one of them is none</comment></member>
            <member limittype="max"><type>VkBool32</type>                            <name>independentResolve</name><comment>depth and stencil resolve modes can be set independently</comment></member>
            <member limittype="max"><type>VkBool32</type>                            <name>filterMinmaxSingleComponentFormats</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>filterMinmaxImageComponentMapping</name></member>
            <member limittype="max"><type>uint64_t</type>                            <name>maxTimelineSemaphoreValueDifference</name></member>
            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type> <name>framebufferIntegerColorSampleCounts</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVulkan13Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>robustImageAccess</name></member>
            <member><type>VkBool32</type>                         <name>inlineUniformBlock</name></member>
            <member><type>VkBool32</type>                         <name>descriptorBindingInlineUniformBlockUpdateAfterBind</name></member>
            <member><type>VkBool32</type>                         <name>pipelineCreationCacheControl</name></member>
            <member><type>VkBool32</type>                         <name>privateData</name></member>
            <member><type>VkBool32</type>                         <name>shaderDemoteToHelperInvocation</name></member>
            <member><type>VkBool32</type>                         <name>shaderTerminateInvocation</name></member>
            <member><type>VkBool32</type>                         <name>subgroupSizeControl</name></member>
            <member><type>VkBool32</type>                         <name>computeFullSubgroups</name></member>
            <member><type>VkBool32</type>                         <name>synchronization2</name></member>
            <member><type>VkBool32</type>                         <name>textureCompressionASTC_HDR</name></member>
            <member><type>VkBool32</type>                         <name>shaderZeroInitializeWorkgroupMemory</name></member>
            <member><type>VkBool32</type>                         <name>dynamicRendering</name></member>
            <member><type>VkBool32</type>                         <name>shaderIntegerDotProduct</name></member>
            <member><type>VkBool32</type>                         <name>maintenance4</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVulkan13Properties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member limittype="min,pot" noautovalidity="true"><type>uint32_t</type> <name>minSubgroupSize</name><comment>The minimum subgroup size supported by this device</comment></member>
            <member limittype="max,pot" noautovalidity="true"><type>uint32_t</type> <name>maxSubgroupSize</name><comment>The maximum subgroup size supported by this device</comment></member>
            <member limittype="max" noautovalidity="true"><type>uint32_t</type> <name>maxComputeWorkgroupSubgroups</name><comment>The maximum number of subgroups supported in a workgroup</comment></member>
            <member limittype="bitmask"><type>VkShaderStageFlags</type>         <name>requiredSubgroupSizeStages</name><comment>The shader stages that support specifying a subgroup size</comment></member>
            <member limittype="max"><type>uint32_t</type>                       <name>maxInlineUniformBlockSize</name></member>
            <member limittype="max"><type>uint32_t</type>                       <name>maxPerStageDescriptorInlineUniformBlocks</name></member>
            <member limittype="max"><type>uint32_t</type>                       <name>maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks</name></member>
            <member limittype="max"><type>uint32_t</type>                       <name>maxDescriptorSetInlineUniformBlocks</name></member>
            <member limittype="max"><type>uint32_t</type>                       <name>maxDescriptorSetUpdateAfterBindInlineUniformBlocks</name></member>
            <member limittype="max"><type>uint32_t</type>                       <name>maxInlineUniformTotalSize</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProduct8BitUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProduct8BitSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProduct8BitMixedSignednessAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProduct4x8BitPackedUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProduct4x8BitPackedSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProduct4x8BitPackedMixedSignednessAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProduct16BitUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProduct16BitSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProduct16BitMixedSignednessAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProduct32BitUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProduct32BitSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProduct32BitMixedSignednessAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProduct64BitUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProduct64BitSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProduct64BitMixedSignednessAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProductAccumulatingSaturating8BitUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProductAccumulatingSaturating8BitSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProductAccumulatingSaturating16BitUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProductAccumulatingSaturating16BitSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProductAccumulatingSaturating32BitUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProductAccumulatingSaturating32BitSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProductAccumulatingSaturating64BitUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProductAccumulatingSaturating64BitSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated</name></member>
            <member limittype="min,pot"><type>VkDeviceSize</type>               <name>storageTexelBufferOffsetAlignmentBytes</name></member>
            <member limittype="exact"><type>VkBool32</type>                     <name>storageTexelBufferOffsetSingleTexelAlignment</name></member>
            <member limittype="min,pot"><type>VkDeviceSize</type>               <name>uniformTexelBufferOffsetAlignmentBytes</name></member>
            <member limittype="exact"><type>VkBool32</type>                     <name>uniformTexelBufferOffsetSingleTexelAlignment</name></member>
            <member limittype="max"><type>VkDeviceSize</type>                   <name>maxBufferSize</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVulkan14Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>globalPriorityQuery</name></member>
            <member><type>VkBool32</type>                         <name>shaderSubgroupRotate</name></member>
            <member><type>VkBool32</type>                         <name>shaderSubgroupRotateClustered</name></member>
            <member><type>VkBool32</type>                         <name>shaderFloatControls2</name></member>
            <member><type>VkBool32</type>                         <name>shaderExpectAssume</name></member>
            <member><type>VkBool32</type>                         <name>rectangularLines</name></member>
            <member><type>VkBool32</type>                         <name>bresenhamLines</name></member>
            <member><type>VkBool32</type>                         <name>smoothLines</name></member>
            <member><type>VkBool32</type>                         <name>stippledRectangularLines</name></member>
            <member><type>VkBool32</type>                         <name>stippledBresenhamLines</name></member>
            <member><type>VkBool32</type>                         <name>stippledSmoothLines</name></member>
            <member><type>VkBool32</type>                         <name>vertexAttributeInstanceRateDivisor</name></member>
            <member><type>VkBool32</type>                         <name>vertexAttributeInstanceRateZeroDivisor</name></member>
            <member><type>VkBool32</type>                         <name>indexTypeUint8</name></member>
            <member><type>VkBool32</type>                         <name>dynamicRenderingLocalRead</name></member>
            <member><type>VkBool32</type>                         <name>maintenance5</name></member>
            <member><type>VkBool32</type>                         <name>maintenance6</name></member>
            <member><type>VkBool32</type>                         <name>pipelineProtectedAccess</name></member>
            <member><type>VkBool32</type>                         <name>pipelineRobustness</name></member>
            <member><type>VkBool32</type>                         <name>hostImageCopy</name></member>
            <member><type>VkBool32</type>                         <name>pushDescriptor</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVulkan14Properties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                                      <name>pNext</name></member>
            <member limittype="bits"><type>uint32_t</type>                                                  <name>lineSubPixelPrecisionBits</name></member>
            <member limittype="max"><type>uint32_t</type>                                                   <name>maxVertexAttribDivisor</name><comment>max value of vertex attribute divisor</comment></member>
            <member limittype="max"><type>VkBool32</type>                                                   <name>supportsNonZeroFirstInstance</name></member>
            <member limittype="max"><type>uint32_t</type>                                                   <name>maxPushDescriptors</name></member>
            <member limittype="max"><type>VkBool32</type>                                                   <name>dynamicRenderingLocalReadDepthStencilAttachments</name></member>
            <member limittype="max"><type>VkBool32</type>                                                   <name>dynamicRenderingLocalReadMultisampledAttachments</name></member>
            <member limittype="max"><type>VkBool32</type>                                                   <name>earlyFragmentMultisampleCoverageAfterSampleCounting</name></member>
            <member limittype="max"><type>VkBool32</type>                                                   <name>earlyFragmentSampleMaskTestBeforeSampleCounting</name></member>
            <member limittype="max"><type>VkBool32</type>                                                   <name>depthStencilSwizzleOneSupport</name></member>
            <member limittype="exact"><type>VkBool32</type>                                                 <name>polygonModePointSize</name></member>
            <member limittype="max"><type>VkBool32</type>                                                   <name>nonStrictSinglePixelWideLinesUseParallelogram</name></member>
            <member limittype="max"><type>VkBool32</type>                                                   <name>nonStrictWideLinesUseParallelogram</name></member>
            <member limittype="max"><type>VkBool32</type>                                                   <name>blockTexelViewCompatibleMultipleLayers</name></member>
            <member limittype="max"><type>uint32_t</type>                                                   <name>maxCombinedImageSamplerDescriptorCount</name></member>
            <member limittype="max"><type>VkBool32</type>                                                   <name>fragmentShadingRateClampCombinerInputs</name></member>
            <member limittype="exact"><type>VkPipelineRobustnessBufferBehavior</type>                       <name>defaultRobustnessStorageBuffers</name></member>
            <member limittype="exact"><type>VkPipelineRobustnessBufferBehavior</type>                       <name>defaultRobustnessUniformBuffers</name></member>
            <member limittype="exact"><type>VkPipelineRobustnessBufferBehavior</type>                       <name>defaultRobustnessVertexInputs</name></member>
            <member limittype="exact"><type>VkPipelineRobustnessImageBehavior</type>                        <name>defaultRobustnessImages</name></member>
            <member optional="true" limittype="noauto"><type>uint32_t</type>                                <name>copySrcLayoutCount</name></member>
            <member optional="true" limittype="noauto" len="copySrcLayoutCount"><type>VkImageLayout</type>* <name>pCopySrcLayouts</name></member>
            <member optional="true" limittype="noauto"><type>uint32_t</type>                                <name>copyDstLayoutCount</name></member>
            <member optional="true" limittype="noauto" len="copyDstLayoutCount"><type>VkImageLayout</type>* <name>pCopyDstLayouts</name></member>
            <member optional="true" limittype="noauto"><type>uint8_t</type>                                 <name>optimalTilingLayoutUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
            <member limittype="max"><type>VkBool32</type>                                                   <name>identicalMemoryTypeRequirements</name></member>
        </type>
        <type category="struct" name="VkPipelineCompilerControlCreateInfoAMD" structextends="VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkExecutionGraphPipelineCreateInfoAMDX">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD"><type>VkStructureType</type>   <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                                            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineCompilerControlFlagsAMD</type>                                      <name>compilerControlFlags</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCoherentMemoryFeaturesAMD" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>deviceCoherentMemory</name></member>
        </type>
        <type category="struct" name="VkFaultData" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_FAULT_DATA"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true" optional="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkFaultLevel</type>                    <name>faultLevel</name></member>
            <member><type>VkFaultType</type>                     <name>faultType</name></member>
        </type>
        <type category="struct" name="VkFaultCallbackInfo" structextends="VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_FAULT_CALLBACK_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>           <name>faultCount</name></member>
            <member optional="true" len="faultCount"><type>VkFaultData</type>* <name>pFaults</name></member>
            <member><type>PFN_vkFaultCallbackFunction</type>        <name>pfnFaultCallback</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceToolProperties" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*      <name>pNext</name></member>
            <member len="null-terminated"><type>char</type> <name>name</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]</member>
            <member len="null-terminated"><type>char</type> <name>version</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]</member>
            <member><type>VkToolPurposeFlags</type>         <name>purposes</name></member>
            <member len="null-terminated"><type>char</type> <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
            <member len="null-terminated"><type>char</type> <name>layer</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]</member>
        </type>
        <type category="struct" name="VkPhysicalDeviceToolPropertiesEXT" alias="VkPhysicalDeviceToolProperties"/>
        <type category="struct" name="VkSamplerCustomBorderColorCreateInfoEXT" structextends="VkSamplerCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                                            <name>pNext</name></member>
            <member noautovalidity="true"><type>VkClearColorValue</type>                                                                      <name>customBorderColor</name></member>
            <member><type>VkFormat</type>                                                                               <name>format</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCustomBorderColorPropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                                                   <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>                                                                                      <name>maxCustomBorderColorSamplers</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCustomBorderColorFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>customBorderColors</name></member>
            <member><type>VkBool32</type>                           <name>customBorderColorWithoutFormat</name></member>
        </type>
        <type category="struct" name="VkSamplerBorderColorComponentMappingCreateInfoEXT" structextends="VkSamplerCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                                       <name>pNext</name></member>
            <member><type>VkComponentMapping</type>                                                                                <name>components</name></member>
            <member><type>VkBool32</type>                                                                                          <name>srgb</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceBorderColorSwizzleFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                     <name>borderColorSwizzle</name></member>
            <member><type>VkBool32</type>                     <name>borderColorSwizzleFromImage</name></member>
        </type>
        <type category="union" name="VkDeviceOrHostAddressKHR">
            <member noautovalidity="true"><type>VkDeviceAddress</type>            <name>deviceAddress</name></member>
            <member noautovalidity="true"><type>void</type>*                      <name>hostAddress</name></member>
        </type>
        <type category="union" name="VkDeviceOrHostAddressConstKHR">
            <member noautovalidity="true"><type>VkDeviceAddress</type>            <name>deviceAddress</name></member>
            <member noautovalidity="true">const <type>void</type>*                <name>hostAddress</name></member>
        </type>
        <type category="union" name="VkDeviceOrHostAddressConstAMDX">
            <member noautovalidity="true"><type>VkDeviceAddress</type>            <name>deviceAddress</name></member>
            <member noautovalidity="true">const <type>void</type>*                <name>hostAddress</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureGeometryTrianglesDataKHR">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                   <name>pNext</name></member>
            <member><type>VkFormat</type>                                      <name>vertexFormat</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                 <name>vertexData</name></member>
            <member><type>VkDeviceSize</type>                                  <name>vertexStride</name></member>
            <member><type>uint32_t</type>                                      <name>maxVertex</name></member>
            <member><type>VkIndexType</type>                                   <name>indexType</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                 <name>indexData</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                 <name>transformData</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureGeometryAabbsDataKHR">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                           <name>pNext</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>         <name>data</name></member>
            <member><type>VkDeviceSize</type>                          <name>stride</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureGeometryInstancesDataKHR">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                           <name>pNext</name></member>
            <member><type>VkBool32</type>                              <name>arrayOfPointers</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>         <name>data</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureGeometryLinearSweptSpheresDataNV" structextends="VkAccelerationStructureGeometryKHR">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
            <member><type>VkFormat</type>                                            <name>vertexFormat</name></member>
            <member><type>VkDeviceOrHostAddressConstKHR</type>                       <name>vertexData</name></member>
            <member><type>VkDeviceSize</type>                                        <name>vertexStride</name></member>
            <member><type>VkFormat</type>                                            <name>radiusFormat</name></member>
            <member><type>VkDeviceOrHostAddressConstKHR</type>                       <name>radiusData</name></member>
            <member><type>VkDeviceSize</type>                                        <name>radiusStride</name></member>
            <member><type>VkIndexType</type>                                         <name>indexType</name></member>
            <member><type>VkDeviceOrHostAddressConstKHR</type>                       <name>indexData</name></member>
            <member><type>VkDeviceSize</type>                                        <name>indexStride</name></member>
            <member><type>VkRayTracingLssIndexingModeNV</type>                       <name>indexingMode</name></member>
            <member><type>VkRayTracingLssPrimitiveEndCapsModeNV</type>               <name>endCapsMode</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureGeometrySpheresDataNV" structextends="VkAccelerationStructureGeometryKHR">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
            <member><type>VkFormat</type>                                            <name>vertexFormat</name></member>
            <member><type>VkDeviceOrHostAddressConstKHR</type>                       <name>vertexData</name></member>
            <member><type>VkDeviceSize</type>                                        <name>vertexStride</name></member>
            <member><type>VkFormat</type>                                            <name>radiusFormat</name></member>
            <member><type>VkDeviceOrHostAddressConstKHR</type>                       <name>radiusData</name></member>
            <member><type>VkDeviceSize</type>                                        <name>radiusStride</name></member>
            <member><type>VkIndexType</type>                                         <name>indexType</name></member>
            <member><type>VkDeviceOrHostAddressConstKHR</type>                       <name>indexData</name></member>
            <member><type>VkDeviceSize</type>                                        <name>indexStride</name></member>
        </type>
        <type category="union" name="VkAccelerationStructureGeometryDataKHR">
            <member selection="VK_GEOMETRY_TYPE_TRIANGLES_KHR"><type>VkAccelerationStructureGeometryTrianglesDataKHR</type> <name>triangles</name></member>
            <member selection="VK_GEOMETRY_TYPE_AABBS_KHR"><type>VkAccelerationStructureGeometryAabbsDataKHR</type>         <name>aabbs</name></member>
            <member selection="VK_GEOMETRY_TYPE_INSTANCES_KHR"><type>VkAccelerationStructureGeometryInstancesDataKHR</type> <name>instances</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureGeometryKHR">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
            <member><type>VkGeometryTypeKHR</type>                      <name>geometryType</name></member>
            <member selector="geometryType"><type>VkAccelerationStructureGeometryDataKHR</type> <name>geometry</name></member>
            <member optional="true"><type>VkGeometryFlagsKHR</type>     <name>flags</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureBuildGeometryInfoKHR">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                        <name>pNext</name></member>
            <member><type>VkAccelerationStructureTypeKHR</type>                                     <name>type</name></member>
            <member optional="true"><type>VkBuildAccelerationStructureFlagsKHR</type>               <name>flags</name></member>
            <member noautovalidity="true"><type>VkBuildAccelerationStructureModeKHR</type>          <name>mode</name></member>
            <member optional="true" noautovalidity="true"><type>VkAccelerationStructureKHR</type>                   <name>srcAccelerationStructure</name></member>
            <member optional="true" noautovalidity="true"><type>VkAccelerationStructureKHR</type>                   <name>dstAccelerationStructure</name></member>
            <member optional="true"><type>uint32_t</type>                                           <name>geometryCount</name></member>
            <member len="geometryCount" optional="true">const <type>VkAccelerationStructureGeometryKHR</type>*    <name>pGeometries</name></member>
            <member len="geometryCount,1" optional="true,false">const <type>VkAccelerationStructureGeometryKHR</type>* const*   <name>ppGeometries</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressKHR</type>                                           <name>scratchData</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureBuildRangeInfoKHR">
            <member><type>uint32_t</type>                                                <name>primitiveCount</name></member>
            <member><type>uint32_t</type>                                                <name>primitiveOffset</name></member>
            <member><type>uint32_t</type>                                                <name>firstVertex</name></member>
            <member><type>uint32_t</type>                                                <name>transformOffset</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                             <name>pNext</name></member>
            <member optional="true"><type>VkAccelerationStructureCreateFlagsKHR</type>   <name>createFlags</name></member>
            <member><type>VkBuffer</type>                                                <name>buffer</name></member>
            <member><type>VkDeviceSize</type>                                            <name>offset</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>                                            <name>size</name></member>
            <member><type>VkAccelerationStructureTypeKHR</type>                          <name>type</name></member>
            <member optional="true"><type>VkDeviceAddress</type>                         <name>deviceAddress</name></member>
        </type>
        <type category="struct" name="VkAabbPositionsKHR">
            <member><type>float</type>                                                   <name>minX</name></member>
            <member><type>float</type>                                                   <name>minY</name></member>
            <member><type>float</type>                                                   <name>minZ</name></member>
            <member><type>float</type>                                                   <name>maxX</name></member>
            <member><type>float</type>                                                   <name>maxY</name></member>
            <member><type>float</type>                                                   <name>maxZ</name></member>
        </type>
        <type category="struct" name="VkAabbPositionsNV"                                       alias="VkAabbPositionsKHR"/>
        <type category="struct" name="VkTransformMatrixKHR">
            <member><type>float</type>                                                   <name>matrix</name>[3][4]</member>
        </type>
        <type category="struct" name="VkTransformMatrixNV"                                     alias="VkTransformMatrixKHR"/>
        <type category="struct" name="VkAccelerationStructureInstanceKHR">
            <comment>The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.</comment>
            <member><type>VkTransformMatrixKHR</type>                                    <name>transform</name></member>
            <member><type>uint32_t</type>                                                <name>instanceCustomIndex</name>:24</member>
            <member><type>uint32_t</type>                                                <name>mask</name>:8</member>
            <member><type>uint32_t</type>                                                <name>instanceShaderBindingTableRecordOffset</name>:24</member>
            <member optional="true"><type>VkGeometryInstanceFlagsKHR</type>              <name>flags</name>:8</member>
            <member><type>uint64_t</type>                                                <name>accelerationStructureReference</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureInstanceNV"                       alias="VkAccelerationStructureInstanceKHR"/>
        <type category="struct" name="VkAccelerationStructureDeviceAddressInfoKHR">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
            <member><type>VkAccelerationStructureKHR</type>                             <name>accelerationStructure</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureVersionInfoKHR">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
            <member len="latexmath:[2 \times \mathtt{VK\_UUID\_SIZE}]" altlen="2*VK_UUID_SIZE">const <type>uint8_t</type>*                    <name>pVersionData</name></member>
        </type>
        <type category="struct" name="VkCopyAccelerationStructureInfoKHR">
            <member values="VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
            <member><type>VkAccelerationStructureKHR</type>                             <name>src</name></member>
            <member><type>VkAccelerationStructureKHR</type>                             <name>dst</name></member>
            <member><type>VkCopyAccelerationStructureModeKHR</type>                     <name>mode</name></member>
        </type>
        <type category="struct" name="VkCopyAccelerationStructureToMemoryInfoKHR">
            <member values="VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
            <member><type>VkAccelerationStructureKHR</type>                             <name>src</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressKHR</type>                               <name>dst</name></member>
            <member><type>VkCopyAccelerationStructureModeKHR</type>                     <name>mode</name></member>
        </type>
        <type category="struct" name="VkCopyMemoryToAccelerationStructureInfoKHR">
            <member values="VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                          <name>src</name></member>
            <member><type>VkAccelerationStructureKHR</type>                             <name>dst</name></member>
            <member><type>VkCopyAccelerationStructureModeKHR</type>                     <name>mode</name></member>
        </type>
        <type category="struct" name="VkRayTracingPipelineInterfaceCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
            <member><type>uint32_t</type>                                               <name>maxPipelineRayPayloadSize</name></member>
            <member><type>uint32_t</type>                                               <name>maxPipelineRayHitAttributeSize</name></member>
        </type>
        <type category="struct" name="VkPipelineLibraryCreateInfoKHR" structextends="VkGraphicsPipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                               <name>libraryCount</name></member>
            <member len="libraryCount">const <type>VkPipeline</type>*                   <name>pLibraries</name></member>
        </type>
        <type category="struct" name="VkRefreshObjectKHR">
            <member><type>VkObjectType</type>                                       <name>objectType</name></member>
            <member objecttype="objectType" externsync="true"><type>uint64_t</type> <name>objectHandle</name></member>
            <member optional="true"><type>VkRefreshObjectFlagsKHR</type>            <name>flags</name></member>
        </type>
        <type category="struct" name="VkRefreshObjectListKHR">
            <member values="VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
            <member><type>uint32_t</type>                                           <name>objectCount</name></member>
            <member len="objectCount">const <type>VkRefreshObjectKHR</type>*        <name>pObjects</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExtendedDynamicStateFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>extendedDynamicState</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExtendedDynamicState2FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState2</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState2LogicOp</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState2PatchControlPoints</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExtendedDynamicState3FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3TessellationDomainOrigin</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3DepthClampEnable</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3PolygonMode</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3RasterizationSamples</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3SampleMask</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3AlphaToCoverageEnable</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3AlphaToOneEnable</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3LogicOpEnable</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3ColorBlendEnable</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3ColorBlendEquation</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3ColorWriteMask</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3RasterizationStream</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3ConservativeRasterizationMode</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3ExtraPrimitiveOverestimationSize</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3DepthClipEnable</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3SampleLocationsEnable</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3ColorBlendAdvanced</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3ProvokingVertexMode</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3LineRasterizationMode</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3LineStippleEnable</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3DepthClipNegativeOneToOne</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3ViewportWScalingEnable</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3ViewportSwizzle</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3CoverageToColorEnable</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3CoverageToColorLocation</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3CoverageModulationMode</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3CoverageModulationTableEnable</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3CoverageModulationTable</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3CoverageReductionMode</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3RepresentativeFragmentTestEnable</name></member>
            <member><type>VkBool32</type>                     <name>extendedDynamicState3ShadingRateImageEnable</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExtendedDynamicState3PropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>     <name>dynamicPrimitiveTopologyUnrestricted</name></member>
        </type>
        <type category="struct" name="VkColorBlendEquationEXT">
            <member><type>VkBlendFactor</type>               <name>srcColorBlendFactor</name></member>
            <member><type>VkBlendFactor</type>               <name>dstColorBlendFactor</name></member>
            <member><type>VkBlendOp</type>                   <name>colorBlendOp</name></member>
            <member><type>VkBlendFactor</type>               <name>srcAlphaBlendFactor</name></member>
            <member><type>VkBlendFactor</type>               <name>dstAlphaBlendFactor</name></member>
            <member><type>VkBlendOp</type>                   <name>alphaBlendOp</name></member>
        </type>
        <type category="struct" name="VkColorBlendAdvancedEXT">
            <member><type>VkBlendOp</type>                   <name>advancedBlendOp</name></member>
            <member><type>VkBool32</type>                    <name>srcPremultiplied</name></member>
            <member><type>VkBool32</type>                    <name>dstPremultiplied</name></member>
            <member><type>VkBlendOverlapEXT</type>           <name>blendOverlap</name></member>
            <member><type>VkBool32</type>                    <name>clampResults</name></member>
        </type>
        <type category="struct" name="VkRenderPassTransformBeginInfoQCOM" structextends="VkRenderPassBeginInfo">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                           <name>pNext</name><comment>Pointer to next structure</comment></member>
            <member noautovalidity="true"><type>VkSurfaceTransformFlagBitsKHR</type>   <name>transform</name></member>
        </type>
        <type category="struct" name="VkCopyCommandTransformInfoQCOM" structextends="VkBufferImageCopy2,VkImageBlit2">
            <member values="VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true">const <type>void</type>*     <name>pNext</name></member>
            <member noautovalidity="true"><type>VkSurfaceTransformFlagBitsKHR</type>   <name>transform</name></member>
        </type>
        <type category="struct" name="VkCommandBufferInheritanceRenderPassTransformInfoQCOM" structextends="VkCommandBufferInheritanceInfo">
            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                           <name>pNext</name><comment>Pointer to next structure</comment></member>
            <member noautovalidity="true"><type>VkSurfaceTransformFlagBitsKHR</type>   <name>transform</name></member>
            <member><type>VkRect2D</type>                        <name>renderArea</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member><type>VkBool32</type>                                       <name>partitionedAccelerationStructure</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*    <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>                       <name>maxPartitionCount</name></member>
        </type>
        <type category="struct" name="VkBuildPartitionedAccelerationStructureIndirectCommandNV">
            <member><type>VkPartitionedAccelerationStructureOpTypeNV</type>    <name>opType</name></member>
            <member><type>uint32_t</type>                                       <name>argCount</name></member>
            <member><type>VkStridedDeviceAddressNV</type>                      <name>argData</name></member>
        </type>
        <type category="struct" name="VkPartitionedAccelerationStructureFlagsNV" structextends="VkPartitionedAccelerationStructureInstancesInputNV">
            <member values="VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                           <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>enablePartitionTranslation</name></member>
        </type>
        <type category="struct" name="VkPartitionedAccelerationStructureWriteInstanceDataNV">
            <member><type>VkTransformMatrixKHR</type>                           <name>transform</name></member>
            <member><type>float</type>                                          <name>explicitAABB</name>[6]</member>
            <member><type>uint32_t</type>                                       <name>instanceID</name></member>
            <member><type>uint32_t</type>                                       <name>instanceMask</name></member>
            <member><type>uint32_t</type>                                       <name>instanceContributionToHitGroupIndex</name></member>
            <member optional="true"><type>VkPartitionedAccelerationStructureInstanceFlagsNV</type> <name>instanceFlags</name></member>
            <member><type>uint32_t</type>                                       <name>instanceIndex</name></member>
            <member><type>uint32_t</type>                                       <name>partitionIndex</name></member>
            <member><type>VkDeviceAddress</type>                                <name>accelerationStructure</name></member>
        </type>
        <type category="struct" name="VkPartitionedAccelerationStructureUpdateInstanceDataNV">
            <member><type>uint32_t</type>                                       <name>instanceIndex</name></member>
            <member><type>uint32_t</type>                                       <name>instanceContributionToHitGroupIndex</name></member>
            <member><type>VkDeviceAddress</type>                                <name>accelerationStructure</name></member>
        </type>
        <type category="struct" name="VkPartitionedAccelerationStructureWritePartitionTranslationDataNV">
            <member><type>uint32_t</type>                                       <name>partitionIndex</name></member>
            <member><type>float</type>                                          <name>partitionTranslation</name>[3]</member>
        </type>
        <type category="struct" name="VkWriteDescriptorSetPartitionedAccelerationStructureNV" structextends="VkWriteDescriptorSet">
            <member values="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member><type>uint32_t</type>                                       <name>accelerationStructureCount</name></member>
            <member optional="false,true" len="accelerationStructureCount">const <type>VkDeviceAddress</type>* <name>pAccelerationStructures</name></member>
        </type>
        <type category="struct" name="VkPartitionedAccelerationStructureInstancesInputNV">
            <member values="VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member optional="true"><type>VkBuildAccelerationStructureFlagsKHR</type> <name>flags</name></member>
            <member><type>uint32_t</type>                                       <name>instanceCount</name></member>
            <member><type>uint32_t</type>                                       <name>maxInstancePerPartitionCount</name></member>
            <member><type>uint32_t</type>                                       <name>partitionCount</name></member>
            <member><type>uint32_t</type>                                       <name>maxInstanceInGlobalPartitionCount</name></member>
        </type>
        <type category="struct" name="VkBuildPartitionedAccelerationStructureInfoNV">
            <member values="VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member><type>VkPartitionedAccelerationStructureInstancesInputNV</type> <name>input</name></member>
            <member><type>VkDeviceAddress</type>                                <name>srcAccelerationStructureData</name></member>
            <member><type>VkDeviceAddress</type>                                <name>dstAccelerationStructureData</name></member>
            <member><type>VkDeviceAddress</type>                                <name>scratchData</name></member>
            <member><type>VkDeviceAddress</type>                                <name>srcInfos</name></member>
            <member><type>VkDeviceAddress</type>                                <name>srcInfosCount</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDiagnosticsConfigFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                       <name>diagnosticsConfig</name></member>
        </type>
        <type category="struct" name="VkDeviceDiagnosticsConfigCreateInfoNV" structextends="VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                         <name>pNext</name></member>
            <member optional="true"><type>VkDeviceDiagnosticsConfigFlagsNV</type>    <name>flags</name></member>
        </type>
        <type category="struct" name="VkPipelineOfflineCreateInfo" structextends="VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkRayTracingPipelineCreateInfoKHR,VkRayTracingPipelineCreateInfoNV">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
            <member><type>uint8_t</type>                                       <name>pipelineIdentifier</name>[<enum>VK_UUID_SIZE</enum>]</member>
            <member><type>VkPipelineMatchControl</type>                        <name>matchControl</name></member>
            <member><type>VkDeviceSize</type>                                  <name>poolEntrySize</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*          <name>pNext</name></member>
            <member><type>VkBool32</type>       <name>shaderZeroInitializeWorkgroupMemory</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR" alias="VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures"/>
        <type category="struct" name="VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type> <name>shaderSubgroupUniformControlFlow</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRobustness2FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>robustBufferAccess2</name></member>
            <member><type>VkBool32</type>                           <name>robustImageAccess2</name></member>
            <member><type>VkBool32</type>                           <name>nullDescriptor</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRobustness2FeaturesEXT" alias="VkPhysicalDeviceRobustness2FeaturesKHR"/>
        <type category="struct" name="VkPhysicalDeviceRobustness2PropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member limittype="min,pot"><type>VkDeviceSize</type>    <name>robustStorageBufferAccessSizeAlignment</name></member>
            <member limittype="min,pot"><type>VkDeviceSize</type>    <name>robustUniformBufferAccessSizeAlignment</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRobustness2PropertiesEXT" alias="VkPhysicalDeviceRobustness2PropertiesKHR"/>
        <type category="struct" name="VkPhysicalDeviceImageRobustnessFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>robustImageAccess</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImageRobustnessFeaturesEXT" alias="VkPhysicalDeviceImageRobustnessFeatures"/>
        <type category="struct" name="VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>workgroupMemoryExplicitLayout</name></member>
            <member><type>VkBool32</type>                           <name>workgroupMemoryExplicitLayoutScalarBlockLayout</name></member>
            <member><type>VkBool32</type>                           <name>workgroupMemoryExplicitLayout8BitAccess</name></member>
            <member><type>VkBool32</type>                           <name>workgroupMemoryExplicitLayout16BitAccess</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePortabilitySubsetFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>constantAlphaColorBlendFactors</name></member>
            <member><type>VkBool32</type>                           <name>events</name></member>
            <member><type>VkBool32</type>                           <name>imageViewFormatReinterpretation</name></member>
            <member><type>VkBool32</type>                           <name>imageViewFormatSwizzle</name></member>
            <member><type>VkBool32</type>                           <name>imageView2DOn3DImage</name></member>
            <member><type>VkBool32</type>                           <name>multisampleArrayImage</name></member>
            <member><type>VkBool32</type>                           <name>mutableComparisonSamplers</name></member>
            <member><type>VkBool32</type>                           <name>pointPolygons</name></member>
            <member><type>VkBool32</type>                           <name>samplerMipLodBias</name></member>
            <member><type>VkBool32</type>                           <name>separateStencilMaskRef</name></member>
            <member><type>VkBool32</type>                           <name>shaderSampleRateInterpolationFunctions</name></member>
            <member><type>VkBool32</type>                           <name>tessellationIsolines</name></member>
            <member><type>VkBool32</type>                           <name>tessellationPointMode</name></member>
            <member><type>VkBool32</type>                           <name>triangleFans</name></member>
            <member><type>VkBool32</type>                           <name>vertexAttributeAccessBeyondStride</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePortabilitySubsetPropertiesKHR" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member limittype="min,pot"><type>uint32_t</type>  <name>minVertexInputBindingStrideAlignment</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevice4444FormatsFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>formatA4R4G4B4</name></member>
            <member><type>VkBool32</type>                           <name>formatA4B4G4R4</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSubpassShadingFeaturesHUAWEI" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>subpassShading</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI"><type>VkStructureType</type>  <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type> <name>clustercullingShader</name></member>
            <member><type>VkBool32</type> <name>multiviewClusterCullingShader</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI" structextends="VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI"><type>VkStructureType</type>  <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type> <name>clusterShadingRate</name></member>
        </type>
        <type category="struct" name="VkBufferCopy2">
            <member values="VK_STRUCTURE_TYPE_BUFFER_COPY_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
            <member><type>VkDeviceSize</type>                       <name>srcOffset</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>                       <name>dstOffset</name><comment>Specified in bytes</comment></member>
            <member noautovalidity="true"><type>VkDeviceSize</type> <name>size</name><comment>Specified in bytes</comment></member>
        </type>
        <type category="struct" name="VkBufferCopy2KHR" alias="VkBufferCopy2"/>
        <type category="struct" name="VkImageCopy2">
            <member values="VK_STRUCTURE_TYPE_IMAGE_COPY_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
            <member><type>VkImageSubresourceLayers</type>           <name>srcSubresource</name></member>
            <member><type>VkOffset3D</type>                         <name>srcOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
            <member><type>VkImageSubresourceLayers</type>           <name>dstSubresource</name></member>
            <member><type>VkOffset3D</type>                         <name>dstOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
            <member><type>VkExtent3D</type>                         <name>extent</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
        </type>
        <type category="struct" name="VkImageCopy2KHR" alias="VkImageCopy2"/>
        <type category="struct" name="VkImageBlit2">
            <member values="VK_STRUCTURE_TYPE_IMAGE_BLIT_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
            <member><type>VkImageSubresourceLayers</type>           <name>srcSubresource</name></member>
            <member><type>VkOffset3D</type>                         <name>srcOffsets</name>[2]<comment>Specified in pixels for both compressed and uncompressed images</comment></member>
            <member><type>VkImageSubresourceLayers</type>           <name>dstSubresource</name></member>
            <member><type>VkOffset3D</type>                         <name>dstOffsets</name>[2]<comment>Specified in pixels for both compressed and uncompressed images</comment></member>
        </type>
        <type category="struct" name="VkImageBlit2KHR" alias="VkImageBlit2"/>
        <type category="struct" name="VkBufferImageCopy2">
            <member values="VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
            <member><type>VkDeviceSize</type>                       <name>bufferOffset</name><comment>Specified in bytes</comment></member>
            <member><type>uint32_t</type>                           <name>bufferRowLength</name><comment>Specified in texels</comment></member>
            <member><type>uint32_t</type>                           <name>bufferImageHeight</name></member>
            <member><type>VkImageSubresourceLayers</type>           <name>imageSubresource</name></member>
            <member><type>VkOffset3D</type>                         <name>imageOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
            <member><type>VkExtent3D</type>                         <name>imageExtent</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
        </type>
        <type category="struct" name="VkBufferImageCopy2KHR" alias="VkBufferImageCopy2"/>
        <type category="struct" name="VkImageResolve2">
            <member values="VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
            <member><type>VkImageSubresourceLayers</type>           <name>srcSubresource</name></member>
            <member><type>VkOffset3D</type>                         <name>srcOffset</name></member>
            <member><type>VkImageSubresourceLayers</type>           <name>dstSubresource</name></member>
            <member><type>VkOffset3D</type>                         <name>dstOffset</name></member>
            <member><type>VkExtent3D</type>                         <name>extent</name></member>
        </type>
        <type category="struct" name="VkImageResolve2KHR" alias="VkImageResolve2"/>
        <type category="struct" name="VkCopyBufferInfo2">
            <member values="VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
            <member><type>VkBuffer</type>                           <name>srcBuffer</name></member>
            <member><type>VkBuffer</type>                           <name>dstBuffer</name></member>
            <member><type>uint32_t</type>                           <name>regionCount</name></member>
            <member len="regionCount">const <type>VkBufferCopy2</type>* <name>pRegions</name></member>
        </type>
        <type category="struct" name="VkCopyBufferInfo2KHR" alias="VkCopyBufferInfo2"/>
        <type category="struct" name="VkCopyImageInfo2">
            <member values="VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
            <member><type>VkImage</type>                            <name>srcImage</name></member>
            <member><type>VkImageLayout</type>                      <name>srcImageLayout</name></member>
            <member><type>VkImage</type>                            <name>dstImage</name></member>
            <member><type>VkImageLayout</type>                      <name>dstImageLayout</name></member>
            <member><type>uint32_t</type>                           <name>regionCount</name></member>
            <member len="regionCount">const <type>VkImageCopy2</type>* <name>pRegions</name></member>
        </type>
        <type category="struct" name="VkCopyImageInfo2KHR" alias="VkCopyImageInfo2"/>
        <type category="struct" name="VkBlitImageInfo2">
            <member values="VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkImage</type>                                <name>srcImage</name></member>
            <member><type>VkImageLayout</type>                          <name>srcImageLayout</name></member>
            <member><type>VkImage</type>                                <name>dstImage</name></member>
            <member><type>VkImageLayout</type>                          <name>dstImageLayout</name></member>
            <member><type>uint32_t</type>                               <name>regionCount</name></member>
            <member len="regionCount">const <type>VkImageBlit2</type>*  <name>pRegions</name></member>
            <member><type>VkFilter</type>                               <name>filter</name></member>
        </type>
        <type category="struct" name="VkBlitImageInfo2KHR" alias="VkBlitImageInfo2"/>
        <type category="struct" name="VkCopyBufferToImageInfo2">
            <member values="VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                 <name>pNext</name></member>
            <member><type>VkBuffer</type>                                    <name>srcBuffer</name></member>
            <member><type>VkImage</type>                                     <name>dstImage</name></member>
            <member><type>VkImageLayout</type>                               <name>dstImageLayout</name></member>
            <member><type>uint32_t</type>                                    <name>regionCount</name></member>
            <member len="regionCount">const <type>VkBufferImageCopy2</type>* <name>pRegions</name></member>
        </type>
        <type category="struct" name="VkCopyBufferToImageInfo2KHR" alias="VkCopyBufferToImageInfo2"/>
        <type category="struct" name="VkCopyImageToBufferInfo2">
            <member values="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                   <name>pNext</name></member>
            <member><type>VkImage</type>                                       <name>srcImage</name></member>
            <member><type>VkImageLayout</type>                                 <name>srcImageLayout</name></member>
            <member><type>VkBuffer</type>                                      <name>dstBuffer</name></member>
            <member><type>uint32_t</type>                                      <name>regionCount</name></member>
            <member len="regionCount">const <type>VkBufferImageCopy2</type>*   <name>pRegions</name></member>
        </type>
        <type category="struct" name="VkCopyImageToBufferInfo2KHR" alias="VkCopyImageToBufferInfo2"/>
        <type category="struct" name="VkResolveImageInfo2">
            <member values="VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member><type>VkImage</type>                                    <name>srcImage</name></member>
            <member><type>VkImageLayout</type>                              <name>srcImageLayout</name></member>
            <member><type>VkImage</type>                                    <name>dstImage</name></member>
            <member><type>VkImageLayout</type>                              <name>dstImageLayout</name></member>
            <member><type>uint32_t</type>                                   <name>regionCount</name></member>
            <member len="regionCount">const <type>VkImageResolve2</type>*   <name>pRegions</name></member>
        </type>
        <type category="struct" name="VkResolveImageInfo2KHR" alias="VkResolveImageInfo2"/>
        <type category="struct" name="VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>shaderImageInt64Atomics</name></member>
            <member><type>VkBool32</type>                            <name>sparseImageInt64Atomics</name></member>
        </type>
        <type category="struct" name="VkFragmentShadingRateAttachmentInfoKHR" structextends="VkSubpassDescription2">
            <member values="VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member optional="true">const <type>VkAttachmentReference2</type>* <name>pFragmentShadingRateAttachment</name></member>
            <member><type>VkExtent2D</type>                 <name>shadingRateAttachmentTexelSize</name></member>
        </type>
        <type category="struct" name="VkPipelineFragmentShadingRateStateCreateInfoKHR" structextends="VkGraphicsPipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                <name>pNext</name></member>
            <member><type>VkExtent2D</type>                                 <name>fragmentSize</name></member>
            <member noautovalidity="true"><type>VkFragmentShadingRateCombinerOpKHR</type>         <name>combinerOps</name>[2]</member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentShadingRateFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member><type>VkBool32</type>           <name>pipelineFragmentShadingRate</name></member>
            <member><type>VkBool32</type>           <name>primitiveFragmentShadingRate</name></member>
            <member><type>VkBool32</type>           <name>attachmentFragmentShadingRate</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentShadingRatePropertiesKHR" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member limittype="min"><type>VkExtent2D</type>             <name>minFragmentShadingRateAttachmentTexelSize</name></member>
            <member limittype="max"><type>VkExtent2D</type>             <name>maxFragmentShadingRateAttachmentTexelSize</name></member>
            <member limittype="max,pot"><type>uint32_t</type>                <name>maxFragmentShadingRateAttachmentTexelSizeAspectRatio</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>primitiveFragmentShadingRateWithMultipleViewports</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>layeredShadingRateAttachments</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>fragmentShadingRateNonTrivialCombinerOps</name></member>
            <member limittype="max"><type>VkExtent2D</type>             <name>maxFragmentSize</name></member>
            <member limittype="max,pot"><type>uint32_t</type>                <name>maxFragmentSizeAspectRatio</name></member>
            <member limittype="max"><type>uint32_t</type>                   <name>maxFragmentShadingRateCoverageSamples</name></member>
            <member limittype="max"><type>VkSampleCountFlagBits</type>  <name>maxFragmentShadingRateRasterizationSamples</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>fragmentShadingRateWithShaderDepthStencilWrites</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>fragmentShadingRateWithSampleMask</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>fragmentShadingRateWithShaderSampleMask</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>fragmentShadingRateWithConservativeRasterization</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>fragmentShadingRateWithFragmentShaderInterlock</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>fragmentShadingRateWithCustomSampleLocations</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>fragmentShadingRateStrictMultiplyCombiner</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentShadingRateKHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member><type>VkSampleCountFlags</type> <name>sampleCounts</name></member>
            <member><type>VkExtent2D</type>         <name>fragmentSize</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderTerminateInvocationFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                                       <name>shaderTerminateInvocation</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR" alias="VkPhysicalDeviceShaderTerminateInvocationFeatures"/>
        <type category="struct" name="VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>fragmentShadingRateEnums</name></member>
            <member><type>VkBool32</type>                           <name>supersampleFragmentShadingRates</name></member>
            <member><type>VkBool32</type>                           <name>noInvocationFragmentShadingRates</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member limittype="max"><type>VkSampleCountFlagBits</type>              <name>maxFragmentShadingRateInvocationCount</name></member>
        </type>
        <type category="struct" name="VkPipelineFragmentShadingRateEnumStateCreateInfoNV" structextends="VkGraphicsPipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
            <member noautovalidity="true"><type>VkFragmentShadingRateTypeNV</type>        <name>shadingRateType</name></member>
            <member noautovalidity="true"><type>VkFragmentShadingRateNV</type>            <name>shadingRate</name></member>
            <member noautovalidity="true"><type>VkFragmentShadingRateCombinerOpKHR</type> <name>combinerOps</name>[2]</member>
        </type>
        <type category="struct" name="VkAccelerationStructureBuildSizesInfoKHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkDeviceSize</type>                       <name>accelerationStructureSize</name></member>
            <member><type>VkDeviceSize</type>                       <name>updateScratchSize</name></member>
            <member><type>VkDeviceSize</type>                       <name>buildScratchSize</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImage2DViewOf3DFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*                     <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>image2DViewOf3D</name></member>
            <member><type>VkBool32</type>                                        <name>sampler2DViewOf3D</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*                     <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>imageSlicedViewOf3D</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>attachmentFeedbackLoopDynamicState</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>legacyVertexAttributes</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>                        <name>nativeUnalignedPerformance</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>mutableDescriptorType</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE" alias="VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT"/>
        <type category="struct" name="VkMutableDescriptorTypeListEXT">
            <member optional="true"><type>uint32_t</type>                          <name>descriptorTypeCount</name></member>
            <member len="descriptorTypeCount">const <type>VkDescriptorType</type>* <name>pDescriptorTypes</name></member>
        </type>
        <type category="struct" name="VkMutableDescriptorTypeListVALVE" alias="VkMutableDescriptorTypeListEXT"/>
        <type category="struct" name="VkMutableDescriptorTypeCreateInfoEXT" structextends="VkDescriptorSetLayoutCreateInfo,VkDescriptorPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                       <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                          <name>mutableDescriptorTypeListCount</name></member>
            <member len="mutableDescriptorTypeListCount">const <type>VkMutableDescriptorTypeListEXT</type>* <name>pMutableDescriptorTypeLists</name></member>
        </type>
        <type category="struct" name="VkMutableDescriptorTypeCreateInfoVALVE" alias="VkMutableDescriptorTypeCreateInfoEXT"/>
        <type category="struct" name="VkPhysicalDeviceDepthClipControlFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type>                                    <name>depthClipControl</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type>                                    <name>zeroInitializeDeviceMemory</name></member>
        </type>
        <type category="struct" name="VkBeginCustomResolveInfoEXT">
            <member values="VK_STRUCTURE_TYPE_BEGIN_CUSTOM_RESOLVE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCustomResolveFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_RESOLVE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type>                                    <name>customResolve</name></member>
        </type>
        <type category="struct" name="VkCustomResolveCreateInfoEXT" structextends="VkGraphicsPipelineCreateInfo,VkCommandBufferInheritanceInfo,VkShaderCreateInfoEXT">
            <member values="VK_STRUCTURE_TYPE_CUSTOM_RESOLVE_CREATE_INFO_EXT"><type>VkStructureType</type>  <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
            <member><type>VkBool32</type>                                                                   <name>customResolve</name></member>
            <member optional="true"><type>uint32_t</type>                                                   <name>colorAttachmentCount</name></member>
            <member noautovalidity="true" len="colorAttachmentCount">const <type>VkFormat</type>*           <name>pColorAttachmentFormats</name></member>
            <member noautovalidity="true"><type>VkFormat</type>                                             <name>depthAttachmentFormat</name></member>
            <member noautovalidity="true"><type>VkFormat</type>                                             <name>stencilAttachmentFormat</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type>                                    <name>deviceGeneratedCommands</name></member>
            <member><type>VkBool32</type>                                    <name>dynamicGeneratedPipelineLayout</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxIndirectPipelineCount</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxIndirectShaderObjectCount</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxIndirectSequenceCount</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxIndirectCommandsTokenCount</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxIndirectCommandsTokenOffset</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxIndirectCommandsIndirectStride</name></member>
            <member limittype="bitmask"><type>VkIndirectCommandsInputModeFlagsEXT</type> <name>supportedIndirectCommandsInputModes</name></member>
            <member limittype="bitmask"><type>VkShaderStageFlags</type>              <name>supportedIndirectCommandsShaderStages</name></member>
            <member limittype="bitmask"><type>VkShaderStageFlags</type>              <name>supportedIndirectCommandsShaderStagesPipelineBinding</name></member>
            <member limittype="bitmask"><type>VkShaderStageFlags</type>              <name>supportedIndirectCommandsShaderStagesShaderBinding</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>deviceGeneratedCommandsTransformFeedback</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>deviceGeneratedCommandsMultiDrawIndirectCount</name></member>
        </type>
        <type category="struct" name="VkGeneratedCommandsPipelineInfoEXT" structextends="VkGeneratedCommandsInfoEXT,VkGeneratedCommandsMemoryRequirementsInfoEXT">
            <member values="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member><type>VkPipeline</type>                                       <name>pipeline</name></member>
        </type>
        <type category="struct" name="VkGeneratedCommandsShaderInfoEXT" structextends="VkGeneratedCommandsInfoEXT,VkGeneratedCommandsMemoryRequirementsInfoEXT">
            <member values="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member><type>uint32_t</type>                                       <name>shaderCount</name></member>
            <member len="shaderCount">const <type>VkShaderEXT</type>*                              <name>pShaders</name></member>
        </type>
        <type category="struct" name="VkGeneratedCommandsMemoryRequirementsInfoEXT">
            <member values="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
            <member optional="true"><type>VkIndirectExecutionSetEXT</type>      <name>indirectExecutionSet</name></member>
            <member><type>VkIndirectCommandsLayoutEXT</type>                    <name>indirectCommandsLayout</name></member>
            <member><type>uint32_t</type>                                       <name>maxSequenceCount</name></member>
            <member><type>uint32_t</type>                                       <name>maxDrawCount</name></member>
        </type>
        <type category="struct" name="VkIndirectExecutionSetPipelineInfoEXT">
            <member values="VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkPipeline</type>                                          <name>initialPipeline</name></member>
            <member><type>uint32_t</type>                                            <name>maxPipelineCount</name></member>
        </type>
        <type category="struct" name="VkIndirectExecutionSetShaderLayoutInfoEXT">
            <member values="VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                                                                <name>setLayoutCount</name></member>
            <member len="setLayoutCount" optional="false,true">const <type>VkDescriptorSetLayout</type>*             <name>pSetLayouts</name></member>
        </type>
        <type category="struct" name="VkIndirectExecutionSetShaderInfoEXT">
            <member values="VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type>                                                                <name>shaderCount</name></member>
            <member len="shaderCount">const <type>VkShaderEXT</type>*                               <name>pInitialShaders</name></member>
            <member len="shaderCount" optional="true">const <type>VkIndirectExecutionSetShaderLayoutInfoEXT</type>*  <name>pSetLayoutInfos</name></member>
            <member><type>uint32_t</type>                                                                <name>maxShaderCount</name></member>
            <member optional="true"><type>uint32_t</type>                                                <name>pushConstantRangeCount</name></member>
            <member len="pushConstantRangeCount">const <type>VkPushConstantRange</type>*                 <name>pPushConstantRanges</name></member>
        </type>
        <type category="union" name="VkIndirectExecutionSetInfoEXT">
            <member selection="VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT">const <type>VkIndirectExecutionSetPipelineInfoEXT</type>*     <name>pPipelineInfo</name></member>
            <member selection="VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT">const <type>VkIndirectExecutionSetShaderInfoEXT</type>*  <name>pShaderInfo</name></member>
        </type>
        <type category="struct" name="VkIndirectExecutionSetCreateInfoEXT">
            <member values="VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkIndirectExecutionSetInfoTypeEXT</type>                 <name>type</name></member>
            <member selector="type" noautovalidity="true"><type>VkIndirectExecutionSetInfoEXT</type>  <name>info</name></member>
        </type>
        <type category="struct" name="VkGeneratedCommandsInfoEXT">
            <member values="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkShaderStageFlags</type>                          <name>shaderStages</name></member>
            <member optional="true"><type>VkIndirectExecutionSetEXT</type>   <name>indirectExecutionSet</name></member>
            <member><type>VkIndirectCommandsLayoutEXT</type>                 <name>indirectCommandsLayout</name></member>
            <member><type>VkDeviceAddress</type>                             <name>indirectAddress</name></member>
            <member><type>VkDeviceSize</type>                                <name>indirectAddressSize</name></member>
            <member optional="true"><type>VkDeviceAddress</type>             <name>preprocessAddress</name></member>
            <member><type>VkDeviceSize</type>                                <name>preprocessSize</name></member>
            <member><type>uint32_t</type>                                    <name>maxSequenceCount</name></member>
            <member optional="true"><type>VkDeviceAddress</type>             <name>sequenceCountAddress</name></member>
            <member><type>uint32_t</type>                                    <name>maxDrawCount</name></member>
        </type>
        <type category="struct" name="VkWriteIndirectExecutionSetPipelineEXT">
            <member values="VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type>                                            <name>index</name></member>
            <member><type>VkPipeline</type>                                          <name>pipeline</name></member>
        </type>
        <type category="struct" name="VkWriteIndirectExecutionSetShaderEXT">
            <member values="VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type>                                            <name>index</name></member>
            <member><type>VkShaderEXT</type>                                         <name>shader</name></member>
        </type>
        <type category="struct" name="VkIndirectCommandsLayoutCreateInfoEXT">
            <member values="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member optional="true"><type>VkIndirectCommandsLayoutUsageFlagsEXT</type> <name>flags</name></member>
            <member><type>VkShaderStageFlags</type>                                    <name>shaderStages</name></member>
            <member><type>uint32_t</type>                                              <name>indirectStride</name></member>
            <member optional="true"><type>VkPipelineLayout</type>                      <name>pipelineLayout</name></member>
            <member><type>uint32_t</type>                                              <name>tokenCount</name></member>
            <member len="tokenCount">const <type>VkIndirectCommandsLayoutTokenEXT</type>*                   <name>pTokens</name></member>
        </type>
        <type category="struct" name="VkIndirectCommandsLayoutTokenEXT">
            <member values="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkIndirectCommandsTokenTypeEXT</type>              <name>type</name></member>
            <member selector="type" noautovalidity="true"><type>VkIndirectCommandsTokenDataEXT</type> <name>data</name></member>
            <member><type>uint32_t</type>                                    <name>offset</name></member>
        </type>
        <type category="struct" name="VkDrawIndirectCountIndirectCommandEXT">
            <member><type>VkDeviceAddress</type>      <name>bufferAddress</name></member>
            <member><type>uint32_t</type>             <name>stride</name></member>
            <member><type>uint32_t</type>             <name>commandCount</name></member>
        </type>
        <type category="struct" name="VkIndirectCommandsVertexBufferTokenEXT">
            <member><type>uint32_t</type>             <name>vertexBindingUnit</name></member>
        </type>
        <type category="struct" name="VkBindVertexBufferIndirectCommandEXT">
            <member><type>VkDeviceAddress</type>      <name>bufferAddress</name></member>
            <member><type>uint32_t</type>             <name>size</name></member>
            <member><type>uint32_t</type>             <name>stride</name></member>
        </type>
        <type category="struct" name="VkIndirectCommandsIndexBufferTokenEXT">
            <member><type>VkIndirectCommandsInputModeFlagBitsEXT</type>              <name>mode</name></member>
        </type>
        <type category="struct" name="VkBindIndexBufferIndirectCommandEXT">
            <member><type>VkDeviceAddress</type>      <name>bufferAddress</name></member>
            <member><type>uint32_t</type>             <name>size</name></member>
            <member><type>VkIndexType</type>          <name>indexType</name></member>
        </type>
        <type category="struct" name="VkIndirectCommandsPushConstantTokenEXT">
            <member><type>VkPushConstantRange</type>      <name>updateRange</name></member>
        </type>
        <type category="struct" name="VkIndirectCommandsExecutionSetTokenEXT">
            <member><type>VkIndirectExecutionSetInfoTypeEXT</type>        <name>type</name></member>
            <member><type>VkShaderStageFlags</type>                            <name>shaderStages</name></member>
        </type>
        <type category="union" name="VkIndirectCommandsTokenDataEXT">
            <member selection="VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT,VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT">const <type>VkIndirectCommandsPushConstantTokenEXT</type>*  <name>pPushConstant</name></member>
            <member selection="VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT">const <type>VkIndirectCommandsVertexBufferTokenEXT</type>*  <name>pVertexBuffer</name></member>
            <member selection="VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT">const <type>VkIndirectCommandsIndexBufferTokenEXT</type>*    <name>pIndexBuffer</name></member>
            <member selection="VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT">const <type>VkIndirectCommandsExecutionSetTokenEXT</type>*  <name>pExecutionSet</name></member>
        </type>
        <type category="struct" name="VkPipelineViewportDepthClipControlCreateInfoEXT" structextends="VkPipelineViewportStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type>                    <name>negativeOneToOne</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDepthClampControlFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type>                                    <name>depthClampControl</name></member>
        </type>
        <type category="struct" name="VkPipelineViewportDepthClampControlCreateInfoEXT" structextends="VkPipelineViewportStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
            <member><type>VkDepthClampModeEXT</type>                            <name>depthClampMode</name></member>
            <member optional="true">const <type>VkDepthClampRangeEXT</type>*    <name>pDepthClampRange</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>vertexInputDynamicState</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalMemoryRDMAFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>externalMemoryRDMA</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>shaderRelaxedExtendedInstruction</name></member>
        </type>
        <type category="struct" name="VkVertexInputBindingDescription2EXT">
            <member values="VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>uint32_t</type>                       <name>binding</name></member>
            <member><type>uint32_t</type>                       <name>stride</name></member>
            <member><type>VkVertexInputRate</type>              <name>inputRate</name></member>
            <member><type>uint32_t</type>                       <name>divisor</name></member>
        </type>
        <type category="struct" name="VkVertexInputAttributeDescription2EXT">
            <member values="VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>uint32_t</type>                       <name>location</name><comment>location of the shader vertex attrib</comment></member>
            <member><type>uint32_t</type>                       <name>binding</name><comment>Vertex buffer binding id</comment></member>
            <member><type>VkFormat</type>                       <name>format</name><comment>format of source data</comment></member>
            <member><type>uint32_t</type>                       <name>offset</name><comment>Offset of first element in bytes from base of vertex</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceColorWriteEnableFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                     <name>colorWriteEnable</name></member>
        </type>
        <type category="struct" name="VkPipelineColorWriteCreateInfoEXT" structextends="VkPipelineColorBlendStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>               <name>attachmentCount</name><comment># of pAttachments</comment></member>
            <member len="attachmentCount">const <type>VkBool32</type>*  <name>pColorWriteEnables</name></member>
        </type>
        <type category="struct" name="VkMemoryBarrier2" structextends="VkSubpassDependency2">
            <member values="VK_STRUCTURE_TYPE_MEMORY_BARRIER_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineStageFlags2</type>  <name>srcStageMask</name></member>
            <member optional="true"><type>VkAccessFlags2</type>         <name>srcAccessMask</name></member>
            <member optional="true"><type>VkPipelineStageFlags2</type>  <name>dstStageMask</name></member>
            <member optional="true"><type>VkAccessFlags2</type>         <name>dstAccessMask</name></member>
        </type>
        <type category="struct" name="VkMemoryBarrier2KHR" alias="VkMemoryBarrier2"/>
        <type category="struct" name="VkImageMemoryBarrier2">
            <member values="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineStageFlags2</type>  <name>srcStageMask</name></member>
            <member optional="true"><type>VkAccessFlags2</type>         <name>srcAccessMask</name></member>
            <member optional="true"><type>VkPipelineStageFlags2</type>  <name>dstStageMask</name></member>
            <member optional="true"><type>VkAccessFlags2</type>         <name>dstAccessMask</name></member>
            <member><type>VkImageLayout</type>                          <name>oldLayout</name></member>
            <member><type>VkImageLayout</type>                          <name>newLayout</name></member>
            <member><type>uint32_t</type>                               <name>srcQueueFamilyIndex</name></member>
            <member><type>uint32_t</type>                               <name>dstQueueFamilyIndex</name></member>
            <member><type>VkImage</type>                                <name>image</name></member>
            <member><type>VkImageSubresourceRange</type>                <name>subresourceRange</name></member>
        </type>
        <type category="struct" name="VkImageMemoryBarrier2KHR" alias="VkImageMemoryBarrier2"/>
        <type category="struct" name="VkBufferMemoryBarrier2">
            <member values="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineStageFlags2</type>  <name>srcStageMask</name></member>
            <member optional="true"><type>VkAccessFlags2</type>         <name>srcAccessMask</name></member>
            <member optional="true"><type>VkPipelineStageFlags2</type>  <name>dstStageMask</name></member>
            <member optional="true"><type>VkAccessFlags2</type>         <name>dstAccessMask</name></member>
            <member><type>uint32_t</type>                               <name>srcQueueFamilyIndex</name></member>
            <member><type>uint32_t</type>                               <name>dstQueueFamilyIndex</name></member>
            <member><type>VkBuffer</type>                               <name>buffer</name></member>
            <member><type>VkDeviceSize</type>                           <name>offset</name></member>
            <member><type>VkDeviceSize</type>                           <name>size</name></member>
        </type>
        <type category="struct" name="VkBufferMemoryBarrier2KHR" alias="VkBufferMemoryBarrier2"/>
        <type category="struct" name="VkMemoryBarrierAccessFlags3KHR" structextends="VkSubpassDependency2,VkBufferMemoryBarrier2,VkImageMemoryBarrier2">
            <member values="VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkAccessFlags3KHR</type>      <name>srcAccessMask3</name></member>
            <member optional="true"><type>VkAccessFlags3KHR</type>      <name>dstAccessMask3</name></member>
        </type>
        <type category="struct" name="VkDependencyInfo">
            <member values="VK_STRUCTURE_TYPE_DEPENDENCY_INFO"><type>VkStructureType</type>   <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                  <name>pNext</name></member>
            <member optional="true"><type>VkDependencyFlags</type>                            <name>dependencyFlags</name></member>
            <member optional="true"><type>uint32_t</type>                                     <name>memoryBarrierCount</name></member>
            <member len="memoryBarrierCount">const <type>VkMemoryBarrier2</type>*             <name>pMemoryBarriers</name></member>
            <member optional="true"><type>uint32_t</type>                                     <name>bufferMemoryBarrierCount</name></member>
            <member len="bufferMemoryBarrierCount">const <type>VkBufferMemoryBarrier2</type>* <name>pBufferMemoryBarriers</name></member>
            <member optional="true"><type>uint32_t</type>                                     <name>imageMemoryBarrierCount</name></member>
            <member len="imageMemoryBarrierCount">const <type>VkImageMemoryBarrier2</type>*   <name>pImageMemoryBarriers</name></member>
        </type>
        <type category="struct" name="VkDependencyInfoKHR" alias="VkDependencyInfo"/>
        <type category="struct" name="VkSemaphoreSubmitInfo">
            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO"><type>VkStructureType</type>           <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
            <member><type>VkSemaphore</type>                                                                <name>semaphore</name></member>
            <member><type>uint64_t</type>                                                                   <name>value</name></member>
            <member optional="true"><type>VkPipelineStageFlags2</type>                                      <name>stageMask</name></member>
            <member><type>uint32_t</type>                                                                   <name>deviceIndex</name></member>
        </type>
        <type category="struct" name="VkSemaphoreSubmitInfoKHR" alias="VkSemaphoreSubmitInfo"/>
        <type category="struct" name="VkCommandBufferSubmitInfo">
            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO"><type>VkStructureType</type>      <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
            <member><type>VkCommandBuffer</type>                                                            <name>commandBuffer</name></member>
            <member><type>uint32_t</type>                                                                   <name>deviceMask</name></member>
        </type>
        <type category="struct" name="VkCommandBufferSubmitInfoKHR" alias="VkCommandBufferSubmitInfo"/>
        <type category="struct" name="VkSubmitInfo2">
            <member values="VK_STRUCTURE_TYPE_SUBMIT_INFO_2"><type>VkStructureType</type>                   <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
            <member optional="true"><type>VkSubmitFlags</type>                                              <name>flags</name></member>
            <member optional="true"><type>uint32_t</type>                                                   <name>waitSemaphoreInfoCount</name></member>
            <member len="waitSemaphoreInfoCount">const <type>VkSemaphoreSubmitInfo</type>*                  <name>pWaitSemaphoreInfos</name></member>
            <member optional="true"><type>uint32_t</type>                                                   <name>commandBufferInfoCount</name></member>
            <member len="commandBufferInfoCount">const <type>VkCommandBufferSubmitInfo</type>*              <name>pCommandBufferInfos</name></member>
            <member optional="true"><type>uint32_t</type>                                                   <name>signalSemaphoreInfoCount</name></member>
            <member len="signalSemaphoreInfoCount">const <type>VkSemaphoreSubmitInfo</type>*                <name>pSignalSemaphoreInfos</name></member>
        </type>
        <type category="struct" name="VkSubmitInfo2KHR" alias="VkSubmitInfo2"/>
        <type category="struct" name="VkQueueFamilyCheckpointProperties2NV" structextends="VkQueueFamilyProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*           <name>pNext</name></member>
            <member limittype="bitmask"><type>VkPipelineStageFlags2</type> <name>checkpointExecutionStageMask</name></member>
        </type>
        <type category="struct" name="VkCheckpointData2NV" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*       <name>pNext</name></member>
            <member><type>VkPipelineStageFlags2</type>       <name>stage</name></member>
            <member noautovalidity="true"><type>void</type>* <name>pCheckpointMarker</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSynchronization2Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                   <name>synchronization2</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSynchronization2FeaturesKHR" alias="VkPhysicalDeviceSynchronization2Features"/>
        <type category="struct" name="VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*      <name>pNext</name></member>
            <member><type>VkBool32</type>                   <name>unifiedImageLayouts</name></member>
            <member><type>VkBool32</type>                   <name>unifiedImageLayoutsVideo</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceHostImageCopyFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*      <name>pNext</name></member>
            <member><type>VkBool32</type>                   <name>hostImageCopy</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceHostImageCopyFeaturesEXT" alias="VkPhysicalDeviceHostImageCopyFeatures"/>
        <type category="struct" name="VkPhysicalDeviceHostImageCopyProperties" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                                        <name>pNext</name></member>
            <member optional="true" limittype="noauto"><type>uint32_t</type>                                  <name>copySrcLayoutCount</name></member>
            <member optional="true" limittype="noauto" len="copySrcLayoutCount"><type>VkImageLayout</type>*   <name>pCopySrcLayouts</name></member>
            <member optional="true" limittype="noauto"><type>uint32_t</type>                                  <name>copyDstLayoutCount</name></member>
            <member optional="true" limittype="noauto" len="copyDstLayoutCount"><type>VkImageLayout</type>*   <name>pCopyDstLayouts</name></member>
            <member optional="true" limittype="noauto"><type>uint8_t</type>                                   <name>optimalTilingLayoutUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
            <member limittype="max"><type>VkBool32</type>                                                     <name>identicalMemoryTypeRequirements</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceHostImageCopyPropertiesEXT" alias="VkPhysicalDeviceHostImageCopyProperties"/>
        <type category="struct" name="VkMemoryToImageCopy">
            <member values="VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
            <member>const <type>void</type>*                                    <name>pHostPointer</name></member>
            <member><type>uint32_t</type>                                       <name>memoryRowLength</name><comment>Specified in texels</comment></member>
            <member><type>uint32_t</type>                                       <name>memoryImageHeight</name></member>
            <member><type>VkImageSubresourceLayers</type>                       <name>imageSubresource</name></member>
            <member><type>VkOffset3D</type>                                     <name>imageOffset</name></member>
            <member><type>VkExtent3D</type>                                     <name>imageExtent</name></member>
        </type>
        <type category="struct" name="VkMemoryToImageCopyEXT" alias="VkMemoryToImageCopy"/>
        <type category="struct" name="VkImageToMemoryCopy">
            <member values="VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
            <member><type>void</type>*                                          <name>pHostPointer</name></member>
            <member><type>uint32_t</type>                                       <name>memoryRowLength</name><comment>Specified in texels</comment></member>
            <member><type>uint32_t</type>                                       <name>memoryImageHeight</name></member>
            <member><type>VkImageSubresourceLayers</type>                       <name>imageSubresource</name></member>
            <member><type>VkOffset3D</type>                                     <name>imageOffset</name></member>
            <member><type>VkExtent3D</type>                                     <name>imageExtent</name></member>
        </type>
        <type category="struct" name="VkImageToMemoryCopyEXT" alias="VkImageToMemoryCopy"/>
        <type category="struct" name="VkCopyMemoryToImageInfo">
            <member values="VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member optional="true"><type>VkHostImageCopyFlags</type>       <name>flags</name></member>
            <member><type>VkImage</type>                                    <name>dstImage</name></member>
            <member><type>VkImageLayout</type>                              <name>dstImageLayout</name></member>
            <member><type>uint32_t</type>                                   <name>regionCount</name></member>
            <member len="regionCount">const <type>VkMemoryToImageCopy</type>*    <name>pRegions</name></member>
        </type>
        <type category="struct" name="VkCopyMemoryToImageInfoEXT" alias="VkCopyMemoryToImageInfo"/>
        <type category="struct" name="VkCopyImageToMemoryInfo">
            <member values="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member optional="true"><type>VkHostImageCopyFlags</type>       <name>flags</name></member>
            <member><type>VkImage</type>                                    <name>srcImage</name></member>
            <member><type>VkImageLayout</type>                              <name>srcImageLayout</name></member>
            <member><type>uint32_t</type>                                   <name>regionCount</name></member>
            <member len="regionCount">const <type>VkImageToMemoryCopy</type>*    <name>pRegions</name></member>
        </type>
        <type category="struct" name="VkCopyImageToMemoryInfoEXT" alias="VkCopyImageToMemoryInfo"/>
        <type category="struct" name="VkCopyImageToImageInfo">
            <member values="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member optional="true"><type>VkHostImageCopyFlags</type>       <name>flags</name></member>
            <member><type>VkImage</type>                                    <name>srcImage</name></member>
            <member><type>VkImageLayout</type>                              <name>srcImageLayout</name></member>
            <member><type>VkImage</type>                                    <name>dstImage</name></member>
            <member><type>VkImageLayout</type>                              <name>dstImageLayout</name></member>
            <member><type>uint32_t</type>                                   <name>regionCount</name></member>
            <member len="regionCount">const <type>VkImageCopy2</type>*      <name>pRegions</name></member>
        </type>
        <type category="struct" name="VkCopyImageToImageInfoEXT" alias="VkCopyImageToImageInfo"/>
        <type category="struct" name="VkHostImageLayoutTransitionInfo">
            <member values="VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*  <name>pNext</name></member>
            <member><type>VkImage</type>                      <name>image</name></member>
            <member><type>VkImageLayout</type>                <name>oldLayout</name></member>
            <member><type>VkImageLayout</type>                <name>newLayout</name></member>
            <member><type>VkImageSubresourceRange</type>      <name>subresourceRange</name></member>
        </type>
        <type category="struct" name="VkHostImageLayoutTransitionInfoEXT" alias="VkHostImageLayoutTransitionInfo"/>
        <type category="struct" name="VkSubresourceHostMemcpySize" returnedonly="true" structextends="VkSubresourceLayout2">
            <member values="VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkDeviceSize</type>                 <name>size</name><comment>Specified in bytes</comment></member>
        </type>
        <type category="struct" name="VkSubresourceHostMemcpySizeEXT" alias="VkSubresourceHostMemcpySize"/>
        <type category="struct" name="VkHostImageCopyDevicePerformanceQuery" returnedonly="true" structextends="VkImageFormatProperties2">
            <member values="VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                     <name>optimalDeviceAccess</name><comment>Specifies if device access is optimal</comment></member>
            <member><type>VkBool32</type>                     <name>identicalMemoryLayout</name><comment>Specifies if memory layout is identical</comment></member>
        </type>
        <type category="struct" name="VkHostImageCopyDevicePerformanceQueryEXT" alias="VkHostImageCopyDevicePerformanceQuery"/>
        <type category="struct" name="VkPhysicalDeviceVulkanSC10Properties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*          <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>       <name>deviceNoDynamicHostAllocations</name></member>
            <member limittype="max"><type>VkBool32</type>       <name>deviceDestroyFreesMemory</name></member>
            <member limittype="max"><type>VkBool32</type>       <name>commandPoolMultipleCommandBuffersRecording</name></member>
            <member limittype="max"><type>VkBool32</type>       <name>commandPoolResetCommandBuffer</name></member>
            <member limittype="max"><type>VkBool32</type>       <name>commandBufferSimultaneousUse</name></member>
            <member limittype="max"><type>VkBool32</type>       <name>secondaryCommandBufferNullOrImagelessFramebuffer</name></member>
            <member limittype="max"><type>VkBool32</type>       <name>recycleDescriptorSetMemory</name></member>
            <member limittype="max"><type>VkBool32</type>       <name>recyclePipelineMemory</name></member>
            <member limittype="max"><type>uint32_t</type>       <name>maxRenderPassSubpasses</name></member>
            <member limittype="max"><type>uint32_t</type>       <name>maxRenderPassDependencies</name></member>
            <member limittype="max"><type>uint32_t</type>       <name>maxSubpassInputAttachments</name></member>
            <member limittype="max"><type>uint32_t</type>       <name>maxSubpassPreserveAttachments</name></member>
            <member limittype="max"><type>uint32_t</type>       <name>maxFramebufferAttachments</name></member>
            <member limittype="max"><type>uint32_t</type>       <name>maxDescriptorSetLayoutBindings</name></member>
            <member limittype="max"><type>uint32_t</type>       <name>maxQueryFaultCount</name></member>
            <member limittype="max"><type>uint32_t</type>       <name>maxCallbackFaultCount</name></member>
            <member limittype="max"><type>uint32_t</type>       <name>maxCommandPoolCommandBuffers</name></member>
            <member limittype="max"><type>VkDeviceSize</type>   <name>maxCommandBufferSize</name></member>
        </type>
        <type category="struct" name="VkPipelinePoolSize">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_POOL_SIZE"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
            <member><type>VkDeviceSize</type>                   <name>poolEntrySize</name></member>
            <member><type>uint32_t</type>                       <name>poolEntryCount</name></member>
        </type>
        <type category="struct" name="VkDeviceObjectReservationCreateInfo" allowduplicate="true" structextends="VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>       <name>pipelineCacheCreateInfoCount</name></member>
            <member len="pipelineCacheCreateInfoCount">const <type>VkPipelineCacheCreateInfo</type>* <name>pPipelineCacheCreateInfos</name></member>
            <member optional="true"><type>uint32_t</type>       <name>pipelinePoolSizeCount</name></member>
            <member len="pipelinePoolSizeCount">const <type>VkPipelinePoolSize</type>* <name>pPipelinePoolSizes</name></member>
            <member optional="true"><type>uint32_t</type>       <name>semaphoreRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>commandBufferRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>fenceRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>deviceMemoryRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>bufferRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>imageRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>eventRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>queryPoolRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>bufferViewRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>imageViewRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>layeredImageViewRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>pipelineCacheRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>pipelineLayoutRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>renderPassRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>graphicsPipelineRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>computePipelineRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>descriptorSetLayoutRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>samplerRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>descriptorPoolRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>descriptorSetRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>framebufferRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>commandPoolRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>samplerYcbcrConversionRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>surfaceRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>swapchainRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>displayModeRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>subpassDescriptionRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>attachmentDescriptionRequestCount</name></member>
            <member optional="true"><type>uint32_t</type>       <name>descriptorSetLayoutBindingRequestCount</name></member>
            <member><type>uint32_t</type>                       <name>descriptorSetLayoutBindingLimit</name></member>
            <member><type>uint32_t</type>                       <name>maxImageViewMipLevels</name></member>
            <member><type>uint32_t</type>                       <name>maxImageViewArrayLayers</name></member>
            <member><type>uint32_t</type>                       <name>maxLayeredImageViewMipLevels</name></member>
            <member><type>uint32_t</type>                       <name>maxOcclusionQueriesPerPool</name></member>
            <member><type>uint32_t</type>                       <name>maxPipelineStatisticsQueriesPerPool</name></member>
            <member><type>uint32_t</type>                       <name>maxTimestampQueriesPerPool</name></member>
            <member><type>uint32_t</type>                       <name>maxImmutableSamplersPerDescriptorSetLayout</name></member>
        </type>
        <type category="struct" name="VkCommandPoolMemoryReservationCreateInfo" structextends="VkCommandPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_RESERVATION_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
            <member><type>VkDeviceSize</type>  <name>commandPoolReservedSize</name></member>
            <member><type>uint32_t</type>      <name>commandPoolMaxCommandBuffers</name></member>
        </type>
        <type category="struct" name="VkCommandPoolMemoryConsumption" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_CONSUMPTION"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*          <name>pNext</name></member>
            <member><type>VkDeviceSize</type>                   <name>commandPoolAllocated</name></member>
            <member><type>VkDeviceSize</type>                   <name>commandPoolReservedSize</name></member>
            <member><type>VkDeviceSize</type>                   <name>commandBufferAllocated</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVulkanSC10Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*          <name>pNext</name></member>
            <member><type>VkBool32</type>                       <name>shaderAtomicInstructions</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member><type>VkBool32</type>               <name>primitivesGeneratedQuery</name></member>
            <member><type>VkBool32</type>               <name>primitivesGeneratedQueryWithRasterizerDiscard</name></member>
            <member><type>VkBool32</type>               <name>primitivesGeneratedQueryWithNonZeroStreams</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceLegacyDitheringFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member><type>VkBool32</type>               <name>legacyDithering</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*   <name>pNext</name></member>
            <member><type>VkBool32</type>                <name>multisampledRenderToSingleSampled</name></member>
        </type>
        <type category="struct" name="VkSurfaceCapabilitiesPresentId2KHR" structextends="VkSurfaceCapabilities2KHR">
            <member values="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*          <name>pNext</name></member>
            <member><type>VkBool32</type>       <name>presentId2Supported</name></member>
        </type>
        <type category="struct" name="VkSurfaceCapabilitiesPresentWait2KHR" structextends="VkSurfaceCapabilities2KHR">
            <member values="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*          <name>pNext</name></member>
            <member><type>VkBool32</type>       <name>presentWait2Supported</name></member>
        </type>
        <type category="struct" name="VkSubpassResolvePerformanceQueryEXT" returnedonly="true" structextends="VkFormatProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type> <name>optimal</name></member>
        </type>
        <type category="struct" name="VkMultisampledRenderToSingleSampledInfoEXT" structextends="VkSubpassDescription2,VkRenderingInfo">
            <member values="VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*   <name>pNext</name></member>
            <member><type>VkBool32</type>                      <name>multisampledRenderToSingleSampledEnable</name></member>
            <member><type>VkSampleCountFlagBits</type>         <name>rasterizationSamples</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePipelineProtectedAccessFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*  <name>pNext</name></member>
            <member><type>VkBool32</type>               <name>pipelineProtectedAccess</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePipelineProtectedAccessFeaturesEXT" alias="VkPhysicalDevicePipelineProtectedAccessFeatures"/>
        <type category="struct" name="VkQueueFamilyVideoPropertiesKHR" returnedonly="true" structextends="VkQueueFamilyProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member limittype="bitmask"><type>VkVideoCodecOperationFlagsKHR</type>  <name>videoCodecOperations</name></member>
        </type>
        <type category="struct" name="VkQueueFamilyQueryResultStatusPropertiesKHR" returnedonly="true" structextends="VkQueueFamilyProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>                           <name>queryResultStatusSupport</name></member>
        </type>
        <type category="struct" name="VkVideoProfileListInfoKHR" structextends="VkPhysicalDeviceImageFormatInfo2,VkPhysicalDeviceVideoFormatInfoKHR,VkImageCreateInfo,VkBufferCreateInfo">
            <member values="VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                   <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                                      <name>profileCount</name></member>
            <member len="profileCount">const <type>VkVideoProfileInfoKHR</type>*               <name>pProfiles</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVideoFormatInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                          <name>pNext</name></member>
            <member><type>VkImageUsageFlags</type>                                    <name>imageUsage</name></member>
        </type>
        <type category="struct" name="VkVideoFormatPropertiesKHR" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                                  <name>pNext</name></member>
            <member limittype="exact"><type>VkFormat</type>                                             <name>format</name></member>
            <member limittype="exact"><type>VkComponentMapping</type>                                   <name>componentMapping</name></member>
            <member limittype="bitmask"><type>VkImageCreateFlags</type>                                 <name>imageCreateFlags</name></member>
            <member limittype="exact"><type>VkImageType</type>                                          <name>imageType</name></member>
            <member limittype="exact"><type>VkImageTiling</type>                                        <name>imageTiling</name></member>
            <member limittype="bitmask"><type>VkImageUsageFlags</type>                                  <name>imageUsageFlags</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeQuantizationMapCapabilitiesKHR" returnedonly="true" structextends="VkVideoCapabilitiesKHR" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member limittype="max"><type>VkExtent2D</type>         <name>maxQuantizationMapExtent</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH264QuantizationMapCapabilitiesKHR" returnedonly="true" structextends="VkVideoCapabilitiesKHR" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member limittype="min"><type>int32_t</type>            <name>minQpDelta</name></member>
            <member limittype="max"><type>int32_t</type>            <name>maxQpDelta</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH265QuantizationMapCapabilitiesKHR" returnedonly="true" structextends="VkVideoCapabilitiesKHR" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member limittype="min"><type>int32_t</type>            <name>minQpDelta</name></member>
            <member limittype="max"><type>int32_t</type>            <name>maxQpDelta</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeAV1QuantizationMapCapabilitiesKHR" returnedonly="true" structextends="VkVideoCapabilitiesKHR" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member limittype="min"><type>int32_t</type>            <name>minQIndexDelta</name></member>
            <member limittype="max"><type>int32_t</type>            <name>maxQIndexDelta</name></member>
        </type>
        <type category="struct" name="VkVideoFormatQuantizationMapPropertiesKHR" returnedonly="true" structextends="VkVideoFormatPropertiesKHR" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member limittype="exact"><type>VkExtent2D</type>       <name>quantizationMapTexelSize</name></member>
        </type>
        <type category="struct" name="VkVideoFormatH265QuantizationMapPropertiesKHR" returnedonly="true" structextends="VkVideoFormatPropertiesKHR" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member limittype="bitmask"><type>VkVideoEncodeH265CtbSizeFlagsKHR</type> <name>compatibleCtbSizes</name></member>
        </type>
        <type category="struct" name="VkVideoFormatAV1QuantizationMapPropertiesKHR" returnedonly="true" structextends="VkVideoFormatPropertiesKHR" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member limittype="bitmask"><type>VkVideoEncodeAV1SuperblockSizeFlagsKHR</type> <name>compatibleSuperblockSizes</name></member>
        </type>
        <type category="struct" name="VkVideoProfileInfoKHR" structextends="VkQueryPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
            <member><type>VkVideoCodecOperationFlagBitsKHR</type>   <name>videoCodecOperation</name></member>
            <member><type>VkVideoChromaSubsamplingFlagsKHR</type>   <name>chromaSubsampling</name></member>
            <member><type>VkVideoComponentBitDepthFlagsKHR</type>   <name>lumaBitDepth</name></member>
            <member optional="true"><type>VkVideoComponentBitDepthFlagsKHR</type> <name>chromaBitDepth</name></member>
        </type>
        <type category="struct" name="VkVideoCapabilitiesKHR" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member limittype="bitmask"><type>VkVideoCapabilityFlagsKHR</type>  <name>flags</name></member>
            <member limittype="min,pot"><type>VkDeviceSize</type>               <name>minBitstreamBufferOffsetAlignment</name></member>
            <member limittype="min,pot"><type>VkDeviceSize</type>               <name>minBitstreamBufferSizeAlignment</name></member>
            <member limittype="min"><type>VkExtent2D</type>                     <name>pictureAccessGranularity</name></member>
            <member limittype="min"><type>VkExtent2D</type>                     <name>minCodedExtent</name></member>
            <member limittype="max"><type>VkExtent2D</type>                     <name>maxCodedExtent</name></member>
            <member limittype="max"><type>uint32_t</type>                       <name>maxDpbSlots</name></member>
            <member limittype="max"><type>uint32_t</type>                       <name>maxActiveReferencePictures</name></member>
            <member limittype="noauto"><type>VkExtensionProperties</type>       <name>stdHeaderVersion</name></member>
        </type>
        <type category="struct" name="VkVideoSessionMemoryRequirementsKHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*             <name>pNext</name></member>
            <member><type>uint32_t</type>                          <name>memoryBindIndex</name></member>
            <member><type>VkMemoryRequirements</type>              <name>memoryRequirements</name></member>
        </type>
        <type category="struct" name="VkBindVideoSessionMemoryInfoKHR">
            <member values="VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*       <name>pNext</name></member>
            <member><type>uint32_t</type>                          <name>memoryBindIndex</name></member>
            <member><type>VkDeviceMemory</type>                    <name>memory</name></member>
            <member><type>VkDeviceSize</type>                      <name>memoryOffset</name></member>
            <member><type>VkDeviceSize</type>                      <name>memorySize</name></member>
        </type>
        <type category="struct" name="VkVideoPictureResourceInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
            <member><type>VkOffset2D</type>         <name>codedOffset</name><comment>The offset to be used for the picture resource, currently only used in field mode</comment></member>
            <member><type>VkExtent2D</type>         <name>codedExtent</name><comment>The extent to be used for the picture resource</comment></member>
            <member><type>uint32_t</type>           <name>baseArrayLayer</name><comment>The first array layer to be accessed for the Decode or Encode Operations</comment></member>
            <member><type>VkImageView</type>        <name>imageViewBinding</name><comment>The ImageView binding of the resource</comment></member>
        </type>
        <type category="struct" name="VkVideoReferenceSlotInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
            <member><type>int32_t</type>                            <name>slotIndex</name><comment>The reference slot index</comment></member>
            <member optional="true">const <type>VkVideoPictureResourceInfoKHR</type>* <name>pPictureResource</name><comment>The reference picture resource</comment></member>
        </type>
        <type category="struct" name="VkVideoDecodeCapabilitiesKHR" returnedonly="true" structextends="VkVideoCapabilitiesKHR" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                 <name>pNext</name></member>
            <member limittype="bitmask" noautovalidity="true"><type>VkVideoDecodeCapabilityFlagsKHR</type> <name>flags</name></member>
        </type>
        <type category="struct" name="VkVideoDecodeUsageInfoKHR" structextends="VkVideoProfileInfoKHR,VkQueryPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member optional="true"><type>VkVideoDecodeUsageFlagsKHR</type> <name>videoUsageHints</name></member>
        </type>
        <type category="struct" name="VkVideoDecodeInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
            <member optional="true"><type>VkVideoDecodeFlagsKHR</type>  <name>flags</name></member>
            <member><type>VkBuffer</type>                               <name>srcBuffer</name></member>
            <member><type>VkDeviceSize</type>                           <name>srcBufferOffset</name></member>
            <member><type>VkDeviceSize</type>                           <name>srcBufferRange</name></member>
            <member><type>VkVideoPictureResourceInfoKHR</type>          <name>dstPictureResource</name></member>
            <member optional="true">const <type>VkVideoReferenceSlotInfoKHR</type>* <name>pSetupReferenceSlot</name></member>
            <member optional="true"><type>uint32_t</type>               <name>referenceSlotCount</name></member>
            <member len="referenceSlotCount">const <type>VkVideoReferenceSlotInfoKHR</type>* <name>pReferenceSlots</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVideoMaintenance1FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>videoMaintenance1</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVideoMaintenance2FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>videoMaintenance2</name></member>
        </type>
        <type category="struct" name="VkVideoInlineQueryInfoKHR" structextends="VkVideoDecodeInfoKHR,VkVideoEncodeInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkQueryPool</type>            <name>queryPool</name></member>
            <member><type>uint32_t</type>                               <name>firstQuery</name></member>
            <member><type>uint32_t</type>                               <name>queryCount</name></member>
        </type>
            <comment>Video Decode Codec Standard specific structures</comment>
        <type category="include" name="vk_video/vulkan_video_codec_h264std.h">#include "vk_video/vulkan_video_codec_h264std.h"</type>
        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264ProfileIdc"/>
        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264LevelIdc"/>
        <type category="include" name="vk_video/vulkan_video_codec_h264std_decode.h">#include "vk_video/vulkan_video_codec_h264std_decode.h"</type>
        <type requires="vk_video/vulkan_video_codec_h264std_decode.h" name="StdVideoDecodeH264PictureInfo"/>
        <type requires="vk_video/vulkan_video_codec_h264std_decode.h" name="StdVideoDecodeH264ReferenceInfo"/>
        <type category="struct" name="VkVideoDecodeH264ProfileInfoKHR" structextends="VkVideoProfileInfoKHR,VkQueryPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                  <name>pNext</name></member>
            <member><type>StdVideoH264ProfileIdc</type>                                       <name>stdProfileIdc</name></member>
            <member optional="true"><type>VkVideoDecodeH264PictureLayoutFlagBitsKHR</type>    <name>pictureLayout</name></member>
        </type>
        <type category="struct" name="VkVideoDecodeH264CapabilitiesKHR" returnedonly="true" structextends="VkVideoCapabilitiesKHR" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member limittype="max"><type>StdVideoH264LevelIdc</type>   <name>maxLevelIdc</name></member>
            <member limittype="noauto"><type>VkOffset2D</type>          <name>fieldOffsetGranularity</name></member>
        </type>
        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264SequenceParameterSet"/>
        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264PictureParameterSet"/>
        <type category="struct" name="VkVideoDecodeH264SessionParametersAddInfoKHR" structextends="VkVideoSessionParametersUpdateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                                       <name>stdSPSCount</name></member>
            <member len="stdSPSCount">const <type>StdVideoH264SequenceParameterSet</type>*      <name>pStdSPSs</name></member>
            <member optional="true"><type>uint32_t</type>                                       <name>stdPPSCount</name></member>
            <member len="stdPPSCount">const <type>StdVideoH264PictureParameterSet</type>*       <name>pStdPPSs</name><comment>List of Picture Parameters associated with the spsStd, above</comment></member>
        </type>
        <type category="struct" name="VkVideoDecodeH264SessionParametersCreateInfoKHR" structextends="VkVideoSessionParametersCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                               <name>pNext</name></member>
            <member><type>uint32_t</type>                                                                  <name>maxStdSPSCount</name></member>
            <member><type>uint32_t</type>                                                                  <name>maxStdPPSCount</name></member>
            <member optional="true">const <type>VkVideoDecodeH264SessionParametersAddInfoKHR</type>*       <name>pParametersAddInfo</name></member>
        </type>
        <type category="struct" name="VkVideoDecodeH264InlineSessionParametersInfoKHR" structextends="VkVideoDecodeInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
            <member optional="true">const <type>StdVideoH264SequenceParameterSet</type>*        <name>pStdSPS</name></member>
            <member optional="true">const <type>StdVideoH264PictureParameterSet</type>*         <name>pStdPPS</name></member>
        </type>
        <type category="struct" name="VkVideoDecodeH264PictureInfoKHR" structextends="VkVideoDecodeInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*           <name>pNext</name></member>
            <member>const <type>StdVideoDecodeH264PictureInfo</type>*  <name>pStdPictureInfo</name></member>
            <member><type>uint32_t</type>                              <name>sliceCount</name></member>
            <member len="sliceCount">const <type>uint32_t</type>*      <name>pSliceOffsets</name></member>
        </type>
        <type category="struct" name="VkVideoDecodeH264DpbSlotInfoKHR" structextends="VkVideoReferenceSlotInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member>const <type>StdVideoDecodeH264ReferenceInfo</type>* <name>pStdReferenceInfo</name></member>
        </type>
        <type category="include" name="vk_video/vulkan_video_codec_h265std.h">#include "vk_video/vulkan_video_codec_h265std.h"</type>
        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265ProfileIdc"/>
        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265VideoParameterSet"/>
        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265SequenceParameterSet"/>
        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265PictureParameterSet"/>
        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265LevelIdc"/>
        <type category="include" name="vk_video/vulkan_video_codec_h265std_decode.h">#include "vk_video/vulkan_video_codec_h265std_decode.h"</type>
        <type requires="vk_video/vulkan_video_codec_h265std_decode.h" name="StdVideoDecodeH265PictureInfo"/>
        <type requires="vk_video/vulkan_video_codec_h265std_decode.h" name="StdVideoDecodeH265ReferenceInfo"/>
        <type category="struct" name="VkVideoDecodeH265ProfileInfoKHR" structextends="VkVideoProfileInfoKHR,VkQueryPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
            <member><type>StdVideoH265ProfileIdc</type>         <name>stdProfileIdc</name></member>
        </type>
        <type category="struct" name="VkVideoDecodeH265CapabilitiesKHR" returnedonly="true" structextends="VkVideoCapabilitiesKHR" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="max"><type>StdVideoH265LevelIdc</type>             <name>maxLevelIdc</name></member>
        </type>
        <type category="struct" name="VkVideoDecodeH265SessionParametersAddInfoKHR" structextends="VkVideoSessionParametersUpdateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                                   <name>stdVPSCount</name></member>
            <member len="stdVPSCount">const <type>StdVideoH265VideoParameterSet</type>*     <name>pStdVPSs</name></member>
            <member optional="true"><type>uint32_t</type>                                   <name>stdSPSCount</name></member>
            <member len="stdSPSCount">const <type>StdVideoH265SequenceParameterSet</type>*  <name>pStdSPSs</name></member>
            <member optional="true"><type>uint32_t</type>                                   <name>stdPPSCount</name></member>
            <member len="stdPPSCount">const <type>StdVideoH265PictureParameterSet</type>*   <name>pStdPPSs</name><comment>List of Picture Parameters associated with the spsStd, above</comment></member>
        </type>
        <type category="struct" name="VkVideoDecodeH265SessionParametersCreateInfoKHR" structextends="VkVideoSessionParametersCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                         <name>pNext</name></member>
            <member><type>uint32_t</type>                                                            <name>maxStdVPSCount</name></member>
            <member><type>uint32_t</type>                                                            <name>maxStdSPSCount</name></member>
            <member><type>uint32_t</type>                                                            <name>maxStdPPSCount</name></member>
            <member optional="true">const <type>VkVideoDecodeH265SessionParametersAddInfoKHR</type>* <name>pParametersAddInfo</name></member>
        </type>
        <type category="struct" name="VkVideoDecodeH265InlineSessionParametersInfoKHR" structextends="VkVideoDecodeInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
            <member optional="true">const <type>StdVideoH265VideoParameterSet</type>*           <name>pStdVPS</name></member>
            <member optional="true">const <type>StdVideoH265SequenceParameterSet</type>*        <name>pStdSPS</name></member>
            <member optional="true">const <type>StdVideoH265PictureParameterSet</type>*         <name>pStdPPS</name></member>
        </type>
        <type category="struct" name="VkVideoDecodeH265PictureInfoKHR" structextends="VkVideoDecodeInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member>const <type>StdVideoDecodeH265PictureInfo</type>*       <name>pStdPictureInfo</name></member>
            <member><type>uint32_t</type>                                   <name>sliceSegmentCount</name></member>
            <member len="sliceSegmentCount">const <type>uint32_t</type>*    <name>pSliceSegmentOffsets</name></member>
        </type>
        <type category="struct" name="VkVideoDecodeH265DpbSlotInfoKHR" structextends="VkVideoReferenceSlotInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*             <name>pNext</name></member>
            <member>const <type>StdVideoDecodeH265ReferenceInfo</type>*  <name>pStdReferenceInfo</name></member>
        </type>
        <type category="include" name="vk_video/vulkan_video_codec_vp9std.h">#include "vk_video/vulkan_video_codec_vp9std.h"</type>
        <type requires="vk_video/vulkan_video_codec_vp9std.h" name="StdVideoVP9Profile"/>
        <type requires="vk_video/vulkan_video_codec_vp9std.h" name="StdVideoVP9Level"/>
        <type category="include" name="vk_video/vulkan_video_codec_vp9std_decode.h">#include "vk_video/vulkan_video_codec_vp9std_decode.h"</type>
        <type requires="vk_video/vulkan_video_codec_vp9std_decode.h" name="StdVideoDecodeVP9PictureInfo"/>
        <type category="struct" name="VkPhysicalDeviceVideoDecodeVP9FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>videoDecodeVP9</name></member>
        </type>
        <type category="struct" name="VkVideoDecodeVP9ProfileInfoKHR" structextends="VkVideoProfileInfoKHR,VkQueryPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>StdVideoVP9Profile</type>                     <name>stdProfile</name></member>
        </type>
        <type category="struct" name="VkVideoDecodeVP9CapabilitiesKHR" returnedonly="true" structextends="VkVideoCapabilitiesKHR" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member limittype="max"><type>StdVideoVP9Level</type>       <name>maxLevel</name></member>
        </type>
        <type category="struct" name="VkVideoDecodeVP9PictureInfoKHR" structextends="VkVideoDecodeInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member>const <type>StdVideoDecodeVP9PictureInfo</type>*    <name>pStdPictureInfo</name></member>
            <member><type>int32_t</type>                                <name>referenceNameSlotIndices</name>[<enum>VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR</enum>]</member>
            <member><type>uint32_t</type>                               <name>uncompressedHeaderOffset</name></member>
            <member><type>uint32_t</type>                               <name>compressedHeaderOffset</name></member>
            <member><type>uint32_t</type>                               <name>tilesOffset</name></member>
        </type>
        <type category="include" name="vk_video/vulkan_video_codec_av1std.h">#include "vk_video/vulkan_video_codec_av1std.h"</type>
        <type requires="vk_video/vulkan_video_codec_av1std.h" name="StdVideoAV1Profile"/>
        <type requires="vk_video/vulkan_video_codec_av1std.h" name="StdVideoAV1Level"/>
        <type requires="vk_video/vulkan_video_codec_av1std.h" name="StdVideoAV1SequenceHeader"/>
        <type category="include" name="vk_video/vulkan_video_codec_av1std_decode.h">#include "vk_video/vulkan_video_codec_av1std_decode.h"</type>
        <type requires="vk_video/vulkan_video_codec_av1std_decode.h" name="StdVideoDecodeAV1PictureInfo"/>
        <type requires="vk_video/vulkan_video_codec_av1std_decode.h" name="StdVideoDecodeAV1ReferenceInfo"/>
        <type category="struct" name="VkVideoDecodeAV1ProfileInfoKHR" structextends="VkVideoProfileInfoKHR,VkQueryPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>StdVideoAV1Profile</type>                     <name>stdProfile</name></member>
            <member><type>VkBool32</type>                               <name>filmGrainSupport</name></member>
        </type>
        <type category="struct" name="VkVideoDecodeAV1CapabilitiesKHR" returnedonly="true" structextends="VkVideoCapabilitiesKHR" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member limittype="max"><type>StdVideoAV1Level</type>       <name>maxLevel</name></member>
        </type>
        <type category="struct" name="VkVideoDecodeAV1SessionParametersCreateInfoKHR" structextends="VkVideoSessionParametersCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member>const <type>StdVideoAV1SequenceHeader</type>*       <name>pStdSequenceHeader</name></member>
        </type>
        <type category="struct" name="VkVideoDecodeAV1InlineSessionParametersInfoKHR" structextends="VkVideoDecodeInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
            <member optional="true">const <type>StdVideoAV1SequenceHeader</type>*   <name>pStdSequenceHeader</name></member>
        </type>
        <type category="struct" name="VkVideoDecodeAV1PictureInfoKHR" structextends="VkVideoDecodeInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member>const <type>StdVideoDecodeAV1PictureInfo</type>*    <name>pStdPictureInfo</name></member>
            <member><type>int32_t</type>                                <name>referenceNameSlotIndices</name>[<enum>VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR</enum>]</member>
            <member><type>uint32_t</type>                               <name>frameHeaderOffset</name></member>
            <member><type>uint32_t</type>                               <name>tileCount</name></member>
            <member len="tileCount">const <type>uint32_t</type>*        <name>pTileOffsets</name></member>
            <member len="tileCount">const <type>uint32_t</type>*        <name>pTileSizes</name></member>
        </type>
        <type category="struct" name="VkVideoDecodeAV1DpbSlotInfoKHR" structextends="VkVideoReferenceSlotInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member>const <type>StdVideoDecodeAV1ReferenceInfo</type>*  <name>pStdReferenceInfo</name></member>
        </type>
        <type category="struct" name="VkVideoSessionCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                   <name>pNext</name></member>
            <member><type>uint32_t</type>                                      <name>queueFamilyIndex</name></member>
            <member optional="true"><type>VkVideoSessionCreateFlagsKHR</type>  <name>flags</name></member>
            <member>const <type>VkVideoProfileInfoKHR</type>*                  <name>pVideoProfile</name></member>
            <member><type>VkFormat</type>                                      <name>pictureFormat</name></member>
            <member><type>VkExtent2D</type>                                    <name>maxCodedExtent</name></member>
            <member><type>VkFormat</type>                                      <name>referencePictureFormat</name></member>
            <member><type>uint32_t</type>                                      <name>maxDpbSlots</name></member>
            <member><type>uint32_t</type>                                      <name>maxActiveReferencePictures</name></member>
            <member>const <type>VkExtensionProperties</type>*                  <name>pStdHeaderVersion</name></member>
        </type>
        <type category="struct" name="VkVideoSessionParametersCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
            <member optional="true"><type>VkVideoSessionParametersCreateFlagsKHR</type> <name>flags</name></member>
            <member optional="true"><type>VkVideoSessionParametersKHR</type>            <name>videoSessionParametersTemplate</name></member>
            <member><type>VkVideoSessionKHR</type>                                      <name>videoSession</name></member>
        </type>
        <type category="struct" name="VkVideoSessionParametersUpdateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
            <member><type>uint32_t</type>                                               <name>updateSequenceCount</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeSessionParametersGetInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
            <member><type>VkVideoSessionParametersKHR</type>                    <name>videoSessionParameters</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeSessionParametersFeedbackInfoKHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member><type>VkBool32</type>                                       <name>hasOverrides</name></member>
        </type>
        <type category="struct" name="VkVideoBeginCodingInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                             <name>pNext</name></member>
            <member optional="true"><type>VkVideoBeginCodingFlagsKHR</type>              <name>flags</name></member>
            <member><type>VkVideoSessionKHR</type>                                       <name>videoSession</name></member>
            <member optional="true"><type>VkVideoSessionParametersKHR</type>             <name>videoSessionParameters</name></member>
            <member optional="true"><type>uint32_t</type>                                <name>referenceSlotCount</name></member>
            <member len="referenceSlotCount">const <type>VkVideoReferenceSlotInfoKHR</type>* <name>pReferenceSlots</name></member>
        </type>
        <type category="struct" name="VkVideoEndCodingInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                              <name>pNext</name></member>
            <member optional="true"><type>VkVideoEndCodingFlagsKHR</type> <name>flags</name></member>
        </type>
        <type category="struct" name="VkVideoCodingControlInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
            <member><type>VkVideoCodingControlFlagsKHR</type>                   <name>flags</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeUsageInfoKHR" structextends="VkVideoProfileInfoKHR,VkQueryPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
            <member optional="true"><type>VkVideoEncodeUsageFlagsKHR</type>     <name>videoUsageHints</name></member>
            <member optional="true"><type>VkVideoEncodeContentFlagsKHR</type>   <name>videoContentHints</name></member>
            <member optional="true"><type>VkVideoEncodeTuningModeKHR</type>     <name>tuningMode</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkVideoEncodeFlagsKHR</type>  <name>flags</name></member>
            <member><type>VkBuffer</type>                               <name>dstBuffer</name></member>
            <member><type>VkDeviceSize</type>                           <name>dstBufferOffset</name></member>
            <member><type>VkDeviceSize</type>                           <name>dstBufferRange</name></member>
            <member><type>VkVideoPictureResourceInfoKHR</type>          <name>srcPictureResource</name></member>
            <member optional="true">const <type>VkVideoReferenceSlotInfoKHR</type>* <name>pSetupReferenceSlot</name></member>
            <member optional="true"><type>uint32_t</type>               <name>referenceSlotCount</name></member>
            <member len="referenceSlotCount">const <type>VkVideoReferenceSlotInfoKHR</type>* <name>pReferenceSlots</name></member>
            <member><type>uint32_t</type>                               <name>precedingExternallyEncodedBytes</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeQuantizationMapInfoKHR" structextends="VkVideoEncodeInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkImageView</type>            <name>quantizationMap</name></member>
            <member><type>VkExtent2D</type>                             <name>quantizationMapExtent</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR" structextends="VkVideoSessionParametersCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkExtent2D</type>                             <name>quantizationMapTexelSize</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                       <name>pNext</name></member>
            <member><type>VkBool32</type>                                    <name>videoEncodeQuantizationMap</name></member>
        </type>
        <type category="struct" name="VkQueryPoolVideoEncodeFeedbackCreateInfoKHR" structextends="VkQueryPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkVideoEncodeFeedbackFlagsKHR</type>          <name>encodeFeedbackFlags</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeQualityLevelInfoKHR" structextends="VkVideoCodingControlInfoKHR,VkVideoSessionParametersCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>uint32_t</type>                               <name>qualityLevel</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member>const <type>VkVideoProfileInfoKHR</type>*           <name>pVideoProfile</name></member>
            <member><type>uint32_t</type>                               <name>qualityLevel</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeQualityLevelPropertiesKHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member><type>VkVideoEncodeRateControlModeFlagBitsKHR</type> <name>preferredRateControlMode</name></member>
            <member><type>uint32_t</type>                               <name>preferredRateControlLayerCount</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeRateControlInfoKHR" structextends="VkVideoCodingControlInfoKHR,VkVideoBeginCodingInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkVideoEncodeRateControlFlagsKHR</type> <name>flags</name></member>
            <member optional="true"><type>VkVideoEncodeRateControlModeFlagBitsKHR</type> <name>rateControlMode</name></member>
            <member optional="true"><type>uint32_t</type>               <name>layerCount</name></member>
            <member len="layerCount">const <type>VkVideoEncodeRateControlLayerInfoKHR</type>* <name>pLayers</name></member>
            <member><type>uint32_t</type>                               <name>virtualBufferSizeInMs</name></member>
            <member><type>uint32_t</type>                               <name>initialVirtualBufferSizeInMs</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeRateControlLayerInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>uint64_t</type>                               <name>averageBitrate</name></member>
            <member><type>uint64_t</type>                               <name>maxBitrate</name></member>
            <member><type>uint32_t</type>                               <name>frameRateNumerator</name></member>
            <member><type>uint32_t</type>                               <name>frameRateDenominator</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeCapabilitiesKHR" returnedonly="true" structextends="VkVideoCapabilitiesKHR" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                 <name>pNext</name></member>
            <member limittype="bitmask" noautovalidity="true"><type>VkVideoEncodeCapabilityFlagsKHR</type> <name>flags</name></member>
            <member limittype="bitmask"><type>VkVideoEncodeRateControlModeFlagsKHR</type> <name>rateControlModes</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxRateControlLayers</name></member>
            <member limittype="max"><type>uint64_t</type>              <name>maxBitrate</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxQualityLevels</name></member>
            <member limittype="min"><type>VkExtent2D</type>            <name>encodeInputPictureGranularity</name></member>
            <member limittype="bitmask"><type>VkVideoEncodeFeedbackFlagsKHR</type> <name>supportedEncodeFeedbackFlags</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH264CapabilitiesKHR" returnedonly="true" structextends="VkVideoCapabilitiesKHR" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                 <name>pNext</name></member>
            <member limittype="bitmask" noautovalidity="true"><type>VkVideoEncodeH264CapabilityFlagsKHR</type> <name>flags</name></member>
            <member limittype="max"><type>StdVideoH264LevelIdc</type>  <name>maxLevelIdc</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxSliceCount</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxPPictureL0ReferenceCount</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxBPictureL0ReferenceCount</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxL1ReferenceCount</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxTemporalLayerCount</name></member>
            <member limittype="min"><type>VkBool32</type>              <name>expectDyadicTemporalLayerPattern</name></member>
            <member limittype="min"><type>int32_t</type>               <name>minQp</name></member>
            <member limittype="max"><type>int32_t</type>               <name>maxQp</name></member>
            <member limittype="min"><type>VkBool32</type>              <name>prefersGopRemainingFrames</name></member>
            <member limittype="min"><type>VkBool32</type>              <name>requiresGopRemainingFrames</name></member>
            <member limittype="bitmask" noautovalidity="true"><type>VkVideoEncodeH264StdFlagsKHR</type> <name>stdSyntaxFlags</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH264QualityLevelPropertiesKHR" returnedonly="true" structextends="VkVideoEncodeQualityLevelPropertiesKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member><type>VkVideoEncodeH264RateControlFlagsKHR</type>   <name>preferredRateControlFlags</name></member>
            <member><type>uint32_t</type>                               <name>preferredGopFrameCount</name></member>
            <member><type>uint32_t</type>                               <name>preferredIdrPeriod</name></member>
            <member><type>uint32_t</type>                               <name>preferredConsecutiveBFrameCount</name></member>
            <member><type>uint32_t</type>                               <name>preferredTemporalLayerCount</name></member>
            <member><type>VkVideoEncodeH264QpKHR</type>                 <name>preferredConstantQp</name></member>
            <member><type>uint32_t</type>                               <name>preferredMaxL0ReferenceCount</name></member>
            <member><type>uint32_t</type>                               <name>preferredMaxL1ReferenceCount</name></member>
            <member><type>VkBool32</type>                               <name>preferredStdEntropyCodingModeFlag</name></member>
        </type>
        <type category="include" name="vk_video/vulkan_video_codec_h264std_encode.h">#include "vk_video/vulkan_video_codec_h264std_encode.h"</type>
        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264SliceHeader"/>
        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264PictureInfo"/>
        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264ReferenceInfo"/>
        <type category="struct" name="VkVideoEncodeH264SessionCreateInfoKHR" structextends="VkVideoSessionCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                               <name>useMaxLevelIdc</name></member>
            <member><type>StdVideoH264LevelIdc</type>                   <name>maxLevelIdc</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH264SessionParametersAddInfoKHR" structextends="VkVideoSessionParametersUpdateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                               <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                                                  <name>stdSPSCount</name></member>
            <member len="stdSPSCount" optional="true">const <type>StdVideoH264SequenceParameterSet</type>* <name>pStdSPSs</name></member>
            <member optional="true"><type>uint32_t</type>                                                  <name>stdPPSCount</name></member>
            <member len="stdPPSCount" optional="true">const <type>StdVideoH264PictureParameterSet</type>*  <name>pStdPPSs</name><comment>List of Picture Parameters associated with the spsStd, above</comment></member>
        </type>
        <type category="struct" name="VkVideoEncodeH264SessionParametersCreateInfoKHR" structextends="VkVideoSessionParametersCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                         <name>pNext</name></member>
            <member><type>uint32_t</type>                                                            <name>maxStdSPSCount</name></member>
            <member><type>uint32_t</type>                                                            <name>maxStdPPSCount</name></member>
            <member optional="true">const <type>VkVideoEncodeH264SessionParametersAddInfoKHR</type>* <name>pParametersAddInfo</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH264SessionParametersGetInfoKHR" structextends="VkVideoEncodeSessionParametersGetInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                               <name>writeStdSPS</name></member>
            <member><type>VkBool32</type>                               <name>writeStdPPS</name></member>
            <member><type>uint32_t</type>                               <name>stdSPSId</name></member>
            <member><type>uint32_t</type>                               <name>stdPPSId</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH264SessionParametersFeedbackInfoKHR" structextends="VkVideoEncodeSessionParametersFeedbackInfoKHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member><type>VkBool32</type>                               <name>hasStdSPSOverrides</name></member>
            <member><type>VkBool32</type>                               <name>hasStdPPSOverrides</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH264DpbSlotInfoKHR" structextends="VkVideoReferenceSlotInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                          <name>pNext</name></member>
            <member>const <type>StdVideoEncodeH264ReferenceInfo</type>*                               <name>pStdReferenceInfo</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH264PictureInfoKHR" structextends="VkVideoEncodeInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                        <name>pNext</name></member>
            <member><type>uint32_t</type>                                                           <name>naluSliceEntryCount</name></member>
            <member len="naluSliceEntryCount">const <type>VkVideoEncodeH264NaluSliceInfoKHR</type>* <name>pNaluSliceEntries</name></member>
            <member>const <type>StdVideoEncodeH264PictureInfo</type>*                               <name>pStdPictureInfo</name></member>
            <member><type>VkBool32</type>                                                           <name>generatePrefixNalu</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH264ProfileInfoKHR" structextends="VkVideoProfileInfoKHR,VkQueryPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*             <name>pNext</name></member>
            <member><type>StdVideoH264ProfileIdc</type>                  <name>stdProfileIdc</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH264NaluSliceInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                     <name>pNext</name></member>
            <member><type>int32_t</type>                                         <name>constantQp</name></member>
            <member>const <type>StdVideoEncodeH264SliceHeader</type>*            <name>pStdSliceHeader</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH264RateControlInfoKHR" structextends="VkVideoCodingControlInfoKHR,VkVideoBeginCodingInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                     <name>pNext</name></member>
            <member optional="true"><type>VkVideoEncodeH264RateControlFlagsKHR</type> <name>flags</name></member>
            <member><type>uint32_t</type>                                        <name>gopFrameCount</name></member>
            <member><type>uint32_t</type>                                        <name>idrPeriod</name></member>
            <member><type>uint32_t</type>                                        <name>consecutiveBFrameCount</name></member>
            <member><type>uint32_t</type>                                        <name>temporalLayerCount</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH264QpKHR">
            <member noautovalidity="true"><type>int32_t</type> <name>qpI</name></member>
            <member noautovalidity="true"><type>int32_t</type> <name>qpP</name></member>
            <member noautovalidity="true"><type>int32_t</type> <name>qpB</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH264FrameSizeKHR">
            <member noautovalidity="true"><type>uint32_t</type> <name>frameISize</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>framePSize</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>frameBSize</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH264GopRemainingFrameInfoKHR" structextends="VkVideoBeginCodingInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                       <name>useGopRemainingFrames</name></member>
            <member><type>uint32_t</type>                       <name>gopRemainingI</name></member>
            <member><type>uint32_t</type>                       <name>gopRemainingP</name></member>
            <member><type>uint32_t</type>                       <name>gopRemainingB</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH264RateControlLayerInfoKHR" structextends="VkVideoEncodeRateControlLayerInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                     <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>useMinQp</name></member>
            <member><type>VkVideoEncodeH264QpKHR</type>                          <name>minQp</name></member>
            <member><type>VkBool32</type>                                        <name>useMaxQp</name></member>
            <member><type>VkVideoEncodeH264QpKHR</type>                          <name>maxQp</name></member>
            <member><type>VkBool32</type>                                        <name>useMaxFrameSize</name></member>
            <member><type>VkVideoEncodeH264FrameSizeKHR</type>                   <name>maxFrameSize</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH265CapabilitiesKHR" returnedonly="true" structextends="VkVideoCapabilitiesKHR" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                 <name>pNext</name></member>
            <member limittype="bitmask" noautovalidity="true"><type>VkVideoEncodeH265CapabilityFlagsKHR</type> <name>flags</name></member>
            <member limittype="max"><type>StdVideoH265LevelIdc</type>  <name>maxLevelIdc</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxSliceSegmentCount</name></member>
            <member limittype="max"><type>VkExtent2D</type>            <name>maxTiles</name></member>
            <member limittype="bitmask"><type>VkVideoEncodeH265CtbSizeFlagsKHR</type> <name>ctbSizes</name></member>
            <member limittype="bitmask"><type>VkVideoEncodeH265TransformBlockSizeFlagsKHR</type> <name>transformBlockSizes</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxPPictureL0ReferenceCount</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxBPictureL0ReferenceCount</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxL1ReferenceCount</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxSubLayerCount</name></member>
            <member limittype="min"><type>VkBool32</type>              <name>expectDyadicTemporalSubLayerPattern</name></member>
            <member limittype="min"><type>int32_t</type>               <name>minQp</name></member>
            <member limittype="max"><type>int32_t</type>               <name>maxQp</name></member>
            <member limittype="min"><type>VkBool32</type>              <name>prefersGopRemainingFrames</name></member>
            <member limittype="min"><type>VkBool32</type>              <name>requiresGopRemainingFrames</name></member>
            <member limittype="bitmask" noautovalidity="true"><type>VkVideoEncodeH265StdFlagsKHR</type> <name>stdSyntaxFlags</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH265QualityLevelPropertiesKHR" returnedonly="true" structextends="VkVideoEncodeQualityLevelPropertiesKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member><type>VkVideoEncodeH265RateControlFlagsKHR</type>   <name>preferredRateControlFlags</name></member>
            <member><type>uint32_t</type>                               <name>preferredGopFrameCount</name></member>
            <member><type>uint32_t</type>                               <name>preferredIdrPeriod</name></member>
            <member><type>uint32_t</type>                               <name>preferredConsecutiveBFrameCount</name></member>
            <member><type>uint32_t</type>                               <name>preferredSubLayerCount</name></member>
            <member><type>VkVideoEncodeH265QpKHR</type>                 <name>preferredConstantQp</name></member>
            <member><type>uint32_t</type>                               <name>preferredMaxL0ReferenceCount</name></member>
            <member><type>uint32_t</type>                               <name>preferredMaxL1ReferenceCount</name></member>
        </type>
        <type category="include" name="vk_video/vulkan_video_codec_h265std_encode.h">#include "vk_video/vulkan_video_codec_h265std_encode.h"</type>
        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265PictureInfo"/>
        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265SliceSegmentHeader"/>
        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265ReferenceInfo"/>
        <type category="struct" name="VkVideoEncodeH265SessionCreateInfoKHR" structextends="VkVideoSessionCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                               <name>useMaxLevelIdc</name></member>
            <member><type>StdVideoH265LevelIdc</type>                   <name>maxLevelIdc</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH265SessionParametersAddInfoKHR" structextends="VkVideoSessionParametersUpdateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                               <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                                                  <name>stdVPSCount</name></member>
            <member len="stdVPSCount" optional="true">const <type>StdVideoH265VideoParameterSet</type>*    <name>pStdVPSs</name></member>
            <member optional="true"><type>uint32_t</type>                                                  <name>stdSPSCount</name></member>
            <member len="stdSPSCount" optional="true">const <type>StdVideoH265SequenceParameterSet</type>* <name>pStdSPSs</name></member>
            <member optional="true"><type>uint32_t</type>                                                  <name>stdPPSCount</name></member>
            <member len="stdPPSCount" optional="true">const <type>StdVideoH265PictureParameterSet</type>*  <name>pStdPPSs</name><comment>List of Picture Parameters associated with the spsStd, above</comment></member>
        </type>
        <type category="struct" name="VkVideoEncodeH265SessionParametersCreateInfoKHR" structextends="VkVideoSessionParametersCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                         <name>pNext</name></member>
            <member><type>uint32_t</type>                                                            <name>maxStdVPSCount</name></member>
            <member><type>uint32_t</type>                                                            <name>maxStdSPSCount</name></member>
            <member><type>uint32_t</type>                                                            <name>maxStdPPSCount</name></member>
            <member optional="true">const <type>VkVideoEncodeH265SessionParametersAddInfoKHR</type>* <name>pParametersAddInfo</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH265SessionParametersGetInfoKHR" structextends="VkVideoEncodeSessionParametersGetInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                               <name>writeStdVPS</name></member>
            <member><type>VkBool32</type>                               <name>writeStdSPS</name></member>
            <member><type>VkBool32</type>                               <name>writeStdPPS</name></member>
            <member><type>uint32_t</type>                               <name>stdVPSId</name></member>
            <member><type>uint32_t</type>                               <name>stdSPSId</name></member>
            <member><type>uint32_t</type>                               <name>stdPPSId</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH265SessionParametersFeedbackInfoKHR" structextends="VkVideoEncodeSessionParametersFeedbackInfoKHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member><type>VkBool32</type>                               <name>hasStdVPSOverrides</name></member>
            <member><type>VkBool32</type>                               <name>hasStdSPSOverrides</name></member>
            <member><type>VkBool32</type>                               <name>hasStdPPSOverrides</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH265PictureInfoKHR" structextends="VkVideoEncodeInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                       <name>pNext</name></member>
            <member><type>uint32_t</type>                                                          <name>naluSliceSegmentEntryCount</name></member>
            <member len="naluSliceSegmentEntryCount">const <type>VkVideoEncodeH265NaluSliceSegmentInfoKHR</type>* <name>pNaluSliceSegmentEntries</name></member>
            <member>const <type>StdVideoEncodeH265PictureInfo</type>*                              <name>pStdPictureInfo</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH265NaluSliceSegmentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                <name>pNext</name></member>
            <member><type>int32_t</type>                                                    <name>constantQp</name></member>
            <member>const <type>StdVideoEncodeH265SliceSegmentHeader</type>*                <name>pStdSliceSegmentHeader</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH265RateControlInfoKHR" structextends="VkVideoCodingControlInfoKHR,VkVideoBeginCodingInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                     <name>pNext</name></member>
            <member optional="true"><type>VkVideoEncodeH265RateControlFlagsKHR</type> <name>flags</name></member>
            <member><type>uint32_t</type>                                        <name>gopFrameCount</name></member>
            <member><type>uint32_t</type>                                        <name>idrPeriod</name></member>
            <member><type>uint32_t</type>                                        <name>consecutiveBFrameCount</name></member>
            <member><type>uint32_t</type>                                        <name>subLayerCount</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH265QpKHR">
            <member noautovalidity="true"><type>int32_t</type> <name>qpI</name></member>
            <member noautovalidity="true"><type>int32_t</type> <name>qpP</name></member>
            <member noautovalidity="true"><type>int32_t</type> <name>qpB</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH265FrameSizeKHR">
            <member noautovalidity="true"><type>uint32_t</type> <name>frameISize</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>framePSize</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>frameBSize</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH265GopRemainingFrameInfoKHR" structextends="VkVideoBeginCodingInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                       <name>useGopRemainingFrames</name></member>
            <member><type>uint32_t</type>                       <name>gopRemainingI</name></member>
            <member><type>uint32_t</type>                       <name>gopRemainingP</name></member>
            <member><type>uint32_t</type>                       <name>gopRemainingB</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH265RateControlLayerInfoKHR" structextends="VkVideoEncodeRateControlLayerInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                     <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>useMinQp</name></member>
            <member><type>VkVideoEncodeH265QpKHR</type>                          <name>minQp</name></member>
            <member><type>VkBool32</type>                                        <name>useMaxQp</name></member>
            <member><type>VkVideoEncodeH265QpKHR</type>                          <name>maxQp</name></member>
            <member><type>VkBool32</type>                                        <name>useMaxFrameSize</name></member>
            <member><type>VkVideoEncodeH265FrameSizeKHR</type>                   <name>maxFrameSize</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH265ProfileInfoKHR" structextends="VkVideoProfileInfoKHR,VkQueryPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
            <member><type>StdVideoH265ProfileIdc</type>         <name>stdProfileIdc</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeH265DpbSlotInfoKHR" structextends="VkVideoReferenceSlotInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*              <name>pNext</name></member>
            <member>const <type>StdVideoEncodeH265ReferenceInfo</type>*   <name>pStdReferenceInfo</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeAV1CapabilitiesKHR" returnedonly="true" structextends="VkVideoCapabilitiesKHR" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                 <name>pNext</name></member>
            <member limittype="bitmask" noautovalidity="true"><type>VkVideoEncodeAV1CapabilityFlagsKHR</type> <name>flags</name></member>
            <member limittype="max"><type>StdVideoAV1Level</type>      <name>maxLevel</name></member>
            <member limittype="min,pot"><type>VkExtent2D</type>        <name>codedPictureAlignment</name></member>
            <member limittype="max"><type>VkExtent2D</type>            <name>maxTiles</name></member>
            <member limittype="min"><type>VkExtent2D</type>            <name>minTileSize</name></member>
            <member limittype="max"><type>VkExtent2D</type>            <name>maxTileSize</name></member>
            <member limittype="bitmask"><type>VkVideoEncodeAV1SuperblockSizeFlagsKHR</type> <name>superblockSizes</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxSingleReferenceCount</name></member>
            <member limittype="bitmask"><type>uint32_t</type>          <name>singleReferenceNameMask</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxUnidirectionalCompoundReferenceCount</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxUnidirectionalCompoundGroup1ReferenceCount</name></member>
            <member limittype="bitmask"><type>uint32_t</type>          <name>unidirectionalCompoundReferenceNameMask</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxBidirectionalCompoundReferenceCount</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxBidirectionalCompoundGroup1ReferenceCount</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxBidirectionalCompoundGroup2ReferenceCount</name></member>
            <member limittype="bitmask"><type>uint32_t</type>          <name>bidirectionalCompoundReferenceNameMask</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxTemporalLayerCount</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxSpatialLayerCount</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxOperatingPoints</name></member>
            <member limittype="min"><type>uint32_t</type>              <name>minQIndex</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>maxQIndex</name></member>
            <member limittype="min"><type>VkBool32</type>              <name>prefersGopRemainingFrames</name></member>
            <member limittype="min"><type>VkBool32</type>              <name>requiresGopRemainingFrames</name></member>
            <member limittype="bitmask" noautovalidity="true"><type>VkVideoEncodeAV1StdFlagsKHR</type> <name>stdSyntaxFlags</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeAV1QualityLevelPropertiesKHR" returnedonly="true" structextends="VkVideoEncodeQualityLevelPropertiesKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member><type>VkVideoEncodeAV1RateControlFlagsKHR</type>    <name>preferredRateControlFlags</name></member>
            <member><type>uint32_t</type>                               <name>preferredGopFrameCount</name></member>
            <member><type>uint32_t</type>                               <name>preferredKeyFramePeriod</name></member>
            <member><type>uint32_t</type>                               <name>preferredConsecutiveBipredictiveFrameCount</name></member>
            <member><type>uint32_t</type>                               <name>preferredTemporalLayerCount</name></member>
            <member><type>VkVideoEncodeAV1QIndexKHR</type>              <name>preferredConstantQIndex</name></member>
            <member><type>uint32_t</type>                               <name>preferredMaxSingleReferenceCount</name></member>
            <member><type>uint32_t</type>                               <name>preferredSingleReferenceNameMask</name></member>
            <member><type>uint32_t</type>                               <name>preferredMaxUnidirectionalCompoundReferenceCount</name></member>
            <member><type>uint32_t</type>                               <name>preferredMaxUnidirectionalCompoundGroup1ReferenceCount</name></member>
            <member><type>uint32_t</type>                               <name>preferredUnidirectionalCompoundReferenceNameMask</name></member>
            <member><type>uint32_t</type>                               <name>preferredMaxBidirectionalCompoundReferenceCount</name></member>
            <member><type>uint32_t</type>                               <name>preferredMaxBidirectionalCompoundGroup1ReferenceCount</name></member>
            <member><type>uint32_t</type>                               <name>preferredMaxBidirectionalCompoundGroup2ReferenceCount</name></member>
            <member><type>uint32_t</type>                               <name>preferredBidirectionalCompoundReferenceNameMask</name></member>
        </type>
        <type category="include" name="vk_video/vulkan_video_codec_av1std_encode.h">#include "vk_video/vulkan_video_codec_av1std_encode.h"</type>
        <type requires="vk_video/vulkan_video_codec_av1std_encode.h" name="StdVideoEncodeAV1ExtensionHeader"/>
        <type requires="vk_video/vulkan_video_codec_av1std_encode.h" name="StdVideoEncodeAV1DecoderModelInfo"/>
        <type requires="vk_video/vulkan_video_codec_av1std_encode.h" name="StdVideoEncodeAV1OperatingPointInfo"/>
        <type requires="vk_video/vulkan_video_codec_av1std_encode.h" name="StdVideoEncodeAV1PictureInfo"/>
        <type requires="vk_video/vulkan_video_codec_av1std_encode.h" name="StdVideoEncodeAV1ReferenceInfo"/>
        <type category="struct" name="VkPhysicalDeviceVideoEncodeAV1FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>videoEncodeAV1</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeAV1SessionCreateInfoKHR" structextends="VkVideoSessionCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                               <name>useMaxLevel</name></member>
            <member><type>StdVideoAV1Level</type>                       <name>maxLevel</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeAV1SessionParametersCreateInfoKHR" structextends="VkVideoSessionParametersCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member>const <type>StdVideoAV1SequenceHeader</type>*       <name>pStdSequenceHeader</name></member>
            <member optional="true">const <type>StdVideoEncodeAV1DecoderModelInfo</type>* <name>pStdDecoderModelInfo</name></member>
            <member optional="true"><type>uint32_t</type>               <name>stdOperatingPointCount</name></member>
            <member optional="true" len="stdOperatingPointCount">const <type>StdVideoEncodeAV1OperatingPointInfo</type>* <name>pStdOperatingPoints</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeAV1DpbSlotInfoKHR" structextends="VkVideoReferenceSlotInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member>const <type>StdVideoEncodeAV1ReferenceInfo</type>*  <name>pStdReferenceInfo</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeAV1PictureInfoKHR" structextends="VkVideoEncodeInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkVideoEncodeAV1PredictionModeKHR</type>      <name>predictionMode</name></member>
            <member><type>VkVideoEncodeAV1RateControlGroupKHR</type>    <name>rateControlGroup</name></member>
            <member><type>uint32_t</type>                               <name>constantQIndex</name></member>
            <member>const <type>StdVideoEncodeAV1PictureInfo</type>*    <name>pStdPictureInfo</name></member>
            <member><type>int32_t</type>                                <name>referenceNameSlotIndices</name>[<enum>VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR</enum>]</member>
            <member><type>VkBool32</type>                               <name>primaryReferenceCdfOnly</name></member>
            <member><type>VkBool32</type>                               <name>generateObuExtensionHeader</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeAV1ProfileInfoKHR" structextends="VkVideoProfileInfoKHR,VkQueryPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>StdVideoAV1Profile</type>                     <name>stdProfile</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeAV1RateControlInfoKHR" structextends="VkVideoCodingControlInfoKHR,VkVideoBeginCodingInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkVideoEncodeAV1RateControlFlagsKHR</type> <name>flags</name></member>
            <member><type>uint32_t</type>                               <name>gopFrameCount</name></member>
            <member><type>uint32_t</type>                               <name>keyFramePeriod</name></member>
            <member><type>uint32_t</type>                               <name>consecutiveBipredictiveFrameCount</name></member>
            <member><type>uint32_t</type>                               <name>temporalLayerCount</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeAV1QIndexKHR">
            <member noautovalidity="true"><type>uint32_t</type> <name>intraQIndex</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>predictiveQIndex</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>bipredictiveQIndex</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeAV1FrameSizeKHR">
            <member noautovalidity="true"><type>uint32_t</type> <name>intraFrameSize</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>predictiveFrameSize</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>bipredictiveFrameSize</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeAV1GopRemainingFrameInfoKHR" structextends="VkVideoBeginCodingInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                       <name>useGopRemainingFrames</name></member>
            <member><type>uint32_t</type>                       <name>gopRemainingIntra</name></member>
            <member><type>uint32_t</type>                       <name>gopRemainingPredictive</name></member>
            <member><type>uint32_t</type>                       <name>gopRemainingBipredictive</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeAV1RateControlLayerInfoKHR" structextends="VkVideoEncodeRateControlLayerInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                               <name>useMinQIndex</name></member>
            <member><type>VkVideoEncodeAV1QIndexKHR</type>              <name>minQIndex</name></member>
            <member><type>VkBool32</type>                               <name>useMaxQIndex</name></member>
            <member><type>VkVideoEncodeAV1QIndexKHR</type>              <name>maxQIndex</name></member>
            <member><type>VkBool32</type>                               <name>useMaxFrameSize</name></member>
            <member><type>VkVideoEncodeAV1FrameSizeKHR</type>           <name>maxFrameSize</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceInheritedViewportScissorFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>inheritedViewportScissor2D</name></member>
        </type>
        <type category="struct" name="VkCommandBufferInheritanceViewportScissorInfoNV" structextends="VkCommandBufferInheritanceInfo">
            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
            <member><type>VkBool32</type>                                       <name>viewportScissor2D</name></member>
            <member><type>uint32_t</type>                                       <name>viewportDepthCount</name></member>
            <member noautovalidity="true">const <type>VkViewport</type>*        <name>pViewportDepths</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                     <name>ycbcr2plane444Formats</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceProvokingVertexFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>provokingVertexLast</name></member>
            <member><type>VkBool32</type>                           <name>transformFeedbackPreservesProvokingVertex</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceProvokingVertexPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>provokingVertexModePerPipeline</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>transformFeedbackPreservesTriangleFanProvokingVertex</name></member>
        </type>
        <type category="struct" name="VkPipelineRasterizationProvokingVertexStateCreateInfoEXT" structextends="VkPipelineRasterizationStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
            <member><type>VkProvokingVertexModeEXT</type>           <name>provokingVertexMode</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeIntraRefreshCapabilitiesKHR" returnedonly="true" structextends="VkVideoCapabilitiesKHR" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
            <member limittype="bitmask" optional="true"><type>VkVideoEncodeIntraRefreshModeFlagsKHR</type> <name>intraRefreshModes</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxIntraRefreshCycleDuration</name></member>
            <member limittype="max"><type>uint32_t</type>               <name>maxIntraRefreshActiveReferencePictures</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>partitionIndependentIntraRefreshRegions</name></member>
            <member limittype="max"><type>VkBool32</type>               <name>nonRectangularIntraRefreshRegions</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeSessionIntraRefreshCreateInfoKHR" structextends="VkVideoSessionCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member optional="true"><type>VkVideoEncodeIntraRefreshModeFlagBitsKHR</type> <name>intraRefreshMode</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeIntraRefreshInfoKHR" structextends="VkVideoEncodeInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>uint32_t</type>                               <name>intraRefreshCycleDuration</name></member>
            <member><type>uint32_t</type>                               <name>intraRefreshIndex</name></member>
        </type>
        <type category="struct" name="VkVideoReferenceIntraRefreshInfoKHR" structextends="VkVideoReferenceSlotInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>uint32_t</type>                               <name>dirtyIntraRefreshRegions</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                       <name>pNext</name></member>
            <member><type>VkBool32</type>                                    <name>videoEncodeIntraRefresh</name></member>
        </type>
        <type category="struct" name="VkCuModuleCreateInfoNVX">
            <member values="VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>size_t</type>                 <name>dataSize</name></member>
            <member len="dataSize">const <type>void</type>*             <name>pData</name></member>
        </type>
        <type category="struct" name="VkCuModuleTexturingModeCreateInfoNVX" structextends="VkCuModuleCreateInfoNVX">
            <member values="VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type> <name>use64bitTexturing</name></member>
        </type>
        <type category="struct" name="VkCuFunctionCreateInfoNVX">
            <member values="VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
            <member><type>VkCuModuleNVX</type>                      <name>module</name></member>
            <member len="null-terminated">const <type>char</type>*  <name>pName</name></member>
        </type>
        <type category="struct" name="VkCuLaunchInfoNVX">
            <member values="VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkCuFunctionNVX</type>        <name>function</name></member>
            <member><type>uint32_t</type>               <name>gridDimX</name></member>
            <member><type>uint32_t</type>               <name>gridDimY</name></member>
            <member><type>uint32_t</type>               <name>gridDimZ</name></member>
            <member><type>uint32_t</type>               <name>blockDimX</name></member>
            <member><type>uint32_t</type>               <name>blockDimY</name></member>
            <member><type>uint32_t</type>               <name>blockDimZ</name></member>
            <member><type>uint32_t</type>               <name>sharedMemBytes</name></member>
            <member optional="true"><type>size_t</type>                 <name>paramCount</name></member>
            <member len="paramCount">const <type>void</type>* const *    <name>pParams</name></member>
            <member optional="true"><type>size_t</type>                 <name>extraCount</name></member>
            <member len="extraCount">const <type>void</type>* const *    <name>pExtras</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDescriptorBufferFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>descriptorBuffer</name></member>
            <member><type>VkBool32</type>                           <name>descriptorBufferCaptureReplay</name></member>
            <member><type>VkBool32</type>                           <name>descriptorBufferImageLayoutIgnored</name></member>
            <member><type>VkBool32</type>                           <name>descriptorBufferPushDescriptors</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDescriptorBufferPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>combinedImageSamplerDescriptorSingleArray</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>bufferlessPushDescriptors</name></member>
            <member limittype="max"><type>VkBool32</type>                            <name>allowSamplerImageViewPostSubmitCreation</name></member>
            <member limittype="noauto"><type>VkDeviceSize</type>                     <name>descriptorBufferOffsetAlignment</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxDescriptorBufferBindings</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxResourceDescriptorBufferBindings</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxSamplerDescriptorBufferBindings</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxEmbeddedImmutableSamplerBindings</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxEmbeddedImmutableSamplers</name></member>
            <member limittype="noauto"><type>size_t</type>                           <name>bufferCaptureReplayDescriptorDataSize</name></member>
            <member limittype="noauto"><type>size_t</type>                           <name>imageCaptureReplayDescriptorDataSize</name></member>
            <member limittype="noauto"><type>size_t</type>                           <name>imageViewCaptureReplayDescriptorDataSize</name></member>
            <member limittype="noauto"><type>size_t</type>                           <name>samplerCaptureReplayDescriptorDataSize</name></member>
            <member limittype="noauto"><type>size_t</type>                           <name>accelerationStructureCaptureReplayDescriptorDataSize</name></member>
            <member limittype="max"><type>size_t</type>                              <name>samplerDescriptorSize</name></member>
            <member limittype="max"><type>size_t</type>                              <name>combinedImageSamplerDescriptorSize</name></member>
            <member limittype="max"><type>size_t</type>                              <name>sampledImageDescriptorSize</name></member>
            <member limittype="max"><type>size_t</type>                              <name>storageImageDescriptorSize</name></member>
            <member limittype="max"><type>size_t</type>                              <name>uniformTexelBufferDescriptorSize</name></member>
            <member limittype="max"><type>size_t</type>                              <name>robustUniformTexelBufferDescriptorSize</name></member>
            <member limittype="max"><type>size_t</type>                              <name>storageTexelBufferDescriptorSize</name></member>
            <member limittype="max"><type>size_t</type>                              <name>robustStorageTexelBufferDescriptorSize</name></member>
            <member limittype="max"><type>size_t</type>                              <name>uniformBufferDescriptorSize</name></member>
            <member limittype="max"><type>size_t</type>                              <name>robustUniformBufferDescriptorSize</name></member>
            <member limittype="max"><type>size_t</type>                              <name>storageBufferDescriptorSize</name></member>
            <member limittype="max"><type>size_t</type>                              <name>robustStorageBufferDescriptorSize</name></member>
            <member limittype="max"><type>size_t</type>                              <name>inputAttachmentDescriptorSize</name></member>
            <member limittype="max"><type>size_t</type>                              <name>accelerationStructureDescriptorSize</name></member>
            <member limittype="max"><type>VkDeviceSize</type>                        <name>maxSamplerDescriptorBufferRange</name></member>
            <member limittype="max"><type>VkDeviceSize</type>                        <name>maxResourceDescriptorBufferRange</name></member>
            <member limittype="max"><type>VkDeviceSize</type>                        <name>samplerDescriptorBufferAddressSpaceSize</name></member>
            <member limittype="max"><type>VkDeviceSize</type>                        <name>resourceDescriptorBufferAddressSpaceSize</name></member>
            <member limittype="max"><type>VkDeviceSize</type>                        <name>descriptorBufferAddressSpaceSize</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member limittype="max"><type>size_t</type>                              <name>combinedImageSamplerDensityMapDescriptorSize</name></member>
        </type>
        <type category="struct" name="VkDescriptorAddressInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                   <name>pNext</name></member>
            <member optional="true"><type>VkDeviceAddress</type>         <name>address</name></member>
            <member><type>VkDeviceSize</type>                            <name>range</name></member>
            <member><type>VkFormat</type>                                <name>format</name></member>
        </type>
        <type category="struct" name="VkDescriptorBufferBindingInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*             <name>pNext</name></member>
            <member><type>VkDeviceAddress</type>                         <name>address</name></member>
            <member optional="true" noautovalidity="true"><type>VkBufferUsageFlags</type> <name>usage</name></member>
        </type>
        <type category="struct" name="VkDescriptorBufferBindingPushDescriptorBufferHandleEXT" structextends="VkDescriptorBufferBindingInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*             <name>pNext</name></member>
            <member><type>VkBuffer</type>                                <name>buffer</name></member>
        </type>
        <type category="union" name="VkDescriptorDataEXT">
            <member selection="VK_DESCRIPTOR_TYPE_SAMPLER">const <type>VkSampler</type>*                                                     <name>pSampler</name></member>
            <member selection="VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER">const <type>VkDescriptorImageInfo</type>*                          <name>pCombinedImageSampler</name></member>
            <member selection="VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT">const <type>VkDescriptorImageInfo</type>*                                <name>pInputAttachmentImage</name></member>
            <member selection="VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE" optional="true">const <type>VkDescriptorImageInfo</type>*                   <name>pSampledImage</name></member>
            <member selection="VK_DESCRIPTOR_TYPE_STORAGE_IMAGE" optional="true">const <type>VkDescriptorImageInfo</type>*                   <name>pStorageImage</name></member>
            <member selection="VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER" optional="true">const <type>VkDescriptorAddressInfoEXT</type>*       <name>pUniformTexelBuffer</name></member>
            <member selection="VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER" optional="true">const <type>VkDescriptorAddressInfoEXT</type>*       <name>pStorageTexelBuffer</name></member>
            <member selection="VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER" optional="true">const <type>VkDescriptorAddressInfoEXT</type>*             <name>pUniformBuffer</name></member>
            <member selection="VK_DESCRIPTOR_TYPE_STORAGE_BUFFER" optional="true">const <type>VkDescriptorAddressInfoEXT</type>*             <name>pStorageBuffer</name></member>
            <member selection="VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR,VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV"><type>VkDeviceAddress</type> <name>accelerationStructure</name></member>
        </type>
        <type category="struct" name="VkDescriptorGetInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkDescriptorType</type>       <name>type</name></member>
            <member selector="type" noautovalidity="true"><type>VkDescriptorDataEXT</type>  <name>data</name></member>
        </type>
        <type category="struct" name="VkBufferCaptureDescriptorDataInfoEXT">
            <member values="VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkBuffer</type>               <name>buffer</name></member>
        </type>
        <type category="struct" name="VkImageCaptureDescriptorDataInfoEXT">
            <member values="VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkImage</type>                <name>image</name></member>
        </type>
        <type category="struct" name="VkImageViewCaptureDescriptorDataInfoEXT">
            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkImageView</type>                <name>imageView</name></member>
        </type>
        <type category="struct" name="VkSamplerCaptureDescriptorDataInfoEXT">
            <member values="VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkSampler</type>              <name>sampler</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureCaptureDescriptorDataInfoEXT">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkAccelerationStructureKHR</type>             <name>accelerationStructure</name></member>
            <member optional="true"><type>VkAccelerationStructureNV</type>              <name>accelerationStructureNV</name></member>
        </type>
        <type category="struct" name="VkOpaqueCaptureDescriptorDataCreateInfoEXT" structextends="VkBufferCreateInfo,VkImageCreateInfo,VkImageViewCreateInfo,VkSamplerCreateInfo,VkAccelerationStructureCreateInfoKHR,VkAccelerationStructureCreateInfoNV,VkTensorCreateInfoARM,VkTensorViewCreateInfoARM">
            <member values="VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member>const <type>void</type>*            <name>opaqueCaptureDescriptorData</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderIntegerDotProductFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>shaderIntegerDotProduct</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR" alias="VkPhysicalDeviceShaderIntegerDotProductFeatures"/>
        <type category="struct" name="VkPhysicalDeviceShaderIntegerDotProductProperties" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*               <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProduct8BitUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProduct8BitSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProduct8BitMixedSignednessAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProduct4x8BitPackedUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProduct4x8BitPackedSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProduct4x8BitPackedMixedSignednessAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProduct16BitUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProduct16BitSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProduct16BitMixedSignednessAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProduct32BitUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProduct32BitSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProduct32BitMixedSignednessAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProduct64BitUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProduct64BitSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProduct64BitMixedSignednessAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProductAccumulatingSaturating8BitUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProductAccumulatingSaturating8BitSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProductAccumulatingSaturating16BitUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProductAccumulatingSaturating16BitSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProductAccumulatingSaturating32BitUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProductAccumulatingSaturating32BitSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProductAccumulatingSaturating64BitUnsignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProductAccumulatingSaturating64BitSignedAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>          <name>integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR" alias="VkPhysicalDeviceShaderIntegerDotProductProperties"/>
        <type category="struct" name="VkPhysicalDeviceDrmPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>   <name>hasPrimary</name></member>
            <member limittype="max"><type>VkBool32</type>   <name>hasRender</name></member>
            <member limittype="noauto"><type>int64_t</type> <name>primaryMajor</name></member>
            <member limittype="noauto"><type>int64_t</type> <name>primaryMinor</name></member>
            <member limittype="noauto"><type>int64_t</type> <name>renderMajor</name></member>
            <member limittype="noauto"><type>int64_t</type> <name>renderMinor</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*  <name>pNext</name></member>
            <member><type>VkBool32</type>               <name>fragmentShaderBarycentric</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*  <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>                <name>triStripVertexOrderIndependentOfProvokingVertex</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderFmaFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FMA_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member><type>VkBool32</type>                                           <name>shaderFmaFloat16</name></member>
            <member><type>VkBool32</type>                                           <name>shaderFmaFloat32</name></member>
            <member><type>VkBool32</type>                                           <name>shaderFmaFloat64</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRayTracingMotionBlurFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>rayTracingMotionBlur</name></member>
            <member><type>VkBool32</type>                           <name>rayTracingMotionBlurPipelineTraceRaysIndirect</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRayTracingValidationFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member><type>VkBool32</type>                                           <name>rayTracingValidation</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*  <name>pNext</name></member>
            <member><type>VkBool32</type>                                     <name>spheres</name></member>
            <member><type>VkBool32</type>                                     <name>linearSweptSpheres</name></member>
        </type>
        <type name="VkAccelerationStructureMotionInstanceTypeNV" category="enum"/>
        <type category="struct" name="VkAccelerationStructureGeometryMotionTrianglesDataNV" structextends="VkAccelerationStructureGeometryTrianglesDataKHR">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                   <name>pNext</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                 <name>vertexData</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureMotionInfoNV" structextends="VkAccelerationStructureCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
            <member><type>uint32_t</type>                                       <name>maxInstances</name></member>
            <member optional="true"><type>VkAccelerationStructureMotionInfoFlagsNV</type> <name>flags</name></member>
        </type>
        <type category="struct" name="VkSRTDataNV">
            <member><type>float</type> <name>sx</name></member>
            <member><type>float</type> <name>a</name></member>
            <member><type>float</type> <name>b</name></member>
            <member><type>float</type> <name>pvx</name></member>
            <member><type>float</type> <name>sy</name></member>
            <member><type>float</type> <name>c</name></member>
            <member><type>float</type> <name>pvy</name></member>
            <member><type>float</type> <name>sz</name></member>
            <member><type>float</type> <name>pvz</name></member>
            <member><type>float</type> <name>qx</name></member>
            <member><type>float</type> <name>qy</name></member>
            <member><type>float</type> <name>qz</name></member>
            <member><type>float</type> <name>qw</name></member>
            <member><type>float</type> <name>tx</name></member>
            <member><type>float</type> <name>ty</name></member>
            <member><type>float</type> <name>tz</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureSRTMotionInstanceNV">
            <comment>The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.</comment>
            <member><type>VkSRTDataNV</type>                                             <name>transformT0</name></member>
            <member><type>VkSRTDataNV</type>                                             <name>transformT1</name></member>
            <member><type>uint32_t</type>                                                <name>instanceCustomIndex</name>:24</member>
            <member><type>uint32_t</type>                                                <name>mask</name>:8</member>
            <member><type>uint32_t</type>                                                <name>instanceShaderBindingTableRecordOffset</name>:24</member>
            <member optional="true"><type>VkGeometryInstanceFlagsKHR</type>              <name>flags</name>:8</member>
            <member><type>uint64_t</type>                                                <name>accelerationStructureReference</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureMatrixMotionInstanceNV">
            <comment>The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.</comment>
            <member><type>VkTransformMatrixKHR</type>                                    <name>transformT0</name></member>
            <member><type>VkTransformMatrixKHR</type>                                    <name>transformT1</name></member>
            <member><type>uint32_t</type>                                                <name>instanceCustomIndex</name>:24</member>
            <member><type>uint32_t</type>                                                <name>mask</name>:8</member>
            <member><type>uint32_t</type>                                                <name>instanceShaderBindingTableRecordOffset</name>:24</member>
            <member optional="true"><type>VkGeometryInstanceFlagsKHR</type>              <name>flags</name>:8</member>
            <member><type>uint64_t</type>                                                <name>accelerationStructureReference</name></member>
        </type>
        <type category="union" name="VkAccelerationStructureMotionInstanceDataNV">
            <member selection="VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV"><type>VkAccelerationStructureInstanceKHR</type>            <name>staticInstance</name></member>
            <member selection="VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV"><type>VkAccelerationStructureMatrixMotionInstanceNV</type> <name>matrixMotionInstance</name></member>
            <member selection="VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV"><type>VkAccelerationStructureSRTMotionInstanceNV</type>    <name>srtMotionInstance</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureMotionInstanceNV">
            <member><type>VkAccelerationStructureMotionInstanceTypeNV</type> <name>type</name></member>
            <member optional="true"><type>VkAccelerationStructureMotionInstanceFlagsNV</type> <name>flags</name></member>
            <member selector="type"><type>VkAccelerationStructureMotionInstanceDataNV</type> <name>data</name></member>
        </type>
        <type category="basetype">typedef <type>void</type>* <name>VkRemoteAddressNV</name>;</type>
        <type category="struct" name="VkMemoryGetRemoteAddressInfoNV">
            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
            <member><type>VkDeviceMemory</type>                     <name>memory</name></member>
            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
        </type>
        <type category="struct" name="VkImportMemoryBufferCollectionFUCHSIA" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
            <member><type>VkBufferCollectionFUCHSIA</type>        <name>collection</name></member>
            <member><type>uint32_t</type>                         <name>index</name></member>
        </type>
        <type category="struct" name="VkBufferCollectionImageCreateInfoFUCHSIA" structextends="VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
            <member><type>VkBufferCollectionFUCHSIA</type>        <name>collection</name></member>
            <member><type>uint32_t</type>                         <name>index</name></member>
        </type>
        <type category="struct" name="VkBufferCollectionBufferCreateInfoFUCHSIA" structextends="VkBufferCreateInfo">
            <member values="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
            <member><type>VkBufferCollectionFUCHSIA</type>        <name>collection</name></member>
            <member><type>uint32_t</type>                         <name>index</name></member>
        </type>
        <type category="struct" name="VkBufferCollectionCreateInfoFUCHSIA">
            <member values="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
            <member><type>zx_handle_t</type>                      <name>collectionToken</name></member>
        </type>
        <type category="struct" name="VkBufferCollectionPropertiesFUCHSIA" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>memoryTypeBits</name></member>
            <member><type>uint32_t</type>                         <name>bufferCount</name></member>
            <member><type>uint32_t</type>                         <name>createInfoIndex</name></member>
            <member><type>uint64_t</type>                         <name>sysmemPixelFormat</name></member>
            <member><type>VkFormatFeatureFlags</type>             <name>formatFeatures</name></member>
            <member><type>VkSysmemColorSpaceFUCHSIA</type>        <name>sysmemColorSpaceIndex</name></member>
            <member><type>VkComponentMapping</type>               <name>samplerYcbcrConversionComponents</name></member>
            <member><type>VkSamplerYcbcrModelConversion</type>    <name>suggestedYcbcrModel</name></member>
            <member><type>VkSamplerYcbcrRange</type>              <name>suggestedYcbcrRange</name></member>
            <member><type>VkChromaLocation</type>                 <name>suggestedXChromaOffset</name></member>
            <member><type>VkChromaLocation</type>                 <name>suggestedYChromaOffset</name></member>
        </type>
        <type category="struct" name="VkBufferConstraintsInfoFUCHSIA">
            <member values="VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*               <name>pNext</name></member>
            <member><type>VkBufferCreateInfo</type>                        <name>createInfo</name></member>
            <member optional="true"><type>VkFormatFeatureFlags</type>      <name>requiredFormatFeatures</name></member>
            <member><type>VkBufferCollectionConstraintsInfoFUCHSIA</type>  <name>bufferCollectionConstraints</name></member>
        </type>
        <type category="struct" name="VkSysmemColorSpaceFUCHSIA">
            <member values="VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
            <member><type>uint32_t</type>                        <name>colorSpace</name></member>
        </type>
        <type category="struct" name="VkImageFormatConstraintsInfoFUCHSIA">
            <member values="VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
            <member><type>VkImageCreateInfo</type>                                      <name>imageCreateInfo</name></member>
            <member><type>VkFormatFeatureFlags</type>                                   <name>requiredFormatFeatures</name></member>
            <member optional="true"><type>VkImageFormatConstraintsFlagsFUCHSIA</type>   <name>flags</name></member>
            <member optional="true"><type>uint64_t</type>                               <name>sysmemPixelFormat</name></member>
            <member><type>uint32_t</type>                                               <name>colorSpaceCount</name></member>
            <member len="colorSpaceCount">const <type>VkSysmemColorSpaceFUCHSIA</type>* <name>pColorSpaces</name></member>
        </type>
        <type category="struct" name="VkImageConstraintsInfoFUCHSIA">
            <member values="VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                      <name>pNext</name></member>
            <member><type>uint32_t</type>                                                         <name>formatConstraintsCount</name></member>
            <member len="formatConstraintsCount">const <type>VkImageFormatConstraintsInfoFUCHSIA</type>* <name>pFormatConstraints</name></member>
            <member><type>VkBufferCollectionConstraintsInfoFUCHSIA</type>                         <name>bufferCollectionConstraints</name></member>
            <member optional="true"><type>VkImageConstraintsInfoFlagsFUCHSIA</type>               <name>flags</name></member>
        </type>
        <type category="struct" name="VkBufferCollectionConstraintsInfoFUCHSIA">
            <member values="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
            <member><type>uint32_t</type>                        <name>minBufferCount</name></member>
            <member><type>uint32_t</type>                        <name>maxBufferCount</name></member>
            <member><type>uint32_t</type>                        <name>minBufferCountForCamping</name></member>
            <member><type>uint32_t</type>                        <name>minBufferCountForDedicatedSlack</name></member>
            <member><type>uint32_t</type>                        <name>minBufferCountForSharedSlack</name></member>
        </type>
        <type category="handle" parent="VkDevice" objtypeenum="VK_OBJECT_TYPE_CUDA_MODULE_NV"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkCudaModuleNV</name>)</type>
        <type category="handle" parent="VkDevice" objtypeenum="VK_OBJECT_TYPE_CUDA_FUNCTION_NV"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkCudaFunctionNV</name>)</type>
        <type category="struct" name="VkCudaModuleCreateInfoNV">
            <member values="VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>size_t</type>                 <name>dataSize</name></member>
            <member len="dataSize">const <type>void</type>*            <name>pData</name></member>
        </type>
        <type category="struct" name="VkCudaFunctionCreateInfoNV">
            <member values="VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkCudaModuleNV</type>         <name>module</name></member>
            <member len="null-terminated">const <type>char</type>*            <name>pName</name></member>
        </type>
        <type category="struct" name="VkCudaLaunchInfoNV">
            <member values="VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkCudaFunctionNV</type>       <name>function</name></member>
            <member><type>uint32_t</type>               <name>gridDimX</name></member>
            <member><type>uint32_t</type>               <name>gridDimY</name></member>
            <member><type>uint32_t</type>               <name>gridDimZ</name></member>
            <member><type>uint32_t</type>               <name>blockDimX</name></member>
            <member><type>uint32_t</type>               <name>blockDimY</name></member>
            <member><type>uint32_t</type>               <name>blockDimZ</name></member>
            <member><type>uint32_t</type>               <name>sharedMemBytes</name></member>
            <member optional="true"><type>size_t</type>                                     <name>paramCount</name></member>
            <member noautovalidity="true" len="paramCount">const <type>void</type>* const * <name>pParams</name></member>
            <member optional="true"><type>size_t</type>                                     <name>extraCount</name></member>
            <member noautovalidity="true" len="extraCount">const <type>void</type>* const * <name>pExtras</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>formatRgba10x6WithoutYCbCrSampler</name></member>
        </type>
        <type category="struct" name="VkFormatProperties3" returnedonly="true" structextends="VkFormatProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member optional="true" limittype="bitmask"><type>VkFormatFeatureFlags2</type>            <name>linearTilingFeatures</name></member>
            <member optional="true" limittype="bitmask"><type>VkFormatFeatureFlags2</type>            <name>optimalTilingFeatures</name></member>
            <member optional="true" limittype="bitmask"><type>VkFormatFeatureFlags2</type>            <name>bufferFeatures</name></member>
        </type>
        <type category="struct" name="VkFormatProperties3KHR" alias="VkFormatProperties3"/>
        <type category="struct" name="VkDrmFormatModifierPropertiesList2EXT" returnedonly="true" structextends="VkFormatProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member limittype="noauto" optional="true"><type>uint32_t</type> <name>drmFormatModifierCount</name></member>
            <member limittype="struct" optional="true" len="drmFormatModifierCount"><type>VkDrmFormatModifierProperties2EXT</type>* <name>pDrmFormatModifierProperties</name></member>
        </type>
        <type category="struct" name="VkDrmFormatModifierProperties2EXT" returnedonly="true" requiredlimittype="true">
            <member limittype="exact"><type>uint64_t</type>                 <name>drmFormatModifier</name></member>
            <member limittype="exact"><type>uint32_t</type>                 <name>drmFormatModifierPlaneCount</name></member>
            <member limittype="bitmask"><type>VkFormatFeatureFlags2</type>  <name>drmFormatModifierTilingFeatures</name></member>
        </type>
        <type category="struct" name="VkAndroidHardwareBufferFormatProperties2ANDROID" structextends="VkAndroidHardwareBufferPropertiesANDROID" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member><type>VkFormat</type>                           <name>format</name></member>
            <member><type>uint64_t</type>                           <name>externalFormat</name></member>
            <member><type>VkFormatFeatureFlags2</type>              <name>formatFeatures</name></member>
            <member><type>VkComponentMapping</type>                 <name>samplerYcbcrConversionComponents</name></member>
            <member><type>VkSamplerYcbcrModelConversion</type>      <name>suggestedYcbcrModel</name></member>
            <member><type>VkSamplerYcbcrRange</type>                <name>suggestedYcbcrRange</name></member>
            <member><type>VkChromaLocation</type>                   <name>suggestedXChromaOffset</name></member>
            <member><type>VkChromaLocation</type>                   <name>suggestedYChromaOffset</name></member>
        </type>
        <type category="struct" name="VkPipelineRenderingCreateInfo" structextends="VkGraphicsPipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
            <member><type>uint32_t</type>                                                                   <name>viewMask</name></member>
            <member optional="true"><type>uint32_t</type>                                                   <name>colorAttachmentCount</name></member>
            <member noautovalidity="true" len="colorAttachmentCount">const <type>VkFormat</type>*           <name>pColorAttachmentFormats</name></member>
            <member noautovalidity="true"><type>VkFormat</type>                                             <name>depthAttachmentFormat</name></member>
            <member noautovalidity="true"><type>VkFormat</type>                                             <name>stencilAttachmentFormat</name></member>
        </type>
        <type category="struct" name="VkPipelineRenderingCreateInfoKHR" alias="VkPipelineRenderingCreateInfo"/>
        <type category="struct" name="VkRenderingInfo">
            <member values="VK_STRUCTURE_TYPE_RENDERING_INFO"><type>VkStructureType</type>                  <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
            <member optional="true"><type>VkRenderingFlags</type>                                           <name>flags</name></member>
            <member><type>VkRect2D</type>                                                                   <name>renderArea</name></member>
            <member><type>uint32_t</type>                                                                   <name>layerCount</name></member>
            <member><type>uint32_t</type>                                                                   <name>viewMask</name></member>
            <member optional="true"><type>uint32_t</type>                                                   <name>colorAttachmentCount</name></member>
            <member len="colorAttachmentCount">const <type>VkRenderingAttachmentInfo</type>*                <name>pColorAttachments</name></member>
            <member optional="true">const <type>VkRenderingAttachmentInfo</type>*                           <name>pDepthAttachment</name></member>
            <member optional="true">const <type>VkRenderingAttachmentInfo</type>*                           <name>pStencilAttachment</name></member>
        </type>
        <type category="struct" name="VkRenderingInfoKHR" alias="VkRenderingInfo"/>
        <type category="struct" name="VkRenderingEndInfoKHR">
            <member values="VK_STRUCTURE_TYPE_RENDERING_END_INFO_KHR"><type>VkStructureType</type>          <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
        </type>
        <type category="struct" name="VkRenderingEndInfoEXT" alias="VkRenderingEndInfoKHR"/>
        <type category="struct" name="VkRenderingAttachmentInfo">
            <member values="VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO"><type>VkStructureType</type>       <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
            <member optional="true"><type>VkImageView</type>                                                <name>imageView</name></member>
            <member><type>VkImageLayout</type>                                                              <name>imageLayout</name></member>
            <member optional="true"><type>VkResolveModeFlagBits</type>                                      <name>resolveMode</name></member>
            <member optional="true"><type>VkImageView</type>                                                <name>resolveImageView</name></member>
            <member><type>VkImageLayout</type>                                                              <name>resolveImageLayout</name></member>
            <member><type>VkAttachmentLoadOp</type>                                                         <name>loadOp</name></member>
            <member><type>VkAttachmentStoreOp</type>                                                        <name>storeOp</name></member>
            <member><type>VkClearValue</type>                                                               <name>clearValue</name></member>
        </type>
        <type category="struct" name="VkRenderingAttachmentInfoKHR" alias="VkRenderingAttachmentInfo"/>
        <type category="struct" name="VkRenderingFragmentShadingRateAttachmentInfoKHR" structextends="VkRenderingInfo">
            <member values="VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member  optional="true">const <type>void</type>*                                               <name>pNext</name></member>
            <member optional="true"><type>VkImageView</type>                                                <name>imageView</name></member>
            <member><type>VkImageLayout</type>                                                              <name>imageLayout</name></member>
            <member><type>VkExtent2D</type>                                                                 <name>shadingRateAttachmentTexelSize</name></member>
        </type>
        <type category="struct" name="VkRenderingFragmentDensityMapAttachmentInfoEXT" structextends="VkRenderingInfo">
            <member values="VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
            <member><type>VkImageView</type>                                                                <name>imageView</name></member>
            <member><type>VkImageLayout</type>                                                              <name>imageLayout</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDynamicRenderingFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*                                <name>pNext</name></member>
            <member><type>VkBool32</type>                                                                   <name>dynamicRendering</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDynamicRenderingFeaturesKHR" alias="VkPhysicalDeviceDynamicRenderingFeatures"/>
        <type category="struct" name="VkCommandBufferInheritanceRenderingInfo" structextends="VkCommandBufferInheritanceInfo">
            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
            <member optional="true"><type>VkRenderingFlags</type>                                           <name>flags</name></member>
            <member><type>uint32_t</type>                                                                   <name>viewMask</name></member>
            <member api="vulkan,vulkanbase" optional="true"><type>uint32_t</type>                                      <name>colorAttachmentCount</name></member>
            <member api="vulkansc"><type>uint32_t</type>                                                    <name>colorAttachmentCount</name></member>
            <member len="colorAttachmentCount">const <type>VkFormat</type>*                                 <name>pColorAttachmentFormats</name></member>
            <member><type>VkFormat</type>                                                                   <name>depthAttachmentFormat</name></member>
            <member><type>VkFormat</type>                                                                   <name>stencilAttachmentFormat</name></member>
            <member optional="true"><type>VkSampleCountFlagBits</type>                                      <name>rasterizationSamples</name></member>
        </type>
        <type category="struct" name="VkCommandBufferInheritanceRenderingInfoKHR" alias="VkCommandBufferInheritanceRenderingInfo"/>
        <type category="struct" name="VkAttachmentSampleCountInfoAMD" structextends="VkCommandBufferInheritanceInfo,VkGraphicsPipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                                                   <name>colorAttachmentCount</name></member>
            <member noautovalidity="true" len="colorAttachmentCount">const <type>VkSampleCountFlagBits</type>* <name>pColorAttachmentSamples</name></member>
            <member noautovalidity="true" optional="true"><type>VkSampleCountFlagBits</type>                <name>depthStencilAttachmentSamples</name></member>
        </type>
        <type category="struct" name="VkAttachmentSampleCountInfoNV" alias="VkAttachmentSampleCountInfoAMD"/>
        <type category="struct" name="VkMultiviewPerViewAttributesInfoNVX" structextends="VkCommandBufferInheritanceInfo,VkGraphicsPipelineCreateInfo,VkRenderingInfo">
            <member values="VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                               <name>perViewAttributes</name></member>
            <member><type>VkBool32</type>                               <name>perViewAttributesPositionXOnly</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImageViewMinLodFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>minLod</name></member>
        </type>
        <type category="struct" name="VkImageViewMinLodCreateInfoEXT" structextends="VkImageViewCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>float</type>                       <name>minLod</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>rasterizationOrderColorAttachmentAccess</name></member>
            <member><type>VkBool32</type>                         <name>rasterizationOrderDepthAttachmentAccess</name></member>
            <member><type>VkBool32</type>                         <name>rasterizationOrderStencilAttachmentAccess</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM" alias="VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT"/>
        <type category="struct" name="VkPhysicalDeviceLinearColorAttachmentFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>linearColorAttachment</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                     <name>graphicsPipelineLibrary</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePipelineBinaryFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                     <name>pipelineBinaries</name></member>
        </type>
        <type category="struct" name="VkDevicePipelineBinaryInternalCacheControlKHR" structextends="VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*  <name>pNext</name></member>
            <member><type>VkBool32</type>                     <name>disableInternalCache</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePipelineBinaryPropertiesKHR" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>     <name>pipelineBinaryInternalCache</name></member>
            <member limittype="max"><type>VkBool32</type>     <name>pipelineBinaryInternalCacheControl</name></member>
            <member limittype="max"><type>VkBool32</type>     <name>pipelineBinaryPrefersInternalCache</name></member>
            <member limittype="max"><type>VkBool32</type>     <name>pipelineBinaryPrecompiledInternalCache</name></member>
            <member limittype="max"><type>VkBool32</type>     <name>pipelineBinaryCompressedData</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>graphicsPipelineLibraryFastLinking</name></member>
            <member limittype="max"><type>VkBool32</type>                       <name>graphicsPipelineLibraryIndependentInterpolationDecoration</name></member>
        </type>
        <type category="struct" name="VkGraphicsPipelineLibraryCreateInfoEXT" structextends="VkGraphicsPipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*       <name>pNext</name></member>
            <member><type>VkGraphicsPipelineLibraryFlagsEXT</type> <name>flags</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*                                                           <name>pNext</name></member>
            <member><type>VkBool32</type>                                                                                              <name>descriptorSetHostMapping</name></member>
        </type>
        <type category="struct" name="VkDescriptorSetBindingReferenceVALVE">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                       <name>pNext</name></member>
            <member><type>VkDescriptorSetLayout</type>                                                             <name>descriptorSetLayout</name></member>
            <member><type>uint32_t</type>                                                                          <name>binding</name></member>
        </type>
        <type category="struct" name="VkDescriptorSetLayoutHostMappingInfoVALVE">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                                                    <name>pNext</name></member>
            <member><type>size_t</type>                                                                                   <name>descriptorOffset</name></member>
            <member><type>uint32_t</type>                                                                                 <name>descriptorSize</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceNestedCommandBufferFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>nestedCommandBuffer</name></member>
            <member><type>VkBool32</type>                                        <name>nestedCommandBufferRendering</name></member>
            <member><type>VkBool32</type>                                        <name>nestedCommandBufferSimultaneousUse</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceNestedCommandBufferPropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                           <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>                        <name>maxCommandBufferNestingLevel</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*                                                      <name>pNext</name></member>
            <member><type>VkBool32</type>                                                                                         <name>shaderModuleIdentifier</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
            <member limittype="noauto"><type>uint8_t</type> <name>shaderModuleIdentifierAlgorithmUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
        </type>
        <type category="struct" name="VkPipelineShaderStageModuleIdentifierCreateInfoEXT" structextends="VkPipelineShaderStageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*         <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>            <name>identifierSize</name></member>
            <member len="identifierSize">const <type>uint8_t</type>* <name>pIdentifier</name></member>
        </type>
        <type category="struct" name="VkShaderModuleIdentifierEXT" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*          <name>pNext</name></member>
            <member noautovalidity="true"><type>uint32_t</type> <name>identifierSize</name></member>
            <member len="identifierSize"><type>uint8_t</type>   <name>identifier</name>[<enum>VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT</enum>]</member>
        </type>
        <type category="struct" name="VkImageCompressionControlEXT" structextends="VkImageCreateInfo,VkSwapchainCreateInfoKHR,VkPhysicalDeviceImageFormatInfo2">
            <member values="VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
            <member noautovalidity="true"><type>VkImageCompressionFlagsEXT</type>   <name>flags</name></member>
            <member optional="true"><type>uint32_t</type>             <name>compressionControlPlaneCount</name></member>
            <member noautovalidity="true" len="compressionControlPlaneCount"><type>VkImageCompressionFixedRateFlagsEXT</type>* <name>pFixedRateFlags</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImageCompressionControlFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type>                             <name>imageCompressionControl</name></member>
        </type>
        <type category="struct" name="VkImageCompressionPropertiesEXT" structextends="VkImageFormatProperties2,VkSurfaceFormat2KHR,VkSubresourceLayout2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                <name>pNext</name></member>
            <member><type>VkImageCompressionFlagsEXT</type>           <name>imageCompressionFlags</name></member>
            <member><type>VkImageCompressionFixedRateFlagsEXT</type>  <name>imageCompressionFixedRateFlags</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type>                             <name>imageCompressionControlSwapchain</name></member>
        </type>
        <type category="struct" name="VkImageSubresource2">
            <member values="VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*  <name>pNext</name></member>
            <member><type>VkImageSubresource</type>     <name>imageSubresource</name></member>
        </type>
        <type category="struct" name="VkImageSubresource2KHR" alias="VkImageSubresource2"/>
        <type category="struct" name="VkImageSubresource2EXT" alias="VkImageSubresource2"/>
        <type category="struct" name="VkSubresourceLayout2"  returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*  <name>pNext</name></member>
            <member><type>VkSubresourceLayout</type>    <name>subresourceLayout</name></member>
        </type>
        <type category="struct" name="VkSubresourceLayout2KHR" alias="VkSubresourceLayout2"/>
        <type category="struct" name="VkSubresourceLayout2EXT" alias="VkSubresourceLayout2"/>
        <type category="struct" name="VkRenderPassCreationControlEXT" structextends="VkRenderPassCreateInfo2,VkSubpassDescription2">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                 <name>pNext</name></member>
            <member><type>VkBool32</type>                                                                    <name>disallowMerging</name></member>
        </type>
        <type category="struct" name="VkRenderPassCreationFeedbackInfoEXT" returnedonly="true">
            <member><type>uint32_t</type>                                                                          <name>postMergeSubpassCount</name></member>
        </type>
        <type category="struct" name="VkRenderPassCreationFeedbackCreateInfoEXT" structextends="VkRenderPassCreateInfo2">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                              <name>pNext</name></member>
            <member><type>VkRenderPassCreationFeedbackInfoEXT</type>*                                                     <name>pRenderPassFeedback</name></member>
        </type>
        <type category="struct" name="VkRenderPassSubpassFeedbackInfoEXT" returnedonly="true">
            <member><type>VkSubpassMergeStatusEXT</type>                                                          <name>subpassMergeStatus</name></member>
            <member len="null-terminated"><type>char</type>                                                       <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
            <member><type>uint32_t</type>                                                                         <name>postMergeIndex</name></member>
        </type>
        <type category="struct" name="VkRenderPassSubpassFeedbackCreateInfoEXT" structextends="VkSubpassDescription2">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT"><type>VkStructureType</type>     <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                                 <name>pNext</name></member>
            <member><type>VkRenderPassSubpassFeedbackInfoEXT</type>*                                                         <name>pSubpassFeedback</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*                                                    <name>pNext</name></member>
            <member><type>VkBool32</type>                                                                                       <name>subpassMergeFeedback</name></member>
        </type>
        <type category="struct" name="VkMicromapBuildInfoEXT">
            <member values="VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                        <name>pNext</name></member>
            <member><type>VkMicromapTypeEXT</type>                                     <name>type</name></member>
            <member optional="true"><type>VkBuildMicromapFlagsEXT</type>               <name>flags</name></member>
            <member noautovalidity="true"><type>VkBuildMicromapModeEXT</type>          <name>mode</name></member>
            <member optional="true" noautovalidity="true"><type>VkMicromapEXT</type>                   <name>dstMicromap</name></member>
            <member optional="true"><type>uint32_t</type>                                           <name>usageCountsCount</name></member>
            <member len="usageCountsCount" optional="true">const <type>VkMicromapUsageEXT</type>*    <name>pUsageCounts</name></member>
            <member len="usageCountsCount,1" optional="true,false">const <type>VkMicromapUsageEXT</type>* const*   <name>ppUsageCounts</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                               <name>data</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressKHR</type>                                    <name>scratchData</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                               <name>triangleArray</name></member>
            <member><type>VkDeviceSize</type>                                                                      <name>triangleArrayStride</name></member>
        </type>
        <type category="struct" name="VkMicromapCreateInfoEXT">
            <member values="VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                             <name>pNext</name></member>
            <member optional="true"><type>VkMicromapCreateFlagsEXT</type>   <name>createFlags</name></member>
            <member><type>VkBuffer</type>                                                <name>buffer</name></member>
            <member><type>VkDeviceSize</type>                                            <name>offset</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>                                            <name>size</name></member>
            <member><type>VkMicromapTypeEXT</type>                          <name>type</name></member>
            <member optional="true"><type>VkDeviceAddress</type>                         <name>deviceAddress</name></member>
        </type>
        <type category="struct" name="VkMicromapVersionInfoEXT">
            <member values="VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
            <member len="latexmath:[2 \times \mathtt{VK\_UUID\_SIZE}]" altlen="2*VK_UUID_SIZE">const <type>uint8_t</type>*                    <name>pVersionData</name></member>
        </type>
        <type category="struct" name="VkCopyMicromapInfoEXT">
            <member values="VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
            <member><type>VkMicromapEXT</type>                             <name>src</name></member>
            <member><type>VkMicromapEXT</type>                             <name>dst</name></member>
            <member><type>VkCopyMicromapModeEXT</type>                     <name>mode</name></member>
        </type>
        <type category="struct" name="VkCopyMicromapToMemoryInfoEXT">
            <member values="VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
            <member><type>VkMicromapEXT</type>                             <name>src</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressKHR</type>                               <name>dst</name></member>
            <member><type>VkCopyMicromapModeEXT</type>                     <name>mode</name></member>
        </type>
        <type category="struct" name="VkCopyMemoryToMicromapInfoEXT">
            <member values="VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                          <name>src</name></member>
            <member><type>VkMicromapEXT</type>                             <name>dst</name></member>
            <member><type>VkCopyMicromapModeEXT</type>                     <name>mode</name></member>
        </type>
        <type category="struct" name="VkMicromapBuildSizesInfoEXT">
            <member values="VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
            <member><type>VkDeviceSize</type>                       <name>micromapSize</name></member>
            <member><type>VkDeviceSize</type>                       <name>buildScratchSize</name></member>
            <member><type>VkBool32</type>                           <name>discardable</name></member>
        </type>
        <type category="struct" name="VkMicromapUsageEXT">
            <member><type>uint32_t</type>                                               <name>count</name></member>
            <member><type>uint32_t</type>                                               <name>subdivisionLevel</name></member>
            <member><type>uint32_t</type>                                               <name>format</name><comment>Interpretation depends on parent type</comment></member>
        </type>
        <type category="struct" name="VkMicromapTriangleEXT">
            <member><type>uint32_t</type>                                               <name>dataOffset</name><comment>Specified in bytes</comment></member>
            <member><type>uint16_t</type>                                               <name>subdivisionLevel</name></member>
            <member><type>uint16_t</type>                                               <name>format</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceOpacityMicromapFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>micromap</name></member>
            <member><type>VkBool32</type>                         <name>micromapCaptureReplay</name></member>
            <member><type>VkBool32</type>                         <name>micromapHostCommands</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceOpacityMicromapPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxOpacity2StateSubdivisionLevel</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxOpacity4StateSubdivisionLevel</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureTrianglesOpacityMicromapEXT" structextends="VkAccelerationStructureGeometryTrianglesDataKHR,VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                  <name>pNext</name></member>
            <member><type>VkIndexType</type>                                            <name>indexType</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>    <name>indexBuffer</name></member>
            <member><type>VkDeviceSize</type>                                           <name>indexStride</name></member>
            <member><type>uint32_t</type>                                               <name>baseTriangle</name></member>
            <member optional="true"><type>uint32_t</type>                               <name>usageCountsCount</name></member>
            <member len="usageCountsCount" optional="true">const <type>VkMicromapUsageEXT</type>*  <name>pUsageCounts</name></member>
            <member len="usageCountsCount,1" optional="true,false">const <type>VkMicromapUsageEXT</type>* const* <name>ppUsageCounts</name></member>
            <member optional="true"><type>VkMicromapEXT</type>                          <name>micromap</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDisplacementMicromapFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>displacementMicromap</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDisplacementMicromapPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxDisplacementMicromapSubdivisionLevel</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureTrianglesDisplacementMicromapNV" structextends="VkAccelerationStructureGeometryTrianglesDataKHR">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                  <name>pNext</name></member>

            <member><type>VkFormat</type>                                               <name>displacementBiasAndScaleFormat</name></member>
            <member><type>VkFormat</type>                                               <name>displacementVectorFormat</name></member>

            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>    <name>displacementBiasAndScaleBuffer</name></member>
            <member><type>VkDeviceSize</type>                                           <name>displacementBiasAndScaleStride</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>    <name>displacementVectorBuffer</name></member>
            <member><type>VkDeviceSize</type>                                           <name>displacementVectorStride</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>    <name>displacedMicromapPrimitiveFlags</name></member>
            <member><type>VkDeviceSize</type>                                           <name>displacedMicromapPrimitiveFlagsStride</name></member>
            <member><type>VkIndexType</type>                                            <name>indexType</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>    <name>indexBuffer</name></member>
            <member><type>VkDeviceSize</type>                                           <name>indexStride</name></member>

            <member><type>uint32_t</type>                                               <name>baseTriangle</name></member>

            <member optional="true"><type>uint32_t</type>                                                          <name>usageCountsCount</name></member>
            <member len="usageCountsCount" optional="true">const <type>VkMicromapUsageEXT</type>*                  <name>pUsageCounts</name></member>
            <member len="usageCountsCount,1" optional="true,false">const <type>VkMicromapUsageEXT</type>* const*   <name>ppUsageCounts</name></member>

            <member optional="true"><type>VkMicromapEXT</type>                          <name>micromap</name></member>
        </type>
        <type category="struct" name="VkPipelinePropertiesIdentifierEXT" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member><type>uint8_t</type>                            <name>pipelineIdentifier</name>[<enum>VK_UUID_SIZE</enum>]</member>
        </type>
        <type category="struct" name="VkPhysicalDevicePipelinePropertiesFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>pipelinePropertiesIdentifier</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true" optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>shaderEarlyAndLateFragmentTests</name></member>
        </type>
        <type category="struct" name="VkExternalMemoryAcquireUnmodifiedEXT" structextends="VkBufferMemoryBarrier,VkBufferMemoryBarrier2,VkImageMemoryBarrier,VkImageMemoryBarrier2">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                       <name>acquireUnmodifiedMemory</name></member>
        </type>
        <type category="struct" name="VkExportMetalObjectCreateInfoEXT" structextends="VkInstanceCreateInfo,VkMemoryAllocateInfo,VkImageCreateInfo,VkImageViewCreateInfo,VkBufferViewCreateInfo,VkSemaphoreCreateInfo,VkEventCreateInfo" allowduplicate="true">
            <member values="VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member optional="true"><type>VkExportMetalObjectTypeFlagBitsEXT</type>  <name>exportObjectType</name></member>
        </type>
        <type category="struct" name="VkExportMetalObjectsInfoEXT">
            <member values="VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
        </type>
        <type category="struct" name="VkExportMetalDeviceInfoEXT" structextends="VkExportMetalObjectsInfoEXT">
            <member values="VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member><type>MTLDevice_id</type>                               <name>mtlDevice</name></member>
        </type>
        <type category="struct" name="VkExportMetalCommandQueueInfoEXT" structextends="VkExportMetalObjectsInfoEXT" allowduplicate="true">
            <member values="VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member><type>VkQueue</type>                                    <name>queue</name></member>
            <member><type>MTLCommandQueue_id</type>                         <name>mtlCommandQueue</name></member>
        </type>
        <type category="struct" name="VkExportMetalBufferInfoEXT" structextends="VkExportMetalObjectsInfoEXT" allowduplicate="true">
            <member values="VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member><type>VkDeviceMemory</type>                             <name>memory</name></member>
            <member><type>MTLBuffer_id</type>                               <name>mtlBuffer</name></member>
        </type>
        <type category="struct" name="VkImportMetalBufferInfoEXT" structextends="VkMemoryAllocateInfo" allowduplicate="false">
            <member values="VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member><type>MTLBuffer_id</type>                               <name>mtlBuffer</name></member>
        </type>
        <type category="struct" name="VkExportMetalTextureInfoEXT" structextends="VkExportMetalObjectsInfoEXT" allowduplicate="true">
            <member values="VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member optional="true"><type>VkImage</type>                    <name>image</name></member>
            <member optional="true"><type>VkImageView</type>                <name>imageView</name></member>
            <member optional="true"><type>VkBufferView</type>               <name>bufferView</name></member>
            <member><type>VkImageAspectFlagBits</type>                      <name>plane</name></member>
            <member><type>MTLTexture_id</type>                              <name>mtlTexture</name></member>
        </type>
        <type category="struct" name="VkImportMetalTextureInfoEXT" structextends="VkImageCreateInfo" allowduplicate="true">
            <member values="VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member><type>VkImageAspectFlagBits</type>                      <name>plane</name></member>
            <member><type>MTLTexture_id</type>                              <name>mtlTexture</name></member>
        </type>
        <type category="struct" name="VkExportMetalIOSurfaceInfoEXT" structextends="VkExportMetalObjectsInfoEXT" allowduplicate="true">
            <member values="VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member><type>VkImage</type>                                    <name>image</name></member>
            <member><type>IOSurfaceRef</type>                               <name>ioSurface</name></member>
        </type>
        <type category="struct" name="VkImportMetalIOSurfaceInfoEXT" structextends="VkImageCreateInfo" allowduplicate="false">
            <member values="VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member optional="true"><type>IOSurfaceRef</type>               <name>ioSurface</name></member>
        </type>
        <type category="struct" name="VkExportMetalSharedEventInfoEXT" structextends="VkExportMetalObjectsInfoEXT" allowduplicate="true">
            <member values="VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member optional="true"><type>VkSemaphore</type>                <name>semaphore</name></member>
            <member optional="true"><type>VkEvent</type>                    <name>event</name></member>
            <member><type>MTLSharedEvent_id</type>                          <name>mtlSharedEvent</name></member>
        </type>
        <type category="struct" name="VkImportMetalSharedEventInfoEXT" structextends="VkSemaphoreCreateInfo,VkEventCreateInfo" allowduplicate="false">
            <member values="VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member><type>MTLSharedEvent_id</type>                          <name>mtlSharedEvent</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*                                                   <name>pNext</name></member>
            <member><type>VkBool32</type>                                                                                      <name>nonSeamlessCubeMap</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePipelineRobustnessFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true" optional="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                                       <name>pipelineRobustness</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePipelineRobustnessFeaturesEXT" alias="VkPhysicalDevicePipelineRobustnessFeatures"/>
        <type category="struct" name="VkPipelineRobustnessCreateInfo" structextends="VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkPipelineShaderStageCreateInfo,VkRayTracingPipelineCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true" optional="true">const <type>void</type>*      <name>pNext</name></member>
            <member><type>VkPipelineRobustnessBufferBehavior</type>      <name>storageBuffers</name></member>
            <member><type>VkPipelineRobustnessBufferBehavior</type>      <name>uniformBuffers</name></member>
            <member><type>VkPipelineRobustnessBufferBehavior</type>      <name>vertexInputs</name></member>
            <member><type>VkPipelineRobustnessImageBehavior</type>       <name>images</name></member>
        </type>
        <type category="struct" name="VkPipelineRobustnessCreateInfoEXT" alias="VkPipelineRobustnessCreateInfo"/>
        <type category="struct" name="VkPhysicalDevicePipelineRobustnessProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member limittype="exact"><type>VkPipelineRobustnessBufferBehavior</type>      <name>defaultRobustnessStorageBuffers</name></member>
            <member limittype="exact"><type>VkPipelineRobustnessBufferBehavior</type>      <name>defaultRobustnessUniformBuffers</name></member>
            <member limittype="exact"><type>VkPipelineRobustnessBufferBehavior</type>      <name>defaultRobustnessVertexInputs</name></member>
            <member limittype="exact"><type>VkPipelineRobustnessImageBehavior</type>       <name>defaultRobustnessImages</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePipelineRobustnessPropertiesEXT" alias="VkPhysicalDevicePipelineRobustnessProperties"/>
        <type category="struct" name="VkImageViewSampleWeightCreateInfoQCOM" structextends="VkImageViewCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*       <name>pNext</name></member>
            <member><type>VkOffset2D</type>                        <name>filterCenter</name></member>
            <member><type>VkExtent2D</type>                        <name>filterSize</name></member>
            <member><type>uint32_t</type>                          <name>numPhases</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImageProcessingFeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>textureSampleWeighted</name></member>
            <member><type>VkBool32</type>                           <name>textureBoxFilter</name></member>
            <member><type>VkBool32</type>                           <name>textureBlockMatch</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImageProcessingPropertiesQCOM" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="max" optional="true"><type>uint32_t</type>         <name>maxWeightFilterPhases</name></member>
            <member limittype="max" optional="true"><type>VkExtent2D</type>       <name>maxWeightFilterDimension</name></member>
            <member limittype="max" optional="true"><type>VkExtent2D</type>       <name>maxBlockMatchRegion</name></member>
            <member limittype="max" optional="true"><type>VkExtent2D</type>       <name>maxBoxFilterBlockSize</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceTilePropertiesFeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>tileProperties</name></member>
        </type>
        <type category="struct" name="VkTilePropertiesQCOM">
            <member values="VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkExtent3D</type>                       <name>tileSize</name></member>
            <member><type>VkExtent2D</type>                       <name>apronSize</name></member>
            <member><type>VkOffset2D</type>                       <name>origin</name></member>
        </type>
        <type category="struct" name="VkTileMemoryBindInfoQCOM" structextends="VkCommandBufferInheritanceInfo">
            <member values="VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceAmigoProfilingFeaturesSEC" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>amigoProfiling</name></member>
        </type>
        <type category="struct" name="VkAmigoProfilingSubmitInfoSEC" structextends="VkSubmitInfo">
            <member values="VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
            <member><type>uint64_t</type>                         <name>firstDrawTimestamp</name></member>
            <member><type>uint64_t</type>                         <name>swapBufferTimestamp</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>attachmentFeedbackLoopLayout</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDepthClampZeroOneFeaturesEXT" alias="VkPhysicalDeviceDepthClampZeroOneFeaturesKHR" />
        <type category="struct" name="VkAttachmentFeedbackLoopInfoEXT" structextends="VkRenderingAttachmentInfo">
            <member values="VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*   <name>pNext</name></member>
            <member><type>VkBool32</type>                      <name>feedbackLoopEnable</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceAddressBindingReportFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>reportAddressBinding</name></member>
        </type>
        <type category="struct" name="VkRenderingAttachmentFlagsInfoKHR" structextends="VkRenderingAttachmentInfo">
            <member values="VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_FLAGS_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*   <name>pNext</name></member>
            <member optional="true"><type>VkRenderingAttachmentFlagsKHR</type>   <name>flags</name></member>
        </type>
        <type category="struct" name="VkResolveImageModeInfoKHR" structextends="VkResolveImageInfo2">
            <member values="VK_STRUCTURE_TYPE_RESOLVE_IMAGE_MODE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*   <name>pNext</name></member>
            <member optional="true"><type>VkResolveImageFlagsKHR</type>   <name>flags</name></member>
            <member optional="true"><type>VkResolveModeFlagBits</type>   <name>resolveMode</name></member>
            <member optional="true"><type>VkResolveModeFlagBits</type>   <name>stencilResolveMode</name></member>
        </type>
        <type category="struct" name="VkDeviceAddressBindingCallbackDataEXT" structextends="VkDebugUtilsMessengerCallbackDataEXT">
            <member values="VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member optional="true"><type>VkDeviceAddressBindingFlagsEXT</type>     <name>flags</name></member>
            <member><type>VkDeviceAddress</type>                    <name>baseAddress</name></member>
            <member><type>VkDeviceSize</type>                       <name>size</name></member>
            <member><type>VkDeviceAddressBindingTypeEXT</type>      <name>bindingType</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceOpticalFlowFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>opticalFlow</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceOpticalFlowPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member limittype="bitmask"><type>VkOpticalFlowGridSizeFlagsNV</type> <name>supportedOutputGridSizes</name></member>
            <member limittype="bitmask"><type>VkOpticalFlowGridSizeFlagsNV</type> <name>supportedHintGridSizes</name></member>
            <member limittype="max"><type>VkBool32</type>     <name>hintSupported</name></member>
            <member limittype="max"><type>VkBool32</type>     <name>costSupported</name></member>
            <member limittype="max"><type>VkBool32</type>     <name>bidirectionalFlowSupported</name></member>
            <member limittype="max"><type>VkBool32</type>     <name>globalFlowSupported</name></member>
            <member limittype="noauto"><type>uint32_t</type>  <name>minWidth</name></member>
            <member limittype="noauto"><type>uint32_t</type>  <name>minHeight</name></member>
            <member limittype="noauto"><type>uint32_t</type>  <name>maxWidth</name></member>
            <member limittype="noauto"><type>uint32_t</type>  <name>maxHeight</name></member>
            <member limittype="noauto"><type>uint32_t</type>  <name>maxNumRegionsOfInterest</name></member>
        </type>
        <type category="struct" name="VkOpticalFlowImageFormatInfoNV" structextends="VkPhysicalDeviceImageFormatInfo2,VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*  <name>pNext</name></member>
            <member><type>VkOpticalFlowUsageFlagsNV</type> <name>usage</name></member>
        </type>
        <type category="struct" name="VkOpticalFlowImageFormatPropertiesNV" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*  <name>pNext</name></member>
            <member><type>VkFormat</type> <name>format</name></member>
        </type>
        <type category="struct" name="VkOpticalFlowSessionCreateInfoNV">
            <member values="VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                              <name>pNext</name></member>
            <member><type>uint32_t</type>                                                           <name>width</name></member>
            <member><type>uint32_t</type>                                                           <name>height</name></member>
            <member><type>VkFormat</type>                                                           <name>imageFormat</name></member>
            <member><type>VkFormat</type>                                                           <name>flowVectorFormat</name></member>
            <member optional="true"><type>VkFormat</type>                                           <name>costFormat</name></member>
            <member><type>VkOpticalFlowGridSizeFlagsNV</type>                                       <name>outputGridSize</name></member>
            <member optional="true"><type>VkOpticalFlowGridSizeFlagsNV</type>                       <name>hintGridSize</name></member>
            <member optional="true"><type>VkOpticalFlowPerformanceLevelNV</type>                    <name>performanceLevel</name></member>
            <member optional="true"><type>VkOpticalFlowSessionCreateFlagsNV</type>                  <name>flags</name></member>
        </type>
        <type category="struct" name="VkOpticalFlowSessionCreatePrivateDataInfoNV" structextends="VkOpticalFlowSessionCreateInfoNV"><comment>NV internal use only</comment>
            <member values="VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                              <name>pNext</name></member>
            <member><type>uint32_t</type>                                                           <name>id</name></member>
            <member><type>uint32_t</type>                                                           <name>size</name></member>
            <member>const <type>void</type>*                                                        <name>pPrivateData</name></member>
        </type>
        <type category="struct" name="VkOpticalFlowExecuteInfoNV">
            <member values="VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member optional="true"><type>VkOpticalFlowExecuteFlagsNV</type>        <name>flags</name></member>
            <member optional="true"><type>uint32_t</type>                           <name>regionCount</name></member>
            <member len="regionCount">const <type>VkRect2D</type>*                  <name>pRegions</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFaultFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>deviceFault</name></member>
            <member><type>VkBool32</type>                            <name>deviceFaultVendorBinary</name></member>
        </type>
        <type category="struct" name="VkDeviceFaultAddressInfoEXT">
            <member><type>VkDeviceFaultAddressTypeEXT</type>         <name>addressType</name></member>
            <member><type>VkDeviceAddress</type>                     <name>reportedAddress</name></member>
            <member><type>VkDeviceSize</type>                        <name>addressPrecision</name></member>
        </type>
        <type category="struct" name="VkDeviceFaultVendorInfoEXT">
            <member noautovalidity="true" len="null-terminated"><type>char</type> <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]<comment>Free-form description of the fault</comment></member>
            <member><type>uint64_t</type>                                         <name>vendorFaultCode</name></member>
            <member><type>uint64_t</type>                                         <name>vendorFaultData</name></member>
        </type>
        <type category="struct" name="VkDeviceFaultCountsEXT">
            <member values="VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*               <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                            <name>addressInfoCount</name></member>
            <member optional="true"><type>uint32_t</type>                            <name>vendorInfoCount</name></member>
            <member optional="true"><type>VkDeviceSize</type>                        <name>vendorBinarySize</name><comment>Specified in bytes</comment></member>
        </type>
        <type category="struct" name="VkDeviceFaultInfoEXT" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member noautovalidity="true" len="null-terminated"><type>char</type> <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]<comment>Free-form description of the fault</comment></member>
            <member optional="true"><type>VkDeviceFaultAddressInfoEXT</type>*     <name>pAddressInfos</name></member>
            <member optional="true"><type>VkDeviceFaultVendorInfoEXT</type>*      <name>pVendorInfos</name></member>
            <member optional="true"><type>void</type>*                            <name>pVendorBinaryData</name></member>
        </type>
        <type category="struct" name="VkDeviceFaultVendorBinaryHeaderVersionOneEXT">
            <comment>The fields in this structure are non-normative since structure packing is implementation-defined in C. The specification defines the normative layout.</comment>
            <member><type>uint32_t</type>               <name>headerSize</name></member>
            <member><type>VkDeviceFaultVendorBinaryHeaderVersionEXT</type> <name>headerVersion</name></member>
            <member><type>uint32_t</type>               <name>vendorID</name></member>
            <member><type>uint32_t</type>               <name>deviceID</name></member>
            <member><type>uint32_t</type>               <name>driverVersion</name></member>
            <member><type>uint8_t</type>                <name>pipelineCacheUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
            <member><type>uint32_t</type>               <name>applicationNameOffset</name></member>
            <member><type>uint32_t</type>               <name>applicationVersion</name></member>
            <member><type>uint32_t</type>               <name>engineNameOffset</name></member>
            <member><type>uint32_t</type>               <name>engineVersion</name></member>
            <member><type>uint32_t</type>               <name>apiVersion</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*                                                            <name>pNext</name></member>
            <member><type>VkBool32</type>                                                                                               <name>pipelineLibraryGroupHandles</name></member>
        </type>
        <type category="struct" name="VkDepthBiasInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
            <member><type>float</type>                              <name>depthBiasConstantFactor</name></member>
            <member><type>float</type>                              <name>depthBiasClamp</name></member>
            <member><type>float</type>                              <name>depthBiasSlopeFactor</name></member>
        </type>
        <type category="struct" name="VkDepthBiasRepresentationInfoEXT" structextends="VkDepthBiasInfoEXT,VkPipelineRasterizationStateCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
            <member><type>VkDepthBiasRepresentationEXT</type>       <name>depthBiasRepresentation</name></member>
            <member><type>VkBool32</type>                           <name>depthBiasExact</name></member>
        </type>
        <type category="struct" name="VkDecompressMemoryRegionNV">
            <member><type>VkDeviceAddress</type>   <name>srcAddress</name></member>
            <member><type>VkDeviceAddress</type>   <name>dstAddress</name></member>
            <member><type>VkDeviceSize</type>      <name>compressedSize</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>      <name>decompressedSize</name><comment>Specified in bytes</comment></member>
            <member><type>VkMemoryDecompressionMethodFlagsNV</type> <name>decompressionMethod</name></member>
        </type>
        <type category="struct" name="VkDecompressMemoryRegionEXT">
            <member><type>VkDeviceAddress</type>   <name>srcAddress</name></member>
            <member><type>VkDeviceAddress</type>   <name>dstAddress</name></member>
            <member><type>VkDeviceSize</type>      <name>compressedSize</name><comment>Specified in bytes</comment></member>
            <member><type>VkDeviceSize</type>      <name>decompressedSize</name><comment>Specified in bytes</comment></member>
        </type>
        <type category="struct" name="VkDecompressMemoryInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DECOMPRESS_MEMORY_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*         <name>pNext</name></member>
            <member><type>VkMemoryDecompressionMethodFlagsEXT</type> <name>decompressionMethod</name></member>
            <member><type>uint32_t</type>                            <name>regionCount</name></member>
            <member len="regionCount">const <type>VkDecompressMemoryRegionEXT</type>* <name>pRegions</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member limittype="bitmask"><type>uint64_t</type>                   <name>shaderCoreMask</name></member>
            <member limittype="max"><type>uint32_t</type>                       <name>shaderCoreCount</name></member>
            <member limittype="max"><type>uint32_t</type>                       <name>shaderWarpsPerCore</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                 <name>shaderCoreBuiltins</name></member>
        </type>
        <type category="struct" name="VkFrameBoundaryEXT" structextends="VkSubmitInfo,VkSubmitInfo2,VkPresentInfoKHR,VkBindSparseInfo">
            <member values="VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
            <member optional="true"><type>VkFrameBoundaryFlagsEXT</type>            <name>flags</name></member>
            <member><type>uint64_t</type>                                           <name>frameID</name></member>
            <member optional="true"><type>uint32_t</type>                           <name>imageCount</name></member>
            <member optional="true" len="imageCount">const <type>VkImage</type>*    <name>pImages</name></member>
            <member optional="true"><type>uint32_t</type>                           <name>bufferCount</name></member>
            <member optional="true" len="bufferCount">const <type>VkBuffer</type>*  <name>pBuffers</name></member>
            <member optional="true"><type>uint64_t</type>                           <name>tagName</name></member>
            <member optional="true"><type>size_t</type>                             <name>tagSize</name></member>
            <member optional="true" len="tagSize">const <type>void</type>*          <name>pTag</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFrameBoundaryFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                 <name>frameBoundary</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                 <name>dynamicRenderingUnusedAttachments</name></member>
        </type>
        <type category="struct" name="VkSurfacePresentModeKHR" structextends="VkPhysicalDeviceSurfaceInfo2KHR">
            <member values="VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*               <name>pNext</name></member>
            <member><type>VkPresentModeKHR</type>                    <name>presentMode</name></member>
        </type>
        <type category="struct" name="VkSurfacePresentModeEXT" alias="VkSurfacePresentModeKHR"/>
        <type category="struct" name="VkSurfacePresentScalingCapabilitiesKHR" structextends="VkSurfaceCapabilities2KHR">
            <member values="VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                    <name>pNext</name></member>
            <member optional="true"><type>VkPresentScalingFlagsKHR</type> <name>supportedPresentScaling</name></member>
            <member optional="true"><type>VkPresentGravityFlagsKHR</type> <name>supportedPresentGravityX</name></member>
            <member optional="true"><type>VkPresentGravityFlagsKHR</type> <name>supportedPresentGravityY</name></member>
            <member optional="true"><type>VkExtent2D</type>               <name>minScaledImageExtent</name><comment>Supported minimum image width and height for the surface when scaling is used</comment></member>
            <member optional="true"><type>VkExtent2D</type>               <name>maxScaledImageExtent</name><comment>Supported maximum image width and height for the surface when scaling is used</comment></member>
        </type>
        <type category="struct" name="VkSurfacePresentScalingCapabilitiesEXT" alias="VkSurfacePresentScalingCapabilitiesKHR"/>
        <type category="struct" name="VkSurfacePresentModeCompatibilityKHR" structextends="VkSurfaceCapabilities2KHR">
            <member values="VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                    <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                                 <name>presentModeCount</name></member>
            <member optional="true" len="presentModeCount"><type>VkPresentModeKHR</type>* <name>pPresentModes</name><comment>Output list of present modes compatible with the one specified in VkSurfacePresentModeKHR</comment></member>
        </type>
        <type category="struct" name="VkSurfacePresentModeCompatibilityEXT" alias="VkSurfacePresentModeCompatibilityKHR"/>
        <type category="struct" name="VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>swapchainMaintenance1</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT" alias="VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR"/>
        <type category="struct" name="VkSwapchainPresentFenceInfoKHR" structextends="VkPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*         <name>pNext</name></member>
            <member><type>uint32_t</type>                            <name>swapchainCount</name><comment>Copy of VkPresentInfoKHR::swapchainCount</comment></member>
            <member len="swapchainCount" optional="false,true">const <type>VkFence</type>* <name>pFences</name><comment>Fence to signal for each swapchain</comment></member>
        </type>
        <type category="struct" name="VkSwapchainPresentFenceInfoEXT" alias="VkSwapchainPresentFenceInfoKHR"/>
        <type category="struct" name="VkSwapchainPresentModesCreateInfoKHR" structextends="VkSwapchainCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*         <name>pNext</name></member>
            <member><type>uint32_t</type>                            <name>presentModeCount</name></member><comment>Length of the pPresentModes array</comment>
            <member len="presentModeCount">const <type>VkPresentModeKHR</type>* <name>pPresentModes</name></member><comment>Presentation modes which will be usable with this swapchain</comment>
        </type>
        <type category="struct" name="VkSwapchainPresentModesCreateInfoEXT" alias="VkSwapchainPresentModesCreateInfoKHR"/>
        <type category="struct" name="VkSwapchainPresentModeInfoKHR" structextends="VkPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*         <name>pNext</name></member>
            <member><type>uint32_t</type>                            <name>swapchainCount</name><comment>Copy of VkPresentInfoKHR::swapchainCount</comment></member>
            <member len="swapchainCount">const <type>VkPresentModeKHR</type>* <name>pPresentModes</name><comment>Presentation mode for each swapchain</comment></member>
        </type>
        <type category="struct" name="VkSwapchainPresentModeInfoEXT" alias="VkSwapchainPresentModeInfoKHR"/>
        <type category="struct" name="VkSwapchainPresentScalingCreateInfoKHR" structextends="VkSwapchainCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                 <name>pNext</name></member>
            <member optional="true"><type>VkPresentScalingFlagsKHR</type>    <name>scalingBehavior</name></member>
            <member optional="true"><type>VkPresentGravityFlagsKHR</type>    <name>presentGravityX</name></member>
            <member optional="true"><type>VkPresentGravityFlagsKHR</type>    <name>presentGravityY</name></member>
        </type>
        <type category="struct" name="VkSwapchainPresentScalingCreateInfoEXT" alias="VkSwapchainPresentScalingCreateInfoKHR"/>
        <type category="struct" name="VkReleaseSwapchainImagesInfoKHR">
            <member values="VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                 <name>pNext</name></member>
            <member externsync="true"><type>VkSwapchainKHR</type>            <name>swapchain</name><comment>Swapchain for which images are being released</comment></member>
            <member><type>uint32_t</type>                                    <name>imageIndexCount</name><comment>Number of indices to release</comment></member>
            <member len="imageIndexCount">const <type>uint32_t</type>*       <name>pImageIndices</name><comment>Indices of which presentable images to release</comment></member>
        </type>
        <type category="struct" name="VkReleaseSwapchainImagesInfoEXT" alias="VkReleaseSwapchainImagesInfoKHR"/>
        <type category="struct" name="VkPhysicalDeviceDepthBiasControlFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>depthBiasControl</name></member>
            <member><type>VkBool32</type>                           <name>leastRepresentableValueForceUnormRepresentation</name></member>
            <member><type>VkBool32</type>                           <name>floatRepresentation</name></member>
            <member><type>VkBool32</type>                           <name>depthBiasExact</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*                                                      <name>pNext</name></member>
            <member><type>VkBool32</type>                                                                                         <name>rayTracingInvocationReorder</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*                                                      <name>pNext</name></member>
            <member featurelink="rayTracingInvocationReorderNV"><type>VkBool32</type>                                             <name>rayTracingInvocationReorder</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
            <member limittype="noauto"><type>VkRayTracingInvocationReorderModeEXT</type>   <name>rayTracingInvocationReorderReorderingHint</name></member>
            <member limittype="min"><type>uint32_t</type>                                  <name>maxShaderBindingTableRecordIndex</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
            <member limittype="noauto"><type>VkRayTracingInvocationReorderModeEXT</type>                                    <name>rayTracingInvocationReorderReorderingHint</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*  <name>pNext</name></member>
            <member><type>VkBool32</type>                                     <name>extendedSparseAddressSpace</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                        <name>pNext</name></member>
            <member limittype="max"><type>VkDeviceSize</type>                 <name>extendedSparseAddressSpaceSize</name><comment>Total address space available for extended sparse allocations (bytes)</comment></member>
            <member limittype="bitmask"><type>VkImageUsageFlags</type>        <name>extendedSparseImageUsageFlags</name><comment>Bitfield of which image usages are supported for extended sparse allocations</comment></member>
            <member limittype="bitmask"><type>VkBufferUsageFlags</type>       <name>extendedSparseBufferUsageFlags</name><comment>Bitfield of which buffer usages are supported for extended sparse allocations</comment></member>
        </type>
        <type category="struct" name="VkDirectDriverLoadingInfoLUNARG">
            <member values="VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*                                  <name>pNext</name></member>
            <member><type>VkDirectDriverLoadingFlagsLUNARG</type>                                             <name>flags</name></member>
            <member noautovalidity="true"><type>PFN_vkGetInstanceProcAddrLUNARG</type>                        <name>pfnGetInstanceProcAddr</name></member>
        </type>
        <type category="struct" name="VkDirectDriverLoadingListLUNARG" structextends="VkInstanceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true">const <type>void</type>*           <name>pNext</name></member>
            <member><type>VkDirectDriverLoadingModeLUNARG</type>                             <name>mode</name></member>
            <member><type>uint32_t</type>                                                    <name>driverCount</name></member>
            <member len="driverCount">const <type>VkDirectDriverLoadingInfoLUNARG</type>*    <name>pDrivers</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>multiviewPerViewViewports</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                     <name>rayTracingPositionFetch</name></member>
        </type>
        <type category="struct" name="VkDeviceImageSubresourceInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                              <name>pNext</name></member>
            <member>const <type>VkImageCreateInfo</type>*                                                 <name>pCreateInfo</name></member>
            <member>const <type>VkImageSubresource2</type>*                                               <name>pSubresource</name></member>
        </type>
        <type category="struct" name="VkDeviceImageSubresourceInfoKHR" alias="VkDeviceImageSubresourceInfo"/>
        <type category="struct" name="VkPhysicalDeviceShaderCorePropertiesARM" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member limittype="exact"><type>uint32_t</type>         <name>pixelRate</name></member>
            <member limittype="exact"><type>uint32_t</type>         <name>texelRate</name></member>
            <member limittype="exact"><type>uint32_t</type>         <name>fmaRate</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>multiviewPerViewRenderAreas</name></member>
        </type>
        <type category="struct" name="VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM" structextends="VkRenderPassBeginInfo,VkRenderingInfo">
            <member values="VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>         <name>perViewRenderAreaCount</name></member>
            <member len="perViewRenderAreaCount">const <type>VkRect2D</type>*  <name>pPerViewRenderAreas</name></member>
        </type>
        <type category="struct" name="VkQueryLowLatencySupportNV" structextends="VkSemaphoreCreateInfo">
            <member values="VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>void</type>*                                       <name>pQueriedLowLatencyData</name></member>
        </type>
        <type category="struct" name="VkMemoryMapInfo">
            <member values="VK_STRUCTURE_TYPE_MEMORY_MAP_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
            <member optional="true"><type>VkMemoryMapFlags</type> <name>flags</name></member>
            <member externsync="true"><type>VkDeviceMemory</type> <name>memory</name></member>
            <member><type>VkDeviceSize</type>                     <name>offset</name></member>
            <member><type>VkDeviceSize</type>                     <name>size</name></member>
        </type>
        <type category="struct" name="VkMemoryMapInfoKHR" alias="VkMemoryMapInfo"/>
        <type category="struct" name="VkMemoryUnmapInfo">
            <member values="VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkMemoryUnmapFlags</type>  <name>flags</name></member>
            <member externsync="true"><type>VkDeviceMemory</type>       <name>memory</name></member>
        </type>
        <type category="struct" name="VkMemoryUnmapInfoKHR" alias="VkMemoryUnmapInfo"/>
        <type category="struct" name="VkPhysicalDeviceShaderObjectFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*                                           <name>pNext</name></member>
            <member><type>VkBool32</type>                                                                              <name>shaderObject</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderObjectPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*                                             <name>pNext</name></member>
            <member limittype="noauto"><type>uint8_t</type>                                                              <name>shaderBinaryUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
            <member limittype="noauto"><type>uint32_t</type>                                                             <name>shaderBinaryVersion</name></member>
        </type>
        <type category="struct" name="VkShaderCreateInfoEXT">
            <member values="VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT"><type>VkStructureType</type>       <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                             <name>pNext</name></member>
            <member optional="true"><type>VkShaderCreateFlagsEXT</type>                                  <name>flags</name></member>
            <member><type>VkShaderStageFlagBits</type>                                                   <name>stage</name></member>
            <member optional="true"><type>VkShaderStageFlags</type>                                      <name>nextStage</name></member>
            <member><type>VkShaderCodeTypeEXT</type>                                                     <name>codeType</name></member>
            <member><type>size_t</type>                                                                  <name>codeSize</name></member>
            <member len="codeSize">const <type>void</type>*                                              <name>pCode</name></member>
            <member optional="true" len="null-terminated">const <type>char</type>*                       <name>pName</name></member>
            <member optional="true"><type>uint32_t</type>                                                <name>setLayoutCount</name></member>
            <member optional="true" len="setLayoutCount">const <type>VkDescriptorSetLayout</type>*       <name>pSetLayouts</name></member>
            <member optional="true"><type>uint32_t</type>                                                <name>pushConstantRangeCount</name></member>
            <member optional="true" len="pushConstantRangeCount">const <type>VkPushConstantRange</type>* <name>pPushConstantRanges</name></member>
            <member optional="true">const <type>VkSpecializationInfo</type>*                             <name>pSpecializationInfo</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderTileImageFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>shaderTileImageColorReadAccess</name></member>
            <member><type>VkBool32</type>                           <name>shaderTileImageDepthReadAccess</name></member>
            <member><type>VkBool32</type>                           <name>shaderTileImageStencilReadAccess</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderTileImagePropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>           <name>shaderTileImageCoherentReadAccelerated</name></member>
            <member limittype="max"><type>VkBool32</type>           <name>shaderTileImageReadSampleFromPixelRateInvocation</name></member>
            <member limittype="max"><type>VkBool32</type>           <name>shaderTileImageReadFromHelperInvocation</name></member>
        </type>
        <type category="struct" name="VkImportScreenBufferInfoQNX" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
            <member noautovalidity="true">struct <type>_screen_buffer</type>*       <name>buffer</name></member>
        </type>
        <type category="struct" name="VkScreenBufferPropertiesQNX" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member><type>VkDeviceSize</type>                       <name>allocationSize</name></member>
            <member><type>uint32_t</type>                           <name>memoryTypeBits</name></member>
        </type>
        <type category="struct" name="VkScreenBufferFormatPropertiesQNX" structextends="VkScreenBufferPropertiesQNX" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member><type>VkFormat</type>                           <name>format</name></member>
            <member><type>uint64_t</type>                           <name>externalFormat</name></member>
            <member><type>uint64_t</type>                           <name>screenUsage</name></member>
            <member><type>VkFormatFeatureFlags</type>               <name>formatFeatures</name></member>
            <member><type>VkComponentMapping</type>                 <name>samplerYcbcrConversionComponents</name></member>
            <member><type>VkSamplerYcbcrModelConversion</type>      <name>suggestedYcbcrModel</name></member>
            <member><type>VkSamplerYcbcrRange</type>                <name>suggestedYcbcrRange</name></member>
            <member><type>VkChromaLocation</type>                   <name>suggestedXChromaOffset</name></member>
            <member><type>VkChromaLocation</type>                   <name>suggestedYChromaOffset</name></member>
        </type>
        <type category="struct" name="VkExternalFormatQNX" structextends="VkImageCreateInfo,VkSamplerYcbcrConversionCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member><type>uint64_t</type>                           <name>externalFormat</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                       <name>pNext</name></member>
            <member><type>VkBool32</type>                                    <name>screenBufferImport</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCooperativeMatrixFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>cooperativeMatrix</name></member>
            <member><type>VkBool32</type>                            <name>cooperativeMatrixRobustBufferAccess</name></member>
        </type>
        <type category="struct" name="VkCooperativeMatrixPropertiesKHR" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member><type>uint32_t</type>                            <name>MSize</name></member>
            <member><type>uint32_t</type>                            <name>NSize</name></member>
            <member><type>uint32_t</type>                            <name>KSize</name></member>
            <member><type>VkComponentTypeKHR</type>                  <name>AType</name></member>
            <member><type>VkComponentTypeKHR</type>                  <name>BType</name></member>
            <member><type>VkComponentTypeKHR</type>                  <name>CType</name></member>
            <member><type>VkComponentTypeKHR</type>                  <name>ResultType</name></member>
            <member><type>VkBool32</type>                            <name>saturatingAccumulation</name></member>
            <member><type>VkScopeKHR</type>                          <name>scope</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCooperativeMatrixPropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member limittype="bitmask"><type>VkShaderStageFlags</type>              <name>cooperativeMatrixSupportedStages</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderEnqueuePropertiesAMDX" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true"  optional="true"><type>void</type>*               <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>                                   <name>maxExecutionGraphDepth</name></member>
            <member limittype="max"><type>uint32_t</type>                                   <name>maxExecutionGraphShaderOutputNodes</name></member>
            <member limittype="max"><type>uint32_t</type>                                   <name>maxExecutionGraphShaderPayloadSize</name></member>
            <member limittype="max"><type>uint32_t</type>                                   <name>maxExecutionGraphShaderPayloadCount</name></member>
            <member limittype="noauto"><type>uint32_t</type>                                <name>executionGraphDispatchAddressAlignment</name></member>
            <member limittype="max"><type>uint32_t</type>                                   <name>maxExecutionGraphWorkgroupCount</name>[3]</member>
            <member limittype="max"><type>uint32_t</type>                                   <name>maxExecutionGraphWorkgroups</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderEnqueueFeaturesAMDX" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true" optional="true"><type>void</type>*                <name>pNext</name></member>
            <member><type>VkBool32</type>                                                   <name>shaderEnqueue</name></member>
            <member><type>VkBool32</type>                                                   <name>shaderMeshEnqueue</name></member>
        </type>
        <type category="struct" name="VkExecutionGraphPipelineCreateInfoAMDX">
            <member values="VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                <name>pNext</name></member>
            <member noautovalidity="true" optional="true"><type>VkPipelineCreateFlags</type>                      <name>flags</name></member>
            <member optional="true"><type>uint32_t</type>                                   <name>stageCount</name></member>
            <member optional="true" len="stageCount">const <type>VkPipelineShaderStageCreateInfo</type>*    <name>pStages</name></member>
            <member optional="true">const <type>VkPipelineLibraryCreateInfoKHR</type>*      <name>pLibraryInfo</name></member>
            <member><type>VkPipelineLayout</type>                                           <name>layout</name></member>
            <member noautovalidity="true" optional="true"><type>VkPipeline</type>           <name>basePipelineHandle</name></member>
            <member><type>int32_t</type>                                                    <name>basePipelineIndex</name></member>
        </type>
        <type category="struct" name="VkPipelineShaderStageNodeCreateInfoAMDX" structextends="VkPipelineShaderStageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX">  <type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                <name>pNext</name></member>
            <member optional="true" len="null-terminated">const <type>char</type>*          <name>pName</name></member>
            <member><type>uint32_t</type>                                                   <name>index</name></member>
        </type>
        <type category="struct" name="VkExecutionGraphPipelineScratchSizeAMDX">
            <member values="VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true" optional="true"><type>void</type>*                <name>pNext</name></member>
            <member><type>VkDeviceSize</type>                                               <name>minSize</name></member>
            <member><type>VkDeviceSize</type>                                               <name>maxSize</name></member>
            <member><type>VkDeviceSize</type>                                               <name>sizeGranularity</name></member>
        </type>
        <type category="struct" name="VkDispatchGraphInfoAMDX">
            <member><type>uint32_t</type>                                                   <name>nodeIndex</name></member>
            <member optional="true"><type>uint32_t</type>                                   <name>payloadCount</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstAMDX</type>           <name>payloads</name></member>
            <member><type>uint64_t</type>                                                   <name>payloadStride</name></member>
        </type>
        <type category="struct" name="VkDispatchGraphCountInfoAMDX">
            <member optional="true"><type>uint32_t</type>                                   <name>count</name></member>
            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstAMDX</type>                  <name>infos</name></member>
            <member><type>uint64_t</type>                                                   <name>stride</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceAntiLagFeaturesAMD" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true" optional="true"><type>void</type>*                <name>pNext</name></member>
            <member><type>VkBool32</type>                                                   <name>antiLag</name></member>
        </type>
        <type category="struct" name="VkAntiLagDataAMD">
            <member values="VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true" optional="true">const <type>void</type>*          <name>pNext</name></member>
            <member><type>VkAntiLagModeAMD</type>                                           <name>mode</name></member>
            <member><type>uint32_t</type>                                                   <name>maxFPS</name></member>
            <member optional="true">const <type>VkAntiLagPresentationInfoAMD</type>*        <name>pPresentationInfo</name></member>
        </type>
        <type category="struct" name="VkAntiLagPresentationInfoAMD">
            <member values="VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true" optional="true"><type>void</type>*                <name>pNext</name></member>
            <member><type>VkAntiLagStageAMD</type>                                          <name>stage</name></member>
            <member><type>uint64_t</type>                                                   <name>frameIndex</name></member>
        </type>
        <type category="struct" name="VkBindMemoryStatus" structextends="VkBindBufferMemoryInfo,VkBindImageMemoryInfo">
            <member values="VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                <name>pNext</name></member>
            <member><type>VkResult</type>*                                                  <name>pResult</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceTileMemoryHeapFeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true" optional="true"><type>void</type>*                <name>pNext</name></member>
            <member><type>VkBool32</type>                                                   <name>tileMemoryHeap</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceTileMemoryHeapPropertiesQCOM" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true" optional="true"><type>void</type>*                <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type>                                   <name>queueSubmitBoundary</name></member>
            <member limittype="max"><type>VkBool32</type>                                   <name>tileBufferTransfers</name></member>
        </type>
        <type category="struct" name="VkTileMemorySizeInfoQCOM" structextends="VkRenderPassCreateInfo,VkRenderPassCreateInfo2,VkRenderingInfo">
            <member values="VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member noautovalidity="true" optional="true">const <type>void</type>*          <name>pNext</name></member>
            <member><type>VkDeviceSize</type>                                               <name>size</name></member>
        </type>
        <type category="struct" name="VkTileMemoryRequirementsQCOM" structextends="VkMemoryRequirements2">
            <member values="VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                      <name>pNext</name></member>
            <member><type>VkDeviceSize</type>                                               <name>size</name></member>
            <member><type>VkDeviceSize</type>                                               <name>alignment</name></member>
        </type>
        <type category="struct" name="VkBindMemoryStatusKHR" alias="VkBindMemoryStatus"/>
        <type category="struct" name="VkBindDescriptorSetsInfo">
            <member values="VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
            <member><type>VkShaderStageFlags</type>                                             <name>stageFlags</name></member>
            <member optional="true"><type>VkPipelineLayout</type>                               <name>layout</name></member>
            <member optional="true"><type>uint32_t</type>                                       <name>firstSet</name></member>
            <member><type>uint32_t</type>                                                       <name>descriptorSetCount</name></member>
            <member len="descriptorSetCount">const <type>VkDescriptorSet</type>*                <name>pDescriptorSets</name></member>
            <member optional="true"><type>uint32_t</type>                                       <name>dynamicOffsetCount</name></member>
            <member optional="true,true" len="dynamicOffsetCount">const <type>uint32_t</type>*  <name>pDynamicOffsets</name></member>
        </type>
        <type category="struct" name="VkBindDescriptorSetsInfoKHR" alias="VkBindDescriptorSetsInfo"/>
        <type category="struct" name="VkPushConstantsInfo">
            <member values="VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
            <member optional="true"><type>VkPipelineLayout</type>                               <name>layout</name></member>
            <member><type>VkShaderStageFlags</type>                                             <name>stageFlags</name></member>
            <member optional="true"><type>uint32_t</type>                                       <name>offset</name></member>
            <member><type>uint32_t</type>                                                       <name>size</name></member>
            <member len="size">const <type>void</type>*                                         <name>pValues</name></member>
        </type>
        <type category="struct" name="VkPushConstantsInfoKHR" alias="VkPushConstantsInfo"/>
        <type category="struct" name="VkPushDescriptorSetInfo">
            <member values="VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
            <member><type>VkShaderStageFlags</type>                                             <name>stageFlags</name></member>
            <member optional="true"><type>VkPipelineLayout</type>                               <name>layout</name></member>
            <member optional="true"><type>uint32_t</type>                                       <name>set</name></member>
            <member><type>uint32_t</type>                                                       <name>descriptorWriteCount</name></member>
            <member len="descriptorWriteCount">const <type>VkWriteDescriptorSet</type>*         <name>pDescriptorWrites</name></member>
        </type>
        <type category="struct" name="VkPushDescriptorSetInfoKHR" alias="VkPushDescriptorSetInfo"/>
        <type category="struct" name="VkPushDescriptorSetWithTemplateInfo">
            <member values="VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
            <member><type>VkDescriptorUpdateTemplate</type>                                     <name>descriptorUpdateTemplate</name></member>
            <member optional="true"><type>VkPipelineLayout</type>                               <name>layout</name></member>
            <member optional="true"><type>uint32_t</type>                                       <name>set</name></member>
            <member>const <type>void</type>*                                                    <name>pData</name></member>
        </type>
        <type category="struct" name="VkPushDescriptorSetWithTemplateInfoKHR" alias="VkPushDescriptorSetWithTemplateInfo"/>
        <type category="struct" name="VkSetDescriptorBufferOffsetsInfoEXT">
            <member values="VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
            <member><type>VkShaderStageFlags</type>                                             <name>stageFlags</name></member>
            <member optional="true"><type>VkPipelineLayout</type>                               <name>layout</name></member>
            <member optional="true"><type>uint32_t</type>                                       <name>firstSet</name></member>
            <member><type>uint32_t</type>                                                       <name>setCount</name></member>
            <member len="setCount">const <type>uint32_t</type>*                                 <name>pBufferIndices</name></member>
            <member len="setCount">const <type>VkDeviceSize</type>*                             <name>pOffsets</name></member>
        </type>
        <type category="struct" name="VkBindDescriptorBufferEmbeddedSamplersInfoEXT">
            <member values="VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
            <member><type>VkShaderStageFlags</type>                                             <name>stageFlags</name></member>
            <member optional="true"><type>VkPipelineLayout</type>                               <name>layout</name></member>
            <member optional="true"><type>uint32_t</type>                                       <name>set</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCubicClampFeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>cubicRangeClamp</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceYcbcrDegammaFeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                     <name>ycbcrDegamma</name></member>
        </type>
        <type category="struct" name="VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM" structextends="VkSamplerYcbcrConversionCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>enableYDegamma</name></member>
            <member><type>VkBool32</type>                           <name>enableCbCrDegamma</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCubicWeightsFeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>selectableCubicWeights</name></member>
        </type>
        <type category="struct" name="VkSamplerCubicWeightsCreateInfoQCOM" structextends="VkSamplerCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
            <member><type>VkCubicFilterWeightsQCOM</type>         <name>cubicWeights</name></member>
        </type>
        <type category="struct" name="VkBlitImageCubicWeightsInfoQCOM" structextends="VkBlitImageInfo2">
            <member values="VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
            <member><type>VkCubicFilterWeightsQCOM</type>         <name>cubicWeights</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImageProcessing2FeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*   <name>pNext</name></member>
            <member><type>VkBool32</type>                                      <name>textureBlockMatch2</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImageProcessing2PropertiesQCOM" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                        <name>pNext</name></member>
            <member limittype="max" optional="true"><type>VkExtent2D</type>  <name>maxBlockMatchWindow</name></member>
        </type>
        <type category="struct" name="VkSamplerBlockMatchWindowCreateInfoQCOM" structextends="VkSamplerCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                  <name>pNext</name></member>
            <member><type>VkExtent2D</type>                                   <name>windowExtent</name></member>
            <member><type>VkBlockMatchWindowCompareModeQCOM</type>            <name>windowCompareMode</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>descriptorPoolOverallocation</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceLayeredDriverPropertiesMSFT" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member limittype="exact"><type>VkLayeredDriverUnderlyingApiMSFT</type> <name>underlyingAPI</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePerStageDescriptorSetFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type>                                    <name>perStageDescriptorSet</name></member>
            <member><type>VkBool32</type>                                    <name>dynamicPipelineLayout</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalFormatResolveFeaturesANDROID" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                <name>pNext</name></member>
            <member><type>VkBool32</type>                             <name>externalFormatResolve</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalFormatResolvePropertiesANDROID" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                <name>pNext</name></member>
            <member limittype="min"><type>VkBool32</type>             <name>nullColorAttachmentWithExternalFormatResolve</name></member>
            <member limittype="noauto"><type>VkChromaLocation</type>  <name>externalFormatResolveChromaOffsetX</name></member>
            <member limittype="noauto"><type>VkChromaLocation</type>  <name>externalFormatResolveChromaOffsetY</name></member>
        </type>
        <type category="struct" name="VkAndroidHardwareBufferFormatResolvePropertiesANDROID" structextends="VkAndroidHardwareBufferPropertiesANDROID" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkFormat</type>                     <name>colorAttachmentFormat</name></member>
        </type>
        <type category="struct" name="VkLatencySleepModeInfoNV">
            <member values="VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type> <name>lowLatencyMode</name></member>
            <member><type>VkBool32</type> <name>lowLatencyBoost</name></member>
            <member><type>uint32_t</type> <name>minimumIntervalUs</name></member>
        </type>
        <type category="struct" name="VkLatencySleepInfoNV">
            <member values="VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkSemaphore</type> <name>signalSemaphore</name></member>
            <member><type>uint64_t</type> <name>value</name></member>
        </type>
        <type category="struct" name="VkSetLatencyMarkerInfoNV">
            <member values="VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint64_t</type> <name>presentID</name></member>
            <member><type>VkLatencyMarkerNV</type> <name>marker</name></member>
        </type>
        <type category="struct" name="VkGetLatencyMarkerInfoNV">
            <member values="VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type> <name>timingCount</name></member>
            <member optional="true" len="timingCount"><type>VkLatencyTimingsFrameReportNV</type>* <name>pTimings</name></member>
        </type>
        <type category="struct" name="VkLatencyTimingsFrameReportNV" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
            <member><type>uint64_t</type>               <name>presentID</name></member>
            <member><type>uint64_t</type>               <name>inputSampleTimeUs</name></member>
            <member><type>uint64_t</type>               <name>simStartTimeUs</name></member>
            <member><type>uint64_t</type>               <name>simEndTimeUs</name></member>
            <member><type>uint64_t</type>               <name>renderSubmitStartTimeUs</name></member>
            <member><type>uint64_t</type>               <name>renderSubmitEndTimeUs</name></member>
            <member><type>uint64_t</type>               <name>presentStartTimeUs</name></member>
            <member><type>uint64_t</type>               <name>presentEndTimeUs</name></member>
            <member><type>uint64_t</type>               <name>driverStartTimeUs</name></member>
            <member><type>uint64_t</type>               <name>driverEndTimeUs</name></member>
            <member><type>uint64_t</type>               <name>osRenderQueueStartTimeUs</name></member>
            <member><type>uint64_t</type>               <name>osRenderQueueEndTimeUs</name></member>
            <member><type>uint64_t</type>               <name>gpuRenderStartTimeUs</name></member>
            <member><type>uint64_t</type>               <name>gpuRenderEndTimeUs</name></member>
        </type>
        <type category="struct" name="VkOutOfBandQueueTypeInfoNV">
            <member values="VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkOutOfBandQueueTypeNV</type> <name>queueType</name></member>
        </type>
        <type category="struct" name="VkLatencySubmissionPresentIdNV" structextends="VkSubmitInfo,VkSubmitInfo2">
            <member values="VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
            <member><type>uint64_t</type>                         <name>presentID</name></member>
        </type>
        <type category="struct" name="VkSwapchainLatencyCreateInfoNV" structextends="VkSwapchainCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
            <member optional="true"><type>VkBool32</type>                           <name>latencyModeEnable</name></member>
        </type>
        <type category="struct" name="VkLatencySurfaceCapabilitiesNV" structextends="VkSurfaceCapabilities2KHR">
            <member values="VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                              <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                                 <name>presentModeCount</name></member>
            <member optional="true" len="presentModeCount"><type>VkPresentModeKHR</type>* <name>pPresentModes</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCudaKernelLaunchFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                       <name>cudaKernelLaunchFeatures</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCudaKernelLaunchPropertiesNV" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>         <name>computeCapabilityMinor</name></member>
            <member limittype="min"><type>uint32_t</type>         <name>computeCapabilityMajor</name></member>
        </type>
        <type category="struct" name="VkDeviceQueueShaderCoreControlCreateInfoARM" structextends="VkDeviceQueueCreateInfo,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>shaderCoreCount</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSchedulingControlsFeaturesARM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>schedulingControls</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceSchedulingControlsPropertiesARM" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                              <name>pNext</name></member>
            <member limittype="bitmask"><type>VkPhysicalDeviceSchedulingControlsFlagsARM</type>     <name>schedulingControlsFlags</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member><type>VkBool32</type>                                       <name>relaxedLineRasterization</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRenderPassStripedFeaturesARM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                                       <name>renderPassStriped</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRenderPassStripedPropertiesARM" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
            <member limittype="max,mul"><type>VkExtent2D</type>                 <name>renderPassStripeGranularity</name></member>
            <member limittype="max"><type>uint32_t</type>                       <name>maxRenderPassStripes</name></member>
        </type>
        <type category="struct" name="VkRenderPassStripeInfoARM">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkRect2D</type>                                       <name>stripeArea</name></member>
        </type>
        <type category="struct" name="VkRenderPassStripeBeginInfoARM" structextends="VkRenderingInfo,VkRenderPassBeginInfo">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
            <member><type>uint32_t</type>                                               <name>stripeInfoCount</name></member>
            <member len="stripeInfoCount">const <type>VkRenderPassStripeInfoARM</type>* <name>pStripeInfos</name></member>
        </type>
        <type category="struct" name="VkRenderPassStripeSubmitInfoARM" structextends="VkCommandBufferSubmitInfo">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                 <name>pNext</name></member>
            <member><type>uint32_t</type>                                                    <name>stripeSemaphoreInfoCount</name></member>
            <member len="stripeSemaphoreInfoCount">const <type>VkSemaphoreSubmitInfo</type>* <name>pStripeSemaphoreInfos</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePipelineOpacityMicromapFeaturesARM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>pipelineOpacityMicromap</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type> <name>shaderMaximalReconvergence</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderSubgroupRotateFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type> <name>shaderSubgroupRotate</name></member>
            <member><type>VkBool32</type> <name>shaderSubgroupRotateClustered</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR" alias="VkPhysicalDeviceShaderSubgroupRotateFeatures"/>
        <type category="struct" name="VkPhysicalDeviceShaderExpectAssumeFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>shaderExpectAssume</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderExpectAssumeFeaturesKHR" alias="VkPhysicalDeviceShaderExpectAssumeFeatures"/>
        <type category="struct" name="VkPhysicalDeviceShaderFloatControls2Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                     <name>shaderFloatControls2</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderFloatControls2FeaturesKHR" alias="VkPhysicalDeviceShaderFloatControls2Features"/>
        <type category="struct" name="VkPhysicalDeviceDynamicRenderingLocalReadFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*                                <name>pNext</name></member>
            <member><type>VkBool32</type>                                                                   <name>dynamicRenderingLocalRead</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR" alias="VkPhysicalDeviceDynamicRenderingLocalReadFeatures"/>
        <type category="struct" name="VkRenderingAttachmentLocationInfo" structextends="VkGraphicsPipelineCreateInfo,VkCommandBufferInheritanceInfo">
            <member values="VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                                                   <name>colorAttachmentCount</name></member>
            <member noautovalidity="true" len="colorAttachmentCount">const <type>uint32_t</type>*           <name>pColorAttachmentLocations</name></member>
        </type>
        <type category="struct" name="VkRenderingAttachmentLocationInfoKHR" alias="VkRenderingAttachmentLocationInfo"/>
        <type category="struct" name="VkRenderingInputAttachmentIndexInfo" structextends="VkGraphicsPipelineCreateInfo,VkCommandBufferInheritanceInfo">
            <member values="VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                                                   <name>colorAttachmentCount</name></member>
            <member len="colorAttachmentCount" optional="true">const <type>uint32_t</type>*                 <name>pColorAttachmentInputIndices</name></member>
            <member optional="true">const <type>uint32_t</type>*                                            <name>pDepthInputAttachmentIndex</name></member>
            <member optional="true">const <type>uint32_t</type>*                                            <name>pStencilInputAttachmentIndex</name></member>
        </type>
        <type category="struct" name="VkRenderingInputAttachmentIndexInfoKHR" alias="VkRenderingInputAttachmentIndexInfo"/>
        <type category="struct" name="VkPhysicalDeviceShaderQuadControlFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>shaderQuadControl</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>shaderFloat16VectorAtomics</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMapMemoryPlacedFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>memoryMapPlaced</name></member>
            <member><type>VkBool32</type>                         <name>memoryMapRangePlaced</name></member>
            <member><type>VkBool32</type>                         <name>memoryUnmapReserve</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMapMemoryPlacedPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member limittype="min,pot"><type>VkDeviceSize</type> <name>minPlacedMemoryMapAlignment</name></member>
        </type>
        <type category="struct" name="VkMemoryMapPlacedInfoEXT" structextends="VkMemoryMapInfo">
            <member values="VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*  <name>pNext</name></member>
            <member noautovalidity="true"><type>void</type>*  <name>pPlacedAddress</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderBfloat16FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                           <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>shaderBFloat16Type</name></member>
            <member><type>VkBool32</type>                                        <name>shaderBFloat16DotProduct</name></member>
            <member><type>VkBool32</type>                                        <name>shaderBFloat16CooperativeMatrix</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceRawAccessChainsFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                           <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>shaderRawAccessChains</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCommandBufferInheritanceFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                           <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>commandBufferInheritance</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImageAlignmentControlFeaturesMESA" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                           <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>imageAlignmentControl</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceImageAlignmentControlPropertiesMESA" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                           <name>pNext</name></member>
            <member limittype="bitmask"><type>uint32_t</type>                    <name>supportedImageAlignmentMask</name></member>
        </type>
        <type category="struct" name="VkImageAlignmentControlCreateInfoMESA" structextends="VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                     <name>pNext</name></member>
            <member><type>uint32_t</type>                                        <name>maximumRequestedAlignment</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>shaderReplicatedComposites</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT" alias="VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR"/>
        <type category="struct" name="VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                           <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>presentModeFifoLatestReady</name></member>
        </type>
        <type category="struct" name="VkDepthClampRangeEXT">
            <member><type>float</type>          <name>minDepthClamp</name></member>
            <member><type>float</type>          <name>maxDepthClamp</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCooperativeMatrix2FeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>cooperativeMatrixWorkgroupScope</name></member>
            <member><type>VkBool32</type>                            <name>cooperativeMatrixFlexibleDimensions</name></member>
            <member><type>VkBool32</type>                            <name>cooperativeMatrixReductions</name></member>
            <member><type>VkBool32</type>                            <name>cooperativeMatrixConversions</name></member>
            <member><type>VkBool32</type>                            <name>cooperativeMatrixPerElementOperations</name></member>
            <member><type>VkBool32</type>                            <name>cooperativeMatrixTensorAddressing</name></member>
            <member><type>VkBool32</type>                            <name>cooperativeMatrixBlockLoads</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCooperativeMatrix2PropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                 <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>cooperativeMatrixWorkgroupScopeMaxWorkgroupSize</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>cooperativeMatrixFlexibleDimensionsMaxDimension</name></member>
            <member limittype="max"><type>uint32_t</type>              <name>cooperativeMatrixWorkgroupScopeReservedSharedMemory</name></member>
        </type>
        <type category="struct" name="VkCooperativeMatrixFlexibleDimensionsPropertiesNV" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*               <name>pNext</name></member>
            <member><type>uint32_t</type>                            <name>MGranularity</name></member>
            <member><type>uint32_t</type>                            <name>NGranularity</name></member>
            <member><type>uint32_t</type>                            <name>KGranularity</name></member>
            <member><type>VkComponentTypeKHR</type>                  <name>AType</name></member>
            <member><type>VkComponentTypeKHR</type>                  <name>BType</name></member>
            <member><type>VkComponentTypeKHR</type>                  <name>CType</name></member>
            <member><type>VkComponentTypeKHR</type>                  <name>ResultType</name></member>
            <member><type>VkBool32</type>                            <name>saturatingAccumulation</name></member>
            <member><type>VkScopeKHR</type>                          <name>scope</name></member>
            <member><type>uint32_t</type>                            <name>workgroupInvocations</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceHdrVividFeaturesHUAWEI" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*    <name>pNext</name></member>
            <member><type>VkBool32</type>                                       <name>hdrVivid</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                           <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>vertexAttributeRobustness</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DENSE_GEOMETRY_FORMAT_FEATURES_AMDX"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>denseGeometryFormat</name></member>
        </type>
        <type category="struct" name="VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX" structextends="VkAccelerationStructureGeometryKHR">
            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DENSE_GEOMETRY_FORMAT_TRIANGLES_DATA_AMDX"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                     <name>pNext</name></member>
            <member><type>VkDeviceOrHostAddressConstKHR</type>                   <name>compressedData</name></member>
            <member><type>VkDeviceSize</type>                                    <name>dataSize</name></member>
            <member><type>uint32_t</type>                                        <name>numTriangles</name></member>
            <member><type>uint32_t</type>                                        <name>numVertices</name></member>
            <member><type>uint32_t</type>                                        <name>maxPrimitiveIndex</name></member>
            <member><type>uint32_t</type>                                        <name>maxGeometryIndex</name></member>
            <member><type>VkCompressedTriangleFormatAMDX</type>                  <name>format</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDepthClampZeroOneFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                     <name>depthClampZeroOne</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCooperativeVectorFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>cooperativeVector</name></member>
            <member><type>VkBool32</type>                            <name>cooperativeVectorTraining</name></member>
        </type>
        <type category="struct" name="VkCooperativeVectorPropertiesNV">
            <member values="VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*               <name>pNext</name></member>
            <member><type>VkComponentTypeKHR</type>                  <name>inputType</name></member>
            <member><type>VkComponentTypeKHR</type>                  <name>inputInterpretation</name></member>
            <member><type>VkComponentTypeKHR</type>                  <name>matrixInterpretation</name></member>
            <member><type>VkComponentTypeKHR</type>                  <name>biasInterpretation</name></member>
            <member><type>VkComponentTypeKHR</type>                  <name>resultType</name></member>
            <member><type>VkBool32</type>                            <name>transpose</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceCooperativeVectorPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
            <member limittype="bitmask"><type>VkShaderStageFlags</type>              <name>cooperativeVectorSupportedStages</name></member>
            <member limittype="exact"><type>VkBool32</type>                          <name>cooperativeVectorTrainingFloat16Accumulation</name></member>
            <member limittype="exact"><type>VkBool32</type>                          <name>cooperativeVectorTrainingFloat32Accumulation</name></member>
            <member limittype="max"><type>uint32_t</type>                            <name>maxCooperativeVectorComponents</name></member>
        </type>
        <type category="struct" name="VkConvertCooperativeVectorMatrixInfoNV">
            <member values="VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
            <member><type>size_t</type>                                              <name>srcSize</name></member>
            <member><type>VkDeviceOrHostAddressConstKHR</type>                       <name>srcData</name></member>
            <member optional="false,true"><type>size_t</type>*                       <name>pDstSize</name></member>
            <member><type>VkDeviceOrHostAddressKHR</type>                            <name>dstData</name></member>
            <member><type>VkComponentTypeKHR</type>                                  <name>srcComponentType</name></member>
            <member><type>VkComponentTypeKHR</type>                                  <name>dstComponentType</name></member>
            <member><type>uint32_t</type>                                            <name>numRows</name></member>
            <member><type>uint32_t</type>                                            <name>numColumns</name></member>
            <member><type>VkCooperativeVectorMatrixLayoutNV</type>                   <name>srcLayout</name></member>
            <member><type>size_t</type>                                              <name>srcStride</name></member>
            <member><type>VkCooperativeVectorMatrixLayoutNV</type>                   <name>dstLayout</name></member>
            <member><type>size_t</type>                                              <name>dstStride</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceTileShadingFeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>tileShading</name></member>
            <member><type>VkBool32</type>                           <name>tileShadingFragmentStage</name></member>
            <member><type>VkBool32</type>                           <name>tileShadingColorAttachments</name></member>
            <member><type>VkBool32</type>                           <name>tileShadingDepthAttachments</name></member>
            <member><type>VkBool32</type>                           <name>tileShadingStencilAttachments</name></member>
            <member><type>VkBool32</type>                           <name>tileShadingInputAttachments</name></member>
            <member><type>VkBool32</type>                           <name>tileShadingSampledAttachments</name></member>
            <member><type>VkBool32</type>                           <name>tileShadingPerTileDraw</name></member>
            <member><type>VkBool32</type>                           <name>tileShadingPerTileDispatch</name></member>
            <member><type>VkBool32</type>                           <name>tileShadingDispatchTile</name></member>
            <member><type>VkBool32</type>                           <name>tileShadingApron</name></member>
            <member><type>VkBool32</type>                           <name>tileShadingAnisotropicApron</name></member>
            <member><type>VkBool32</type>                           <name>tileShadingAtomicOps</name></member>
            <member><type>VkBool32</type>                           <name>tileShadingImageProcessing</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceTileShadingPropertiesQCOM" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                    <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>                 <name>maxApronSize</name></member>
            <member limittype="max"><type>VkBool32</type>                 <name>preferNonCoherent</name></member>
            <member limittype="max,mul"><type>VkExtent2D</type>           <name>tileGranularity</name></member>
            <member limittype="max"><type>VkExtent2D</type>               <name>maxTileShadingRate</name></member>
        </type>
        <type category="struct" name="VkRenderPassTileShadingCreateInfoQCOM" structextends="VkRenderPassCreateInfo,VkRenderPassCreateInfo2,VkRenderingInfo,VkCommandBufferInheritanceInfo">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkTileShadingRenderPassFlagsQCOM</type> <name>flags</name></member>
            <member optional="true"><type>VkExtent2D</type>                       <name>tileApronSize</name></member>
        </type>
        <type category="struct" name="VkPerTileBeginInfoQCOM">
            <member values="VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
        </type>
        <type category="struct" name="VkPerTileEndInfoQCOM">
            <member values="VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
        </type>
        <type category="struct" name="VkDispatchTileInfoQCOM">
            <member values="VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>                         <name>maxFragmentDensityMapLayers</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
            <member><type>VkBool32</type>                                         <name>fragmentDensityMapLayered</name></member>
        </type>
        <type category="struct" name="VkPipelineFragmentDensityMapLayeredCreateInfoVALVE" structextends="VkGraphicsPipelineCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member><type>uint32_t</type>                                         <name>maxFragmentDensityMapLayers</name></member>
        </type>
        <type category="struct" name="VkSetPresentConfigNV" structextends="VkPresentInfoKHR">
            <member values="VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
            <member><type>uint32_t</type>                         <name>numFramesPerBatch</name></member>
            <member><type>uint32_t</type>                         <name>presentConfigFeedback</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePresentMeteringFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                           <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>presentMetering</name></member>
        </type>
        <type category="struct" name="VkExternalComputeQueueDeviceCreateInfoNV" structextends="VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type> <name>reservedExternalQueues</name></member>
        </type>
        <type category="struct" name="VkExternalComputeQueueCreateInfoNV">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkQueue</type> <name>preferredQueue</name></member>
        </type>
        <type category="struct" name="VkExternalComputeQueueDataParamsNV">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type> <name>deviceIndex</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalComputeQueuePropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member limittype="noauto"><type>uint32_t</type> <name>externalDataSize</name></member>
            <member limittype="noauto"><type>uint32_t</type> <name>maxExternalQueues</name></member>
        </type>
        <type category="handle" parent="VkDevice" objtypeenum="VK_OBJECT_TYPE_EXTERNAL_COMPUTE_QUEUE_NV"><type>VK_DEFINE_HANDLE</type>(<name>VkExternalComputeQueueNV</name>)</type>
        <type category="struct" name="VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type> <name>shaderUniformBufferUnsizedArray</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceFormatPackFeaturesARM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*              <name>pNext</name></member>
            <member><type>VkBool32</type>                           <name>formatPack</name></member>
        </type>
        <type category="struct" name="VkTensorDescriptionARM" structextends="VkDataGraphPipelineResourceInfoARM,VkDataGraphPipelineConstantARM">
            <member values="VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*              <name>pNext</name></member>
            <member><type>VkTensorTilingARM</type>                        <name>tiling</name></member>
            <member><type>VkFormat</type>                                 <name>format</name></member>
            <member><type>uint32_t</type>                                 <name>dimensionCount</name></member>
            <member len="dimensionCount">const <type>int64_t</type>*      <name>pDimensions</name></member>
            <member optional="true" len="dimensionCount">const <type>int64_t</type>* <name>pStrides</name></member>
            <member><type>VkTensorUsageFlagsARM</type>                    <name>usage</name></member>
        </type>
        <type category="struct" name="VkTensorCreateInfoARM">
            <member values="VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkTensorCreateFlagsARM</type> <name>flags</name></member>
            <member>const <type>VkTensorDescriptionARM</type>*          <name>pDescription</name></member>
            <member><type>VkSharingMode</type>                          <name>sharingMode</name></member>
            <member optional="true"><type>uint32_t</type>               <name>queueFamilyIndexCount</name></member>
            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>*  <name>pQueueFamilyIndices</name></member>
        </type>
        <type category="struct" name="VkTensorViewCreateInfoARM">
            <member values="VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
            <member optional="true"><type>VkTensorViewCreateFlagsARM</type> <name>flags</name></member>
            <member><type>VkTensorARM</type>                                <name>tensor</name></member>
            <member><type>VkFormat</type>                                   <name>format</name></member>
        </type>
        <type category="struct" name="VkTensorMemoryRequirementsInfoARM">
            <member values="VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
            <member><type>VkTensorARM</type>                        <name>tensor</name></member>
        </type>
        <type category="struct" name="VkBindTensorMemoryInfoARM">
            <member values="VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
            <member externsync="true"><type>VkTensorARM</type>                      <name>tensor</name></member>
            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
            <member><type>VkDeviceSize</type>                     <name>memoryOffset</name></member>
        </type>
        <type category="struct" name="VkWriteDescriptorSetTensorARM" structextends="VkWriteDescriptorSet">
            <member values="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*              <name>pNext</name></member>
            <member><type>uint32_t</type>                                 <name>tensorViewCount</name></member>
            <member len="tensorViewCount" optional="false,true">const <type>VkTensorViewARM</type>* <name>pTensorViews</name></member>
        </type>
        <type category="struct" name="VkTensorFormatPropertiesARM" returnedonly="true" structextends="VkFormatProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                <name>pNext</name></member>
            <member limittype="bitmask"><type>VkFormatFeatureFlags2</type>  <name>optimalTilingTensorFeatures</name></member>
            <member limittype="bitmask"><type>VkFormatFeatureFlags2</type>  <name>linearTilingTensorFeatures</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceTensorPropertiesARM" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*          <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>       <name>maxTensorDimensionCount</name></member>
            <member limittype="max"><type>uint64_t</type>       <name>maxTensorElements</name></member>
            <member limittype="max"><type>uint64_t</type>       <name>maxPerDimensionTensorElements</name></member>
            <member limittype="max"><type>int64_t</type>        <name>maxTensorStride</name></member>
            <member limittype="max"><type>uint64_t</type>       <name>maxTensorSize</name></member>
            <member limittype="max"><type>uint32_t</type>       <name>maxTensorShaderAccessArrayLength</name></member>
            <member limittype="max"><type>uint32_t</type>       <name>maxTensorShaderAccessSize</name></member>
            <member limittype="max"><type>uint32_t</type>       <name>maxDescriptorSetStorageTensors</name></member>
            <member limittype="max"><type>uint32_t</type>       <name>maxPerStageDescriptorSetStorageTensors</name></member>
            <member limittype="max"><type>uint32_t</type>       <name>maxDescriptorSetUpdateAfterBindStorageTensors</name></member>
            <member limittype="max"><type>uint32_t</type>       <name>maxPerStageDescriptorUpdateAfterBindStorageTensors</name></member>
            <member limittype="max"><type>VkBool32</type>       <name>shaderStorageTensorArrayNonUniformIndexingNative</name></member>
            <member limittype="bitmask"><type>VkShaderStageFlags</type>   <name>shaderTensorSupportedStages</name></member>
        </type>
        <type category="struct" name="VkTensorMemoryBarrierARM" structextends="VkDependencyInfo">
            <member values="VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkPipelineStageFlags2</type>  <name>srcStageMask</name></member>
            <member optional="true"><type>VkAccessFlags2</type>         <name>srcAccessMask</name></member>
            <member optional="true"><type>VkPipelineStageFlags2</type>  <name>dstStageMask</name></member>
            <member optional="true"><type>VkAccessFlags2</type>         <name>dstAccessMask</name></member>
            <member><type>uint32_t</type>                               <name>srcQueueFamilyIndex</name></member>
            <member><type>uint32_t</type>                               <name>dstQueueFamilyIndex</name></member>
            <member><type>VkTensorARM</type>                            <name>tensor</name></member>
        </type>
        <type category="struct" name="VkTensorDependencyInfoARM" structextends="VkDependencyInfo">
            <member values="VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*           <name>pNext</name></member>
            <member><type>uint32_t</type>                              <name>tensorMemoryBarrierCount</name></member>
            <member>const <type>VkTensorMemoryBarrierARM</type>*       <name>pTensorMemoryBarriers</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceTensorFeaturesARM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*         <name>pNext</name></member>
            <member><type>VkBool32</type>                      <name>tensorNonPacked</name></member>
            <member><type>VkBool32</type>                      <name>shaderTensorAccess</name></member>
            <member><type>VkBool32</type>                      <name>shaderStorageTensorArrayDynamicIndexing</name></member>
            <member><type>VkBool32</type>                      <name>shaderStorageTensorArrayNonUniformIndexing</name></member>
            <member><type>VkBool32</type>                      <name>descriptorBindingStorageTensorUpdateAfterBind</name></member>
            <member><type>VkBool32</type>                      <name>tensors</name></member>
        </type>
        <type category="struct" name="VkDeviceTensorMemoryRequirementsARM">
            <member values="VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*   <name>pNext</name></member>
            <member>const <type>VkTensorCreateInfoARM</type>*  <name>pCreateInfo</name></member>
        </type>
        <type category="struct" name="VkCopyTensorInfoARM">
            <member values="VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*  <name>pNext</name></member>
            <member><type>VkTensorARM</type>                  <name>srcTensor</name></member>
            <member><type>VkTensorARM</type>                  <name>dstTensor</name></member>
            <member><type>uint32_t</type>                     <name>regionCount</name></member>
            <member len="regionCount">const <type>VkTensorCopyARM</type>* <name>pRegions</name></member>
        </type>
        <type category="struct" name="VkTensorCopyARM">
            <member values="VK_STRUCTURE_TYPE_TENSOR_COPY_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*  <name>pNext</name></member>
            <member optional="true"><type>uint32_t</type>                             <name>dimensionCount</name></member>
            <member optional="true" len="dimensionCount">const <type>uint64_t</type>* <name>pSrcOffset</name></member>
            <member optional="true" len="dimensionCount">const <type>uint64_t</type>* <name>pDstOffset</name></member>
            <member optional="true" len="dimensionCount">const <type>uint64_t</type>* <name>pExtent</name></member>
        </type>
        <type category="struct" name="VkMemoryDedicatedAllocateInfoTensorARM" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
            <member><type>VkTensorARM</type>                      <name>tensor</name><comment>Tensor that this allocation will be bound to</comment></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDescriptorBufferTensorPropertiesARM" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*     <name>pNext</name></member>
            <member limittype="noauto"><type>size_t</type> <name>tensorCaptureReplayDescriptorDataSize</name></member>
            <member limittype="noauto"><type>size_t</type> <name>tensorViewCaptureReplayDescriptorDataSize</name></member>
            <member limittype="max"><type>size_t</type>    <name>tensorDescriptorSize</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDescriptorBufferTensorFeaturesARM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type>              <name>descriptorBufferTensorDescriptors</name></member>
        </type>
        <type category="struct" name="VkTensorCaptureDescriptorDataInfoARM">
            <member values="VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkTensorARM</type>                 <name>tensor</name></member>
        </type>
        <type category="struct" name="VkTensorViewCaptureDescriptorDataInfoARM">
            <member values="VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkTensorViewARM</type>             <name>tensorView</name></member>
        </type>
        <type category="struct" name="VkDescriptorGetTensorInfoARM" structextends="VkDescriptorGetInfoEXT">
            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
            <member optional="true"><type>VkTensorViewARM</type> <name>tensorView</name></member>
        </type>
        <type category="struct" name="VkFrameBoundaryTensorsARM" structextends="VkSubmitInfo,VkSubmitInfo2,VkPresentInfoKHR,VkBindSparseInfo">
            <member values="VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*          <name>pNext</name></member>
            <member><type>uint32_t</type>                             <name>tensorCount</name></member>
            <member len="tensorCount">const <type>VkTensorARM</type>* <name>pTensors</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceExternalTensorInfoARM">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member optional="true"><type>VkTensorCreateFlagsARM</type> <name>flags</name></member>
            <member>const <type>VkTensorDescriptionARM</type>*          <name>pDescription</name></member>
            <member><type>VkExternalMemoryHandleTypeFlagBits</type>     <name>handleType</name></member>
        </type>
        <type category="struct" name="VkExternalTensorPropertiesARM">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*  <name>pNext</name></member>
            <member><type>VkExternalMemoryProperties</type>   <name>externalMemoryProperties</name></member>
        </type>
        <type category="struct" name="VkExternalMemoryTensorCreateInfoARM" structextends="VkTensorCreateInfoARM">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
            <member optional="true"><type>VkExternalMemoryHandleTypeFlags</type> <name>handleTypes</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderFloat8FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>shaderFloat8</name></member>
            <member><type>VkBool32</type>                                        <name>shaderFloat8CooperativeMatrix</name></member>
        </type>
        <type category="struct" name="VkSurfaceCreateInfoOHOS">
            <member values="VK_STRUCTURE_TYPE_SURFACE_CREATE_INFO_OHOS"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
            <member optional="true"><type>VkSurfaceCreateFlagsOHOS</type> <name>flags</name></member>
            <member noautovalidity="true"><type>OHNativeWindow</type>*    <name>window</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDataGraphFeaturesARM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member><type>VkBool32</type> <name>dataGraph</name></member>
            <member><type>VkBool32</type> <name>dataGraphUpdateAfterBind</name></member>
            <member><type>VkBool32</type> <name>dataGraphSpecializationConstants</name></member>
            <member><type>VkBool32</type> <name>dataGraphDescriptorBuffer</name></member>
            <member><type>VkBool32</type> <name>dataGraphShaderModule</name></member>
        </type>
        <type category="struct" name="VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM" structextends="VkDataGraphPipelineConstantARM" allowduplicate="true">
            <member values="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type> <name>dimension</name></member>
            <member><type>uint32_t</type> <name>zeroCount</name></member>
            <member><type>uint32_t</type> <name>groupSize</name></member>
        </type>
        <type category="struct" name="VkDataGraphPipelineConstantARM">
            <member values="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type>                    <name>id</name></member>
            <member>const <type>void</type>*                 <name>pConstantData</name></member>
        </type>
        <type category="struct" name="VkDataGraphPipelineResourceInfoARM">
            <member values="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type>                    <name>descriptorSet</name></member>
            <member><type>uint32_t</type>                    <name>binding</name></member>
            <member optional="true"><type>uint32_t</type>    <name>arrayElement</name></member>
        </type>
        <type category="struct" name="VkDataGraphPipelineCompilerControlCreateInfoARM" structextends="VkDataGraphPipelineCreateInfoARM">
            <member values="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*       <name>pNext</name></member>
            <member len="null-terminated">const <type>char</type>* <name>pVendorOptions</name></member>
        </type>
        <type category="struct" name="VkDataGraphPipelineCreateInfoARM">
            <member values="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                   <name>pNext</name></member>
            <member optional="true"><type>VkPipelineCreateFlags2KHR</type>                     <name>flags</name></member>
            <member><type>VkPipelineLayout</type>                                              <name>layout</name></member>
            <member><type>uint32_t</type>                                                      <name>resourceInfoCount</name></member>
            <member len="resourceInfoCount">const <type>VkDataGraphPipelineResourceInfoARM</type>* <name>pResourceInfos</name></member>
        </type>
        <type category="struct" name="VkDataGraphPipelineShaderModuleCreateInfoARM" structextends="VkDataGraphPipelineCreateInfoARM">
            <member values="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                   <name>pNext</name></member>
            <member optional="true"><type>VkShaderModule</type>                                <name>module</name></member>
            <member len="null-terminated">const <type>char</type>*                             <name>pName</name></member>
            <member optional="true">const <type>VkSpecializationInfo</type>*                   <name>pSpecializationInfo</name></member>
            <member optional="true"><type>uint32_t</type>                                      <name>constantCount</name></member>
            <member optional="true" len="constantCount">const <type>VkDataGraphPipelineConstantARM</type>* <name>pConstants</name></member>
        </type>
        <type category="struct" name="VkDataGraphPipelineSessionCreateInfoARM">
            <member values="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member optional="true"><type>VkDataGraphPipelineSessionCreateFlagsARM</type> <name>flags</name></member>
            <member><type>VkPipeline</type>                  <name>dataGraphPipeline</name></member>
        </type>
        <type category="struct" name="VkDataGraphPipelineSessionBindPointRequirementsInfoARM">
            <member values="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
            <member><type>VkDataGraphPipelineSessionARM</type>   <name>session</name></member>
        </type>
        <type category="struct" name="VkDataGraphPipelineSessionBindPointRequirementARM">
            <member values="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                 <name>pNext</name></member>
            <member><type>VkDataGraphPipelineSessionBindPointARM</type>      <name>bindPoint</name></member>
            <member><type>VkDataGraphPipelineSessionBindPointTypeARM</type>  <name>bindPointType</name></member>
            <member><type>uint32_t</type>                                    <name>numObjects</name></member>
        </type>
        <type category="struct" name="VkDataGraphPipelineSessionMemoryRequirementsInfoARM">
            <member values="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
            <member><type>VkDataGraphPipelineSessionARM</type>          <name>session</name></member>
            <member><type>VkDataGraphPipelineSessionBindPointARM</type> <name>bindPoint</name></member>
            <member><type>uint32_t</type>                               <name>objectIndex</name></member>
        </type>
        <type category="struct" name="VkBindDataGraphPipelineSessionMemoryInfoARM">
            <member values="VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkDataGraphPipelineSessionARM</type>   <name>session</name></member>
            <member><type>VkDataGraphPipelineSessionBindPointARM</type>   <name>bindPoint</name></member>
            <member><type>uint32_t</type>                                 <name>objectIndex</name></member>
            <member><type>VkDeviceMemory</type>              <name>memory</name></member>
            <member><type>VkDeviceSize</type>                <name>memoryOffset</name></member>
        </type>
        <type category="struct" name="VkDataGraphPipelineInfoARM">
            <member values="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkPipeline</type>                  <name>dataGraphPipeline</name></member>
        </type>
        <type category="struct" name="VkDataGraphPipelinePropertyQueryResultARM">
            <member values="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkDataGraphPipelinePropertyARM</type> <name>property</name></member>
            <member><type>VkBool32</type>                   <name>isText</name></member>
            <member optional="true"><type>size_t</type>     <name>dataSize</name></member>
            <member optional="true" len="dataSize"><type>void</type>* <name>pData</name></member>
        </type>
        <type category="struct" name="VkDataGraphPipelineIdentifierCreateInfoARM" structextends="VkDataGraphPipelineCreateInfoARM">
            <member values="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type>                    <name>identifierSize</name></member>
            <member len="identifierSize">const <type>uint8_t</type>* <name>pIdentifier</name></member>
        </type>
        <type category="struct" name="VkDataGraphPipelineDispatchInfoARM">
            <member values="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member optional="true"><type>VkDataGraphPipelineDispatchFlagsARM</type> <name>flags</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDataGraphProcessingEngineARM">
            <member><type>VkPhysicalDeviceDataGraphProcessingEngineTypeARM</type> <name>type</name></member>
            <member><type>VkBool32</type>                                         <name>isForeign</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDataGraphOperationSupportARM">
            <member><type>VkPhysicalDeviceDataGraphOperationTypeARM</type>  <name>operationType</name></member>
            <member len="null-terminated"><type>char</type> <name>name</name>[<enum>VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM</enum>]</member>
            <member><type>uint32_t</type>                                   <name>version</name></member>
        </type>
        <type category="struct" name="VkQueueFamilyDataGraphPropertiesARM">
            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkPhysicalDeviceDataGraphProcessingEngineARM</type> <name>engine</name></member>
            <member><type>VkPhysicalDeviceDataGraphOperationSupportARM</type> <name>operation</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>uint32_t</type> <name>queueFamilyIndex</name></member>
            <member><type>VkPhysicalDeviceDataGraphProcessingEngineTypeARM</type> <name>engineType</name></member>
        </type>
        <type category="struct" name="VkQueueFamilyDataGraphProcessingEnginePropertiesARM">
            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkExternalSemaphoreHandleTypeFlags</type> <name>foreignSemaphoreHandleTypes</name></member>
            <member><type>VkExternalMemoryHandleTypeFlags</type> <name>foreignMemoryHandleTypes</name></member>
        </type>
        <type category="struct" name="VkDataGraphProcessingEngineCreateInfoARM" structextends="VkDataGraphPipelineCreateInfoARM,VkDescriptorPoolCreateInfo,VkCommandPoolCreateInfo">
            <member values="VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                   <name>pNext</name></member>
            <member><type>uint32_t</type>                                      <name>processingEngineCount</name></member>
            <member len="processingEngineCount"><type>VkPhysicalDeviceDataGraphProcessingEngineARM</type>* <name>pProcessingEngines</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*            <name>pNext</name></member>
            <member><type>VkBool32</type>                         <name>pipelineCacheIncrementalMode</name></member>
        </type>
        <type category="struct" name="VkDataGraphPipelineBuiltinModelCreateInfoQCOM" structextends="VkDataGraphPipelineCreateInfoARM">
            <member values="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_BUILTIN_MODEL_CREATE_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                                                   <name>pNext</name></member>
            <member>const <type>VkPhysicalDeviceDataGraphOperationSupportARM</type>*                                           <name>pOperation</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceDataGraphModelFeaturesQCOM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_MODEL_FEATURES_QCOM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                                                                     <name>pNext</name></member>
            <member featurelink="dataGraphModelQCOM"><type>VkBool32</type>                                                 <name>dataGraphModel</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShaderUntypedPointersFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*          <name>pNext</name></member>
            <member><type>VkBool32</type>       <name>shaderUntypedPointers</name></member>
        </type>
        <type category="struct" name="VkNativeBufferOHOS" structextends="VkImageCreateInfo,VkBindImageMemoryInfo">
            <member values="VK_STRUCTURE_TYPE_NATIVE_BUFFER_OHOS"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member>struct <type>OHBufferHandle</type>* <name>handle</name></member>
        </type>
        <type category="struct" name="VkSwapchainImageCreateInfoOHOS" structextends="VkImageCreateInfo">
            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_OHOS"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>* <name>pNext</name></member>
            <member><type>VkSwapchainImageUsageFlagsOHOS</type> <name>usage</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePresentationPropertiesOHOS" returnedonly="true" structextends="VkPhysicalDeviceProperties2" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_OHOS"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>* <name>pNext</name></member>
            <member limittype="max"><type>VkBool32</type> <name>sharedImage</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_RGB_CONVERSION_FEATURES_VALVE"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                       <name>pNext</name></member>
            <member><type>VkBool32</type>                                    <name>videoEncodeRgbConversion</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeRgbConversionCapabilitiesVALVE" structextends="VkVideoCapabilitiesKHR" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_RGB_CONVERSION_CAPABILITIES_VALVE"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                <name>pNext</name></member>
            <member limittype="bitmask"><type>VkVideoEncodeRgbModelConversionFlagsVALVE</type>  <name>rgbModels</name></member>
            <member limittype="bitmask"><type>VkVideoEncodeRgbRangeCompressionFlagsVALVE</type> <name>rgbRanges</name></member>
            <member limittype="bitmask"><type>VkVideoEncodeRgbChromaOffsetFlagsVALVE</type>     <name>xChromaOffsets</name></member>
            <member limittype="bitmask"><type>VkVideoEncodeRgbChromaOffsetFlagsVALVE</type>     <name>yChromaOffsets</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeProfileRgbConversionInfoVALVE" structextends="VkVideoProfileInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_PROFILE_RGB_CONVERSION_INFO_VALVE"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                       <name>pNext</name></member>
            <member><type>VkBool32</type>                                          <name>performEncodeRgbConversion</name></member>
        </type>
        <type category="struct" name="VkVideoEncodeSessionRgbConversionCreateInfoVALVE" structextends="VkVideoSessionCreateInfoKHR">
            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_RGB_CONVERSION_CREATE_INFO_VALVE"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                                 <name>pNext</name></member>
            <member><type>VkVideoEncodeRgbModelConversionFlagBitsVALVE</type>          <name>rgbModel</name></member>
            <member><type>VkVideoEncodeRgbRangeCompressionFlagBitsVALVE</type>         <name>rgbRange</name></member>
            <member><type>VkVideoEncodeRgbChromaOffsetFlagBitsVALVE</type>             <name>xChromaOffset</name></member>
            <member><type>VkVideoEncodeRgbChromaOffsetFlagBitsVALVE</type>             <name>yChromaOffset</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceShader64BitIndexingFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_64_BIT_INDEXING_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*               <name>pNext</name></member>
            <member><type>VkBool32</type>                            <name>shader64BitIndexing</name></member>
        </type>
        <type category="struct" name="VkNativeBufferUsageOHOS" structextends="VkImageFormatProperties2" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_NATIVE_BUFFER_USAGE_OHOS"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member><type>uint64_t</type>                           <name>OHOSNativeBufferUsage</name></member>
        </type>
        <type category="struct" name="VkNativeBufferPropertiesOHOS" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_NATIVE_BUFFER_PROPERTIES_OHOS"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member><type>VkDeviceSize</type>                       <name>allocationSize</name></member>
            <member><type>uint32_t</type>                           <name>memoryTypeBits</name></member>
        </type>
        <type category="struct" name="VkNativeBufferFormatPropertiesOHOS" structextends="VkNativeBufferPropertiesOHOS" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_NATIVE_BUFFER_FORMAT_PROPERTIES_OHOS"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member><type>VkFormat</type>                           <name>format</name></member>
            <member><type>uint64_t</type>                           <name>externalFormat</name></member>
            <member><type>VkFormatFeatureFlags</type>               <name>formatFeatures</name></member>
            <member><type>VkComponentMapping</type>                 <name>samplerYcbcrConversionComponents</name></member>
            <member><type>VkSamplerYcbcrModelConversion</type>      <name>suggestedYcbcrModel</name></member>
            <member><type>VkSamplerYcbcrRange</type>                <name>suggestedYcbcrRange</name></member>
            <member><type>VkChromaLocation</type>                   <name>suggestedXChromaOffset</name></member>
            <member><type>VkChromaLocation</type>                   <name>suggestedYChromaOffset</name></member>
        </type>
        <type category="struct" name="VkImportNativeBufferInfoOHOS" structextends="VkMemoryAllocateInfo">
            <member values="VK_STRUCTURE_TYPE_IMPORT_NATIVE_BUFFER_INFO_OHOS"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
            <member>struct <type>OH_NativeBuffer</type>*            <name>buffer</name></member>
        </type>
        <type category="struct" name="VkMemoryGetNativeBufferInfoOHOS">
            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_NATIVE_BUFFER_INFO_OHOS"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
            <member><type>VkDeviceMemory</type>                     <name>memory</name></member>
        </type>
        <type category="struct" name="VkExternalFormatOHOS" structextends="VkImageCreateInfo,VkSamplerYcbcrConversionCreateInfo,VkAttachmentDescription2,VkGraphicsPipelineCreateInfo,VkCommandBufferInheritanceInfo">
            <member values="VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_OHOS"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
            <member><type>uint64_t</type>                           <name>externalFormat</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePerformanceCountersByRegionFeaturesARM" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_FEATURES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true" noautovalidity="true"><type>void</type>*     <name>pNext</name></member>
            <member><type>VkBool32</type>                                        <name>performanceCountersByRegion</name></member>
        </type>
        <type category="struct" name="VkPhysicalDevicePerformanceCountersByRegionPropertiesARM" structextends="VkPhysicalDeviceProperties2" returnedonly="true" requiredlimittype="true">
            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_PROPERTIES_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                           <name>pNext</name></member>
            <member limittype="max"><type>uint32_t</type>                        <name>maxPerRegionPerformanceCounters</name></member>
            <member limittype="exact"><type>VkExtent2D</type>                    <name>performanceCounterRegionSize</name></member>
            <member limittype="min"><type>uint32_t</type>                        <name>rowStrideAlignment</name></member>
            <member limittype="exact"><type>uint32_t</type>                      <name>regionAlignment</name></member>
            <member limittype="exact"><type>VkBool32</type>                      <name>identityTransformOrder</name></member>
        </type>
        <type category="struct" name="VkPerformanceCounterARM" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                           <name>pNext</name></member>
            <member><type>uint32_t</type> <name>counterID</name></member>
        </type>
        <type category="struct" name="VkPerformanceCounterDescriptionARM" returnedonly="true">
            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                   <name>pNext</name></member>
            <member optional="true"><type>VkPerformanceCounterDescriptionFlagsARM</type> <name>flags</name></member>
            <member len="null-terminated"><type>char</type>              <name>name</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
        </type>
        <type category="struct" name="VkRenderPassPerformanceCountersByRegionBeginInfoARM" structextends="VkRenderPassBeginInfo,VkRenderingInfo">
            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_PERFORMANCE_COUNTERS_BY_REGION_BEGIN_INFO_ARM"><type>VkStructureType</type> <name>sType</name></member>
            <member optional="true"><type>void</type>*                           <name>pNext</name><comment>Pointer to next structure</comment></member>
            <member><type>uint32_t</type>                                        <name>counterAddressCount</name></member>
            <member>const <type>VkDeviceAddress</type>*                          <name>pCounterAddresses</name></member>
            <member><type>VkBool32</type>                                        <name>serializeRegions</name></member>
            <member><type>uint32_t</type>                                        <name>counterIndexCount</name></member>
            <member><type>uint32_t</type>*                                       <name>pCounterIndices</name></member>
        </type>
    </types>


    <comment>Vulkan enumerant (token) definitions</comment>

    <enums name="API Constants" type="constants" comment="Vulkan hardcoded constants - not an enumerated type, part of the header boilerplate">
        <enum type="uint32_t" value="256"       name="VK_MAX_PHYSICAL_DEVICE_NAME_SIZE"/>
        <enum type="uint32_t" value="16"        name="VK_UUID_SIZE"/>
        <enum type="uint32_t" value="8"         name="VK_LUID_SIZE"/>
        <enum type="uint32_t" value="256"       name="VK_MAX_EXTENSION_NAME_SIZE"/>
        <enum type="uint32_t" value="256"       name="VK_MAX_DESCRIPTION_SIZE"/>
        <enum type="uint32_t" value="32"        name="VK_MAX_MEMORY_TYPES"/>
        <enum type="uint32_t" value="16"        name="VK_MAX_MEMORY_HEAPS" comment="The maximum number of unique memory heaps, each of which supporting 1 or more memory types"/>
        <enum type="float"    value="1000.0F"   name="VK_LOD_CLAMP_NONE"/>
        <enum type="uint32_t" value="(~0U)"     name="VK_REMAINING_MIP_LEVELS"/>
        <enum type="uint32_t" value="(~0U)"     name="VK_REMAINING_ARRAY_LAYERS"/>
        <enum type="uint32_t" value="(~0U)"     name="VK_REMAINING_3D_SLICES_EXT"/>
        <enum type="uint64_t" value="(~0ULL)"   name="VK_WHOLE_SIZE"/>
        <enum type="uint32_t" value="(~0U)"     name="VK_ATTACHMENT_UNUSED"/>
        <enum type="uint32_t" value="1"         name="VK_TRUE"/>
        <enum type="uint32_t" value="0"         name="VK_FALSE"/>
        <enum type="uint32_t" value="(~0U)"     name="VK_QUEUE_FAMILY_IGNORED"/>
        <enum type="uint32_t" value="(~1U)"     name="VK_QUEUE_FAMILY_EXTERNAL"/>
        <enum type="uint32_t" value="(~2U)"     name="VK_QUEUE_FAMILY_FOREIGN_EXT"/>
        <enum type="uint32_t" value="(~0U)"     name="VK_SUBPASS_EXTERNAL"/>
        <enum type="uint32_t" value="32"        name="VK_MAX_DEVICE_GROUP_SIZE"/>
        <enum type="uint32_t" value="256"       name="VK_MAX_DRIVER_NAME_SIZE"/>
        <enum type="uint32_t" value="256"       name="VK_MAX_DRIVER_INFO_SIZE"/>
        <enum type="uint32_t" value="(~0U)"     name="VK_SHADER_UNUSED_KHR"/>
        <enum type="uint32_t" value="16"        name="VK_MAX_GLOBAL_PRIORITY_SIZE"/>
        <enum type="uint32_t" value="32"        name="VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT"/>
        <enum type="uint32_t" value="32"        name="VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR"/>
        <enum type="uint32_t" value="7"         name="VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR"/>
        <enum type="uint32_t" value="3"         name="VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR"/>
        <enum type="uint32_t" value="(~0U)"     name="VK_SHADER_INDEX_UNUSED_AMDX"/>
        <enum type="uint32_t" value="(~0U)"     name="VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV"/>
        <enum type="uint32_t" value="128"       name="VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_ALIGNMENT_AMDX"/>
        <enum type="uint32_t" value="128"       name="VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_STRIDE_AMDX"/>
        <enum type="uint32_t" value="128"       name="VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM"/>
        <enum type="uint32_t" value="3"         name="VK_DATA_GRAPH_MODEL_TOOLCHAIN_VERSION_LENGTH_QCOM"/>
    </enums>

    <comment>
        Unlike OpenGL, most tokens in Vulkan are actual typed enumerants in
        their own numeric namespaces. The "name" attribute is the C enum
        type name, and is pulled in from a type tag definition above
        (slightly clunky, but retains the type / enum distinction). "type"
        attributes of "enum" or "bitmask" indicate that these values should
        be generated inside an appropriate definition.
    </comment>

    <enums name="VkImageLayout" type="enum">
        <enum value="0"     name="VK_IMAGE_LAYOUT_UNDEFINED"                         comment="Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)"/>
        <enum value="1"     name="VK_IMAGE_LAYOUT_GENERAL"                           comment="General layout when image can be used for any kind of access"/>
        <enum value="2"     name="VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL"          comment="Optimal layout when image is only used for color attachment read/write"/>
        <enum value="3"     name="VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL"  comment="Optimal layout when image is only used for depth/stencil attachment read/write"/>
        <enum value="4"     name="VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL"   comment="Optimal layout when image is used for read only depth/stencil attachment and shader access"/>
        <enum value="5"     name="VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL"          comment="Optimal layout when image is used for read only shader access"/>
        <enum value="6"     name="VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL"              comment="Optimal layout when image is used only as source of transfer operations"/>
        <enum value="7"     name="VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"              comment="Optimal layout when image is used only as destination of transfer operations"/>
        <enum value="8"     name="VK_IMAGE_LAYOUT_PREINITIALIZED"                    comment="Initial layout used when the data is populated by the CPU"/>
    </enums>
    <enums name="VkAttachmentLoadOp" type="enum">
        <enum value="0"     name="VK_ATTACHMENT_LOAD_OP_LOAD"/>
        <enum value="1"     name="VK_ATTACHMENT_LOAD_OP_CLEAR"/>
        <enum value="2"     name="VK_ATTACHMENT_LOAD_OP_DONT_CARE"/>
    </enums>
    <enums name="VkAttachmentStoreOp" type="enum">
        <enum value="0"     name="VK_ATTACHMENT_STORE_OP_STORE"/>
        <enum value="1"     name="VK_ATTACHMENT_STORE_OP_DONT_CARE"/>
    </enums>
    <enums name="VkImageType" type="enum">
        <enum value="0"     name="VK_IMAGE_TYPE_1D"/>
        <enum value="1"     name="VK_IMAGE_TYPE_2D"/>
        <enum value="2"     name="VK_IMAGE_TYPE_3D"/>
    </enums>
    <enums name="VkImageTiling" type="enum">
        <enum value="0"     name="VK_IMAGE_TILING_OPTIMAL"/>
        <enum value="1"     name="VK_IMAGE_TILING_LINEAR"/>
    </enums>
    <enums name="VkImageViewType" type="enum">
        <enum value="0"     name="VK_IMAGE_VIEW_TYPE_1D"/>
        <enum value="1"     name="VK_IMAGE_VIEW_TYPE_2D"/>
        <enum value="2"     name="VK_IMAGE_VIEW_TYPE_3D"/>
        <enum value="3"     name="VK_IMAGE_VIEW_TYPE_CUBE"/>
        <enum value="4"     name="VK_IMAGE_VIEW_TYPE_1D_ARRAY"/>
        <enum value="5"     name="VK_IMAGE_VIEW_TYPE_2D_ARRAY"/>
        <enum value="6"     name="VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"/>
    </enums>
    <enums name="VkCommandBufferLevel" type="enum">
        <enum value="0"     name="VK_COMMAND_BUFFER_LEVEL_PRIMARY"/>
        <enum value="1"     name="VK_COMMAND_BUFFER_LEVEL_SECONDARY"/>
    </enums>
    <enums name="VkComponentSwizzle" type="enum">
        <enum value="0"     name="VK_COMPONENT_SWIZZLE_IDENTITY"/>
        <enum value="1"     name="VK_COMPONENT_SWIZZLE_ZERO"/>
        <enum value="2"     name="VK_COMPONENT_SWIZZLE_ONE"/>
        <enum value="3"     name="VK_COMPONENT_SWIZZLE_R"/>
        <enum value="4"     name="VK_COMPONENT_SWIZZLE_G"/>
        <enum value="5"     name="VK_COMPONENT_SWIZZLE_B"/>
        <enum value="6"     name="VK_COMPONENT_SWIZZLE_A"/>
    </enums>
    <enums name="VkDescriptorType" type="enum">
        <enum value="0"     name="VK_DESCRIPTOR_TYPE_SAMPLER"/>
        <enum value="1"     name="VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"/>
        <enum value="2"     name="VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE"/>
        <enum value="3"     name="VK_DESCRIPTOR_TYPE_STORAGE_IMAGE"/>
        <enum value="4"     name="VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER"/>
        <enum value="5"     name="VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER"/>
        <enum value="6"     name="VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER"/>
        <enum value="7"     name="VK_DESCRIPTOR_TYPE_STORAGE_BUFFER"/>
        <enum value="8"     name="VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC"/>
        <enum value="9"     name="VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC"/>
        <enum value="10"    name="VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT"/>
    </enums>
    <enums name="VkQueryType" type="enum">
        <enum value="0"     name="VK_QUERY_TYPE_OCCLUSION"/>
        <enum value="1"     name="VK_QUERY_TYPE_PIPELINE_STATISTICS"                 comment="Optional"/>
        <enum value="2"     name="VK_QUERY_TYPE_TIMESTAMP"/>
    </enums>
    <enums name="VkBorderColor" type="enum">
        <enum value="0"     name="VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK"/>
        <enum value="1"     name="VK_BORDER_COLOR_INT_TRANSPARENT_BLACK"/>
        <enum value="2"     name="VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK"/>
        <enum value="3"     name="VK_BORDER_COLOR_INT_OPAQUE_BLACK"/>
        <enum value="4"     name="VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE"/>
        <enum value="5"     name="VK_BORDER_COLOR_INT_OPAQUE_WHITE"/>
    </enums>
    <enums name="VkPipelineBindPoint" type="enum">
        <enum value="0"     name="VK_PIPELINE_BIND_POINT_GRAPHICS"/>
        <enum value="1"     name="VK_PIPELINE_BIND_POINT_COMPUTE"/>
    </enums>
    <enums name="VkPipelineCacheHeaderVersion" type="enum">
        <enum value="1"     name="VK_PIPELINE_CACHE_HEADER_VERSION_ONE"/>
    </enums>
    <enums name="VkPipelineCacheCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkPrimitiveTopology" type="enum">
        <enum value="0"     name="VK_PRIMITIVE_TOPOLOGY_POINT_LIST"/>
        <enum value="1"     name="VK_PRIMITIVE_TOPOLOGY_LINE_LIST"/>
        <enum value="2"     name="VK_PRIMITIVE_TOPOLOGY_LINE_STRIP"/>
        <enum value="3"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST"/>
        <enum value="4"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP"/>
        <enum value="5"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN"/>
        <enum value="6"     name="VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY"/>
        <enum value="7"     name="VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY"/>
        <enum value="8"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY"/>
        <enum value="9"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY"/>
        <enum value="10"    name="VK_PRIMITIVE_TOPOLOGY_PATCH_LIST"/>
    </enums>
    <enums name="VkSharingMode" type="enum">
        <enum value="0"     name="VK_SHARING_MODE_EXCLUSIVE"/>
        <enum value="1"     name="VK_SHARING_MODE_CONCURRENT"/>
    </enums>
    <enums name="VkIndexType" type="enum">
        <enum value="0"     name="VK_INDEX_TYPE_UINT16"/>
        <enum value="1"     name="VK_INDEX_TYPE_UINT32"/>
    </enums>
    <enums name="VkFilter" type="enum">
        <enum value="0"     name="VK_FILTER_NEAREST"/>
        <enum value="1"     name="VK_FILTER_LINEAR"/>
    </enums>
    <enums name="VkSamplerMipmapMode" type="enum">
        <enum value="0"     name="VK_SAMPLER_MIPMAP_MODE_NEAREST"                        comment="Choose nearest mip level"/>
        <enum value="1"     name="VK_SAMPLER_MIPMAP_MODE_LINEAR"                         comment="Linear filter between mip levels"/>
    </enums>
    <enums name="VkSamplerAddressMode" type="enum">
        <enum value="0"     name="VK_SAMPLER_ADDRESS_MODE_REPEAT"/>
        <enum value="1"     name="VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT"/>
        <enum value="2"     name="VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE"/>
        <enum value="3"     name="VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"/>
            <comment>
                value="4" reserved for VK_KHR_sampler_mirror_clamp_to_edge
                enum VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE; do not
                alias!
            </comment>
    </enums>
    <enums name="VkCompareOp" type="enum">
        <enum value="0"     name="VK_COMPARE_OP_NEVER"/>
        <enum value="1"     name="VK_COMPARE_OP_LESS"/>
        <enum value="2"     name="VK_COMPARE_OP_EQUAL"/>
        <enum value="3"     name="VK_COMPARE_OP_LESS_OR_EQUAL"/>
        <enum value="4"     name="VK_COMPARE_OP_GREATER"/>
        <enum value="5"     name="VK_COMPARE_OP_NOT_EQUAL"/>
        <enum value="6"     name="VK_COMPARE_OP_GREATER_OR_EQUAL"/>
        <enum value="7"     name="VK_COMPARE_OP_ALWAYS"/>
    </enums>
    <enums name="VkPolygonMode" type="enum">
        <enum value="0"     name="VK_POLYGON_MODE_FILL"/>
        <enum value="1"     name="VK_POLYGON_MODE_LINE"/>
        <enum value="2"     name="VK_POLYGON_MODE_POINT"/>
    </enums>
    <enums name="VkFrontFace" type="enum">
        <enum value="0"     name="VK_FRONT_FACE_COUNTER_CLOCKWISE"/>
        <enum value="1"     name="VK_FRONT_FACE_CLOCKWISE"/>
    </enums>
    <enums name="VkBlendFactor" type="enum">
        <enum value="0"     name="VK_BLEND_FACTOR_ZERO"/>
        <enum value="1"     name="VK_BLEND_FACTOR_ONE"/>
        <enum value="2"     name="VK_BLEND_FACTOR_SRC_COLOR"/>
        <enum value="3"     name="VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR"/>
        <enum value="4"     name="VK_BLEND_FACTOR_DST_COLOR"/>
        <enum value="5"     name="VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR"/>
        <enum value="6"     name="VK_BLEND_FACTOR_SRC_ALPHA"/>
        <enum value="7"     name="VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA"/>
        <enum value="8"     name="VK_BLEND_FACTOR_DST_ALPHA"/>
        <enum value="9"     name="VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA"/>
        <enum value="10"    name="VK_BLEND_FACTOR_CONSTANT_COLOR"/>
        <enum value="11"    name="VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR"/>
        <enum value="12"    name="VK_BLEND_FACTOR_CONSTANT_ALPHA"/>
        <enum value="13"    name="VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA"/>
        <enum value="14"    name="VK_BLEND_FACTOR_SRC_ALPHA_SATURATE"/>
        <enum value="15"    name="VK_BLEND_FACTOR_SRC1_COLOR"/>
        <enum value="16"    name="VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR"/>
        <enum value="17"    name="VK_BLEND_FACTOR_SRC1_ALPHA"/>
        <enum value="18"    name="VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA"/>
    </enums>
    <enums name="VkBlendOp" type="enum">
        <enum value="0"     name="VK_BLEND_OP_ADD"/>
        <enum value="1"     name="VK_BLEND_OP_SUBTRACT"/>
        <enum value="2"     name="VK_BLEND_OP_REVERSE_SUBTRACT"/>
        <enum value="3"     name="VK_BLEND_OP_MIN"/>
        <enum value="4"     name="VK_BLEND_OP_MAX"/>
    </enums>
    <enums name="VkStencilOp" type="enum">
        <enum value="0"     name="VK_STENCIL_OP_KEEP"/>
        <enum value="1"     name="VK_STENCIL_OP_ZERO"/>
        <enum value="2"     name="VK_STENCIL_OP_REPLACE"/>
        <enum value="3"     name="VK_STENCIL_OP_INCREMENT_AND_CLAMP"/>
        <enum value="4"     name="VK_STENCIL_OP_DECREMENT_AND_CLAMP"/>
        <enum value="5"     name="VK_STENCIL_OP_INVERT"/>
        <enum value="6"     name="VK_STENCIL_OP_INCREMENT_AND_WRAP"/>
        <enum value="7"     name="VK_STENCIL_OP_DECREMENT_AND_WRAP"/>
    </enums>
    <enums name="VkLogicOp" type="enum">
        <enum value="0"     name="VK_LOGIC_OP_CLEAR"/>
        <enum value="1"     name="VK_LOGIC_OP_AND"/>
        <enum value="2"     name="VK_LOGIC_OP_AND_REVERSE"/>
        <enum value="3"     name="VK_LOGIC_OP_COPY"/>
        <enum value="4"     name="VK_LOGIC_OP_AND_INVERTED"/>
        <enum value="5"     name="VK_LOGIC_OP_NO_OP"/>
        <enum value="6"     name="VK_LOGIC_OP_XOR"/>
        <enum value="7"     name="VK_LOGIC_OP_OR"/>
        <enum value="8"     name="VK_LOGIC_OP_NOR"/>
        <enum value="9"     name="VK_LOGIC_OP_EQUIVALENT"/>
        <enum value="10"    name="VK_LOGIC_OP_INVERT"/>
        <enum value="11"    name="VK_LOGIC_OP_OR_REVERSE"/>
        <enum value="12"    name="VK_LOGIC_OP_COPY_INVERTED"/>
        <enum value="13"    name="VK_LOGIC_OP_OR_INVERTED"/>
        <enum value="14"    name="VK_LOGIC_OP_NAND"/>
        <enum value="15"    name="VK_LOGIC_OP_SET"/>
    </enums>
    <enums name="VkInternalAllocationType" type="enum">
        <enum value="0"     name="VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE"/>
    </enums>
    <enums name="VkSystemAllocationScope" type="enum">
        <enum value="0"     name="VK_SYSTEM_ALLOCATION_SCOPE_COMMAND"/>
        <enum value="1"     name="VK_SYSTEM_ALLOCATION_SCOPE_OBJECT"/>
        <enum value="2"     name="VK_SYSTEM_ALLOCATION_SCOPE_CACHE"/>
        <enum value="3"     name="VK_SYSTEM_ALLOCATION_SCOPE_DEVICE"/>
        <enum value="4"     name="VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE"/>
    </enums>
    <enums name="VkPhysicalDeviceType" type="enum">
        <enum value="0"     name="VK_PHYSICAL_DEVICE_TYPE_OTHER"/>
        <enum value="1"     name="VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU"/>
        <enum value="2"     name="VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU"/>
        <enum value="3"     name="VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU"/>
        <enum value="4"     name="VK_PHYSICAL_DEVICE_TYPE_CPU"/>
    </enums>
    <enums name="VkVertexInputRate" type="enum">
        <enum value="0"     name="VK_VERTEX_INPUT_RATE_VERTEX"/>
        <enum value="1"     name="VK_VERTEX_INPUT_RATE_INSTANCE"/>
    </enums>
    <enums name="VkFormat" type="enum" comment="Vulkan format definitions">
        <enum value="0"     name="VK_FORMAT_UNDEFINED"/>
        <enum value="1"     name="VK_FORMAT_R4G4_UNORM_PACK8"/>
        <enum value="2"     name="VK_FORMAT_R4G4B4A4_UNORM_PACK16"/>
        <enum value="3"     name="VK_FORMAT_B4G4R4A4_UNORM_PACK16"/>
        <enum value="4"     name="VK_FORMAT_R5G6B5_UNORM_PACK16"/>
        <enum value="5"     name="VK_FORMAT_B5G6R5_UNORM_PACK16"/>
        <enum value="6"     name="VK_FORMAT_R5G5B5A1_UNORM_PACK16"/>
        <enum value="7"     name="VK_FORMAT_B5G5R5A1_UNORM_PACK16"/>
        <enum value="8"     name="VK_FORMAT_A1R5G5B5_UNORM_PACK16"/>
        <enum value="9"     name="VK_FORMAT_R8_UNORM"/>
        <enum value="10"    name="VK_FORMAT_R8_SNORM"/>
        <enum value="11"    name="VK_FORMAT_R8_USCALED"/>
        <enum value="12"    name="VK_FORMAT_R8_SSCALED"/>
        <enum value="13"    name="VK_FORMAT_R8_UINT"/>
        <enum value="14"    name="VK_FORMAT_R8_SINT"/>
        <enum value="15"    name="VK_FORMAT_R8_SRGB"/>
        <enum value="16"    name="VK_FORMAT_R8G8_UNORM"/>
        <enum value="17"    name="VK_FORMAT_R8G8_SNORM"/>
        <enum value="18"    name="VK_FORMAT_R8G8_USCALED"/>
        <enum value="19"    name="VK_FORMAT_R8G8_SSCALED"/>
        <enum value="20"    name="VK_FORMAT_R8G8_UINT"/>
        <enum value="21"    name="VK_FORMAT_R8G8_SINT"/>
        <enum value="22"    name="VK_FORMAT_R8G8_SRGB"/>
        <enum value="23"    name="VK_FORMAT_R8G8B8_UNORM"/>
        <enum value="24"    name="VK_FORMAT_R8G8B8_SNORM"/>
        <enum value="25"    name="VK_FORMAT_R8G8B8_USCALED"/>
        <enum value="26"    name="VK_FORMAT_R8G8B8_SSCALED"/>
        <enum value="27"    name="VK_FORMAT_R8G8B8_UINT"/>
        <enum value="28"    name="VK_FORMAT_R8G8B8_SINT"/>
        <enum value="29"    name="VK_FORMAT_R8G8B8_SRGB"/>
        <enum value="30"    name="VK_FORMAT_B8G8R8_UNORM"/>
        <enum value="31"    name="VK_FORMAT_B8G8R8_SNORM"/>
        <enum value="32"    name="VK_FORMAT_B8G8R8_USCALED"/>
        <enum value="33"    name="VK_FORMAT_B8G8R8_SSCALED"/>
        <enum value="34"    name="VK_FORMAT_B8G8R8_UINT"/>
        <enum value="35"    name="VK_FORMAT_B8G8R8_SINT"/>
        <enum value="36"    name="VK_FORMAT_B8G8R8_SRGB"/>
        <enum value="37"    name="VK_FORMAT_R8G8B8A8_UNORM"/>
        <enum value="38"    name="VK_FORMAT_R8G8B8A8_SNORM"/>
        <enum value="39"    name="VK_FORMAT_R8G8B8A8_USCALED"/>
        <enum value="40"    name="VK_FORMAT_R8G8B8A8_SSCALED"/>
        <enum value="41"    name="VK_FORMAT_R8G8B8A8_UINT"/>
        <enum value="42"    name="VK_FORMAT_R8G8B8A8_SINT"/>
        <enum value="43"    name="VK_FORMAT_R8G8B8A8_SRGB"/>
        <enum value="44"    name="VK_FORMAT_B8G8R8A8_UNORM"/>
        <enum value="45"    name="VK_FORMAT_B8G8R8A8_SNORM"/>
        <enum value="46"    name="VK_FORMAT_B8G8R8A8_USCALED"/>
        <enum value="47"    name="VK_FORMAT_B8G8R8A8_SSCALED"/>
        <enum value="48"    name="VK_FORMAT_B8G8R8A8_UINT"/>
        <enum value="49"    name="VK_FORMAT_B8G8R8A8_SINT"/>
        <enum value="50"    name="VK_FORMAT_B8G8R8A8_SRGB"/>
        <enum value="51"    name="VK_FORMAT_A8B8G8R8_UNORM_PACK32"/>
        <enum value="52"    name="VK_FORMAT_A8B8G8R8_SNORM_PACK32"/>
        <enum value="53"    name="VK_FORMAT_A8B8G8R8_USCALED_PACK32"/>
        <enum value="54"    name="VK_FORMAT_A8B8G8R8_SSCALED_PACK32"/>
        <enum value="55"    name="VK_FORMAT_A8B8G8R8_UINT_PACK32"/>
        <enum value="56"    name="VK_FORMAT_A8B8G8R8_SINT_PACK32"/>
        <enum value="57"    name="VK_FORMAT_A8B8G8R8_SRGB_PACK32"/>
        <enum value="58"    name="VK_FORMAT_A2R10G10B10_UNORM_PACK32"/>
        <enum value="59"    name="VK_FORMAT_A2R10G10B10_SNORM_PACK32"/>
        <enum value="60"    name="VK_FORMAT_A2R10G10B10_USCALED_PACK32"/>
        <enum value="61"    name="VK_FORMAT_A2R10G10B10_SSCALED_PACK32"/>
        <enum value="62"    name="VK_FORMAT_A2R10G10B10_UINT_PACK32"/>
        <enum value="63"    name="VK_FORMAT_A2R10G10B10_SINT_PACK32"/>
        <enum value="64"    name="VK_FORMAT_A2B10G10R10_UNORM_PACK32"/>
        <enum value="65"    name="VK_FORMAT_A2B10G10R10_SNORM_PACK32"/>
        <enum value="66"    name="VK_FORMAT_A2B10G10R10_USCALED_PACK32"/>
        <enum value="67"    name="VK_FORMAT_A2B10G10R10_SSCALED_PACK32"/>
        <enum value="68"    name="VK_FORMAT_A2B10G10R10_UINT_PACK32"/>
        <enum value="69"    name="VK_FORMAT_A2B10G10R10_SINT_PACK32"/>
        <enum value="70"    name="VK_FORMAT_R16_UNORM"/>
        <enum value="71"    name="VK_FORMAT_R16_SNORM"/>
        <enum value="72"    name="VK_FORMAT_R16_USCALED"/>
        <enum value="73"    name="VK_FORMAT_R16_SSCALED"/>
        <enum value="74"    name="VK_FORMAT_R16_UINT"/>
        <enum value="75"    name="VK_FORMAT_R16_SINT"/>
        <enum value="76"    name="VK_FORMAT_R16_SFLOAT"/>
        <enum value="77"    name="VK_FORMAT_R16G16_UNORM"/>
        <enum value="78"    name="VK_FORMAT_R16G16_SNORM"/>
        <enum value="79"    name="VK_FORMAT_R16G16_USCALED"/>
        <enum value="80"    name="VK_FORMAT_R16G16_SSCALED"/>
        <enum value="81"    name="VK_FORMAT_R16G16_UINT"/>
        <enum value="82"    name="VK_FORMAT_R16G16_SINT"/>
        <enum value="83"    name="VK_FORMAT_R16G16_SFLOAT"/>
        <enum value="84"    name="VK_FORMAT_R16G16B16_UNORM"/>
        <enum value="85"    name="VK_FORMAT_R16G16B16_SNORM"/>
        <enum value="86"    name="VK_FORMAT_R16G16B16_USCALED"/>
        <enum value="87"    name="VK_FORMAT_R16G16B16_SSCALED"/>
        <enum value="88"    name="VK_FORMAT_R16G16B16_UINT"/>
        <enum value="89"    name="VK_FORMAT_R16G16B16_SINT"/>
        <enum value="90"    name="VK_FORMAT_R16G16B16_SFLOAT"/>
        <enum value="91"    name="VK_FORMAT_R16G16B16A16_UNORM"/>
        <enum value="92"    name="VK_FORMAT_R16G16B16A16_SNORM"/>
        <enum value="93"    name="VK_FORMAT_R16G16B16A16_USCALED"/>
        <enum value="94"    name="VK_FORMAT_R16G16B16A16_SSCALED"/>
        <enum value="95"    name="VK_FORMAT_R16G16B16A16_UINT"/>
        <enum value="96"    name="VK_FORMAT_R16G16B16A16_SINT"/>
        <enum value="97"    name="VK_FORMAT_R16G16B16A16_SFLOAT"/>
        <enum value="98"    name="VK_FORMAT_R32_UINT"/>
        <enum value="99"    name="VK_FORMAT_R32_SINT"/>
        <enum value="100"   name="VK_FORMAT_R32_SFLOAT"/>
        <enum value="101"   name="VK_FORMAT_R32G32_UINT"/>
        <enum value="102"   name="VK_FORMAT_R32G32_SINT"/>
        <enum value="103"   name="VK_FORMAT_R32G32_SFLOAT"/>
        <enum value="104"   name="VK_FORMAT_R32G32B32_UINT"/>
        <enum value="105"   name="VK_FORMAT_R32G32B32_SINT"/>
        <enum value="106"   name="VK_FORMAT_R32G32B32_SFLOAT"/>
        <enum value="107"   name="VK_FORMAT_R32G32B32A32_UINT"/>
        <enum value="108"   name="VK_FORMAT_R32G32B32A32_SINT"/>
        <enum value="109"   name="VK_FORMAT_R32G32B32A32_SFLOAT"/>
        <enum value="110"   name="VK_FORMAT_R64_UINT"/>
        <enum value="111"   name="VK_FORMAT_R64_SINT"/>
        <enum value="112"   name="VK_FORMAT_R64_SFLOAT"/>
        <enum value="113"   name="VK_FORMAT_R64G64_UINT"/>
        <enum value="114"   name="VK_FORMAT_R64G64_SINT"/>
        <enum value="115"   name="VK_FORMAT_R64G64_SFLOAT"/>
        <enum value="116"   name="VK_FORMAT_R64G64B64_UINT"/>
        <enum value="117"   name="VK_FORMAT_R64G64B64_SINT"/>
        <enum value="118"   name="VK_FORMAT_R64G64B64_SFLOAT"/>
        <enum value="119"   name="VK_FORMAT_R64G64B64A64_UINT"/>
        <enum value="120"   name="VK_FORMAT_R64G64B64A64_SINT"/>
        <enum value="121"   name="VK_FORMAT_R64G64B64A64_SFLOAT"/>
        <enum value="122"   name="VK_FORMAT_B10G11R11_UFLOAT_PACK32"/>
        <enum value="123"   name="VK_FORMAT_E5B9G9R9_UFLOAT_PACK32"/>
        <enum value="124"   name="VK_FORMAT_D16_UNORM"/>
        <enum value="125"   name="VK_FORMAT_X8_D24_UNORM_PACK32"/>
        <enum value="126"   name="VK_FORMAT_D32_SFLOAT"/>
        <enum value="127"   name="VK_FORMAT_S8_UINT"/>
        <enum value="128"   name="VK_FORMAT_D16_UNORM_S8_UINT"/>
        <enum value="129"   name="VK_FORMAT_D24_UNORM_S8_UINT"/>
        <enum value="130"   name="VK_FORMAT_D32_SFLOAT_S8_UINT"/>
        <enum value="131"   name="VK_FORMAT_BC1_RGB_UNORM_BLOCK"/>
        <enum value="132"   name="VK_FORMAT_BC1_RGB_SRGB_BLOCK"/>
        <enum value="133"   name="VK_FORMAT_BC1_RGBA_UNORM_BLOCK"/>
        <enum value="134"   name="VK_FORMAT_BC1_RGBA_SRGB_BLOCK"/>
        <enum value="135"   name="VK_FORMAT_BC2_UNORM_BLOCK"/>
        <enum value="136"   name="VK_FORMAT_BC2_SRGB_BLOCK"/>
        <enum value="137"   name="VK_FORMAT_BC3_UNORM_BLOCK"/>
        <enum value="138"   name="VK_FORMAT_BC3_SRGB_BLOCK"/>
        <enum value="139"   name="VK_FORMAT_BC4_UNORM_BLOCK"/>
        <enum value="140"   name="VK_FORMAT_BC4_SNORM_BLOCK"/>
        <enum value="141"   name="VK_FORMAT_BC5_UNORM_BLOCK"/>
        <enum value="142"   name="VK_FORMAT_BC5_SNORM_BLOCK"/>
        <enum value="143"   name="VK_FORMAT_BC6H_UFLOAT_BLOCK"/>
        <enum value="144"   name="VK_FORMAT_BC6H_SFLOAT_BLOCK"/>
        <enum value="145"   name="VK_FORMAT_BC7_UNORM_BLOCK"/>
        <enum value="146"   name="VK_FORMAT_BC7_SRGB_BLOCK"/>
        <enum value="147"   name="VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK"/>
        <enum value="148"   name="VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK"/>
        <enum value="149"   name="VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK"/>
        <enum value="150"   name="VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK"/>
        <enum value="151"   name="VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK"/>
        <enum value="152"   name="VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK"/>
        <enum value="153"   name="VK_FORMAT_EAC_R11_UNORM_BLOCK"/>
        <enum value="154"   name="VK_FORMAT_EAC_R11_SNORM_BLOCK"/>
        <enum value="155"   name="VK_FORMAT_EAC_R11G11_UNORM_BLOCK"/>
        <enum value="156"   name="VK_FORMAT_EAC_R11G11_SNORM_BLOCK"/>
        <enum value="157"   name="VK_FORMAT_ASTC_4x4_UNORM_BLOCK"/>
        <enum value="158"   name="VK_FORMAT_ASTC_4x4_SRGB_BLOCK"/>
        <enum value="159"   name="VK_FORMAT_ASTC_5x4_UNORM_BLOCK"/>
        <enum value="160"   name="VK_FORMAT_ASTC_5x4_SRGB_BLOCK"/>
        <enum value="161"   name="VK_FORMAT_ASTC_5x5_UNORM_BLOCK"/>
        <enum value="162"   name="VK_FORMAT_ASTC_5x5_SRGB_BLOCK"/>
        <enum value="163"   name="VK_FORMAT_ASTC_6x5_UNORM_BLOCK"/>
        <enum value="164"   name="VK_FORMAT_ASTC_6x5_SRGB_BLOCK"/>
        <enum value="165"   name="VK_FORMAT_ASTC_6x6_UNORM_BLOCK"/>
        <enum value="166"   name="VK_FORMAT_ASTC_6x6_SRGB_BLOCK"/>
        <enum value="167"   name="VK_FORMAT_ASTC_8x5_UNORM_BLOCK"/>
        <enum value="168"   name="VK_FORMAT_ASTC_8x5_SRGB_BLOCK"/>
        <enum value="169"   name="VK_FORMAT_ASTC_8x6_UNORM_BLOCK"/>
        <enum value="170"   name="VK_FORMAT_ASTC_8x6_SRGB_BLOCK"/>
        <enum value="171"   name="VK_FORMAT_ASTC_8x8_UNORM_BLOCK"/>
        <enum value="172"   name="VK_FORMAT_ASTC_8x8_SRGB_BLOCK"/>
        <enum value="173"   name="VK_FORMAT_ASTC_10x5_UNORM_BLOCK"/>
        <enum value="174"   name="VK_FORMAT_ASTC_10x5_SRGB_BLOCK"/>
        <enum value="175"   name="VK_FORMAT_ASTC_10x6_UNORM_BLOCK"/>
        <enum value="176"   name="VK_FORMAT_ASTC_10x6_SRGB_BLOCK"/>
        <enum value="177"   name="VK_FORMAT_ASTC_10x8_UNORM_BLOCK"/>
        <enum value="178"   name="VK_FORMAT_ASTC_10x8_SRGB_BLOCK"/>
        <enum value="179"   name="VK_FORMAT_ASTC_10x10_UNORM_BLOCK"/>
        <enum value="180"   name="VK_FORMAT_ASTC_10x10_SRGB_BLOCK"/>
        <enum value="181"   name="VK_FORMAT_ASTC_12x10_UNORM_BLOCK"/>
        <enum value="182"   name="VK_FORMAT_ASTC_12x10_SRGB_BLOCK"/>
        <enum value="183"   name="VK_FORMAT_ASTC_12x12_UNORM_BLOCK"/>
        <enum value="184"   name="VK_FORMAT_ASTC_12x12_SRGB_BLOCK"/>
    </enums>
    <enums name="VkStructureType" type="enum" comment="Structure type enumerant">
        <enum value="0"     name="VK_STRUCTURE_TYPE_APPLICATION_INFO"/>
        <enum value="1"     name="VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"/>
        <enum value="2"     name="VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"/>
        <enum value="3"     name="VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"/>
        <enum value="4"     name="VK_STRUCTURE_TYPE_SUBMIT_INFO"/>
        <enum value="5"     name="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"/>
        <enum value="6"     name="VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"/>
        <enum value="7"     name="VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"/>
        <enum value="8"     name="VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"/>
        <enum value="9"     name="VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"/>
        <enum value="10"    name="VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"/>
        <enum value="11"    name="VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"/>
        <enum value="12"    name="VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"/>
        <enum value="13"    name="VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"/>
        <enum value="14"    name="VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"/>
        <enum value="15"    name="VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"/>
        <enum value="16"    name="VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"/>
        <enum value="17"    name="VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"/>
        <enum value="18"    name="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"/>
        <enum value="19"    name="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"/>
        <enum value="20"    name="VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"/>
        <enum value="21"    name="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"/>
        <enum value="22"    name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"/>
        <enum value="23"    name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"/>
        <enum value="24"    name="VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"/>
        <enum value="25"    name="VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"/>
        <enum value="26"    name="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"/>
        <enum value="27"    name="VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"/>
        <enum value="28"    name="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"/>
        <enum value="29"    name="VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"/>
        <enum value="30"    name="VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"/>
        <enum value="31"    name="VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"/>
        <enum value="32"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"/>
        <enum value="33"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"/>
        <enum value="34"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"/>
        <enum value="35"    name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"/>
        <enum value="36"    name="VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"/>
        <enum value="37"    name="VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"/>
        <enum value="38"    name="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"/>
        <enum value="39"    name="VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"/>
        <enum value="40"    name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"/>
        <enum value="41"    name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"/>
        <enum value="42"    name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"/>
        <enum value="43"    name="VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"/>
        <enum value="44"    name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"/>
        <enum value="45"    name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"/>
        <enum value="46"    name="VK_STRUCTURE_TYPE_MEMORY_BARRIER"/>
        <enum value="47"    name="VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO" comment="Reserved for internal use by the loader, layers, and ICDs"/>
        <enum value="48"    name="VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO" comment="Reserved for internal use by the loader, layers, and ICDs"/>
    </enums>
    <enums name="VkSubpassContents" type="enum">
        <enum value="0"     name="VK_SUBPASS_CONTENTS_INLINE"/>
        <enum value="1"     name="VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS"/>
    </enums>
    <enums name="VkResult" type="enum" comment="API result codes">
            <comment>Return codes (positive values)</comment>
        <enum value="0"     name="VK_SUCCESS" comment="Command completed successfully"/>
        <enum value="1"     name="VK_NOT_READY" comment="A fence or query has not yet completed"/>
        <enum value="2"     name="VK_TIMEOUT" comment="A wait operation has not completed in the specified time"/>
        <enum value="3"     name="VK_EVENT_SET" comment="An event is signaled"/>
        <enum value="4"     name="VK_EVENT_RESET" comment="An event is unsignaled"/>
        <enum value="5"     name="VK_INCOMPLETE" comment="A return array was too small for the result"/>
            <comment>Error codes (negative values)</comment>
        <enum value="-1"    name="VK_ERROR_OUT_OF_HOST_MEMORY" comment="A host memory allocation has failed"/>
        <enum value="-2"    name="VK_ERROR_OUT_OF_DEVICE_MEMORY" comment="A device memory allocation has failed"/>
        <enum value="-3"    name="VK_ERROR_INITIALIZATION_FAILED" comment="Initialization of an object has failed"/>
        <enum value="-4"    name="VK_ERROR_DEVICE_LOST" comment="The logical device has been lost. See &lt;&lt;devsandqueues-lost-device&gt;&gt;"/>
        <enum value="-5"    name="VK_ERROR_MEMORY_MAP_FAILED" comment="Mapping of a memory object has failed"/>
        <enum value="-6"    name="VK_ERROR_LAYER_NOT_PRESENT" comment="Layer specified does not exist"/>
        <enum value="-7"    name="VK_ERROR_EXTENSION_NOT_PRESENT" comment="Extension specified does not exist"/>
        <enum value="-8"    name="VK_ERROR_FEATURE_NOT_PRESENT" comment="Requested feature is not available on this device"/>
        <enum value="-9"    name="VK_ERROR_INCOMPATIBLE_DRIVER" comment="Unable to find a Vulkan driver"/>
        <enum value="-10"   name="VK_ERROR_TOO_MANY_OBJECTS" comment="Too many objects of the type have already been created"/>
        <enum value="-11"   name="VK_ERROR_FORMAT_NOT_SUPPORTED" comment="Requested format is not supported on this device"/>
        <enum value="-12"   name="VK_ERROR_FRAGMENTED_POOL" comment="A requested pool allocation has failed due to fragmentation of the pool's memory"/>
        <enum value="-13"   name="VK_ERROR_UNKNOWN" comment="An unknown error has occurred, due to an implementation or application bug"/>
            <unused start="-14" comment="This is the next unused available error code (negative value)"/>
    </enums>
    <enums name="VkDynamicState" type="enum">
        <enum value="0"     name="VK_DYNAMIC_STATE_VIEWPORT"/>
        <enum value="1"     name="VK_DYNAMIC_STATE_SCISSOR"/>
        <enum value="2"     name="VK_DYNAMIC_STATE_LINE_WIDTH"/>
        <enum value="3"     name="VK_DYNAMIC_STATE_DEPTH_BIAS"/>
        <enum value="4"     name="VK_DYNAMIC_STATE_BLEND_CONSTANTS"/>
        <enum value="5"     name="VK_DYNAMIC_STATE_DEPTH_BOUNDS"/>
        <enum value="6"     name="VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK"/>
        <enum value="7"     name="VK_DYNAMIC_STATE_STENCIL_WRITE_MASK"/>
        <enum value="8"     name="VK_DYNAMIC_STATE_STENCIL_REFERENCE"/>
    </enums>
    <enums name="VkDescriptorUpdateTemplateType" type="enum">
        <enum value="0"     name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET"   comment="Create descriptor update template for descriptor set updates"/>
    </enums>
    <enums name="VkObjectType" type="enum" comment="Enums to track objects of various types - also see objtypeenum attributes on type tags">
        <enum value="0"     name="VK_OBJECT_TYPE_UNKNOWN"/>
        <enum value="1"     name="VK_OBJECT_TYPE_INSTANCE"/>
        <enum value="2"     name="VK_OBJECT_TYPE_PHYSICAL_DEVICE"/>
        <enum value="3"     name="VK_OBJECT_TYPE_DEVICE"/>
        <enum value="4"     name="VK_OBJECT_TYPE_QUEUE"/>
        <enum value="5"     name="VK_OBJECT_TYPE_SEMAPHORE"/>
        <enum value="6"     name="VK_OBJECT_TYPE_COMMAND_BUFFER"/>
        <enum value="7"     name="VK_OBJECT_TYPE_FENCE"/>
        <enum value="8"     name="VK_OBJECT_TYPE_DEVICE_MEMORY"/>
        <enum value="9"     name="VK_OBJECT_TYPE_BUFFER"/>
        <enum value="10"    name="VK_OBJECT_TYPE_IMAGE"/>
        <enum value="11"    name="VK_OBJECT_TYPE_EVENT"/>
        <enum value="12"    name="VK_OBJECT_TYPE_QUERY_POOL"/>
        <enum value="13"    name="VK_OBJECT_TYPE_BUFFER_VIEW"/>
        <enum value="14"    name="VK_OBJECT_TYPE_IMAGE_VIEW"/>
        <enum value="15"    name="VK_OBJECT_TYPE_SHADER_MODULE"/>
        <enum value="16"    name="VK_OBJECT_TYPE_PIPELINE_CACHE"/>
        <enum value="17"    name="VK_OBJECT_TYPE_PIPELINE_LAYOUT"/>
        <enum value="18"    name="VK_OBJECT_TYPE_RENDER_PASS"/>
        <enum value="19"    name="VK_OBJECT_TYPE_PIPELINE"/>
        <enum value="20"    name="VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT"/>
        <enum value="21"    name="VK_OBJECT_TYPE_SAMPLER"/>
        <enum value="22"    name="VK_OBJECT_TYPE_DESCRIPTOR_POOL"/>
        <enum value="23"    name="VK_OBJECT_TYPE_DESCRIPTOR_SET"/>
        <enum value="24"    name="VK_OBJECT_TYPE_FRAMEBUFFER"/>
        <enum value="25"    name="VK_OBJECT_TYPE_COMMAND_POOL"/>
    </enums>
    <enums name="VkRayTracingInvocationReorderModeEXT" type="enum">
        <enum value="0"     name="VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_EXT"/>
        <enum value="1"     name="VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_EXT"/>
    </enums>
    <enums name="VkRayTracingLssIndexingModeNV" type="enum">
        <enum value="0" name="VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV"/>
        <enum value="1" name="VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV"/>
    </enums>
    <enums name="VkRayTracingLssPrimitiveEndCapsModeNV" type="enum">
        <enum value="0" name="VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV"/>
        <enum value="1" name="VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV"/>
    </enums>
    <enums name="VkDirectDriverLoadingModeLUNARG" type="enum">
        <enum value="0"     name="VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG"/>
        <enum value="1"     name="VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG"/>
    </enums>
    <enums name="VkAntiLagModeAMD" type="enum">
        <enum value="0"     name="VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD"/>
        <enum value="1"     name="VK_ANTI_LAG_MODE_ON_AMD"/>
        <enum value="2"     name="VK_ANTI_LAG_MODE_OFF_AMD"/>
    </enums>
    <enums name="VkAntiLagStageAMD" type="enum">
        <enum value="0"     name="VK_ANTI_LAG_STAGE_INPUT_AMD"/>
        <enum value="1"     name="VK_ANTI_LAG_STAGE_PRESENT_AMD"/>
    </enums>

        <comment>Flags</comment>
    <enums name="VkQueueFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_QUEUE_GRAPHICS_BIT"                             comment="Queue supports graphics operations"/>
        <enum bitpos="1"    name="VK_QUEUE_COMPUTE_BIT"                              comment="Queue supports compute operations"/>
        <enum bitpos="2"    name="VK_QUEUE_TRANSFER_BIT"                             comment="Queue supports transfer operations"/>
        <enum bitpos="3"    name="VK_QUEUE_SPARSE_BINDING_BIT"                       comment="Queue supports sparse resource memory management operations"/>
    </enums>
    <enums name="VkCullModeFlagBits" type="bitmask">
        <enum value="0"     name="VK_CULL_MODE_NONE"/>
        <enum bitpos="0"    name="VK_CULL_MODE_FRONT_BIT"/>
        <enum bitpos="1"    name="VK_CULL_MODE_BACK_BIT"/>
        <enum value="0x00000003" name="VK_CULL_MODE_FRONT_AND_BACK"/>
    </enums>
    <enums name="VkRenderPassCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkDeviceQueueCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkMemoryPropertyFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT"               comment="If otherwise stated, then allocate memory on device"/>
        <enum bitpos="1"    name="VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT"               comment="Memory is mappable by host"/>
        <enum bitpos="2"    name="VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"              comment="Memory will have i/o coherency. If not set, application may need to use vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges to flush/invalidate host cache"/>
        <enum bitpos="3"    name="VK_MEMORY_PROPERTY_HOST_CACHED_BIT"                comment="Memory will be cached by the host"/>
        <enum bitpos="4"    name="VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT"           comment="Memory may be allocated by the driver when it is required"/>
    </enums>
    <enums name="VkMemoryHeapFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_MEMORY_HEAP_DEVICE_LOCAL_BIT"                   comment="If set, heap represents device memory"/>
    </enums>
    <enums name="VkAccessFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_ACCESS_INDIRECT_COMMAND_READ_BIT"               comment="Controls coherency of indirect command reads"/>
        <enum bitpos="1"    name="VK_ACCESS_INDEX_READ_BIT"                          comment="Controls coherency of index reads"/>
        <enum bitpos="2"    name="VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT"               comment="Controls coherency of vertex attribute reads"/>
        <enum bitpos="3"    name="VK_ACCESS_UNIFORM_READ_BIT"                        comment="Controls coherency of uniform buffer reads"/>
        <enum bitpos="4"    name="VK_ACCESS_INPUT_ATTACHMENT_READ_BIT"               comment="Controls coherency of input attachment reads"/>
        <enum bitpos="5"    name="VK_ACCESS_SHADER_READ_BIT"                         comment="Controls coherency of shader reads"/>
        <enum bitpos="6"    name="VK_ACCESS_SHADER_WRITE_BIT"                        comment="Controls coherency of shader writes"/>
        <enum bitpos="7"    name="VK_ACCESS_COLOR_ATTACHMENT_READ_BIT"               comment="Controls coherency of color attachment reads"/>
        <enum bitpos="8"    name="VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT"              comment="Controls coherency of color attachment writes"/>
        <enum bitpos="9"    name="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT"       comment="Controls coherency of depth/stencil attachment reads"/>
        <enum bitpos="10"   name="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"      comment="Controls coherency of depth/stencil attachment writes"/>
        <enum bitpos="11"   name="VK_ACCESS_TRANSFER_READ_BIT"                       comment="Controls coherency of transfer reads"/>
        <enum bitpos="12"   name="VK_ACCESS_TRANSFER_WRITE_BIT"                      comment="Controls coherency of transfer writes"/>
        <enum bitpos="13"   name="VK_ACCESS_HOST_READ_BIT"                           comment="Controls coherency of host reads"/>
        <enum bitpos="14"   name="VK_ACCESS_HOST_WRITE_BIT"                          comment="Controls coherency of host writes"/>
        <enum bitpos="15"   name="VK_ACCESS_MEMORY_READ_BIT"                         comment="Controls coherency of memory reads"/>
        <enum bitpos="16"   name="VK_ACCESS_MEMORY_WRITE_BIT"                        comment="Controls coherency of memory writes"/>
    </enums>
    <enums name="VkBufferUsageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_BUFFER_USAGE_TRANSFER_SRC_BIT"                  comment="Can be used as a source of transfer operations"/>
        <enum bitpos="1"    name="VK_BUFFER_USAGE_TRANSFER_DST_BIT"                  comment="Can be used as a destination of transfer operations"/>
        <enum bitpos="2"    name="VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT"          comment="Can be used as TBO"/>
        <enum bitpos="3"    name="VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT"          comment="Can be used as IBO"/>
        <enum bitpos="4"    name="VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT"                comment="Can be used as UBO"/>
        <enum bitpos="5"    name="VK_BUFFER_USAGE_STORAGE_BUFFER_BIT"                comment="Can be used as SSBO"/>
        <enum bitpos="6"    name="VK_BUFFER_USAGE_INDEX_BUFFER_BIT"                  comment="Can be used as source of fixed-function index fetch (index buffer)"/>
        <enum bitpos="7"    name="VK_BUFFER_USAGE_VERTEX_BUFFER_BIT"                 comment="Can be used as source of fixed-function vertex fetch (VBO)"/>
        <enum bitpos="8"    name="VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT"               comment="Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)"/>
    </enums>
    <enums name="VkBufferUsageFlagBits2" type="bitmask" bitwidth="64">
        <enum bitpos="0"    name="VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT"/>
        <enum bitpos="1"    name="VK_BUFFER_USAGE_2_TRANSFER_DST_BIT"/>
        <enum bitpos="2"    name="VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT"/>
        <enum bitpos="3"    name="VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT"/>
        <enum bitpos="4"    name="VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT"/>
        <enum bitpos="5"    name="VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT"/>
        <enum bitpos="6"    name="VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT"/>
        <enum bitpos="7"    name="VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT"/>
        <enum bitpos="8"    name="VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT"/>
    </enums>
    <enums name="VkBufferCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_BUFFER_CREATE_SPARSE_BINDING_BIT"               comment="Buffer should support sparse backing"/>
        <enum bitpos="1"    name="VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT"             comment="Buffer should support sparse backing with partial residency"/>
        <enum bitpos="2"    name="VK_BUFFER_CREATE_SPARSE_ALIASED_BIT"               comment="Buffer should support constant data access to physical memory ranges mapped into multiple locations of sparse buffers"/>
    </enums>
    <enums name="VkShaderStageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SHADER_STAGE_VERTEX_BIT"/>
        <enum bitpos="1"    name="VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT"/>
        <enum bitpos="2"    name="VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT"/>
        <enum bitpos="3"    name="VK_SHADER_STAGE_GEOMETRY_BIT"/>
        <enum bitpos="4"    name="VK_SHADER_STAGE_FRAGMENT_BIT"/>
        <enum bitpos="5"    name="VK_SHADER_STAGE_COMPUTE_BIT"/>
        <enum value="0x0000001F" name="VK_SHADER_STAGE_ALL_GRAPHICS"/>
        <enum value="0x7FFFFFFF" name="VK_SHADER_STAGE_ALL"/>
    </enums>
    <enums name="VkImageUsageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_IMAGE_USAGE_TRANSFER_SRC_BIT"                   comment="Can be used as a source of transfer operations"/>
        <enum bitpos="1"    name="VK_IMAGE_USAGE_TRANSFER_DST_BIT"                   comment="Can be used as a destination of transfer operations"/>
        <enum bitpos="2"    name="VK_IMAGE_USAGE_SAMPLED_BIT"                        comment="Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)"/>
        <enum bitpos="3"    name="VK_IMAGE_USAGE_STORAGE_BIT"                        comment="Can be used as storage image (STORAGE_IMAGE descriptor type)"/>
        <enum bitpos="4"    name="VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT"               comment="Can be used as framebuffer color attachment"/>
        <enum bitpos="5"    name="VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT"       comment="Can be used as framebuffer depth/stencil attachment"/>
        <enum bitpos="6"    name="VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT"           comment="Image data not needed outside of rendering"/>
        <enum bitpos="7"    name="VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT"               comment="Can be used as framebuffer input attachment"/>
    </enums>
    <enums name="VkImageCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_IMAGE_CREATE_SPARSE_BINDING_BIT"                comment="Image should support sparse backing"/>
        <enum bitpos="1"    name="VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"              comment="Image should support sparse backing with partial residency"/>
        <enum bitpos="2"    name="VK_IMAGE_CREATE_SPARSE_ALIASED_BIT"                comment="Image should support constant data access to physical memory ranges mapped into multiple locations of sparse images"/>
        <enum bitpos="3"    name="VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT"                comment="Allows image views to have different format than the base image"/>
        <enum bitpos="4"    name="VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT"               comment="Allows creating image views with cube type from the created image"/>
    </enums>
    <enums name="VkImageViewCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkSamplerCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkPipelineCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT"/>
        <enum bitpos="1"    name="VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT"/>
        <enum bitpos="2"    name="VK_PIPELINE_CREATE_DERIVATIVE_BIT"/>
    </enums>
    <enums name="VkPipelineCreateFlagBits2" type="bitmask" bitwidth="64">
        <enum bitpos="0"    name="VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT"/>
        <enum bitpos="1"    name="VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT"/>
        <enum bitpos="2"    name="VK_PIPELINE_CREATE_2_DERIVATIVE_BIT"/>
        <enum bitpos="3"    name="VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT"/>
        <enum bitpos="4"    name="VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT"/>
        <enum bitpos="8"    name="VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT"/>
        <enum bitpos="9"    name="VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT"/>
        <enum bitpos="27"   name="VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT"/>
        <enum bitpos="30"   name="VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT"/>
    </enums>
    <enums name="VkPipelineShaderStageCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkColorComponentFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COLOR_COMPONENT_R_BIT"/>
        <enum bitpos="1"    name="VK_COLOR_COMPONENT_G_BIT"/>
        <enum bitpos="2"    name="VK_COLOR_COMPONENT_B_BIT"/>
        <enum bitpos="3"    name="VK_COLOR_COMPONENT_A_BIT"/>
    </enums>
    <enums name="VkFenceCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_FENCE_CREATE_SIGNALED_BIT"/>
    </enums>
    <enums name="VkSemaphoreCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkFormatFeatureFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT"               comment="Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)"/>
        <enum bitpos="1"    name="VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT"               comment="Format can be used for storage images (STORAGE_IMAGE descriptor type)"/>
        <enum bitpos="2"    name="VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT"        comment="Format supports atomic operations in case it is used for storage images"/>
        <enum bitpos="3"    name="VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"        comment="Format can be used for uniform texel buffers (TBOs)"/>
        <enum bitpos="4"    name="VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"        comment="Format can be used for storage texel buffers (IBOs)"/>
        <enum bitpos="5"    name="VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT" comment="Format supports atomic operations in case it is used for storage texel buffers"/>
        <enum bitpos="6"    name="VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT"               comment="Format can be used for vertex buffers (VBOs)"/>
        <enum bitpos="7"    name="VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT"            comment="Format can be used for color attachment images"/>
        <enum bitpos="8"    name="VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT"      comment="Format supports blending in case it is used for color attachment images"/>
        <enum bitpos="9"    name="VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT"    comment="Format can be used for depth/stencil attachment images"/>
        <enum bitpos="10"   name="VK_FORMAT_FEATURE_BLIT_SRC_BIT"                    comment="Format can be used as the source image of blits with vkCmdBlitImage"/>
        <enum bitpos="11"   name="VK_FORMAT_FEATURE_BLIT_DST_BIT"                    comment="Format can be used as the destination image of blits with vkCmdBlitImage"/>
        <enum bitpos="12"   name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT" comment="Format can be filtered with VK_FILTER_LINEAR when being sampled"/>
    </enums>
    <enums name="VkQueryControlFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_QUERY_CONTROL_PRECISE_BIT"                      comment="Require precise results to be collected by the query"/>
    </enums>
    <enums name="VkQueryResultFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_QUERY_RESULT_64_BIT"                            comment="Results of the queries are written to the destination buffer as 64-bit values"/>
        <enum bitpos="1"    name="VK_QUERY_RESULT_WAIT_BIT"                          comment="Results of the queries are waited on before proceeding with the result copy"/>
        <enum bitpos="2"    name="VK_QUERY_RESULT_WITH_AVAILABILITY_BIT"             comment="Besides the results of the query, the availability of the results is also written"/>
        <enum bitpos="3"    name="VK_QUERY_RESULT_PARTIAL_BIT"                       comment="Copy the partial results of the query even if the final results are not available"/>
    </enums>
    <enums name="VkCommandBufferUsageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT"/>
        <enum bitpos="1"    name="VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT"/>
        <enum bitpos="2"    name="VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT"      comment="Command buffer may be submitted/executed more than once simultaneously"/>
    </enums>
    <enums name="VkQueryPipelineStatisticFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT"                    comment="Optional"/>
        <enum bitpos="1"    name="VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT"                  comment="Optional"/>
        <enum bitpos="2"    name="VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT"                  comment="Optional"/>
        <enum bitpos="3"    name="VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT"                comment="Optional"/>
        <enum bitpos="4"    name="VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT"                 comment="Optional"/>
        <enum bitpos="5"    name="VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT"                       comment="Optional"/>
        <enum bitpos="6"    name="VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT"                        comment="Optional"/>
        <enum bitpos="7"    name="VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT"                comment="Optional"/>
        <enum bitpos="8"    name="VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT"        comment="Optional"/>
        <enum bitpos="9"    name="VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT" comment="Optional"/>
        <enum bitpos="10"   name="VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT"                 comment="Optional"/>
    </enums>
    <enums name="VkMemoryMapFlagBits" type="bitmask">
    </enums>
    <enums name="VkImageAspectFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_IMAGE_ASPECT_COLOR_BIT"/>
        <enum bitpos="1"    name="VK_IMAGE_ASPECT_DEPTH_BIT"/>
        <enum bitpos="2"    name="VK_IMAGE_ASPECT_STENCIL_BIT"/>
        <enum bitpos="3"    name="VK_IMAGE_ASPECT_METADATA_BIT"/>
    </enums>
    <enums name="VkSparseImageFormatFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT"         comment="Image uses a single mip tail region for all array layers"/>
        <enum bitpos="1"    name="VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT"       comment="Image requires mip level dimensions to be an integer multiple of the sparse image block dimensions for non-tail mip levels."/>
        <enum bitpos="2"    name="VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT" comment="Image uses a non-standard sparse image block dimensions"/>
    </enums>
    <enums name="VkSparseMemoryBindFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SPARSE_MEMORY_BIND_METADATA_BIT"                comment="Operation binds resource metadata to memory"/>
    </enums>
    <enums name="VkPipelineStageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT"                 comment="Before subsequent commands are processed"/>
        <enum bitpos="1"    name="VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT"               comment="Draw/DispatchIndirect command fetch"/>
        <enum bitpos="2"    name="VK_PIPELINE_STAGE_VERTEX_INPUT_BIT"                comment="Vertex/index fetch"/>
        <enum bitpos="3"    name="VK_PIPELINE_STAGE_VERTEX_SHADER_BIT"               comment="Vertex shading"/>
        <enum bitpos="4"    name="VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT" comment="Tessellation control shading"/>
        <enum bitpos="5"    name="VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT" comment="Tessellation evaluation shading"/>
        <enum bitpos="6"    name="VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"             comment="Geometry shading"/>
        <enum bitpos="7"    name="VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT"             comment="Fragment shading"/>
        <enum bitpos="8"    name="VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT"        comment="Early fragment (depth and stencil) tests"/>
        <enum bitpos="9"    name="VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT"         comment="Late fragment (depth and stencil) tests"/>
        <enum bitpos="10"   name="VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT"     comment="Color attachment writes"/>
        <enum bitpos="11"   name="VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT"              comment="Compute shading"/>
        <enum bitpos="12"   name="VK_PIPELINE_STAGE_TRANSFER_BIT"                    comment="Transfer/copy operations"/>
        <enum bitpos="13"   name="VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT"              comment="After previous commands have completed"/>
        <enum bitpos="14"   name="VK_PIPELINE_STAGE_HOST_BIT"                        comment="Indicates host (CPU) is a source/sink of the dependency"/>
        <enum bitpos="15"   name="VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT"                comment="All stages of the graphics pipeline"/>
        <enum bitpos="16"   name="VK_PIPELINE_STAGE_ALL_COMMANDS_BIT"                comment="All stages supported on the queue"/>
    </enums>
    <enums name="VkCommandPoolCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COMMAND_POOL_CREATE_TRANSIENT_BIT"              comment="Command buffers have a short lifetime"/>
        <enum bitpos="1"    name="VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"   comment="Command buffers may release their memory individually"/>
    </enums>
    <enums name="VkCommandPoolResetFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT"       comment="Release resources owned by the pool"/>
    </enums>
    <enums name="VkCommandBufferResetFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT"     comment="Release resources owned by the buffer"/>
    </enums>
    <enums name="VkSampleCountFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SAMPLE_COUNT_1_BIT"                             comment="Sample count 1 supported"/>
        <enum bitpos="1"    name="VK_SAMPLE_COUNT_2_BIT"                             comment="Sample count 2 supported"/>
        <enum bitpos="2"    name="VK_SAMPLE_COUNT_4_BIT"                             comment="Sample count 4 supported"/>
        <enum bitpos="3"    name="VK_SAMPLE_COUNT_8_BIT"                             comment="Sample count 8 supported"/>
        <enum bitpos="4"    name="VK_SAMPLE_COUNT_16_BIT"                            comment="Sample count 16 supported"/>
        <enum bitpos="5"    name="VK_SAMPLE_COUNT_32_BIT"                            comment="Sample count 32 supported"/>
        <enum bitpos="6"    name="VK_SAMPLE_COUNT_64_BIT"                            comment="Sample count 64 supported"/>
    </enums>
    <enums name="VkAttachmentDescriptionFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT"           comment="The attachment may alias physical memory of another attachment in the same render pass"/>
    </enums>
    <enums name="VkStencilFaceFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_STENCIL_FACE_FRONT_BIT"                         comment="Front face"/>
        <enum bitpos="1"    name="VK_STENCIL_FACE_BACK_BIT"                          comment="Back face"/>
        <enum value="0x00000003" name="VK_STENCIL_FACE_FRONT_AND_BACK"               comment="Front and back faces"/>
        <enum api="vulkan"  name="VK_STENCIL_FRONT_AND_BACK" alias="VK_STENCIL_FACE_FRONT_AND_BACK" deprecated="aliased"/>
    </enums>
    <enums name="VkDescriptorPoolCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT" comment="Descriptor sets may be freed individually"/>
    </enums>
    <enums name="VkDependencyFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_DEPENDENCY_BY_REGION_BIT"                       comment="Dependency is per pixel region "/>
    </enums>
    <enums name="VkSemaphoreType" type="enum">
        <enum value="0"     name="VK_SEMAPHORE_TYPE_BINARY"/>
        <enum value="1"     name="VK_SEMAPHORE_TYPE_TIMELINE"/>
    </enums>
    <enums name="VkSemaphoreWaitFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SEMAPHORE_WAIT_ANY_BIT"/>
    </enums>

        <comment>WSI Extensions</comment>
    <enums name="VkPresentModeKHR" type="enum">
        <enum value="0"     name="VK_PRESENT_MODE_IMMEDIATE_KHR"/>
        <enum value="1"     name="VK_PRESENT_MODE_MAILBOX_KHR"/>
        <enum value="2"     name="VK_PRESENT_MODE_FIFO_KHR"/>
        <enum value="3"     name="VK_PRESENT_MODE_FIFO_RELAXED_KHR"/>
    </enums>
    <enums name="VkColorSpaceKHR" type="enum">
        <enum value="0"     name="VK_COLOR_SPACE_SRGB_NONLINEAR_KHR"/>
        <enum api="vulkan"  name="VK_COLORSPACE_SRGB_NONLINEAR_KHR" alias="VK_COLOR_SPACE_SRGB_NONLINEAR_KHR" deprecated="aliased"/>
    </enums>
    <enums name="VkDisplayPlaneAlphaFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR"/>
        <enum bitpos="1"    name="VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR"/>
        <enum bitpos="2"    name="VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR"/>
        <enum bitpos="3"    name="VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR"/>
    </enums>
    <enums name="VkCompositeAlphaFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR"/>
        <enum bitpos="1"    name="VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR"/>
        <enum bitpos="2"    name="VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR"/>
        <enum bitpos="3"    name="VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR"/>
    </enums>
    <enums name="VkSurfaceTransformFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR"/>
        <enum bitpos="1"    name="VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR"/>
        <enum bitpos="2"    name="VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR"/>
        <enum bitpos="3"    name="VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR"/>
        <enum bitpos="4"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR"/>
        <enum bitpos="5"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR"/>
        <enum bitpos="6"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR"/>
        <enum bitpos="7"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR"/>
        <enum bitpos="8"    name="VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR"/>
    </enums>
    <enums name="VkDisplaySurfaceStereoTypeNV" type="enum">
        <enum value="0"     name="VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV"/>
        <enum value="1"     name="VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV"/>
        <enum value="2"     name="VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV"/>
        <enum value="3"     name="VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV"/>
    </enums>
    <enums name="VkSwapchainImageUsageFlagBitsANDROID" type="bitmask">
        <enum bitpos="0"      name="VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID"/>
    </enums>
    <enums name="VkTimeDomainKHR" type="enum">
        <enum value="0"     name="VK_TIME_DOMAIN_DEVICE_KHR"/>
        <enum value="1"     name="VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR"/>
        <enum value="2"     name="VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR"/>
        <enum value="3"     name="VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR"/>
    </enums>
    <enums name="VkDebugReportFlagBitsEXT" type="bitmask">
        <enum bitpos="0"    name="VK_DEBUG_REPORT_INFORMATION_BIT_EXT"/>
        <enum bitpos="1"    name="VK_DEBUG_REPORT_WARNING_BIT_EXT"/>
        <enum bitpos="2"    name="VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT"/>
        <enum bitpos="3"    name="VK_DEBUG_REPORT_ERROR_BIT_EXT"/>
        <enum bitpos="4"    name="VK_DEBUG_REPORT_DEBUG_BIT_EXT"/>
    </enums>
    <enums name="VkDebugReportObjectTypeEXT" type="enum">
        <enum value="0"     name="VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT"/>
        <enum value="1"     name="VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT"/>
        <enum value="2"     name="VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT"/>
        <enum value="3"     name="VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT"/>
        <enum value="4"     name="VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT"/>
        <enum value="5"     name="VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT"/>
        <enum value="6"     name="VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT"/>
        <enum value="7"     name="VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT"/>
        <enum value="8"     name="VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT"/>
        <enum value="9"     name="VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT"/>
        <enum value="10"    name="VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT"/>
        <enum value="11"    name="VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT"/>
        <enum value="12"    name="VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT"/>
        <enum value="13"    name="VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT"/>
        <enum value="14"    name="VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT"/>
        <enum value="15"    name="VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT"/>
        <enum value="16"    name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT"/>
        <enum value="17"    name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT"/>
        <enum value="18"    name="VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT"/>
        <enum value="19"    name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT"/>
        <enum value="20"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT"/>
        <enum value="21"    name="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT"/>
        <enum value="22"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT"/>
        <enum value="23"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT"/>
        <enum value="24"    name="VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT"/>
        <enum value="25"    name="VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT"/>
        <enum value="26"    name="VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT"/>
        <enum value="27"    name="VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT"/>
        <enum value="28"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT"/>
        <enum               name="VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT" alias="VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT" deprecated="aliased"/>
        <enum value="29"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT"/>
        <enum value="30"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT"/>
            <comment>NVX_device_generated_commands formerly used these enum values, but that extension has been removed
                value 31 / name VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT
                value 32 / name VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT
            </comment>
        <enum value="33"    name="VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT"/>
        <enum               name="VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT" alias="VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT" deprecated="aliased"/>
    </enums>
    <enums name="VkDeviceMemoryReportEventTypeEXT" type="enum">
        <enum value="0"     name="VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT"/>
        <enum value="1"     name="VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT"/>
        <enum value="2"     name="VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT"/>
        <enum value="3"     name="VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT"/>
        <enum value="4"     name="VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT"/>
    </enums>
    <enums name="VkRasterizationOrderAMD" type="enum">
        <enum value="0"     name="VK_RASTERIZATION_ORDER_STRICT_AMD"/>
        <enum value="1"     name="VK_RASTERIZATION_ORDER_RELAXED_AMD"/>
    </enums>
    <enums name="VkExternalMemoryHandleTypeFlagBitsNV" type="bitmask">
        <enum bitpos="0"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV"/>
        <enum bitpos="1"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV"/>
        <enum bitpos="2"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV"/>
        <enum bitpos="3"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV"/>
    </enums>
    <enums name="VkExternalMemoryFeatureFlagBitsNV" type="bitmask">
        <enum bitpos="0"    name="VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV"/>
        <enum bitpos="1"    name="VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV"/>
        <enum bitpos="2"    name="VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV"/>
    </enums>
    <enums name="VkClusterAccelerationStructureIndexFormatFlagBitsNV" type="bitmask">
        <enum bitpos="0"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_8BIT_NV"/>
        <enum bitpos="1"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_16BIT_NV"/>
        <enum bitpos="2"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_32BIT_NV"/>
    </enums>
    <enums name="VkClusterAccelerationStructureTypeNV" type="enum">
        <enum value="0"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV"/>
        <enum value="1"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV"/>
        <enum value="2"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV"/>
    </enums>
    <enums name="VkClusterAccelerationStructureOpTypeNV" type="enum">
        <enum value="0"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV"/>
        <enum value="1"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV"/>
        <enum value="2"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV"/>
        <enum value="3"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV"/>
        <enum value="4"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV"/>
        <enum value="5"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV"/>
    </enums>
    <enums name="VkClusterAccelerationStructureOpModeNV" type="enum">
        <enum value="0"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV"/>
        <enum value="1"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV"/>
        <enum value="2"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV"/>
    </enums>
    <enums name="VkClusterAccelerationStructureClusterFlagBitsNV" type="bitmask">
        <enum bitpos="0"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_ALLOW_DISABLE_OPACITY_MICROMAPS_NV"/>
    </enums>
    <enums name="VkClusterAccelerationStructureGeometryFlagBitsNV" type="bitmask">
        <enum bitpos="0"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_CULL_DISABLE_BIT_NV"/>
        <enum bitpos="1"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_NO_DUPLICATE_ANYHIT_INVOCATION_BIT_NV"/>
        <enum bitpos="2"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_OPAQUE_BIT_NV"/>
    </enums>
    <enums name="VkClusterAccelerationStructureAddressResolutionFlagBitsNV" type="bitmask">
        <enum value="0"      name="VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_NONE_NV"/>
        <enum bitpos="0"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_IMPLICIT_DATA_BIT_NV"/>
        <enum bitpos="1"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SCRATCH_DATA_BIT_NV"/>
        <enum bitpos="2"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_ADDRESS_ARRAY_BIT_NV"/>
        <enum bitpos="3"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_SIZES_ARRAY_BIT_NV"/>
        <enum bitpos="4"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_ARRAY_BIT_NV"/>
        <enum bitpos="5"     name="VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_COUNT_BIT_NV"/>
    </enums>
    <enums name="VkValidationCheckEXT" type="enum">
        <enum value="0"     name="VK_VALIDATION_CHECK_ALL_EXT"/>
        <enum value="1"     name="VK_VALIDATION_CHECK_SHADERS_EXT"/>
    </enums>
    <enums name="VkValidationFeatureEnableEXT" type="enum">
        <enum value="0"     name="VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT"/>
        <enum value="1"     name="VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT"/>
        <enum value="2"     name="VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT"/>
        <enum value="3"     name="VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT"/>
        <enum value="4"     name="VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT"/>
    </enums>
    <enums name="VkValidationFeatureDisableEXT" type="enum">
        <enum value="0"     name="VK_VALIDATION_FEATURE_DISABLE_ALL_EXT"/>
        <enum value="1"     name="VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT"/>
        <enum value="2"     name="VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT"/>
        <enum value="3"     name="VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT"/>
        <enum value="4"     name="VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT"/>
        <enum value="5"     name="VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT"/>
        <enum value="6"     name="VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT"/>
        <enum value="7"     name="VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT"/>
    </enums>
    <enums name="VkLayerSettingTypeEXT" type="enum">
        <enum value="0"     name="VK_LAYER_SETTING_TYPE_BOOL32_EXT"/>
        <enum value="1"     name="VK_LAYER_SETTING_TYPE_INT32_EXT"/>
        <enum value="2"     name="VK_LAYER_SETTING_TYPE_INT64_EXT"/>
        <enum value="3"     name="VK_LAYER_SETTING_TYPE_UINT32_EXT"/>
        <enum value="4"     name="VK_LAYER_SETTING_TYPE_UINT64_EXT"/>
        <enum value="5"     name="VK_LAYER_SETTING_TYPE_FLOAT32_EXT"/>
        <enum value="6"     name="VK_LAYER_SETTING_TYPE_FLOAT64_EXT"/>
        <enum value="7"     name="VK_LAYER_SETTING_TYPE_STRING_EXT"/>
    </enums>
    <enums name="VkSubgroupFeatureFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SUBGROUP_FEATURE_BASIC_BIT"              comment="Basic subgroup operations"/>
        <enum bitpos="1"    name="VK_SUBGROUP_FEATURE_VOTE_BIT"               comment="Vote subgroup operations"/>
        <enum bitpos="2"    name="VK_SUBGROUP_FEATURE_ARITHMETIC_BIT"         comment="Arithmetic subgroup operations"/>
        <enum bitpos="3"    name="VK_SUBGROUP_FEATURE_BALLOT_BIT"             comment="Ballot subgroup operations"/>
        <enum bitpos="4"    name="VK_SUBGROUP_FEATURE_SHUFFLE_BIT"            comment="Shuffle subgroup operations"/>
        <enum bitpos="5"    name="VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT"   comment="Shuffle relative subgroup operations"/>
        <enum bitpos="6"    name="VK_SUBGROUP_FEATURE_CLUSTERED_BIT"          comment="Clustered subgroup operations"/>
        <enum bitpos="7"    name="VK_SUBGROUP_FEATURE_QUAD_BIT"               comment="Quad subgroup operations"/>
    </enums>
    <enums name="VkIndirectCommandsLayoutUsageFlagBitsNV" type="bitmask">
        <enum bitpos="0"    name="VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV"/>
        <enum bitpos="1"    name="VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV"/>
        <enum bitpos="2"    name="VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV"/>
    </enums>
    <enums name="VkIndirectStateFlagBitsNV" type="bitmask">
        <enum bitpos="0"    name="VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV"/>
    </enums>
    <enums name="VkIndirectCommandsTokenTypeNV" type="enum">
        <enum value="0"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV"/>
        <enum value="1"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV"/>
        <enum value="2"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV"/>
        <enum value="3"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV"/>
        <enum value="4"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV"/>
        <enum value="5"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV"/>
        <enum value="6"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV"/>
        <enum value="7"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV"/>
    </enums>
    <enums name="VkPrivateDataSlotCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkDescriptorSetLayoutCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkExternalMemoryHandleTypeFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT"/>
        <enum bitpos="1"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
        <enum bitpos="2"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
        <enum bitpos="3"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT"/>
        <enum bitpos="4"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT"/>
        <enum bitpos="5"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT"/>
        <enum bitpos="6"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT"/>
    </enums>
    <enums name="VkExternalMemoryFeatureFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT"/>
        <enum bitpos="1"    name="VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT"/>
        <enum bitpos="2"    name="VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT"/>
    </enums>
    <enums name="VkExternalSemaphoreHandleTypeFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT"/>
        <enum bitpos="1"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
        <enum bitpos="2"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
        <enum bitpos="3"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT"/>
        <enum               name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT"/>
        <enum bitpos="4"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT"/>
    </enums>
    <enums name="VkExternalSemaphoreFeatureFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT"/>
        <enum bitpos="1"    name="VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT"/>
    </enums>
    <enums name="VkSemaphoreImportFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SEMAPHORE_IMPORT_TEMPORARY_BIT"/>
    </enums>
    <enums name="VkExternalFenceHandleTypeFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT"/>
        <enum bitpos="1"    name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
        <enum bitpos="2"    name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
        <enum bitpos="3"    name="VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT"/>
    </enums>
    <enums name="VkExternalFenceFeatureFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT"/>
        <enum bitpos="1"    name="VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT"/>
    </enums>
    <enums name="VkFenceImportFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_FENCE_IMPORT_TEMPORARY_BIT"/>
    </enums>
    <enums name="VkSurfaceCounterFlagBitsEXT" type="bitmask">
        <enum bitpos="0"    name="VK_SURFACE_COUNTER_VBLANK_BIT_EXT"/>
        <enum               name="VK_SURFACE_COUNTER_VBLANK_EXT" alias="VK_SURFACE_COUNTER_VBLANK_BIT_EXT" deprecated="aliased"/>
    </enums>
    <enums name="VkDisplayPowerStateEXT" type="enum">
        <enum value="0"     name="VK_DISPLAY_POWER_STATE_OFF_EXT"/>
        <enum value="1"     name="VK_DISPLAY_POWER_STATE_SUSPEND_EXT"/>
        <enum value="2"     name="VK_DISPLAY_POWER_STATE_ON_EXT"/>
    </enums>
    <enums name="VkDeviceEventTypeEXT" type="enum">
        <enum value="0"     name="VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT"/>
    </enums>
    <enums name="VkDisplayEventTypeEXT" type="enum">
        <enum value="0"     name="VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT"/>
    </enums>
    <enums name="VkPeerMemoryFeatureFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT"           comment="Can read with vkCmdCopy commands"/>
        <enum bitpos="1"    name="VK_PEER_MEMORY_FEATURE_COPY_DST_BIT"           comment="Can write with vkCmdCopy commands"/>
        <enum bitpos="2"    name="VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT"        comment="Can read with any access type/command"/>
        <enum bitpos="3"    name="VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT"        comment="Can write with and access type/command"/>
    </enums>
    <enums name="VkMemoryAllocateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT"            comment="Force allocation on specific devices"/>
    </enums>
    <enums name="VkDeviceGroupPresentModeFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR"        comment="Present from local memory"/>
        <enum bitpos="1"    name="VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR"       comment="Present from remote memory"/>
        <enum bitpos="2"    name="VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR"          comment="Present sum of local and/or remote memory"/>
        <enum bitpos="3"    name="VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR" comment="Each physical device presents from local memory"/>
    </enums>
    <enums name="VkSwapchainCreateFlagBitsKHR" type="bitmask">
    </enums>
    <enums name="VkViewportCoordinateSwizzleNV" type="enum">
        <enum value="0"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV"/>
        <enum value="1"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV"/>
        <enum value="2"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV"/>
        <enum value="3"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV"/>
        <enum value="4"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV"/>
        <enum value="5"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV"/>
        <enum value="6"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV"/>
        <enum value="7"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV"/>
    </enums>
    <enums name="VkDiscardRectangleModeEXT" type="enum">
        <enum value="0"     name="VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT"/>
        <enum value="1"     name="VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT"/>
    </enums>
    <enums name="VkSubpassDescriptionFlagBits" type="bitmask">
    </enums>
    <enums name="VkPointClippingBehavior" type="enum">
        <enum value="0"     name="VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES"/>
        <enum value="1"     name="VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY"/>
    </enums>
    <enums name="VkSamplerReductionMode" type="enum">
        <enum value="0"     name="VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE"/>
        <enum value="1"     name="VK_SAMPLER_REDUCTION_MODE_MIN"/>
        <enum value="2"     name="VK_SAMPLER_REDUCTION_MODE_MAX"/>
    </enums>
    <enums name="VkTessellationDomainOrigin" type="enum">
        <enum value="0"     name="VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT"/>
        <enum value="1"     name="VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT"/>
    </enums>
    <enums name="VkSamplerYcbcrModelConversion" type="enum">
        <enum value="0"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY"/>
        <enum value="1"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY" comment="just range expansion"/>
        <enum value="2"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709"      comment="aka HD YUV"/>
        <enum value="3"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601"      comment="aka SD YUV"/>
        <enum value="4"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020"     comment="aka UHD YUV"/>
    </enums>
    <enums name="VkSamplerYcbcrRange" type="enum">
        <enum value="0"     name="VK_SAMPLER_YCBCR_RANGE_ITU_FULL"    comment="Luma 0..1 maps to 0..255, chroma -0.5..0.5 to 1..255 (clamped)"/>
        <enum value="1"     name="VK_SAMPLER_YCBCR_RANGE_ITU_NARROW"  comment="Luma 0..1 maps to 16..235, chroma -0.5..0.5 to 16..240"/>
    </enums>
    <enums name="VkChromaLocation" type="enum">
        <enum value="0"     name="VK_CHROMA_LOCATION_COSITED_EVEN"/>
        <enum value="1"     name="VK_CHROMA_LOCATION_MIDPOINT"/>
    </enums>
    <enums name="VkBlendOverlapEXT" type="enum">
        <enum value="0"     name="VK_BLEND_OVERLAP_UNCORRELATED_EXT"/>
        <enum value="1"     name="VK_BLEND_OVERLAP_DISJOINT_EXT"/>
        <enum value="2"     name="VK_BLEND_OVERLAP_CONJOINT_EXT"/>
    </enums>
    <enums name="VkCoverageModulationModeNV" type="enum">
        <enum value="0"     name="VK_COVERAGE_MODULATION_MODE_NONE_NV"/>
        <enum value="1"     name="VK_COVERAGE_MODULATION_MODE_RGB_NV"/>
        <enum value="2"     name="VK_COVERAGE_MODULATION_MODE_ALPHA_NV"/>
        <enum value="3"     name="VK_COVERAGE_MODULATION_MODE_RGBA_NV"/>
    </enums>
    <enums name="VkCoverageReductionModeNV" type="enum">
        <enum value="0"     name="VK_COVERAGE_REDUCTION_MODE_MERGE_NV"/>
        <enum value="1"     name="VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV"/>
    </enums>
    <enums name="VkValidationCacheHeaderVersionEXT" type="enum">
        <enum value="1"     name="VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT"/>
    </enums>
    <enums name="VkShaderInfoTypeAMD" type="enum">
        <enum value="0"     name="VK_SHADER_INFO_TYPE_STATISTICS_AMD"/>
        <enum value="1"     name="VK_SHADER_INFO_TYPE_BINARY_AMD"/>
        <enum value="2"     name="VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD"/>
    </enums>
    <enums name="VkQueueGlobalPriority" type="enum">
        <enum value="128"   name="VK_QUEUE_GLOBAL_PRIORITY_LOW"/>
        <enum value="256"   name="VK_QUEUE_GLOBAL_PRIORITY_MEDIUM"/>
        <enum value="512"   name="VK_QUEUE_GLOBAL_PRIORITY_HIGH"/>
        <enum value="1024"  name="VK_QUEUE_GLOBAL_PRIORITY_REALTIME"/>
    </enums>
    <enums name="VkDebugUtilsMessageSeverityFlagBitsEXT" type="bitmask">
        <enum bitpos="0"    name="VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT"/>
        <enum bitpos="4"    name="VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT"/>
        <enum bitpos="8"    name="VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT"/>
        <enum bitpos="12"   name="VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT"/>
    </enums>
    <enums name="VkDebugUtilsMessageTypeFlagBitsEXT" type="bitmask">
        <enum bitpos="0"    name="VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT"/>
        <enum bitpos="1"    name="VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT"/>
        <enum bitpos="2"    name="VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT"/>
    </enums>
    <enums name="VkConservativeRasterizationModeEXT" type="enum">
        <enum value="0"     name="VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT"/>
        <enum value="1"     name="VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT"/>
        <enum value="2"     name="VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT"/>
    </enums>
    <enums name="VkDescriptorBindingFlagBits" type="bitmask">
        <enum bitpos="0" name="VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT"/>
        <enum bitpos="1" name="VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT"/>
        <enum bitpos="2" name="VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT"/>
        <enum bitpos="3" name="VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT"/>
    </enums>
    <enums name="VkVendorId" type="enum">
        <comment>Vendor IDs are now represented as enums instead of the old
                 &lt;vendorids&gt; tag, allowing them to be included in the
                 API headers.</comment>
        <enum value="0x10000" name="VK_VENDOR_ID_KHRONOS" comment="Khronos vendor ID"/>
        <enum value="0x10001" name="VK_VENDOR_ID_VIV"   comment="Vivante vendor ID"/>
        <enum value="0x10002" name="VK_VENDOR_ID_VSI"   comment="VeriSilicon vendor ID"/>
        <enum value="0x10003" name="VK_VENDOR_ID_KAZAN" comment="Kazan Software Renderer"/>
        <enum value="0x10004" name="VK_VENDOR_ID_CODEPLAY" comment="Codeplay Software Ltd. vendor ID"/>
        <enum value="0x10005" name="VK_VENDOR_ID_MESA"  comment="Mesa vendor ID"/>
        <enum value="0x10006" name="VK_VENDOR_ID_POCL"  comment="PoCL vendor ID"/>
        <enum value="0x10007" name="VK_VENDOR_ID_MOBILEYE"  comment="Mobileye vendor ID"/>
            <unused start="0x10008" comment="This is the next unused available Khronos vendor ID"/>
    </enums>
    <enums name="VkDriverId" type="enum">
        <comment>Driver IDs are now represented as enums instead of the old
                 &lt;driverids&gt; tag, allowing them to be included in the
                 API headers.</comment>
        <enum value="1"       name="VK_DRIVER_ID_AMD_PROPRIETARY"               comment="Advanced Micro Devices, Inc."/>
        <enum value="2"       name="VK_DRIVER_ID_AMD_OPEN_SOURCE"               comment="Advanced Micro Devices, Inc."/>
        <enum value="3"       name="VK_DRIVER_ID_MESA_RADV"                     comment="Mesa open source project"/>
        <enum value="4"       name="VK_DRIVER_ID_NVIDIA_PROPRIETARY"            comment="NVIDIA Corporation"/>
        <enum value="5"       name="VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS"     comment="Intel Corporation"/>
        <enum value="6"       name="VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA"        comment="Intel Corporation"/>
        <enum value="7"       name="VK_DRIVER_ID_IMAGINATION_PROPRIETARY"       comment="Imagination Technologies"/>
        <enum value="8"       name="VK_DRIVER_ID_QUALCOMM_PROPRIETARY"          comment="Qualcomm Technologies, Inc."/>
        <enum value="9"       name="VK_DRIVER_ID_ARM_PROPRIETARY"               comment="Arm Limited"/>
        <enum value="10"      name="VK_DRIVER_ID_GOOGLE_SWIFTSHADER"            comment="Google LLC"/>
        <enum value="11"      name="VK_DRIVER_ID_GGP_PROPRIETARY"               comment="Google LLC"/>
        <enum value="12"      name="VK_DRIVER_ID_BROADCOM_PROPRIETARY"          comment="Broadcom Inc."/>
        <enum value="13"      name="VK_DRIVER_ID_MESA_LLVMPIPE"                 comment="Mesa"/>
        <enum value="14"      name="VK_DRIVER_ID_MOLTENVK"                      comment="MoltenVK"/>
        <enum value="15"      name="VK_DRIVER_ID_COREAVI_PROPRIETARY"           comment="Core Avionics &amp; Industrial Inc."/>
        <enum value="16"      name="VK_DRIVER_ID_JUICE_PROPRIETARY"             comment="Juice Technologies, Inc."/>
        <enum value="17"      name="VK_DRIVER_ID_VERISILICON_PROPRIETARY"       comment="Verisilicon, Inc."/>
        <enum value="18"      name="VK_DRIVER_ID_MESA_TURNIP"                   comment="Mesa open source project"/>
        <enum value="19"      name="VK_DRIVER_ID_MESA_V3DV"                     comment="Mesa open source project"/>
        <enum value="20"      name="VK_DRIVER_ID_MESA_PANVK"                    comment="Mesa open source project"/>
        <enum value="21"      name="VK_DRIVER_ID_SAMSUNG_PROPRIETARY"           comment="Samsung Electronics Co., Ltd."/>
        <enum value="22"      name="VK_DRIVER_ID_MESA_VENUS"                    comment="Mesa open source project"/>
        <enum value="23"      name="VK_DRIVER_ID_MESA_DOZEN"                    comment="Mesa open source project"/>
        <enum value="24"      name="VK_DRIVER_ID_MESA_NVK"                      comment="Mesa open source project"/>
        <enum value="25"      name="VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA"  comment="Imagination Technologies"/>
        <enum value="26"      name="VK_DRIVER_ID_MESA_HONEYKRISP"               comment="Mesa open source project"/>
        <enum value="27"      name="VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN" comment="Vulkan SC Emulation on Vulkan"/>
        <enum value="28"      name="VK_DRIVER_ID_MESA_KOSMICKRISP"              comment="Mesa open source project"/>
    </enums>
    <enums name="VkConditionalRenderingFlagBitsEXT" type="bitmask">
        <enum bitpos="0"    name="VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT"/>
    </enums>
    <enums name="VkResolveModeFlagBits" type="bitmask">
        <enum value="0" name="VK_RESOLVE_MODE_NONE"/>
        <enum bitpos="0" name="VK_RESOLVE_MODE_SAMPLE_ZERO_BIT"/>
        <enum bitpos="1" name="VK_RESOLVE_MODE_AVERAGE_BIT"/>
        <enum bitpos="2" name="VK_RESOLVE_MODE_MIN_BIT"/>
        <enum bitpos="3" name="VK_RESOLVE_MODE_MAX_BIT"/>
    </enums>
    <enums name="VkShadingRatePaletteEntryNV" type="enum">
        <enum value="0" name="VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV"/>
        <enum value="1" name="VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV"/>
        <enum value="2" name="VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV"/>
        <enum value="3" name="VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV"/>
        <enum value="4" name="VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV"/>
        <enum value="5" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV"/>
        <enum value="6" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV"/>
        <enum value="7" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV"/>
        <enum value="8" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV"/>
        <enum value="9" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV"/>
        <enum value="10" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV"/>
        <enum value="11" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV"/>
    </enums>
    <enums name="VkCoarseSampleOrderTypeNV" type="enum">
        <enum value="0" name="VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV"/>
        <enum value="1" name="VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV"/>
        <enum value="2" name="VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV"/>
        <enum value="3" name="VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV"/>
    </enums>
    <enums name="VkGeometryInstanceFlagBitsKHR" type="bitmask">
        <enum bitpos="0" name="VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR"/>
        <enum bitpos="1" name="VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR"/>
        <enum bitpos="2" name="VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR"/>
        <enum bitpos="3" name="VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR"/>
        <enum            name="VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR" alias="VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR"/>
    </enums>
    <enums name="VkGeometryFlagBitsKHR" type="bitmask">
        <enum bitpos="0" name="VK_GEOMETRY_OPAQUE_BIT_KHR"/>
        <enum bitpos="1" name="VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR"/>
    </enums>
    <enums name="VkBuildAccelerationStructureFlagBitsKHR" type="bitmask">
        <enum bitpos="0" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR"/>
        <enum bitpos="1" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR"/>
        <enum bitpos="2" name="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR"/>
        <enum bitpos="3" name="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR"/>
        <enum bitpos="4" name="VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR"/>
    </enums>
    <enums name="VkAccelerationStructureCreateFlagBitsKHR" type="bitmask">
        <enum bitpos="0" name="VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR"/>
    </enums>
    <enums name="VkCopyAccelerationStructureModeKHR" type="enum">
        <enum value="0" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR"/>
        <enum value="1" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR"/>
    </enums>
    <enums name="VkBuildAccelerationStructureModeKHR" type="enum">
        <enum value="0" name="VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR"/>
        <enum value="1" name="VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR"/>
    </enums>
    <enums name="VkAccelerationStructureTypeKHR" type="enum">
        <enum value="0" name="VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR"/>
        <enum value="1" name="VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR"/>
        <enum value="2" name="VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR"/>
    </enums>
    <enums name="VkGeometryTypeKHR" type="enum">
        <enum value="0" name="VK_GEOMETRY_TYPE_TRIANGLES_KHR"/>
        <enum value="1" name="VK_GEOMETRY_TYPE_AABBS_KHR"/>
        <enum value="2" name="VK_GEOMETRY_TYPE_INSTANCES_KHR"/>
    </enums>
    <enums name="VkAccelerationStructureMemoryRequirementsTypeNV" type="enum">
        <enum value="0" name="VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV"/>
        <enum value="1" name="VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV"/>
        <enum value="2" name="VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV"/>
    </enums>
    <enums name="VkAccelerationStructureBuildTypeKHR" type="enum">
        <enum value="0" name="VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR"/>
        <enum value="1" name="VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR"/>
        <enum value="2" name="VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR"/>
    </enums>
    <enums name="VkRayTracingShaderGroupTypeKHR" type="enum">
        <enum value="0" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR"/>
        <enum value="1" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR"/>
        <enum value="2" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR"/>
    </enums>
    <enums name="VkAccelerationStructureCompatibilityKHR" type="enum">
        <enum value="0" name="VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR"/>
        <enum value="1" name="VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR"/>
    </enums>
    <enums name="VkShaderGroupShaderKHR" type="enum">
        <enum value="0" name="VK_SHADER_GROUP_SHADER_GENERAL_KHR"/>
        <enum value="1" name="VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR"/>
        <enum value="2" name="VK_SHADER_GROUP_SHADER_ANY_HIT_KHR"/>
        <enum value="3" name="VK_SHADER_GROUP_SHADER_INTERSECTION_KHR"/>
    </enums>
    <enums name="VkMemoryOverallocationBehaviorAMD" type="enum">
        <enum value="0"     name="VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD"/>
        <enum value="1"     name="VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD"/>
        <enum value="2"     name="VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD"/>
    </enums>
    <enums name="VkFramebufferCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkQueryPoolCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkDeviceDiagnosticsConfigFlagBitsNV" type="bitmask">
        <enum bitpos="0" name="VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV"/>
        <enum bitpos="1" name="VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV"/>
        <enum bitpos="2" name="VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV"/>
        <enum bitpos="3" name="VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV"/>
    </enums>
    <enums name="VkPipelineCreationFeedbackFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT"/>
        <enum bitpos="1"    name="VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT"/>
        <enum bitpos="2"    name="VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT"/>
    </enums>
    <enums name="VkFullScreenExclusiveEXT" type="enum">
        <enum value="0"     name="VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT"/>
        <enum value="1"     name="VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT"/>
        <enum value="2"     name="VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT"/>
        <enum value="3"     name="VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT"/>
    </enums>
    <enums name="VkPerformanceCounterScopeKHR" type="enum">
        <enum value="0"     name="VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR"/>
        <enum value="1"     name="VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR"/>
        <enum value="2"     name="VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR"/>
        <enum               name="VK_QUERY_SCOPE_COMMAND_BUFFER_KHR" alias="VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR" deprecated="aliased"/>
        <enum               name="VK_QUERY_SCOPE_RENDER_PASS_KHR" alias="VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR" deprecated="aliased"/>
        <enum               name="VK_QUERY_SCOPE_COMMAND_KHR" alias="VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR" deprecated="aliased"/>
    </enums>
    <enums name="VkMemoryDecompressionMethodFlagBitsEXT" type="bitmask" bitwidth="64">
        <enum bitpos="0" name="VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_EXT"/>
        <enum            name="VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_NV" alias="VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_EXT"/>
    </enums>
    <enums name="VkPerformanceCounterUnitKHR" type="enum">
        <enum value="0"     name="VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR"/>
        <enum value="1"     name="VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR"/>
        <enum value="2"     name="VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR"/>
        <enum value="3"     name="VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR"/>
        <enum value="4"     name="VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR"/>
        <enum value="5"     name="VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR"/>
        <enum value="6"     name="VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR"/>
        <enum value="7"     name="VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR"/>
        <enum value="8"     name="VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR"/>
        <enum value="9"     name="VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR"/>
        <enum value="10"    name="VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR"/>
    </enums>
    <enums name="VkPerformanceCounterStorageKHR" type="enum">
        <enum value="0"     name="VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR"/>
        <enum value="1"     name="VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR"/>
        <enum value="2"     name="VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR"/>
        <enum value="3"     name="VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR"/>
        <enum value="4"     name="VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR"/>
        <enum value="5"     name="VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR"/>
    </enums>
    <enums name="VkPerformanceCounterDescriptionFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR"/>
        <enum               name="VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR" alias="VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR" deprecated="aliased"/>
        <enum bitpos="1"    name="VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR"/>
        <enum               name="VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR" alias="VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR" deprecated="aliased"/>
    </enums>
    <enums name="VkAcquireProfilingLockFlagBitsKHR" type="bitmask">
    </enums>
    <enums name="VkShaderCorePropertiesFlagBitsAMD" type="bitmask">
    </enums>
    <enums name="VkRefreshObjectFlagBitsKHR" type="bitmask">
    </enums>
    <enums name="VkPerformanceConfigurationTypeINTEL" type="enum">
        <enum value="0"     name="VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL"/>
    </enums>
    <enums name="VkQueryPoolSamplingModeINTEL" type="enum">
        <enum value="0"     name="VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL"/>
    </enums>
    <enums name="VkPerformanceOverrideTypeINTEL" type="enum">
        <enum value="0"     name="VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL"/>
        <enum value="1"     name="VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL"/>
    </enums>
    <enums name="VkPerformanceParameterTypeINTEL" type="enum">
        <enum value="0"     name="VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL"/>
        <enum value="1"     name="VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL"/>
    </enums>
    <enums name="VkPerformanceValueTypeINTEL" type="enum">
        <enum value="0"     name="VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL"/>
        <enum value="1"     name="VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL"/>
        <enum value="2"     name="VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL"/>
        <enum value="3"     name="VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL"/>
        <enum value="4"     name="VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL"/>
    </enums>
    <enums name="VkShaderFloatControlsIndependence" type="enum">
        <enum value="0"     name="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY"/>
        <enum value="1"     name="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL"/>
        <enum value="2"     name="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE"/>
    </enums>
    <enums name="VkPipelineExecutableStatisticFormatKHR" type="enum">
        <enum value="0" name="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR"/>
        <enum value="1" name="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR"/>
        <enum value="2" name="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR"/>
        <enum value="3" name="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR"/>
    </enums>
    <enums name="VkLineRasterizationMode" type="enum">
        <enum value="0"     name="VK_LINE_RASTERIZATION_MODE_DEFAULT"/>
        <enum value="1"     name="VK_LINE_RASTERIZATION_MODE_RECTANGULAR"/>
        <enum value="2"     name="VK_LINE_RASTERIZATION_MODE_BRESENHAM"/>
        <enum value="3"     name="VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH"/>
    </enums>
    <enums name="VkShaderModuleCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkPipelineCompilerControlFlagBitsAMD" type="bitmask">
    </enums>
    <enums name="VkFaultLevel" type="enum">
        <enum value="0"    name="VK_FAULT_LEVEL_UNASSIGNED"/>
        <enum value="1"    name="VK_FAULT_LEVEL_CRITICAL"/>
        <enum value="2"    name="VK_FAULT_LEVEL_RECOVERABLE"/>
        <enum value="3"    name="VK_FAULT_LEVEL_WARNING"/>
    </enums>
    <enums name="VkFaultType" type="enum">
        <enum value="0"    name="VK_FAULT_TYPE_INVALID"/>
        <enum value="1"    name="VK_FAULT_TYPE_UNASSIGNED"/>
        <enum value="2"    name="VK_FAULT_TYPE_IMPLEMENTATION"/>
        <enum value="3"    name="VK_FAULT_TYPE_SYSTEM"/>
        <enum value="4"    name="VK_FAULT_TYPE_PHYSICAL_DEVICE"/>
        <enum value="5"    name="VK_FAULT_TYPE_COMMAND_BUFFER_FULL"/>
        <enum value="6"    name="VK_FAULT_TYPE_INVALID_API_USAGE"/>
    </enums>
    <enums name="VkFaultQueryBehavior" type="enum">
        <enum value="0"    name="VK_FAULT_QUERY_BEHAVIOR_GET_AND_CLEAR_ALL_FAULTS"/>
    </enums>
    <enums name="VkToolPurposeFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_TOOL_PURPOSE_VALIDATION_BIT"/>
        <enum bitpos="1"    name="VK_TOOL_PURPOSE_PROFILING_BIT"/>
        <enum bitpos="2"    name="VK_TOOL_PURPOSE_TRACING_BIT"/>
        <enum bitpos="3"    name="VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT"/>
        <enum bitpos="4"    name="VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT"/>
    </enums>
    <enums name="VkPipelineMatchControl" type="enum">
        <enum value="0"     name="VK_PIPELINE_MATCH_CONTROL_APPLICATION_UUID_EXACT_MATCH"/>
    </enums>
    <enums name="VkFragmentShadingRateCombinerOpKHR" type="enum">
        <enum value="0" name="VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR"/>
        <enum value="1" name="VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR"/>
        <enum value="2" name="VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR"/>
        <enum value="3" name="VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR"/>
        <enum value="4" name="VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR"/>
    </enums>
    <enums name="VkFragmentShadingRateNV" type="enum">
        <enum value="0"  name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV"/>
        <enum value="1"  name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV"/>
        <enum value="4"  name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV"/>
        <enum value="5"  name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV"/>
        <enum value="6"  name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV"/>
        <enum value="9"  name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV"/>
        <enum value="10" name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV"/>
        <enum value="11" name="VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV"/>
        <enum value="12" name="VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV"/>
        <enum value="13" name="VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV"/>
        <enum value="14" name="VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV"/>
        <enum value="15" name="VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV"/>
    </enums>
    <enums name="VkFragmentShadingRateTypeNV" type="enum">
        <enum value="0"  name="VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV"/>
        <enum value="1"  name="VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV"/>
    </enums>
    <enums name="VkSubpassMergeStatusEXT" type="enum">
        <enum value="0"  name="VK_SUBPASS_MERGE_STATUS_MERGED_EXT"/>
        <enum value="1"  name="VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT"/>
        <enum value="2"  name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT"/>
        <enum value="3"  name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT"/>
        <enum value="4"  name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT"/>
        <enum value="5"  name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT"/>
        <enum value="6"  name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT"/>
        <enum value="7"  name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT"/>
        <enum value="8"  name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT"/>
        <enum value="9"  name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT"/>
        <enum value="10" name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT"/>
        <enum value="11" name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT"/>
        <enum value="12" name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT"/>
        <enum value="13" name="VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT"/>
    </enums>
    <enums name="VkAccessFlagBits2" type="bitmask" bitwidth="64">
        <enum value="0"     name="VK_ACCESS_2_NONE"/>
        <enum bitpos="0"    name="VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT"/>
        <enum bitpos="1"    name="VK_ACCESS_2_INDEX_READ_BIT"/>
        <enum bitpos="2"    name="VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT"/>
        <enum bitpos="3"    name="VK_ACCESS_2_UNIFORM_READ_BIT"/>
        <enum bitpos="4"    name="VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT"/>
        <enum bitpos="5"    name="VK_ACCESS_2_SHADER_READ_BIT"/>
        <enum bitpos="6"    name="VK_ACCESS_2_SHADER_WRITE_BIT"/>
        <enum bitpos="7"    name="VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT"/>
        <enum bitpos="8"    name="VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT"/>
        <enum bitpos="9"    name="VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT"/>
        <enum bitpos="10"   name="VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"/>
        <enum bitpos="11"   name="VK_ACCESS_2_TRANSFER_READ_BIT"/>
        <enum bitpos="12"   name="VK_ACCESS_2_TRANSFER_WRITE_BIT"/>
        <enum bitpos="13"   name="VK_ACCESS_2_HOST_READ_BIT"/>
        <enum bitpos="14"   name="VK_ACCESS_2_HOST_WRITE_BIT"/>
        <enum bitpos="15"   name="VK_ACCESS_2_MEMORY_READ_BIT"/>
        <enum bitpos="16"   name="VK_ACCESS_2_MEMORY_WRITE_BIT"/>
            <comment>bitpos 17-31 are specified by extensions to the original VkAccessFlagBits enum</comment>
        <enum bitpos="32"   name="VK_ACCESS_2_SHADER_SAMPLED_READ_BIT"/>
        <enum bitpos="33"   name="VK_ACCESS_2_SHADER_STORAGE_READ_BIT"/>
        <enum bitpos="34"   name="VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT"/>
    </enums>
    <enums name="VkPipelineStageFlagBits2" type="bitmask" bitwidth="64">
        <enum value="0"     name="VK_PIPELINE_STAGE_2_NONE"/>
        <enum bitpos="0"    name="VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT"/>
        <enum bitpos="1"    name="VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT"/>
        <enum bitpos="2"    name="VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT"/>
        <enum bitpos="3"    name="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT"/>
        <enum bitpos="4"    name="VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT"/>
        <enum bitpos="5"    name="VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT"/>
        <enum bitpos="6"    name="VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT"/>
        <enum bitpos="7"    name="VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT"/>
        <enum bitpos="8"    name="VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT"/>
        <enum bitpos="9"    name="VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT"/>
        <enum bitpos="10"   name="VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT"/>
        <enum bitpos="11"   name="VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT"/>
        <enum bitpos="12"   name="VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT"/>
        <enum               name="VK_PIPELINE_STAGE_2_TRANSFER_BIT" alias="VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT"/>
        <enum bitpos="13"   name="VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT"/>
        <enum bitpos="14"   name="VK_PIPELINE_STAGE_2_HOST_BIT"/>
        <enum bitpos="15"   name="VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT"/>
        <enum bitpos="16"   name="VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT"/>
            <comment>bitpos 17-31 are specified by extensions to the original VkPipelineStageFlagBits enum</comment>
        <enum bitpos="32"   name="VK_PIPELINE_STAGE_2_COPY_BIT"/>
        <enum bitpos="33"   name="VK_PIPELINE_STAGE_2_RESOLVE_BIT"/>
        <enum bitpos="34"   name="VK_PIPELINE_STAGE_2_BLIT_BIT"/>
        <enum bitpos="35"   name="VK_PIPELINE_STAGE_2_CLEAR_BIT"/>
        <enum bitpos="36"   name="VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT"/>
        <enum bitpos="37"   name="VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT"/>
        <enum bitpos="38"   name="VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT"/>
    </enums>
    <enums name="VkSubmitFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SUBMIT_PROTECTED_BIT"/>
    </enums>
    <enums name="VkEventCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkPipelineLayoutCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkSciSyncClientTypeNV" type="enum">
        <enum value="0"    name="VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_NV"/>
        <enum value="1"    name="VK_SCI_SYNC_CLIENT_TYPE_WAITER_NV"/>
        <enum value="2"    name="VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_WAITER_NV"/>
    </enums>
    <enums name="VkSciSyncPrimitiveTypeNV" type="enum">
        <enum value="0"   name="VK_SCI_SYNC_PRIMITIVE_TYPE_FENCE_NV"/>
        <enum value="1"   name="VK_SCI_SYNC_PRIMITIVE_TYPE_SEMAPHORE_NV"/>
    </enums>
    <enums name="VkProvokingVertexModeEXT" type="enum">
        <enum value="0"     name="VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT"/>
        <enum value="1"     name="VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT"/>
    </enums>
    <enums name="VkPipelineCacheValidationVersion" type="enum">
        <enum value="1"     name="VK_PIPELINE_CACHE_VALIDATION_VERSION_SAFETY_CRITICAL_ONE"/>
    </enums>
    <enums name="VkAccelerationStructureMotionInstanceTypeNV" type="enum">
        <enum value="0" name="VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV"/>
        <enum value="1" name="VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV"/>
        <enum value="2" name="VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV"/>
    </enums>
    <enums name="VkPipelineColorBlendStateCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkPipelineDepthStencilStateCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkGraphicsPipelineLibraryFlagBitsEXT" type="bitmask">
        <enum bitpos="0"   name="VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT"/>
        <enum bitpos="1"   name="VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT"/>
        <enum bitpos="2"   name="VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT"/>
        <enum bitpos="3"   name="VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT"/>
    </enums>
    <enums name="VkRenderingAttachmentFlagBitsKHR" type="bitmask">
    </enums>
    <enums name="VkResolveImageFlagBitsKHR" type="bitmask">
    </enums>
    <enums name="VkDeviceAddressBindingFlagBitsEXT" type="bitmask">
        <enum bitpos="0" name="VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT"/>
    </enums>
    <enums name="VkDeviceAddressBindingTypeEXT" type="enum">
        <enum value="0"     name="VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT"/>
        <enum value="1"     name="VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT"/>
    </enums>
    <enums name="VkFrameBoundaryFlagBitsEXT" type="bitmask">
        <enum bitpos="0"     name="VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT"/>
    </enums>
    <enums name="VkPresentScalingFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR"/>
        <enum               name="VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT" alias="VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR"/>
        <enum bitpos="1"    name="VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR"/>
        <enum               name="VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT" alias="VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR"/>
        <enum bitpos="2"    name="VK_PRESENT_SCALING_STRETCH_BIT_KHR"/>
        <enum               name="VK_PRESENT_SCALING_STRETCH_BIT_EXT" alias="VK_PRESENT_SCALING_STRETCH_BIT_KHR"/>
    </enums>
    <enums name="VkPresentGravityFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_PRESENT_GRAVITY_MIN_BIT_KHR"/>
        <enum               name="VK_PRESENT_GRAVITY_MIN_BIT_EXT" alias="VK_PRESENT_GRAVITY_MIN_BIT_KHR"/>
        <enum bitpos="1"    name="VK_PRESENT_GRAVITY_MAX_BIT_KHR"/>
        <enum               name="VK_PRESENT_GRAVITY_MAX_BIT_EXT" alias="VK_PRESENT_GRAVITY_MAX_BIT_KHR"/>
        <enum bitpos="2"    name="VK_PRESENT_GRAVITY_CENTERED_BIT_KHR"/>
        <enum               name="VK_PRESENT_GRAVITY_CENTERED_BIT_EXT" alias="VK_PRESENT_GRAVITY_CENTERED_BIT_KHR"/>
    </enums>
    <enums name="VkPhysicalDeviceSchedulingControlsFlagBitsARM" type="bitmask" bitwidth="64">
        <enum bitpos="0"    name="VK_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_SHADER_CORE_COUNT_ARM"/>
    </enums>
    <enums name="VkPresentStageFlagBitsEXT" type="bitmask">
        <enum bitpos="0"    name="VK_PRESENT_STAGE_QUEUE_OPERATIONS_END_BIT_EXT"/>
        <enum bitpos="1"    name="VK_PRESENT_STAGE_REQUEST_DEQUEUED_BIT_EXT"/>
        <enum bitpos="2"    name="VK_PRESENT_STAGE_IMAGE_FIRST_PIXEL_OUT_BIT_EXT"/>
        <enum bitpos="3"    name="VK_PRESENT_STAGE_IMAGE_FIRST_PIXEL_VISIBLE_BIT_EXT"/>
    </enums>
    <enums name="VkPastPresentationTimingFlagBitsEXT" type="bitmask">
        <enum bitpos="0"    name="VK_PAST_PRESENTATION_TIMING_ALLOW_PARTIAL_RESULTS_BIT_EXT"/>
        <enum bitpos="1"    name="VK_PAST_PRESENTATION_TIMING_ALLOW_OUT_OF_ORDER_RESULTS_BIT_EXT"/>
    </enums>
    <enums name="VkPresentTimingInfoFlagBitsEXT" type="bitmask">
        <enum bitpos="0"    name="VK_PRESENT_TIMING_INFO_PRESENT_AT_RELATIVE_TIME_BIT_EXT"/>
        <enum bitpos="1"    name="VK_PRESENT_TIMING_INFO_PRESENT_AT_NEAREST_REFRESH_CYCLE_BIT_EXT"/>
    </enums>
    <enums name="VkVideoCodecOperationFlagBitsKHR" type="bitmask">
        <enum value="0"     name="VK_VIDEO_CODEC_OPERATION_NONE_KHR"/>
    </enums>
    <enums name="VkVideoChromaSubsamplingFlagBitsKHR" type="bitmask" comment="Vulkan video chroma subsampling definitions">
        <enum value="0"     name="VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR"/>
        <enum bitpos="0"    name="VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR"/>
        <enum bitpos="1"    name="VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR"/>
        <enum bitpos="2"    name="VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR"/>
        <enum bitpos="3"    name="VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR"/>
    </enums>
    <enums name="VkVideoComponentBitDepthFlagBitsKHR" type="bitmask" comment="Vulkan video component bit depth definitions">
        <enum value="0"     name="VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR"/>
        <enum bitpos="0"    name="VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR"/>
        <enum bitpos="2"    name="VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR"/>
        <enum bitpos="4"    name="VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR"/>
    </enums>
    <enums name="VkVideoCapabilityFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR"/>
        <enum bitpos="1"    name="VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR"/>
    </enums>
    <enums name="VkVideoSessionCreateFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR"/>
    </enums>
    <enums name="VkVideoSessionParametersCreateFlagBitsKHR" type="bitmask">
    </enums>
    <enums name="VkVideoDecodeH264PictureLayoutFlagBitsKHR" type="bitmask">
        <enum value="0"       name="VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR"/>
        <enum bitpos="0"      name="VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR"/>
        <enum bitpos="1"      name="VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR"/>
    </enums>
    <enums name="VkVideoCodingControlFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR"/>
    </enums>
    <enums name="VkQueryResultStatusKHR" type="enum">
        <enum value="-1"    name="VK_QUERY_RESULT_STATUS_ERROR_KHR"/>
        <enum value="0"     name="VK_QUERY_RESULT_STATUS_NOT_READY_KHR"/>
        <enum value="1"     name="VK_QUERY_RESULT_STATUS_COMPLETE_KHR"/>
    </enums>
    <enums name="VkVideoDecodeUsageFlagBitsKHR" type="bitmask">
        <enum value="0"     name="VK_VIDEO_DECODE_USAGE_DEFAULT_KHR"/>
        <enum bitpos="0"    name="VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR"/>
        <enum bitpos="1"    name="VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR"/>
        <enum bitpos="2"    name="VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR"/>
    </enums>
    <enums name="VkVideoDecodeCapabilityFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR"/>
        <enum bitpos="1"    name="VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR"/>
    </enums>
    <enums name="VkVideoEncodeFlagBitsKHR" type="bitmask">
    </enums>
    <enums name="VkVideoEncodeUsageFlagBitsKHR" type="bitmask">
        <enum value="0"     name="VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR"/>
        <enum bitpos="0"    name="VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR"/>
        <enum bitpos="1"    name="VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR"/>
        <enum bitpos="2"    name="VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR"/>
        <enum bitpos="3"    name="VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR"/>
    </enums>
    <enums name="VkVideoEncodeContentFlagBitsKHR" type="bitmask">
        <enum value="0"     name="VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR"/>
        <enum bitpos="0"    name="VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR"/>
        <enum bitpos="1"    name="VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR"/>
        <enum bitpos="2"    name="VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR"/>
    </enums>
    <enums name="VkVideoEncodeTuningModeKHR" type="enum">
        <enum value="0"     name="VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR"/>
        <enum value="1"     name="VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR"/>
        <enum value="2"     name="VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR"/>
        <enum value="3"     name="VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR"/>
        <enum value="4"     name="VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR"/>
    </enums>
    <enums name="VkVideoEncodeCapabilityFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR"/>
        <enum bitpos="1"    name="VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR"/>
    </enums>
    <enums name="VkVideoEncodeFeedbackFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR"/>
        <enum bitpos="1"    name="VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR"/>
        <enum bitpos="2"    name="VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR"/>
    </enums>
    <enums name="VkVideoEncodeRateControlModeFlagBitsKHR" type="bitmask">
        <enum value="0"     name="VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR"/>
        <enum bitpos="0"    name="VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR"/>
        <enum bitpos="1"    name="VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR"/>
        <enum bitpos="2"    name="VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR"/>
    </enums>
    <enums name="VkVideoEncodeIntraRefreshModeFlagBitsKHR" type="bitmask">
        <enum value="0"     name="VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_NONE_KHR"/>
        <enum bitpos="0"    name="VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_PER_PICTURE_PARTITION_BIT_KHR"/>
        <enum bitpos="1"    name="VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_BASED_BIT_KHR"/>
        <enum bitpos="2"    name="VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_ROW_BASED_BIT_KHR"/>
        <enum bitpos="3"    name="VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_COLUMN_BASED_BIT_KHR"/>
    </enums>
    <enums name="VkVideoEncodeH264CapabilityFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR"/>
        <enum bitpos="1"    name="VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR"/>
        <enum bitpos="2"    name="VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR"/>
        <enum bitpos="3"    name="VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR"/>
        <enum bitpos="4"    name="VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR"/>
        <enum bitpos="5"    name="VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR"/>
        <enum bitpos="6"    name="VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR"/>
        <enum bitpos="7"    name="VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR"/>
        <enum bitpos="8"    name="VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR"/>
    </enums>
    <enums name="VkVideoEncodeH264StdFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR"/>
        <enum bitpos="1"    name="VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_KHR"/>
        <enum bitpos="2"    name="VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_KHR"/>
        <enum bitpos="3"    name="VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_KHR"/>
        <enum bitpos="4"    name="VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_KHR"/>
        <enum bitpos="5"    name="VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_KHR"/>
        <enum bitpos="6"    name="VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR"/>
        <enum bitpos="7"    name="VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_KHR"/>
        <enum bitpos="8"    name="VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_KHR"/>
        <enum bitpos="9"    name="VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_KHR"/>
        <enum bitpos="10"   name="VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_KHR"/>
        <enum bitpos="11"   name="VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_KHR"/>
        <enum bitpos="12"   name="VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_KHR"/>
        <enum bitpos="13"   name="VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_KHR"/>
        <enum bitpos="14"   name="VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR"/>
        <enum bitpos="15"   name="VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_KHR"/>
        <enum bitpos="16"   name="VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_KHR"/>
        <enum bitpos="17"   name="VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_KHR"/>
        <enum bitpos="19"   name="VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_KHR"/>
        <enum bitpos="20"   name="VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR"/>
    </enums>
    <enums name="VkVideoEncodeH264RateControlFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR"/>
        <enum bitpos="1"    name="VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR"/>
        <enum bitpos="2"    name="VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR"/>
        <enum bitpos="3"    name="VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR"/>
        <enum bitpos="4"    name="VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR"/>
    </enums>
    <enums name="VkHostImageCopyFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_HOST_IMAGE_COPY_MEMCPY_BIT"/>
        <enum               name="VK_HOST_IMAGE_COPY_MEMCPY" alias="VK_HOST_IMAGE_COPY_MEMCPY_BIT" deprecated="aliased"/>
    </enums>
    <enums name="VkPartitionedAccelerationStructureOpTypeNV" type="enum">
        <enum value="0"     name="VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV"/>
        <enum value="1"     name="VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV"/>
        <enum value="2"     name="VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV"/>
    </enums>
    <enums name="VkPartitionedAccelerationStructureInstanceFlagBitsNV" type="bitmask">
        <enum bitpos="0"    name="VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FACING_CULL_DISABLE_BIT_NV"/>
        <enum bitpos="1"    name="VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FLIP_FACING_BIT_NV"/>
        <enum bitpos="2"    name="VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_OPAQUE_BIT_NV"/>
        <enum bitpos="3"    name="VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_NO_OPAQUE_BIT_NV"/>
        <enum bitpos="4"    name="VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV"/>
    </enums>
    <enums name="VkImageFormatConstraintsFlagBitsFUCHSIA" type="bitmask">
    </enums>
    <enums name="VkImageConstraintsInfoFlagBitsFUCHSIA" type="bitmask">
        <enum bitpos="0"    name="VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA"/>
        <enum bitpos="1"    name="VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA"/>
        <enum bitpos="2"    name="VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA"/>
        <enum bitpos="3"    name="VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA"/>
        <enum bitpos="4"    name="VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA"/>
    </enums>
    <enums name="VkFormatFeatureFlagBits2" type="bitmask" bitwidth="64">
        <enum bitpos="0"    name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT"/>
        <enum bitpos="1"    name="VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT"/>
        <enum bitpos="2"    name="VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT"/>
        <enum bitpos="3"    name="VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT"/>
        <enum bitpos="4"    name="VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT"/>
        <enum bitpos="5"    name="VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"/>
        <enum bitpos="6"    name="VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT"/>
        <enum bitpos="7"    name="VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT"/>
        <enum bitpos="8"    name="VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT"/>
        <enum bitpos="9"    name="VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT"/>
        <enum bitpos="10"   name="VK_FORMAT_FEATURE_2_BLIT_SRC_BIT"/>
        <enum bitpos="11"   name="VK_FORMAT_FEATURE_2_BLIT_DST_BIT"/>
        <enum bitpos="12"   name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT"/>
            <comment>bitpos 13 is an extension interaction with VK_EXT_filter_cubic"</comment>
        <enum bitpos="14"   name="VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT"/>
        <enum bitpos="15"   name="VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT"/>
        <enum bitpos="16"   name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT"/>
        <enum bitpos="17"   name="VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT"/>
        <enum bitpos="18"   name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT"/>
        <enum bitpos="19"   name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT"/>
        <enum bitpos="20"   name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT"/>
        <enum bitpos="21"   name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT"/>
        <enum bitpos="22"   name="VK_FORMAT_FEATURE_2_DISJOINT_BIT"/>
        <enum bitpos="23"   name="VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT"/>
        <enum bitpos="31"   name="VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT"/>
        <enum bitpos="32"   name="VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT"/>
        <enum bitpos="33"   name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT"/>
    </enums>
    <enums name="VkRenderingFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT"/>
        <enum bitpos="1"    name="VK_RENDERING_SUSPENDING_BIT"/>
        <enum bitpos="2"    name="VK_RENDERING_RESUMING_BIT"/>
    </enums>
    <enums name="VkVideoEncodeH265CapabilityFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR"/>
        <enum bitpos="1"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR"/>
        <enum bitpos="2"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_KHR"/>
        <enum bitpos="3"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR"/>
        <enum bitpos="4"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR"/>
        <enum bitpos="5"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR"/>
        <enum bitpos="6"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR"/>
        <enum bitpos="7"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR"/>
        <enum bitpos="8"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR"/>
        <enum bitpos="9"    name="VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR"/>
    </enums>
    <enums name="VkVideoEncodeH265StdFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR"/>
        <enum bitpos="1"    name="VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_KHR"/>
        <enum bitpos="2"    name="VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_KHR"/>
        <enum bitpos="3"    name="VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_KHR"/>
        <enum bitpos="4"    name="VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_KHR"/>
        <enum bitpos="5"    name="VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_KHR"/>
        <enum bitpos="6"    name="VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR"/>
        <enum bitpos="7"    name="VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_KHR"/>
        <enum bitpos="8"    name="VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_KHR"/>
        <enum bitpos="9"    name="VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_KHR"/>
        <enum bitpos="10"   name="VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_KHR"/>
        <enum bitpos="11"   name="VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_KHR"/>
        <enum bitpos="12"   name="VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_KHR"/>
        <enum bitpos="13"   name="VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_KHR"/>
        <enum bitpos="14"   name="VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR"/>
        <enum bitpos="15"   name="VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_KHR"/>
        <enum bitpos="16"   name="VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_KHR"/>
        <enum bitpos="17"   name="VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_KHR"/>
        <enum bitpos="18"   name="VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_KHR"/>
        <enum bitpos="19"   name="VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_KHR"/>
        <enum bitpos="20"   name="VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR"/>
    </enums>
    <enums name="VkVideoEncodeH265RateControlFlagBitsKHR" type="bitmask">
        <enum bitpos="0"      name="VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR"/>
        <enum bitpos="1"      name="VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR"/>
        <enum bitpos="2"      name="VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR"/>
        <enum bitpos="3"      name="VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR"/>
        <enum bitpos="4"      name="VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_KHR"/>
    </enums>
    <enums name="VkVideoEncodeH265CtbSizeFlagBitsKHR" type="bitmask">
        <enum bitpos="0"      name="VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_KHR"/>
        <enum bitpos="1"      name="VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_KHR"/>
        <enum bitpos="2"      name="VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_KHR"/>
    </enums>
    <enums name="VkVideoEncodeH265TransformBlockSizeFlagBitsKHR" type="bitmask">
        <enum bitpos="0"      name="VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_KHR"/>
        <enum bitpos="1"      name="VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_KHR"/>
        <enum bitpos="2"      name="VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_KHR"/>
        <enum bitpos="3"      name="VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_KHR"/>
    </enums>
    <enums name="VkVideoEncodeAV1CapabilityFlagBitsKHR" type="bitmask">
        <enum bitpos="0"      name="VK_VIDEO_ENCODE_AV1_CAPABILITY_PER_RATE_CONTROL_GROUP_MIN_MAX_Q_INDEX_BIT_KHR"/>
        <enum bitpos="1"      name="VK_VIDEO_ENCODE_AV1_CAPABILITY_GENERATE_OBU_EXTENSION_HEADER_BIT_KHR"/>
        <enum bitpos="2"      name="VK_VIDEO_ENCODE_AV1_CAPABILITY_PRIMARY_REFERENCE_CDF_ONLY_BIT_KHR"/>
        <enum bitpos="3"      name="VK_VIDEO_ENCODE_AV1_CAPABILITY_FRAME_SIZE_OVERRIDE_BIT_KHR"/>
        <enum bitpos="4"      name="VK_VIDEO_ENCODE_AV1_CAPABILITY_MOTION_VECTOR_SCALING_BIT_KHR"/>
    </enums>
    <enums name="VkVideoEncodeAV1StdFlagBitsKHR" type="bitmask">
        <enum bitpos="0"      name="VK_VIDEO_ENCODE_AV1_STD_UNIFORM_TILE_SPACING_FLAG_SET_BIT_KHR"/>
        <enum bitpos="1"      name="VK_VIDEO_ENCODE_AV1_STD_SKIP_MODE_PRESENT_UNSET_BIT_KHR"/>
        <enum bitpos="2"      name="VK_VIDEO_ENCODE_AV1_STD_PRIMARY_REF_FRAME_BIT_KHR"/>
        <enum bitpos="3"      name="VK_VIDEO_ENCODE_AV1_STD_DELTA_Q_BIT_KHR"/>
    </enums>
    <enums name="VkVideoEncodeAV1RateControlFlagBitsKHR" type="bitmask">
        <enum bitpos="0"      name="VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR"/>
        <enum bitpos="1"      name="VK_VIDEO_ENCODE_AV1_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR"/>
        <enum bitpos="2"      name="VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR"/>
        <enum bitpos="3"      name="VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR"/>
    </enums>
    <enums name="VkVideoEncodeAV1SuperblockSizeFlagBitsKHR" type="bitmask">
        <enum bitpos="0"      name="VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_64_BIT_KHR"/>
        <enum bitpos="1"      name="VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_128_BIT_KHR"/>
    </enums>
    <enums name="VkVideoEncodeAV1PredictionModeKHR" type="enum">
        <enum value="0"     name="VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR"/>
        <enum value="1"     name="VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR"/>
        <enum value="2"     name="VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR"/>
        <enum value="3"     name="VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR"/>
    </enums>
    <enums name="VkVideoEncodeAV1RateControlGroupKHR" type="enum">
        <enum value="0"     name="VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR"/>
        <enum value="1"     name="VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR"/>
        <enum value="2"     name="VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR"/>
    </enums>
    <enums name="VkExportMetalObjectTypeFlagBitsEXT" type="bitmask">
        <enum bitpos="0"      name="VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT"/>
        <enum bitpos="1"      name="VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT"/>
        <enum bitpos="2"      name="VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT"/>
        <enum bitpos="3"      name="VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT"/>
        <enum bitpos="4"      name="VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT"/>
        <enum bitpos="5"      name="VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT"/>
    </enums>
    <enums name="VkInstanceCreateFlagBits" type="bitmask">
    </enums>
    <enums name="VkImageCompressionFlagBitsEXT" type="bitmask">
        <enum value="0"      name="VK_IMAGE_COMPRESSION_DEFAULT_EXT"/>
        <enum bitpos="0"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT"/>
        <enum bitpos="1"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT"/>
        <enum bitpos="2"     name="VK_IMAGE_COMPRESSION_DISABLED_EXT"/>
    </enums>
    <enums name="VkImageCompressionFixedRateFlagBitsEXT" type="bitmask">
        <enum value="0"      name="VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT"/>
        <enum bitpos="0"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT"/>
        <enum bitpos="1"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT"/>
        <enum bitpos="2"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT"/>
        <enum bitpos="3"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT"/>
        <enum bitpos="4"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT"/>
        <enum bitpos="5"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT"/>
        <enum bitpos="6"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT"/>
        <enum bitpos="7"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT"/>
        <enum bitpos="8"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT"/>
        <enum bitpos="9"     name="VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT"/>
        <enum bitpos="10"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT"/>
        <enum bitpos="11"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT"/>
        <enum bitpos="12"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT"/>
        <enum bitpos="13"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT"/>
        <enum bitpos="14"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT"/>
        <enum bitpos="15"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT"/>
        <enum bitpos="16"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT"/>
        <enum bitpos="17"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT"/>
        <enum bitpos="18"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT"/>
        <enum bitpos="19"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT"/>
        <enum bitpos="20"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT"/>
        <enum bitpos="21"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT"/>
        <enum bitpos="22"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT"/>
        <enum bitpos="23"    name="VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT"/>
    </enums>
    <enums name="VkPipelineRobustnessBufferBehavior" type="enum">
        <enum value="0"      name="VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT"/>
        <enum value="1"      name="VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED"/>
        <enum value="2"      name="VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS"/>
        <enum value="3"      name="VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2"/>
    </enums>
    <enums name="VkPipelineRobustnessImageBehavior" type="enum">
        <enum value="0"      name="VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT"/>
        <enum value="1"      name="VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED"/>
        <enum value="2"      name="VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS"/>
        <enum value="3"      name="VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2"/>
    </enums>
    <enums name="VkOpticalFlowGridSizeFlagBitsNV" type="bitmask">
        <enum value="0"       name="VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV"/>
        <enum bitpos="0"      name="VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV"/>
        <enum bitpos="1"      name="VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV"/>
        <enum bitpos="2"      name="VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV"/>
        <enum bitpos="3"      name="VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV"/>
    </enums>
    <enums name="VkOpticalFlowUsageFlagBitsNV" type="bitmask">
        <enum value="0"       name="VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV"/>
        <enum bitpos="0"      name="VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV"/>
        <enum bitpos="1"      name="VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV"/>
        <enum bitpos="2"      name="VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV"/>
        <enum bitpos="3"      name="VK_OPTICAL_FLOW_USAGE_COST_BIT_NV"/>
        <enum bitpos="4"      name="VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV"/>
    </enums>
    <enums name="VkOpticalFlowPerformanceLevelNV" type="enum">
        <enum value="0"       name="VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV"/>
        <enum value="1"       name="VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV"/>
        <enum value="2"       name="VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV"/>
        <enum value="3"       name="VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV"/>
    </enums>
    <enums name="VkOpticalFlowSessionBindingPointNV" type="enum">
        <enum value="0"       name="VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV"/>
        <enum value="1"       name="VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV"/>
        <enum value="2"       name="VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV"/>
        <enum value="3"       name="VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV"/>
        <enum value="4"       name="VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV"/>
        <enum value="5"       name="VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV"/>
        <enum value="6"       name="VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV"/>
        <enum value="7"       name="VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV"/>
        <enum value="8"       name="VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV"/>
    </enums>
    <enums name="VkOpticalFlowSessionCreateFlagBitsNV" type="bitmask">
        <enum bitpos="0"      name="VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV"/>
        <enum bitpos="1"      name="VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV"/>
        <enum bitpos="2"      name="VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV"/>
        <enum bitpos="3"      name="VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV"/>
        <enum bitpos="4"      name="VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV"/>
    </enums>
    <enums name="VkOpticalFlowExecuteFlagBitsNV" type="bitmask">
        <enum bitpos="0"      name="VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV"/>
    </enums>
    <enums name="VkMicromapTypeEXT" type="enum">
        <enum value="0" name="VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT"/>
    </enums>
    <enums name="VkBuildMicromapFlagBitsEXT" type="bitmask">
        <enum bitpos="0" name="VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT"/>
        <enum bitpos="1" name="VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT"/>
        <enum bitpos="2" name="VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT"/>
    </enums>
    <enums name="VkMicromapCreateFlagBitsEXT" type="bitmask">
        <enum bitpos="0" name="VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT"/>
    </enums>
    <enums name="VkCopyMicromapModeEXT" type="enum">
        <enum value="0" name="VK_COPY_MICROMAP_MODE_CLONE_EXT"/>
        <enum value="1" name="VK_COPY_MICROMAP_MODE_SERIALIZE_EXT"/>
        <enum value="2" name="VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT"/>
        <enum value="3" name="VK_COPY_MICROMAP_MODE_COMPACT_EXT"/>
    </enums>
    <enums name="VkBuildMicromapModeEXT" type="enum">
        <enum value="0" name="VK_BUILD_MICROMAP_MODE_BUILD_EXT"/>
    </enums>
    <enums name="VkOpacityMicromapFormatEXT" type="enum">
        <enum value="1" name="VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT"/>
        <enum value="2" name="VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT"/>
    </enums>
    <enums name="VkOpacityMicromapSpecialIndexEXT" type="enum">
        <enum value="-1" name="VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT"/>
        <enum value="-2" name="VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT"/>
        <enum value="-3" name="VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT"/>
        <enum value="-4" name="VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT"/>
    </enums>
    <enums name="VkDepthBiasRepresentationEXT" type="enum">
        <enum value="0"     name="VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT"/>
        <enum value="1"     name="VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT"/>
        <enum value="2"     name="VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT"/>
    </enums>
    <enums name="VkDeviceFaultAddressTypeEXT" type="enum">
        <enum value="0"     name="VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT" comment="Currently unused"/>
        <enum value="1"     name="VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT"/>
        <enum value="2"     name="VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT"/>
        <enum value="3"     name="VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT"/>
        <enum value="4"     name="VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT"/>
        <enum value="5"     name="VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT"/>
        <enum value="6"     name="VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT"/>
    </enums>
    <enums name="VkDeviceFaultVendorBinaryHeaderVersionEXT" type="enum">
        <enum value="1"     name="VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT"/>
    </enums>
    <enums name="VkIndirectCommandsLayoutUsageFlagBitsEXT" type="bitmask">
        <enum bitpos="0"     name="VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT"/>
        <enum bitpos="1"     name="VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT"/>
    </enums>
    <enums name="VkIndirectExecutionSetInfoTypeEXT" type="enum">
        <enum value="0"     name="VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT"/>
        <enum value="1"     name="VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT"/>
    </enums>
    <enums name="VkIndirectCommandsInputModeFlagBitsEXT" type="bitmask">
        <enum bitpos="0"     name="VK_INDIRECT_COMMANDS_INPUT_MODE_VULKAN_INDEX_BUFFER_EXT"/>
        <enum bitpos="1"     name="VK_INDIRECT_COMMANDS_INPUT_MODE_DXGI_INDEX_BUFFER_EXT"/>
    </enums>
    <enums name="VkIndirectCommandsTokenTypeEXT" type="enum">
        <enum value="0"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT"/>
        <enum value="1"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT"/>
        <enum value="2"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT"/>
        <enum value="3"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT"/>
        <enum value="4"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT"/>
        <enum value="5"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT"/>
        <enum value="6"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT"/>
        <enum value="7"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT"/>
        <enum value="8"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT"/>
        <enum value="9"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT"/>
    </enums>
    <enums name="VkDisplacementMicromapFormatNV" type="enum">
        <enum value="1" name="VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV"/>
        <enum value="2" name="VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV"/>
        <enum value="3" name="VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV"/>
    </enums>
    <enums name="VkShaderCreateFlagBitsEXT" type="bitmask">
        <enum bitpos="0" name="VK_SHADER_CREATE_LINK_STAGE_BIT_EXT"/>
    </enums>
    <enums name="VkShaderCodeTypeEXT" type="enum">
        <enum value="0" name="VK_SHADER_CODE_TYPE_BINARY_EXT"/>
        <enum value="1" name="VK_SHADER_CODE_TYPE_SPIRV_EXT"/>
    </enums>
    <enums name="VkScopeKHR" type="enum">
        <enum value="1"     name="VK_SCOPE_DEVICE_KHR"/>
        <enum value="2"     name="VK_SCOPE_WORKGROUP_KHR"/>
        <enum value="3"     name="VK_SCOPE_SUBGROUP_KHR"/>
        <enum value="5"     name="VK_SCOPE_QUEUE_FAMILY_KHR"/>
    </enums>
    <enums name="VkComponentTypeKHR" type="enum">
        <enum value="0"     name="VK_COMPONENT_TYPE_FLOAT16_KHR"/>
        <enum value="1"     name="VK_COMPONENT_TYPE_FLOAT32_KHR"/>
        <enum value="2"     name="VK_COMPONENT_TYPE_FLOAT64_KHR"/>
        <enum value="3"     name="VK_COMPONENT_TYPE_SINT8_KHR"/>
        <enum value="4"     name="VK_COMPONENT_TYPE_SINT16_KHR"/>
        <enum value="5"     name="VK_COMPONENT_TYPE_SINT32_KHR"/>
        <enum value="6"     name="VK_COMPONENT_TYPE_SINT64_KHR"/>
        <enum value="7"     name="VK_COMPONENT_TYPE_UINT8_KHR"/>
        <enum value="8"     name="VK_COMPONENT_TYPE_UINT16_KHR"/>
        <enum value="9"     name="VK_COMPONENT_TYPE_UINT32_KHR"/>
        <enum value="10"    name="VK_COMPONENT_TYPE_UINT64_KHR"/>
    </enums>
    <enums name="VkCubicFilterWeightsQCOM" type="enum">
        <enum value="0"     name="VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM"/>
        <enum value="1"     name="VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM"/>
        <enum value="2"     name="VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM"/>
        <enum value="3"     name="VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM"/>
    </enums>
    <enums name="VkBlockMatchWindowCompareModeQCOM" type="enum">
        <enum value="0" name="VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM"/>
        <enum value="1" name="VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM"/>
    </enums>
    <enums name="VkPhysicalDeviceLayeredApiKHR" type="enum">
        <enum value="0"     name="VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR"/>
        <enum value="1"     name="VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR"/>
        <enum value="2"     name="VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR"/>
        <enum value="3"     name="VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR"/>
        <enum value="4"     name="VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR"/>
    </enums>
    <enums name="VkLayeredDriverUnderlyingApiMSFT" type="enum">
        <enum value="0" name="VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT"/>
        <enum value="1" name="VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT"/>
    </enums>
    <enums name="VkLatencyMarkerNV" type="enum">
        <enum value="0"    name="VK_LATENCY_MARKER_SIMULATION_START_NV"/>
        <enum value="1"    name="VK_LATENCY_MARKER_SIMULATION_END_NV"/>
        <enum value="2"    name="VK_LATENCY_MARKER_RENDERSUBMIT_START_NV"/>
        <enum value="3"    name="VK_LATENCY_MARKER_RENDERSUBMIT_END_NV"/>
        <enum value="4"    name="VK_LATENCY_MARKER_PRESENT_START_NV"/>
        <enum value="5"    name="VK_LATENCY_MARKER_PRESENT_END_NV"/>
        <enum value="6"    name="VK_LATENCY_MARKER_INPUT_SAMPLE_NV"/>
        <enum value="7"    name="VK_LATENCY_MARKER_TRIGGER_FLASH_NV"/>
        <enum value="8"    name="VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV"/>
        <enum value="9"    name="VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV"/>
        <enum value="10"   name="VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV"/>
        <enum value="11"   name="VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV"/>
    </enums>
    <enums name="VkOutOfBandQueueTypeNV" type="enum">
        <enum value="0"    name="VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV"/>
        <enum value="1"    name="VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV"/>
    </enums>
    <enums name="VkMemoryUnmapFlagBits" type="bitmask">
    </enums>
    <enums name="VkCompressedTriangleFormatAMDX" type="enum">
        <enum value="0"     name="VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_AMDX"/>
    </enums>
    <enums name="VkWaylandSurfaceCreateFlagBitsKHR" type="bitmask">
    </enums>
    <enums name="VkDepthClampModeEXT" type="enum">
        <enum value="0"    name="VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT"/>
        <enum value="1"    name="VK_DEPTH_CLAMP_MODE_USER_DEFINED_RANGE_EXT"/>
    </enums>
    <enums name="VkAccessFlagBits3KHR" type="bitmask" bitwidth="64">
        <enum value="0"     name="VK_ACCESS_3_NONE_KHR"/>
    </enums>
    <enums name="VkTileShadingRenderPassFlagBitsQCOM" type="bitmask">
        <enum bitpos="0"    name="VK_TILE_SHADING_RENDER_PASS_ENABLE_BIT_QCOM"/>
        <enum bitpos="1"    name="VK_TILE_SHADING_RENDER_PASS_PER_TILE_EXECUTION_BIT_QCOM"/>
    </enums>
    <enums name="VkCooperativeVectorMatrixLayoutNV" type="enum">
        <enum value="0"     name="VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV"/>
        <enum value="1"     name="VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_COLUMN_MAJOR_NV"/>
        <enum value="2"     name="VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV"/>
        <enum value="3"     name="VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV"/>
    </enums>
    <enums name="VkAddressCopyFlagBitsKHR" type="bitmask">
        <enum bitpos="0"    name="VK_ADDRESS_COPY_DEVICE_LOCAL_BIT_KHR"/>
        <enum bitpos="1"    name="VK_ADDRESS_COPY_SPARSE_BIT_KHR"/>
        <enum bitpos="2"    name="VK_ADDRESS_COPY_PROTECTED_BIT_KHR"/>
    </enums>
    <enums name="VkTensorCreateFlagBitsARM" type="bitmask" bitwidth="64">
        <enum bitpos="0"   name="VK_TENSOR_CREATE_MUTABLE_FORMAT_BIT_ARM"/>
        <enum bitpos="1"   name="VK_TENSOR_CREATE_PROTECTED_BIT_ARM"/>
    </enums>
    <enums name="VkTensorUsageFlagBitsARM" type="bitmask" bitwidth="64">
        <enum bitpos="1"   name="VK_TENSOR_USAGE_SHADER_BIT_ARM"           comment="Tensor written/read through shader descriptor"/>
        <enum bitpos="2"   name="VK_TENSOR_USAGE_TRANSFER_SRC_BIT_ARM"     comment="Tensor can be src of a transfer operation"/>
        <enum bitpos="3"   name="VK_TENSOR_USAGE_TRANSFER_DST_BIT_ARM"     comment="Tensor can be dst of a transfer operation"/>
        <enum bitpos="4"   name="VK_TENSOR_USAGE_IMAGE_ALIASING_BIT_ARM"   comment="Tensor can be aliased with an image"/>
    </enums>
    <enums name="VkTensorTilingARM" type="enum">
        <enum value="0"     name="VK_TENSOR_TILING_OPTIMAL_ARM"/>
        <enum value="1"     name="VK_TENSOR_TILING_LINEAR_ARM"/>
    </enums>
    <enums name="VkTensorViewCreateFlagBitsARM" type="bitmask" bitwidth="64">
    </enums>
    <enums name="VkDefaultVertexAttributeValueKHR" type="enum">
        <enum value="0" name="VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ZERO_KHR"/>
        <enum value="1" name="VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ONE_KHR"/>
    </enums>
    <enums name="VkDataGraphPipelineSessionCreateFlagBitsARM" type="bitmask" bitwidth="64">
        <enum bitpos="0"   name="VK_DATA_GRAPH_PIPELINE_SESSION_CREATE_PROTECTED_BIT_ARM"/>
    </enums>
    <enums name="VkDataGraphPipelineSessionBindPointARM" type="enum">
        <enum value="0"      name="VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM"/>
    </enums>
    <enums name="VkDataGraphPipelineSessionBindPointTypeARM" type="enum">
        <enum value="0"      name="VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MEMORY_ARM"/>
    </enums>
    <enums name="VkDataGraphPipelinePropertyARM" type="enum">
        <enum value="0"      name="VK_DATA_GRAPH_PIPELINE_PROPERTY_CREATION_LOG_ARM"/>
        <enum value="1"      name="VK_DATA_GRAPH_PIPELINE_PROPERTY_IDENTIFIER_ARM"/>
    </enums>
    <enums name="VkDataGraphPipelineDispatchFlagBitsARM" type="bitmask" bitwidth="64">
    </enums>
    <enums name="VkPhysicalDeviceDataGraphProcessingEngineTypeARM" type="enum">
        <enum value="0"      name="VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_DEFAULT_ARM"/>
    </enums>
    <enums name="VkPhysicalDeviceDataGraphOperationTypeARM" type="enum">
        <enum value="0"      name="VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_SPIRV_EXTENDED_INSTRUCTION_SET_ARM"/>
    </enums>
    <enums name="VkDataGraphModelCacheTypeQCOM" type="enum">
        <enum value="0"      name="VK_DATA_GRAPH_MODEL_CACHE_TYPE_GENERIC_BINARY_QCOM"/>
    </enums>
    <enums name="VkVideoEncodeRgbModelConversionFlagBitsVALVE" type="bitmask">
        <enum bitpos="0"  name="VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_RGB_IDENTITY_BIT_VALVE"/>
        <enum bitpos="1"  name="VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_IDENTITY_BIT_VALVE"/>
        <enum bitpos="2"  name="VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_709_BIT_VALVE"/>
        <enum bitpos="3"  name="VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_601_BIT_VALVE"/>
        <enum bitpos="4"  name="VK_VIDEO_ENCODE_RGB_MODEL_CONVERSION_YCBCR_2020_BIT_VALVE"/>
    </enums>
    <enums name="VkVideoEncodeRgbRangeCompressionFlagBitsVALVE" type="bitmask">
        <enum bitpos="0"  name="VK_VIDEO_ENCODE_RGB_RANGE_COMPRESSION_FULL_RANGE_BIT_VALVE"/>
        <enum bitpos="1"  name="VK_VIDEO_ENCODE_RGB_RANGE_COMPRESSION_NARROW_RANGE_BIT_VALVE"/>
    </enums>
    <enums name="VkVideoEncodeRgbChromaOffsetFlagBitsVALVE" type="bitmask">
        <enum bitpos="0"  name="VK_VIDEO_ENCODE_RGB_CHROMA_OFFSET_COSITED_EVEN_BIT_VALVE"/>
        <enum bitpos="1"  name="VK_VIDEO_ENCODE_RGB_CHROMA_OFFSET_MIDPOINT_BIT_VALVE"/>
    </enums>
    <enums name="VkSwapchainImageUsageFlagBitsOHOS" type="bitmask">
        <enum bitpos="0"    name="VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_OHOS"/>
    </enums>

    <commands comment="Vulkan command definitions">
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_LAYER_NOT_PRESENT,VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_INCOMPATIBLE_DRIVER,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateInstance</name></proto>
            <param>const <type>VkInstanceCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkInstance</type>* <name>pInstance</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkDestroyInstance</name></proto>
            <param optional="true" externsync="true"><type>VkInstance</type> <name>instance</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <implicitexternsyncparams>
                <param>all sname:VkPhysicalDevice objects enumerated from pname:instance</param>
            </implicitexternsyncparams>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkEnumeratePhysicalDevices</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPhysicalDeviceCount</name></param>
            <param optional="true" len="pPhysicalDeviceCount"><type>VkPhysicalDevice</type>* <name>pPhysicalDevices</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>PFN_vkVoidFunction</type> <name>vkGetDeviceProcAddr</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param len="null-terminated">const <type>char</type>* <name>pName</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>PFN_vkVoidFunction</type> <name>vkGetInstanceProcAddr</name></proto>
            <param optional="true"><type>VkInstance</type> <name>instance</name></param>
            <param len="null-terminated">const <type>char</type>* <name>pName</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetPhysicalDeviceProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceProperties</type>* <name>pProperties</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetPhysicalDeviceQueueFamilyProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pQueueFamilyPropertyCount</name></param>
            <param optional="true" len="pQueueFamilyPropertyCount"><type>VkQueueFamilyProperties</type>* <name>pQueueFamilyProperties</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetPhysicalDeviceMemoryProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceMemoryProperties</type>* <name>pMemoryProperties</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetPhysicalDeviceFeatures</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceFeatures</type>* <name>pFeatures</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetPhysicalDeviceFormatProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkFormatProperties</type>* <name>pFormatProperties</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceImageFormatProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkImageType</type> <name>type</name></param>
            <param><type>VkImageTiling</type> <name>tiling</name></param>
            <param><type>VkImageUsageFlags</type> <name>usage</name></param>
            <param optional="true"><type>VkImageCreateFlags</type> <name>flags</name></param>
            <param><type>VkImageFormatProperties</type>* <name>pImageFormatProperties</name></param>
        </command>
        <command api="vulkan,vulkanbase" export="vulkan" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_FEATURE_NOT_PRESENT,VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateDevice</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkDeviceCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDevice</type>* <name>pDevice</name></param>
        </command>
        <command api="vulkansc" export="vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_FEATURE_NOT_PRESENT,VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_DEVICE_LOST,VK_ERROR_INVALID_PIPELINE_CACHE_DATA,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateDevice</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkDeviceCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDevice</type>* <name>pDevice</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkDestroyDevice</name></proto>
            <param optional="true" externsync="true"><type>VkDevice</type> <name>device</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <implicitexternsyncparams>
                <param>all sname:VkQueue objects created from pname:device</param>
            </implicitexternsyncparams>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkEnumerateInstanceVersion</name></proto>
            <param><type>uint32_t</type>* <name>pApiVersion</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkEnumerateInstanceLayerProperties</name></proto>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkLayerProperties</type>* <name>pProperties</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_LAYER_NOT_PRESENT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkEnumerateInstanceExtensionProperties</name></proto>
            <param optional="true" len="null-terminated">const <type>char</type>* <name>pLayerName</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkExtensionProperties</type>* <name>pProperties</name></param>
        </command>
        <command api="vulkan,vulkanbase" export="vulkan" successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkEnumerateDeviceLayerProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkLayerProperties</type>* <name>pProperties</name></param>
        </command>
        <command api="vulkansc" export="vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkEnumerateDeviceLayerProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkLayerProperties</type>* <name>pProperties</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_LAYER_NOT_PRESENT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkEnumerateDeviceExtensionProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="true" len="null-terminated">const <type>char</type>* <name>pLayerName</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkExtensionProperties</type>* <name>pProperties</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetDeviceQueue</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>uint32_t</type> <name>queueIndex</name></param>
            <param><type>VkQueue</type>* <name>pQueue</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkQueueSubmit</name></proto>
            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
            <param optional="true"><type>uint32_t</type> <name>submitCount</name></param>
            <param len="submitCount">const <type>VkSubmitInfo</type>* <name>pSubmits</name></param>
            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkQueueWaitIdle</name></proto>
            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkDeviceWaitIdle</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <implicitexternsyncparams>
                <param>all sname:VkQueue objects created from pname:device</param>
            </implicitexternsyncparams>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkAllocateMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkMemoryAllocateInfo</type>* <name>pAllocateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDeviceMemory</type>* <name>pMemory</name></param>
        </command>
        <command export="vulkan">
            <proto><type>void</type> <name>vkFreeMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkDeviceMemory</type> <name>memory</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkMapMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkDeviceSize</type> <name>size</name></param>
            <param optional="true"><type>VkMemoryMapFlags</type> <name>flags</name></param>
            <param optional="false,true"><type>void</type>** <name>ppData</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkUnmapMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkDeviceMemory</type> <name>memory</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkFlushMappedMemoryRanges</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>memoryRangeCount</name></param>
            <param len="memoryRangeCount">const <type>VkMappedMemoryRange</type>* <name>pMemoryRanges</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkInvalidateMappedMemoryRanges</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>memoryRangeCount</name></param>
            <param len="memoryRangeCount">const <type>VkMappedMemoryRange</type>* <name>pMemoryRanges</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetDeviceMemoryCommitment</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkDeviceSize</type>* <name>pCommittedMemoryInBytes</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetBufferMemoryRequirements</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkMemoryRequirements</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkBindBufferMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkDeviceSize</type> <name>memoryOffset</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetImageMemoryRequirements</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>VkMemoryRequirements</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkBindImageMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkImage</type> <name>image</name></param>
            <param><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkDeviceSize</type> <name>memoryOffset</name></param>
        </command>
        <command export="vulkan">
            <proto><type>void</type> <name>vkGetImageSparseMemoryRequirements</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pSparseMemoryRequirementCount</name></param>
            <param optional="true" len="pSparseMemoryRequirementCount"><type>VkSparseImageMemoryRequirements</type>* <name>pSparseMemoryRequirements</name></param>
        </command>
        <command export="vulkan">
            <proto><type>void</type> <name>vkGetPhysicalDeviceSparseImageFormatProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkImageType</type> <name>type</name></param>
            <param><type>VkSampleCountFlagBits</type> <name>samples</name></param>
            <param><type>VkImageUsageFlags</type> <name>usage</name></param>
            <param><type>VkImageTiling</type> <name>tiling</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkSparseImageFormatProperties</type>* <name>pProperties</name></param>
        </command>
        <command export="vulkan" queues="VK_QUEUE_SPARSE_BINDING_BIT" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkQueueBindSparse</name></proto>
            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
            <param optional="true"><type>uint32_t</type> <name>bindInfoCount</name></param>
            <param len="bindInfoCount">const <type>VkBindSparseInfo</type>* <name>pBindInfo</name></param>
            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateFence</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkFenceCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkFence</type>* <name>pFence</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkDestroyFence</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkResetFences</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>fenceCount</name></param>
            <param len="fenceCount" externsync="true">const <type>VkFence</type>* <name>pFences</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS,VK_NOT_READY" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetFenceStatus</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkFence</type> <name>fence</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS,VK_TIMEOUT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkWaitForFences</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>fenceCount</name></param>
            <param len="fenceCount">const <type>VkFence</type>* <name>pFences</name></param>
            <param><type>VkBool32</type> <name>waitAll</name></param>
            <param><type>uint64_t</type> <name>timeout</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateSemaphore</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSemaphoreCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSemaphore</type>* <name>pSemaphore</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkDestroySemaphore</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkSemaphore</type> <name>semaphore</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkEventCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkEvent</type>* <name>pEvent</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkDestroyEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkEvent</type> <name>event</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_EVENT_SET,VK_EVENT_RESET" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetEventStatus</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkEvent</type> <name>event</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkSetEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkEvent</type> <name>event</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkResetEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkEvent</type> <name>event</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateQueryPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkQueryPoolCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkQueryPool</type>* <name>pQueryPool</name></param>
        </command>
        <command export="vulkan">
            <proto><type>void</type> <name>vkDestroyQueryPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkQueryPool</type> <name>queryPool</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS,VK_NOT_READY" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetQueryPoolResults</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>firstQuery</name></param>
            <param><type>uint32_t</type> <name>queryCount</name></param>
            <param><type>size_t</type> <name>dataSize</name></param>
            <param len="dataSize"><type>void</type>* <name>pData</name></param>
            <param><type>VkDeviceSize</type> <name>stride</name></param>
            <param optional="true"><type>VkQueryResultFlags</type> <name>flags</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkResetQueryPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>firstQuery</name></param>
            <param><type>uint32_t</type> <name>queryCount</name></param>
        </command>
        <command name="vkResetQueryPoolEXT"                        alias="vkResetQueryPool"/>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateBuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkBufferCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkBuffer</type>* <name>pBuffer</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkDestroyBuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkBuffer</type> <name>buffer</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateBufferView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkBufferViewCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkBufferView</type>* <name>pView</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkDestroyBufferView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkBufferView</type> <name>bufferView</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_COMPRESSION_EXHAUSTED_EXT,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateImage</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImageCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkImage</type>* <name>pImage</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkDestroyImage</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkImage</type> <name>image</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetImageSubresourceLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param>const <type>VkImageSubresource</type>* <name>pSubresource</name></param>
            <param><type>VkSubresourceLayout</type>* <name>pLayout</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateImageView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImageViewCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkImageView</type>* <name>pView</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkDestroyImageView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkImageView</type> <name>imageView</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command export="vulkan" allownoqueues="true" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateShaderModule</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkShaderModuleCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkShaderModule</type>* <name>pShaderModule</name></param>
        </command>
        <command export="vulkan">
            <proto><type>void</type> <name>vkDestroyShaderModule</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkShaderModule</type> <name>shaderModule</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command api="vulkan,vulkanbase" export="vulkan" allownoqueues="true" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreatePipelineCache</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPipelineCacheCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkPipelineCache</type>* <name>pPipelineCache</name></param>
        </command>
        <command api="vulkansc" export="vulkansc" allownoqueues="true" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_PIPELINE_CACHE_DATA,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreatePipelineCache</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPipelineCacheCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkPipelineCache</type>* <name>pPipelineCache</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkDestroyPipelineCache</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command export="vulkan" successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPipelineCacheData</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param optional="false,true"><type>size_t</type>* <name>pDataSize</name></param>
            <param optional="true" len="pDataSize"><type>void</type>* <name>pData</name></param>
        </command>
        <command export="vulkan" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkMergePipelineCaches</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="maybe"><type>VkPipelineCache</type> <name>dstCache</name></param>
            <param><type>uint32_t</type> <name>srcCacheCount</name></param>
            <param len="srcCacheCount">const <type>VkPipelineCache</type>* <name>pSrcCaches</name></param>
        </command>
        <command allownoqueues="true" successcodes="VK_SUCCESS,VK_INCOMPLETE,VK_PIPELINE_BINARY_MISSING_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreatePipelineBinariesKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPipelineBinaryCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkPipelineBinaryHandlesInfoKHR</type>* <name>pBinaries</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyPipelineBinaryKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkPipelineBinaryKHR</type> <name>pipelineBinary</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPipelineKeyKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true">const <type>VkPipelineCreateInfoKHR</type>* <name>pPipelineCreateInfo</name></param>
            <param><type>VkPipelineBinaryKeyKHR</type>* <name>pPipelineKey</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NOT_ENOUGH_SPACE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPipelineBinaryDataKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPipelineBinaryDataInfoKHR</type>* <name>pInfo</name></param>
            <param><type>VkPipelineBinaryKeyKHR</type>* <name>pPipelineBinaryKey</name></param>
            <param optional="false,true"><type>size_t</type>* <name>pPipelineBinaryDataSize</name></param>
            <param optional="true" len="pPipelineBinaryDataSize"><type>void</type>* <name>pPipelineBinaryData</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkReleaseCapturedPipelineDataKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkReleaseCapturedPipelineDataInfoKHR</type>* <name>pInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command api="vulkan,vulkanbase" export="vulkan" allownoqueues="true" successcodes="VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateGraphicsPipelines</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="maybe"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param><type>uint32_t</type> <name>createInfoCount</name></param>
            <param len="createInfoCount">const <type>VkGraphicsPipelineCreateInfo</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
        </command>
        <command api="vulkansc" export="vulkansc" allownoqueues="true" successcodes="VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NO_PIPELINE_MATCH,VK_ERROR_OUT_OF_POOL_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateGraphicsPipelines</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="maybe"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param><type>uint32_t</type> <name>createInfoCount</name></param>
            <param len="createInfoCount">const <type>VkGraphicsPipelineCreateInfo</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
        </command>
        <command api="vulkan,vulkanbase" export="vulkan" allownoqueues="true" successcodes="VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateComputePipelines</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="maybe"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param><type>uint32_t</type> <name>createInfoCount</name></param>
            <param len="createInfoCount">const <type>VkComputePipelineCreateInfo</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
        </command>
        <command api="vulkansc" export="vulkansc" allownoqueues="true" successcodes="VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NO_PIPELINE_MATCH,VK_ERROR_OUT_OF_POOL_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateComputePipelines</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="maybe"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param><type>uint32_t</type> <name>createInfoCount</name></param>
            <param len="createInfoCount">const <type>VkComputePipelineCreateInfo</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkRenderPass</type> <name>renderpass</name></param>
            <param len="1"><type>VkExtent2D</type>* <name>pMaxWorkgroupSize</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkDestroyPipeline</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkPipeline</type> <name>pipeline</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command export="vulkan,vulkansc" allownoqueues="true" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreatePipelineLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPipelineLayoutCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkPipelineLayout</type>* <name>pPipelineLayout</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkDestroyPipelineLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkPipelineLayout</type> <name>pipelineLayout</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command export="vulkan,vulkansc" allownoqueues="true" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateSampler</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSamplerCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSampler</type>* <name>pSampler</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkDestroySampler</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkSampler</type> <name>sampler</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command export="vulkan,vulkansc" allownoqueues="true" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateDescriptorSetLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDescriptorSetLayoutCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDescriptorSetLayout</type>* <name>pSetLayout</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkDestroyDescriptorSetLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkDescriptorSetLayout</type> <name>descriptorSetLayout</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FRAGMENTATION_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateDescriptorPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDescriptorPoolCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDescriptorPool</type>* <name>pDescriptorPool</name></param>
        </command>
        <command export="vulkan">
            <proto><type>void</type> <name>vkDestroyDescriptorPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkResetDescriptorPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
            <param optional="true"><type>VkDescriptorPoolResetFlags</type> <name>flags</name></param>
            <implicitexternsyncparams>
                <param>any sname:VkDescriptorSet objects allocated from pname:descriptorPool</param>
            </implicitexternsyncparams>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FRAGMENTED_POOL,VK_ERROR_OUT_OF_POOL_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkAllocateDescriptorSets</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDescriptorSetAllocateInfo</type>* <name>pAllocateInfo</name></param>
            <param len="pAllocateInfo-&gt;descriptorSetCount"><type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkFreeDescriptorSets</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
            <param><type>uint32_t</type> <name>descriptorSetCount</name></param>
            <param noautovalidity="true" externsync="true" len="descriptorSetCount">const <type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkUpdateDescriptorSets</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true"><type>uint32_t</type> <name>descriptorWriteCount</name></param>
            <param len="descriptorWriteCount" externsync="maybe:pDescriptorWrites[].dstSet">const <type>VkWriteDescriptorSet</type>* <name>pDescriptorWrites</name></param>
            <param optional="true"><type>uint32_t</type> <name>descriptorCopyCount</name></param>
            <param len="descriptorCopyCount">const <type>VkCopyDescriptorSet</type>* <name>pDescriptorCopies</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateFramebuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkFramebufferCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkFramebuffer</type>* <name>pFramebuffer</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkDestroyFramebuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkFramebuffer</type> <name>framebuffer</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command export="vulkan,vulkansc" allownoqueues="true" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateRenderPass</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkRenderPassCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkRenderPass</type>* <name>pRenderPass</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkDestroyRenderPass</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkRenderPass</type> <name>renderPass</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetRenderAreaGranularity</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkRenderPass</type> <name>renderPass</name></param>
            <param><type>VkExtent2D</type>* <name>pGranularity</name></param>
        </command>
        <command export="vulkan">
            <proto><type>void</type> <name>vkGetRenderingAreaGranularity</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkRenderingAreaInfo</type>* <name>pRenderingAreaInfo</name></param>
            <param><type>VkExtent2D</type>* <name>pGranularity</name></param>
        </command>
        <command name="vkGetRenderingAreaGranularityKHR" alias="vkGetRenderingAreaGranularity"/>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateCommandPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkCommandPoolCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkCommandPool</type>* <name>pCommandPool</name></param>
        </command>
        <command export="vulkan">
            <proto><type>void</type> <name>vkDestroyCommandPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkResetCommandPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
            <param optional="true"><type>VkCommandPoolResetFlags</type> <name>flags</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkAllocateCommandBuffers</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkCommandBufferAllocateInfo</type>* <name>pAllocateInfo</name></param>
            <param len="pAllocateInfo-&gt;commandBufferCount"><type>VkCommandBuffer</type>* <name>pCommandBuffers</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkFreeCommandBuffers</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
            <param><type>uint32_t</type> <name>commandBufferCount</name></param>
            <param noautovalidity="true" externsync="true" len="commandBufferCount">const <type>VkCommandBuffer</type>* <name>pCommandBuffers</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkBeginCommandBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCommandBufferBeginInfo</type>* <name>pBeginInfo</name></param>
            <implicitexternsyncparams>
                <param>the sname:VkCommandPool that pname:commandBuffer was allocated from</param>
            </implicitexternsyncparams>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkEndCommandBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <implicitexternsyncparams>
                <param>the sname:VkCommandPool that pname:commandBuffer was allocated from</param>
            </implicitexternsyncparams>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkResetCommandBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param optional="true"><type>VkCommandBufferResetFlags</type> <name>flags</name></param>
            <implicitexternsyncparams>
                <param>the sname:VkCommandPool that pname:commandBuffer was allocated from</param>
            </implicitexternsyncparams>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_DATA_GRAPH_BIT_ARM" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdBindPipeline</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
            <param><type>VkPipeline</type> <name>pipeline</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetAttachmentFeedbackLoopEnableEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param optional="true"><type>VkImageAspectFlags</type> <name>aspectMask</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetViewport</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstViewport</name></param>
            <param><type>uint32_t</type> <name>viewportCount</name></param>
            <param len="viewportCount">const <type>VkViewport</type>* <name>pViewports</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetScissor</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstScissor</name></param>
            <param><type>uint32_t</type> <name>scissorCount</name></param>
            <param len="scissorCount">const <type>VkRect2D</type>* <name>pScissors</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetLineWidth</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>float</type> <name>lineWidth</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetDepthBias</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>float</type> <name>depthBiasConstantFactor</name></param>
            <param><type>float</type> <name>depthBiasClamp</name></param>
            <param><type>float</type> <name>depthBiasSlopeFactor</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetBlendConstants</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>float</type> <name>blendConstants</name>[4]</param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetDepthBounds</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>float</type> <name>minDepthBounds</name></param>
            <param><type>float</type> <name>maxDepthBounds</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetStencilCompareMask</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
            <param><type>uint32_t</type> <name>compareMask</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetStencilWriteMask</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
            <param><type>uint32_t</type> <name>writeMask</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetStencilReference</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
            <param><type>uint32_t</type> <name>reference</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_DATA_GRAPH_BIT_ARM" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdBindDescriptorSets</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
            <param><type>VkPipelineLayout</type> <name>layout</name></param>
            <param><type>uint32_t</type> <name>firstSet</name></param>
            <param><type>uint32_t</type> <name>descriptorSetCount</name></param>
            <param len="descriptorSetCount" optional="false,true">const <type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
            <param optional="true"><type>uint32_t</type> <name>dynamicOffsetCount</name></param>
            <param len="dynamicOffsetCount">const <type>uint32_t</type>* <name>pDynamicOffsets</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdBindIndexBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param optional="true"><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkIndexType</type> <name>indexType</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdBindVertexBuffers</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstBinding</name></param>
            <param><type>uint32_t</type> <name>bindingCount</name></param>
            <param len="bindingCount" optional="false,true">const <type>VkBuffer</type>* <name>pBuffers</name></param>
            <param len="bindingCount">const <type>VkDeviceSize</type>* <name>pOffsets</name></param>
        </command>
        <command conditionalrendering="true" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDraw</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>vertexCount</name></param>
            <param><type>uint32_t</type> <name>instanceCount</name></param>
            <param><type>uint32_t</type> <name>firstVertex</name></param>
            <param><type>uint32_t</type> <name>firstInstance</name></param>
        </command>
        <command conditionalrendering="true" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDrawIndexed</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>indexCount</name></param>
            <param><type>uint32_t</type> <name>instanceCount</name></param>
            <param><type>uint32_t</type> <name>firstIndex</name></param>
            <param><type>int32_t</type> <name>vertexOffset</name></param>
            <param><type>uint32_t</type> <name>firstInstance</name></param>
        </command>
        <command conditionalrendering="true" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDrawMultiEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param optional="true"><type>uint32_t</type> <name>drawCount</name></param>
            <param noautovalidity="true" len="drawCount" stride="stride">const <type>VkMultiDrawInfoEXT</type>* <name>pVertexInfo</name></param>
            <param><type>uint32_t</type> <name>instanceCount</name></param>
            <param><type>uint32_t</type> <name>firstInstance</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command conditionalrendering="true" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDrawMultiIndexedEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param optional="true"><type>uint32_t</type> <name>drawCount</name></param>
            <param noautovalidity="true" len="drawCount" stride="stride">const <type>VkMultiDrawIndexedInfoEXT</type>* <name>pIndexInfo</name></param>
            <param><type>uint32_t</type> <name>instanceCount</name></param>
            <param><type>uint32_t</type> <name>firstInstance</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
            <param optional="true">const <type>int32_t</type>* <name>pVertexOffset</name></param>
        </command>
        <command conditionalrendering="true" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDrawIndirect</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>uint32_t</type> <name>drawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command conditionalrendering="true" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDrawIndexedIndirect</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>uint32_t</type> <name>drawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command conditionalrendering="true" export="vulkan,vulkansc" queues="VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDispatch</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>groupCountX</name></param>
            <param><type>uint32_t</type> <name>groupCountY</name></param>
            <param><type>uint32_t</type> <name>groupCountZ</name></param>
        </command>
        <command conditionalrendering="true" export="vulkan,vulkansc" queues="VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDispatchIndirect</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdSubpassShadingHUAWEI</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
        </command>
        <command conditionalrendering="true" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDrawClusterHUAWEI</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>groupCountX</name></param>
            <param><type>uint32_t</type> <name>groupCountY</name></param>
            <param><type>uint32_t</type> <name>groupCountZ</name></param>
        </command>
        <command conditionalrendering="true" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDrawClusterIndirectHUAWEI</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdUpdatePipelineIndirectBufferNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineBindPoint</type>           <name>pipelineBindPoint</name></param>
            <param><type>VkPipeline</type>                    <name>pipeline</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>srcBuffer</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkBufferCopy</type>* <name>pRegions</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkImage</type> <name>dstImage</name></param>
            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkImageCopy</type>* <name>pRegions</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdBlitImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkImage</type> <name>dstImage</name></param>
            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkImageBlit</type>* <name>pRegions</name></param>
            <param><type>VkFilter</type> <name>filter</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyBufferToImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>srcBuffer</name></param>
            <param><type>VkImage</type> <name>dstImage</name></param>
            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkBufferImageCopy</type>* <name>pRegions</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyImageToBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkBufferImageCopy</type>* <name>pRegions</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyMemoryIndirectNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkDeviceAddress</type> <name>copyBufferAddress</name></param>
            <param><type>uint32_t</type> <name>copyCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyMemoryIndirectKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCopyMemoryIndirectInfoKHR</type>* <name>pCopyMemoryIndirectInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyMemoryToImageIndirectNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkDeviceAddress</type> <name>copyBufferAddress</name></param>
            <param><type>uint32_t</type> <name>copyCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
            <param><type>VkImage</type> <name>dstImage</name></param>
            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
            <param len="copyCount">const <type>VkImageSubresourceLayers</type>* <name>pImageSubresources</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyMemoryToImageIndirectKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCopyMemoryToImageIndirectInfoKHR</type>* <name>pCopyMemoryToImageIndirectInfo</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdUpdateBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
            <param><type>VkDeviceSize</type> <name>dataSize</name></param>
            <param len="dataSize">const <type>void</type>* <name>pData</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action" comment="transfer support is only available when VK_KHR_maintenance1 is enabled, as documented in valid usage language in the specification">
            <proto><type>void</type> <name>vkCmdFillBuffer</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
            <param><type>VkDeviceSize</type> <name>size</name></param>
            <param><type>uint32_t</type> <name>data</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdClearColorImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
            <param noautovalidity="true">const <type>VkClearColorValue</type>* <name>pColor</name></param>
            <param><type>uint32_t</type> <name>rangeCount</name></param>
            <param len="rangeCount">const <type>VkImageSubresourceRange</type>* <name>pRanges</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdClearDepthStencilImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
            <param>const <type>VkClearDepthStencilValue</type>* <name>pDepthStencil</name></param>
            <param><type>uint32_t</type> <name>rangeCount</name></param>
            <param len="rangeCount">const <type>VkImageSubresourceRange</type>* <name>pRanges</name></param>
        </command>
        <command conditionalrendering="true" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdClearAttachments</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>attachmentCount</name></param>
            <param len="attachmentCount">const <type>VkClearAttachment</type>* <name>pAttachments</name></param>
            <param><type>uint32_t</type> <name>rectCount</name></param>
            <param len="rectCount">const <type>VkClearRect</type>* <name>pRects</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdResolveImage</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkImage</type> <name>dstImage</name></param>
            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param len="regionCount">const <type>VkImageResolve</type>* <name>pRegions</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR" renderpass="outside" videocoding="both" cmdbufferlevel="primary,secondary" tasks="synchronization">
            <proto><type>void</type> <name>vkCmdSetEvent</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkEvent</type> <name>event</name></param>
            <param optional="true"><type>VkPipelineStageFlags</type> <name>stageMask</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR" renderpass="outside" videocoding="both" cmdbufferlevel="primary,secondary" tasks="synchronization">
            <proto><type>void</type> <name>vkCmdResetEvent</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkEvent</type> <name>event</name></param>
            <param optional="true"><type>VkPipelineStageFlags</type> <name>stageMask</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="synchronization">
            <proto><type>void</type> <name>vkCmdWaitEvents</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>eventCount</name></param>
            <param len="eventCount">const <type>VkEvent</type>* <name>pEvents</name></param>
            <param optional="true"><type>VkPipelineStageFlags</type> <name>srcStageMask</name></param>
            <param optional="true"><type>VkPipelineStageFlags</type> <name>dstStageMask</name></param>
            <param optional="true"><type>uint32_t</type> <name>memoryBarrierCount</name></param>
            <param len="memoryBarrierCount">const <type>VkMemoryBarrier</type>* <name>pMemoryBarriers</name></param>
            <param optional="true"><type>uint32_t</type> <name>bufferMemoryBarrierCount</name></param>
            <param len="bufferMemoryBarrierCount">const <type>VkBufferMemoryBarrier</type>* <name>pBufferMemoryBarriers</name></param>
            <param optional="true"><type>uint32_t</type> <name>imageMemoryBarrierCount</name></param>
            <param len="imageMemoryBarrierCount">const <type>VkImageMemoryBarrier</type>* <name>pImageMemoryBarriers</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="synchronization">
            <proto><type>void</type> <name>vkCmdPipelineBarrier</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param optional="true"><type>VkPipelineStageFlags</type> <name>srcStageMask</name></param>
            <param optional="true"><type>VkPipelineStageFlags</type> <name>dstStageMask</name></param>
            <param optional="true"><type>VkDependencyFlags</type> <name>dependencyFlags</name></param>
            <param optional="true"><type>uint32_t</type> <name>memoryBarrierCount</name></param>
            <param len="memoryBarrierCount">const <type>VkMemoryBarrier</type>* <name>pMemoryBarriers</name></param>
            <param optional="true"><type>uint32_t</type> <name>bufferMemoryBarrierCount</name></param>
            <param len="bufferMemoryBarrierCount">const <type>VkBufferMemoryBarrier</type>* <name>pBufferMemoryBarriers</name></param>
            <param optional="true"><type>uint32_t</type> <name>imageMemoryBarrierCount</name></param>
            <param len="imageMemoryBarrierCount">const <type>VkImageMemoryBarrier</type>* <name>pImageMemoryBarriers</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="action,state">
            <proto><type>void</type> <name>vkCmdBeginQuery</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>query</name></param>
            <param optional="true"><type>VkQueryControlFlags</type> <name>flags</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="action,state">
            <proto><type>void</type> <name>vkCmdEndQuery</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>query</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action,state">
            <proto><type>void</type> <name>vkCmdBeginConditionalRenderingEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkConditionalRenderingBeginInfoEXT</type>* <name>pConditionalRenderingBegin</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action,state">
            <proto><type>void</type> <name>vkCmdEndConditionalRenderingEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
        </command>
        <command conditionalrendering="true" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdBeginCustomResolveEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param optional="true">const <type>VkBeginCustomResolveInfoEXT</type>* <name>pBeginCustomResolveInfo</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdResetQueryPool</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>firstQuery</name></param>
            <param><type>uint32_t</type> <name>queryCount</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdWriteTimestamp</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineStageFlagBits</type> <name>pipelineStage</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>query</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyQueryPoolResults</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>firstQuery</name></param>
            <param><type>uint32_t</type> <name>queryCount</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
            <param><type>VkDeviceSize</type> <name>stride</name></param>
            <param optional="true"><type>VkQueryResultFlags</type> <name>flags</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdPushConstants</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineLayout</type> <name>layout</name></param>
            <param><type>VkShaderStageFlags</type> <name>stageFlags</name></param>
            <param><type>uint32_t</type> <name>offset</name></param>
            <param><type>uint32_t</type> <name>size</name></param>
            <param len="size">const <type>void</type>* <name>pValues</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="outside" cmdbufferlevel="primary" tasks="action,state,synchronization">
            <proto><type>void</type> <name>vkCmdBeginRenderPass</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkRenderPassBeginInfo</type>* <name>pRenderPassBegin</name></param>
            <param><type>VkSubpassContents</type> <name>contents</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary" tasks="action,state,synchronization">
            <proto><type>void</type> <name>vkCmdNextSubpass</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkSubpassContents</type> <name>contents</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary" tasks="action,state,synchronization">
            <proto><type>void</type> <name>vkCmdEndRenderPass</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="indirection">
            <proto><type>void</type> <name>vkCmdExecuteCommands</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>commandBufferCount</name></param>
            <param len="commandBufferCount">const <type>VkCommandBuffer</type>* <name>pCommandBuffers</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateAndroidSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkAndroidSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateSurfaceOHOS</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkSurfaceCreateInfoOHOS</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayPropertiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkDisplayPropertiesKHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayPlanePropertiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkDisplayPlanePropertiesKHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetDisplayPlaneSupportedDisplaysKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>planeIndex</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pDisplayCount</name></param>
            <param optional="true" len="pDisplayCount"><type>VkDisplayKHR</type>* <name>pDisplays</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetDisplayModePropertiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkDisplayKHR</type> <name>display</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkDisplayModePropertiesKHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateDisplayModeKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param externsync="true"><type>VkDisplayKHR</type> <name>display</name></param>
            <param>const <type>VkDisplayModeCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDisplayModeKHR</type>* <name>pMode</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetDisplayPlaneCapabilitiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param externsync="true"><type>VkDisplayModeKHR</type> <name>mode</name></param>
            <param><type>uint32_t</type> <name>planeIndex</name></param>
            <param><type>VkDisplayPlaneCapabilitiesKHR</type>* <name>pCapabilities</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateDisplayPlaneSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkDisplaySurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INCOMPATIBLE_DISPLAY_KHR,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateSharedSwapchainsKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>swapchainCount</name></param>
            <param api="vulkan,vulkanbase" len="swapchainCount">const <type>VkSwapchainCreateInfoKHR</type>* <name>pCreateInfos</name></param>
            <param api="vulkansc" len="swapchainCount">const <type>VkSwapchainCreateInfoKHR</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="swapchainCount"><type>VkSwapchainKHR</type>* <name>pSwapchains</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroySurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param optional="true" externsync="true"><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param><type>VkBool32</type>* <name>pSupported</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param><type>VkSurfaceCapabilitiesKHR</type>* <name>pSurfaceCapabilities</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceFormatsKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="true"><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pSurfaceFormatCount</name></param>
            <param optional="true" len="pSurfaceFormatCount"><type>VkSurfaceFormatKHR</type>* <name>pSurfaceFormats</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfacePresentModesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="true"><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPresentModeCount</name></param>
            <param optional="true" len="pPresentModeCount"><type>VkPresentModeKHR</type>* <name>pPresentModes</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_COMPRESSION_EXHAUSTED_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateSwapchainKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param api="vulkan,vulkanbase">const <type>VkSwapchainCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param api="vulkansc">const <type>VkSwapchainCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSwapchainKHR</type>* <name>pSwapchain</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroySwapchainKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetSwapchainImagesKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pSwapchainImageCount</name></param>
            <param optional="true" len="pSwapchainImageCount"><type>VkImage</type>* <name>pSwapchainImages</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_TIMEOUT,VK_NOT_READY,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkAcquireNextImageKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param><type>uint64_t</type> <name>timeout</name></param>
            <param optional="true" externsync="true"><type>VkSemaphore</type> <name>semaphore</name></param>
            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
            <param><type>uint32_t</type>* <name>pImageIndex</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED,VK_ERROR_PRESENT_TIMING_QUEUE_FULL_EXT">
            <proto><type>VkResult</type> <name>vkQueuePresentKHR</name></proto>
            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
            <param>const <type>VkPresentInfoKHR</type>* <name>pPresentInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateViSurfaceNN</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkViSurfaceCreateInfoNN</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateWaylandSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkWaylandSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceWaylandPresentationSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param>struct <type>wl_display</type>* <name>display</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateWin32SurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkWin32SurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceWin32PresentationSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateXlibSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkXlibSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceXlibPresentationSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>Display</type>* <name>dpy</name></param>
            <param><type>VisualID</type> <name>visualID</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateXcbSurfaceKHR</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkXcbSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceXcbPresentationSupportKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>xcb_connection_t</type>* <name>connection</name></param>
            <param><type>xcb_visualid_t</type> <name>visual_id</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateDirectFBSurfaceEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkDirectFBSurfaceCreateInfoEXT</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceDirectFBPresentationSupportEXT</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>IDirectFB</type>* <name>dfb</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateImagePipeSurfaceFUCHSIA</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkImagePipeSurfaceCreateInfoFUCHSIA</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateStreamDescriptorSurfaceGGP</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkStreamDescriptorSurfaceCreateInfoGGP</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateScreenSurfaceQNX</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkScreenSurfaceCreateInfoQNX</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command>
            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceScreenPresentationSupportQNX</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param>struct <type>_screen_window</type>* <name>window</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateDebugReportCallbackEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkDebugReportCallbackCreateInfoEXT</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDebugReportCallbackEXT</type>* <name>pCallback</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyDebugReportCallbackEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param optional="true" externsync="true"><type>VkDebugReportCallbackEXT</type> <name>callback</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDebugReportMessageEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param><type>VkDebugReportFlagsEXT</type> <name>flags</name></param>
            <param><type>VkDebugReportObjectTypeEXT</type> <name>objectType</name></param>
            <param objecttype="objectType"><type>uint64_t</type> <name>object</name></param>
            <param><type>size_t</type> <name>location</name></param>
            <param><type>int32_t</type> <name>messageCode</name></param>
            <param len="null-terminated">const <type>char</type>* <name>pLayerPrefix</name></param>
            <param len="null-terminated">const <type>char</type>* <name>pMessage</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkDebugMarkerSetObjectNameEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDebugMarkerObjectNameInfoEXT</type>* <name>pNameInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkDebugMarkerSetObjectTagEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDebugMarkerObjectTagInfoEXT</type>* <name>pTagInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdDebugMarkerBeginEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkDebugMarkerMarkerInfoEXT</type>* <name>pMarkerInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdDebugMarkerEndEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdDebugMarkerInsertEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkDebugMarkerMarkerInfoEXT</type>* <name>pMarkerInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceExternalImageFormatPropertiesNV</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkImageType</type> <name>type</name></param>
            <param><type>VkImageTiling</type> <name>tiling</name></param>
            <param><type>VkImageUsageFlags</type> <name>usage</name></param>
            <param optional="true"><type>VkImageCreateFlags</type> <name>flags</name></param>
            <param optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>externalHandleType</name></param>
            <param><type>VkExternalImageFormatPropertiesNV</type>* <name>pExternalImageFormatProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetMemoryWin32HandleNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleType</name></param>
            <param><type>HANDLE</type>* <name>pHandle</name></param>
        </command>
        <command conditionalrendering="true" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action,indirection">
            <proto><type>void</type> <name>vkCmdExecuteGeneratedCommandsNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>isPreprocessed</name></param>
            <param>const <type>VkGeneratedCommandsInfoNV</type>* <name>pGeneratedCommandsInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdPreprocessGeneratedCommandsNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkGeneratedCommandsInfoNV</type>* <name>pGeneratedCommandsInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdBindPipelineShaderGroupNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
            <param><type>VkPipeline</type> <name>pipeline</name></param>
            <param><type>uint32_t</type> <name>groupIndex</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetGeneratedCommandsMemoryRequirementsNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkGeneratedCommandsMemoryRequirementsInfoNV</type>* <name>pInfo</name></param>
            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateIndirectCommandsLayoutNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkIndirectCommandsLayoutCreateInfoNV</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkIndirectCommandsLayoutNV</type>* <name>pIndirectCommandsLayout</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyIndirectCommandsLayoutNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkIndirectCommandsLayoutNV</type> <name>indirectCommandsLayout</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command conditionalrendering="true" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary" tasks="action,indirection">
            <proto><type>void</type> <name>vkCmdExecuteGeneratedCommandsEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>isPreprocessed</name></param>
            <param>const <type>VkGeneratedCommandsInfoEXT</type>* <name>pGeneratedCommandsInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary" tasks="action">
            <proto><type>void</type> <name>vkCmdPreprocessGeneratedCommandsEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkGeneratedCommandsInfoEXT</type>* <name>pGeneratedCommandsInfo</name></param>
            <param externsync="true"><type>VkCommandBuffer</type> <name>stateCommandBuffer</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetGeneratedCommandsMemoryRequirementsEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkGeneratedCommandsMemoryRequirementsInfoEXT</type>* <name>pInfo</name></param>
            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateIndirectCommandsLayoutEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkIndirectCommandsLayoutCreateInfoEXT</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkIndirectCommandsLayoutEXT</type>* <name>pIndirectCommandsLayout</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyIndirectCommandsLayoutEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkIndirectCommandsLayoutEXT</type> <name>indirectCommandsLayout</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateIndirectExecutionSetEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkIndirectExecutionSetCreateInfoEXT</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkIndirectExecutionSetEXT</type>* <name>pIndirectExecutionSet</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyIndirectExecutionSetEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkIndirectExecutionSetEXT</type> <name>indirectExecutionSet</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkUpdateIndirectExecutionSetPipelineEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkIndirectExecutionSetEXT</type> <name>indirectExecutionSet</name></param>
            <param><type>uint32_t</type> <name>executionSetWriteCount</name></param>
            <param len="executionSetWriteCount">const <type>VkWriteIndirectExecutionSetPipelineEXT</type>* <name>pExecutionSetWrites</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkUpdateIndirectExecutionSetShaderEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkIndirectExecutionSetEXT</type> <name>indirectExecutionSet</name></param>
            <param><type>uint32_t</type> <name>executionSetWriteCount</name></param>
            <param len="executionSetWriteCount">const <type>VkWriteIndirectExecutionSetShaderEXT</type>* <name>pExecutionSetWrites</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetPhysicalDeviceFeatures2</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceFeatures2</type>* <name>pFeatures</name></param>
        </command>
        <command name="vkGetPhysicalDeviceFeatures2KHR"                        alias="vkGetPhysicalDeviceFeatures2"/>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetPhysicalDeviceProperties2</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceProperties2</type>* <name>pProperties</name></param>
        </command>
        <command name="vkGetPhysicalDeviceProperties2KHR"                      alias="vkGetPhysicalDeviceProperties2"/>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetPhysicalDeviceFormatProperties2</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkFormatProperties2</type>* <name>pFormatProperties</name></param>
        </command>
        <command name="vkGetPhysicalDeviceFormatProperties2KHR"                alias="vkGetPhysicalDeviceFormatProperties2"/>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED,VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceImageFormatProperties2</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceImageFormatInfo2</type>* <name>pImageFormatInfo</name></param>
            <param><type>VkImageFormatProperties2</type>* <name>pImageFormatProperties</name></param>
        </command>
        <command name="vkGetPhysicalDeviceImageFormatProperties2KHR"           alias="vkGetPhysicalDeviceImageFormatProperties2"/>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetPhysicalDeviceQueueFamilyProperties2</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pQueueFamilyPropertyCount</name></param>
            <param optional="true" len="pQueueFamilyPropertyCount"><type>VkQueueFamilyProperties2</type>* <name>pQueueFamilyProperties</name></param>
        </command>
        <command name="vkGetPhysicalDeviceQueueFamilyProperties2KHR"           alias="vkGetPhysicalDeviceQueueFamilyProperties2"/>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetPhysicalDeviceMemoryProperties2</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceMemoryProperties2</type>* <name>pMemoryProperties</name></param>
        </command>
        <command name="vkGetPhysicalDeviceMemoryProperties2KHR"                alias="vkGetPhysicalDeviceMemoryProperties2"/>
        <command export="vulkan">
            <proto><type>void</type> <name>vkGetPhysicalDeviceSparseImageFormatProperties2</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceSparseImageFormatInfo2</type>* <name>pFormatInfo</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkSparseImageFormatProperties2</type>* <name>pProperties</name></param>
        </command>
        <command name="vkGetPhysicalDeviceSparseImageFormatProperties2KHR"     alias="vkGetPhysicalDeviceSparseImageFormatProperties2"/>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdPushDescriptorSet</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
            <param><type>VkPipelineLayout</type> <name>layout</name></param>
            <param><type>uint32_t</type> <name>set</name></param>
            <param><type>uint32_t</type> <name>descriptorWriteCount</name></param>
            <param len="descriptorWriteCount">const <type>VkWriteDescriptorSet</type>* <name>pDescriptorWrites</name></param>
        </command>
        <command name="vkCmdPushDescriptorSetKHR" alias="vkCmdPushDescriptorSet"/>
        <command export="vulkan">
            <proto><type>void</type> <name>vkTrimCommandPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
            <param optional="true"><type>VkCommandPoolTrimFlags</type> <name>flags</name></param>
        </command>
        <command name="vkTrimCommandPoolKHR"                                   alias="vkTrimCommandPool"/>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetPhysicalDeviceExternalBufferProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceExternalBufferInfo</type>* <name>pExternalBufferInfo</name></param>
            <param><type>VkExternalBufferProperties</type>* <name>pExternalBufferProperties</name></param>
        </command>
        <command name="vkGetPhysicalDeviceExternalBufferPropertiesKHR"         alias="vkGetPhysicalDeviceExternalBufferProperties"/>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetMemoryWin32HandleKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkMemoryGetWin32HandleInfoKHR</type>* <name>pGetWin32HandleInfo</name></param>
            <param><type>HANDLE</type>* <name>pHandle</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetMemoryWin32HandlePropertiesKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></param>
            <param><type>HANDLE</type> <name>handle</name></param>
            <param><type>VkMemoryWin32HandlePropertiesKHR</type>* <name>pMemoryWin32HandleProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetMemoryFdKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkMemoryGetFdInfoKHR</type>* <name>pGetFdInfo</name></param>
            <param><type>int</type>* <name>pFd</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetMemoryFdPropertiesKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></param>
            <param><type>int</type> <name>fd</name></param>
            <param><type>VkMemoryFdPropertiesKHR</type>* <name>pMemoryFdProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetMemoryZirconHandleFUCHSIA</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkMemoryGetZirconHandleInfoFUCHSIA</type>* <name>pGetZirconHandleInfo</name></param>
            <param><type>zx_handle_t</type>* <name>pZirconHandle</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetMemoryZirconHandlePropertiesFUCHSIA</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></param>
            <param><type>zx_handle_t</type> <name>zirconHandle</name></param>
            <param><type>VkMemoryZirconHandlePropertiesFUCHSIA</type>* <name>pMemoryZirconHandleProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetMemoryRemoteAddressNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkMemoryGetRemoteAddressInfoNV</type>* <name>pMemoryGetRemoteAddressInfo</name></param>
            <param><type>VkRemoteAddressNV</type>* <name>pAddress</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetMemorySciBufNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkMemoryGetSciBufInfoNV</type>* <name>pGetSciBufInfo</name></param>
            <param><type>NvSciBufObj</type>* <name>pHandle</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></param>
            <param><type>NvSciBufObj</type> <name>handle</name></param>
            <param><type>VkMemorySciBufPropertiesNV</type>* <name>pMemorySciBufProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSciBufAttributesNV</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>NvSciBufAttrList</type> <name>pAttributes</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetPhysicalDeviceExternalSemaphoreProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceExternalSemaphoreInfo</type>* <name>pExternalSemaphoreInfo</name></param>
            <param><type>VkExternalSemaphoreProperties</type>* <name>pExternalSemaphoreProperties</name></param>
        </command>
        <command name="vkGetPhysicalDeviceExternalSemaphorePropertiesKHR"      alias="vkGetPhysicalDeviceExternalSemaphoreProperties"/>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetSemaphoreWin32HandleKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSemaphoreGetWin32HandleInfoKHR</type>* <name>pGetWin32HandleInfo</name></param>
            <param><type>HANDLE</type>* <name>pHandle</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkImportSemaphoreWin32HandleKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImportSemaphoreWin32HandleInfoKHR</type>* <name>pImportSemaphoreWin32HandleInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetSemaphoreFdKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSemaphoreGetFdInfoKHR</type>* <name>pGetFdInfo</name></param>
            <param><type>int</type>* <name>pFd</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkImportSemaphoreFdKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImportSemaphoreFdInfoKHR</type>* <name>pImportSemaphoreFdInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetSemaphoreZirconHandleFUCHSIA</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSemaphoreGetZirconHandleInfoFUCHSIA</type>* <name>pGetZirconHandleInfo</name></param>
            <param><type>zx_handle_t</type>* <name>pZirconHandle</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkImportSemaphoreZirconHandleFUCHSIA</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImportSemaphoreZirconHandleInfoFUCHSIA</type>* <name>pImportSemaphoreZirconHandleInfo</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetPhysicalDeviceExternalFenceProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceExternalFenceInfo</type>* <name>pExternalFenceInfo</name></param>
            <param><type>VkExternalFenceProperties</type>* <name>pExternalFenceProperties</name></param>
        </command>
        <command name="vkGetPhysicalDeviceExternalFencePropertiesKHR"          alias="vkGetPhysicalDeviceExternalFenceProperties"/>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetFenceWin32HandleKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkFenceGetWin32HandleInfoKHR</type>* <name>pGetWin32HandleInfo</name></param>
            <param><type>HANDLE</type>* <name>pHandle</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkImportFenceWin32HandleKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImportFenceWin32HandleInfoKHR</type>* <name>pImportFenceWin32HandleInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetFenceFdKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkFenceGetFdInfoKHR</type>* <name>pGetFdInfo</name></param>
            <param><type>int</type>* <name>pFd</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkImportFenceFdKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImportFenceFdInfoKHR</type>* <name>pImportFenceFdInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetFenceSciSyncFenceNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkFenceGetSciSyncInfoNV</type>* <name>pGetSciSyncHandleInfo</name></param>
            <param><type>void</type>* <name>pHandle</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetFenceSciSyncObjNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkFenceGetSciSyncInfoNV</type>* <name>pGetSciSyncHandleInfo</name></param>
            <param><type>void</type>* <name>pHandle</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkImportFenceSciSyncFenceNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImportFenceSciSyncInfoNV</type>* <name>pImportFenceSciSyncInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkImportFenceSciSyncObjNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImportFenceSciSyncInfoNV</type>* <name>pImportFenceSciSyncInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetSemaphoreSciSyncObjNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSemaphoreGetSciSyncInfoNV</type>* <name>pGetSciSyncInfo</name></param>
            <param><type>void</type>* <name>pHandle</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_NOT_PERMITTED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkImportSemaphoreSciSyncObjNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImportSemaphoreSciSyncInfoNV</type>* <name>pImportSemaphoreSciSyncInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSciSyncAttributesNV</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkSciSyncAttributesInfoNV</type>* <name>pSciSyncAttributesInfo</name></param>
            <param><type>NvSciSyncAttrList</type> <name>pAttributes</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateSemaphoreSciSyncPoolNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSemaphoreSciSyncPoolCreateInfoNV</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSemaphoreSciSyncPoolNV</type>* <name>pSemaphorePool</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroySemaphoreSciSyncPoolNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkSemaphoreSciSyncPoolNV</type> <name>semaphorePool</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkReleaseDisplayEXT</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkDisplayKHR</type> <name>display</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkAcquireXlibDisplayEXT</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>Display</type>* <name>dpy</name></param>
            <param><type>VkDisplayKHR</type> <name>display</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetRandROutputDisplayEXT</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>Display</type>* <name>dpy</name></param>
            <param><type>RROutput</type> <name>rrOutput</name></param>
            <param><type>VkDisplayKHR</type>* <name>pDisplay</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkAcquireWinrtDisplayNV</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkDisplayKHR</type> <name>display</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetWinrtDisplayNV</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>deviceRelativeId</name></param>
            <param><type>VkDisplayKHR</type>* <name>pDisplay</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkDisplayPowerControlEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDisplayKHR</type> <name>display</name></param>
            <param>const <type>VkDisplayPowerInfoEXT</type>* <name>pDisplayPowerInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkRegisterDeviceEventEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDeviceEventInfoEXT</type>* <name>pDeviceEventInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkFence</type>* <name>pFence</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkRegisterDisplayEventEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDisplayKHR</type> <name>display</name></param>
            <param>const <type>VkDisplayEventInfoEXT</type>* <name>pDisplayEventInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkFence</type>* <name>pFence</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetSwapchainCounterEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param><type>VkSurfaceCounterFlagBitsEXT</type> <name>counter</name></param>
            <param><type>uint64_t</type>* <name>pCounterValue</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceCapabilities2EXT</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param><type>VkSurfaceCapabilities2EXT</type>* <name>pSurfaceCapabilities</name></param>
        </command>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkEnumeratePhysicalDeviceGroups</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPhysicalDeviceGroupCount</name></param>
            <param optional="true" len="pPhysicalDeviceGroupCount"><type>VkPhysicalDeviceGroupProperties</type>* <name>pPhysicalDeviceGroupProperties</name></param>
        </command>
        <command name="vkEnumeratePhysicalDeviceGroupsKHR"                     alias="vkEnumeratePhysicalDeviceGroups"/>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetDeviceGroupPeerMemoryFeatures</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>heapIndex</name></param>
            <param><type>uint32_t</type> <name>localDeviceIndex</name></param>
            <param><type>uint32_t</type> <name>remoteDeviceIndex</name></param>
            <param><type>VkPeerMemoryFeatureFlags</type>* <name>pPeerMemoryFeatures</name></param>
        </command>
        <command name="vkGetDeviceGroupPeerMemoryFeaturesKHR"                  alias="vkGetDeviceGroupPeerMemoryFeatures"/>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkBindBufferMemory2</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>bindInfoCount</name></param>
            <param len="bindInfoCount">const <type>VkBindBufferMemoryInfo</type>* <name>pBindInfos</name></param>
        </command>
        <command name="vkBindBufferMemory2KHR"                                 alias="vkBindBufferMemory2"/>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkBindImageMemory2</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>bindInfoCount</name></param>
            <param len="bindInfoCount">const <type>VkBindImageMemoryInfo</type>* <name>pBindInfos</name></param>
        </command>
        <command name="vkBindImageMemory2KHR"                                  alias="vkBindImageMemory2"/>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetDeviceMask</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>deviceMask</name></param>
        </command>
        <command name="vkCmdSetDeviceMaskKHR"                                  alias="vkCmdSetDeviceMask"/>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetDeviceGroupPresentCapabilitiesKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDeviceGroupPresentCapabilitiesKHR</type>* <name>pDeviceGroupPresentCapabilities</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetDeviceGroupSurfacePresentModesKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param optional="false,true"><type>VkDeviceGroupPresentModeFlagsKHR</type>* <name>pModes</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_TIMEOUT,VK_NOT_READY,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkAcquireNextImage2KHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkAcquireNextImageInfoKHR</type>* <name>pAcquireInfo</name></param>
            <param><type>uint32_t</type>* <name>pImageIndex</name></param>
        </command>
        <command conditionalrendering="true" export="vulkan,vulkansc" queues="VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDispatchBase</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>baseGroupX</name></param>
            <param><type>uint32_t</type> <name>baseGroupY</name></param>
            <param><type>uint32_t</type> <name>baseGroupZ</name></param>
            <param><type>uint32_t</type> <name>groupCountX</name></param>
            <param><type>uint32_t</type> <name>groupCountY</name></param>
            <param><type>uint32_t</type> <name>groupCountZ</name></param>
        </command>
        <command name="vkCmdDispatchBaseKHR"                                   alias="vkCmdDispatchBase"/>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDevicePresentRectanglesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param externsync="true"><type>VkSurfaceKHR</type> <name>surface</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pRectCount</name></param>
            <param optional="true" len="pRectCount"><type>VkRect2D</type>* <name>pRects</name></param>
        </command>
        <command export="vulkan" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateDescriptorUpdateTemplate</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDescriptorUpdateTemplateCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDescriptorUpdateTemplate</type>* <name>pDescriptorUpdateTemplate</name></param>
        </command>
        <command name="vkCreateDescriptorUpdateTemplateKHR"                    alias="vkCreateDescriptorUpdateTemplate"/>
        <command export="vulkan">
            <proto><type>void</type> <name>vkDestroyDescriptorUpdateTemplate</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkDescriptorUpdateTemplate</type> <name>descriptorUpdateTemplate</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command name="vkDestroyDescriptorUpdateTemplateKHR"                   alias="vkDestroyDescriptorUpdateTemplate"/>
        <command export="vulkan">
            <proto><type>void</type> <name>vkUpdateDescriptorSetWithTemplate</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="maybe"><type>VkDescriptorSet</type> <name>descriptorSet</name></param>
            <param><type>VkDescriptorUpdateTemplate</type> <name>descriptorUpdateTemplate</name></param>
            <param noautovalidity="true">const <type>void</type>* <name>pData</name></param>
        </command>
        <command name="vkUpdateDescriptorSetWithTemplateKHR"                   alias="vkUpdateDescriptorSetWithTemplate"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdPushDescriptorSetWithTemplate</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkDescriptorUpdateTemplate</type> <name>descriptorUpdateTemplate</name></param>
            <param><type>VkPipelineLayout</type> <name>layout</name></param>
            <param><type>uint32_t</type> <name>set</name></param>
            <param noautovalidity="true">const <type>void</type>* <name>pData</name></param>
        </command>
        <command name="vkCmdPushDescriptorSetWithTemplateKHR" alias="vkCmdPushDescriptorSetWithTemplate"/>
        <command>
            <proto><type>void</type> <name>vkSetHdrMetadataEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>swapchainCount</name></param>
            <param len="swapchainCount">const <type>VkSwapchainKHR</type>* <name>pSwapchains</name></param>
            <param len="swapchainCount">const <type>VkHdrMetadataEXT</type>* <name>pMetadata</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetSwapchainStatusKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetRefreshCycleDurationGOOGLE</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param><type>VkRefreshCycleDurationGOOGLE</type>* <name>pDisplayTimingProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPastPresentationTimingGOOGLE</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPresentationTimingCount</name></param>
            <param optional="true" len="pPresentationTimingCount"><type>VkPastPresentationTimingGOOGLE</type>* <name>pPresentationTimings</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateIOSSurfaceMVK</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkIOSSurfaceCreateInfoMVK</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateMacOSSurfaceMVK</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkMacOSSurfaceCreateInfoMVK</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateMetalSurfaceEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkMetalSurfaceCreateInfoEXT</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetViewportWScalingNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstViewport</name></param>
            <param><type>uint32_t</type> <name>viewportCount</name></param>
            <param len="viewportCount">const <type>VkViewportWScalingNV</type>* <name>pViewportWScalings</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetDiscardRectangleEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstDiscardRectangle</name></param>
            <param><type>uint32_t</type> <name>discardRectangleCount</name></param>
            <param len="discardRectangleCount">const <type>VkRect2D</type>* <name>pDiscardRectangles</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetDiscardRectangleEnableEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>discardRectangleEnable</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetDiscardRectangleModeEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkDiscardRectangleModeEXT</type> <name>discardRectangleMode</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetSampleLocationsEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkSampleLocationsInfoEXT</type>* <name>pSampleLocationsInfo</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceMultisamplePropertiesEXT</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkSampleCountFlagBits</type> <name>samples</name></param>
            <param><type>VkMultisamplePropertiesEXT</type>* <name>pMultisampleProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceCapabilities2KHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceSurfaceInfo2KHR</type>* <name>pSurfaceInfo</name></param>
            <param><type>VkSurfaceCapabilities2KHR</type>* <name>pSurfaceCapabilities</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceFormats2KHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceSurfaceInfo2KHR</type>* <name>pSurfaceInfo</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pSurfaceFormatCount</name></param>
            <param optional="true" len="pSurfaceFormatCount"><type>VkSurfaceFormat2KHR</type>* <name>pSurfaceFormats</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayProperties2KHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkDisplayProperties2KHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayPlaneProperties2KHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkDisplayPlaneProperties2KHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetDisplayModeProperties2KHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkDisplayKHR</type> <name>display</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkDisplayModeProperties2KHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetDisplayPlaneCapabilities2KHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkDisplayPlaneInfo2KHR</type>* <name>pDisplayPlaneInfo</name></param>
            <param><type>VkDisplayPlaneCapabilities2KHR</type>* <name>pCapabilities</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetBufferMemoryRequirements2</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkBufferMemoryRequirementsInfo2</type>* <name>pInfo</name></param>
            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command name="vkGetBufferMemoryRequirements2KHR"                      alias="vkGetBufferMemoryRequirements2"/>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetImageMemoryRequirements2</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImageMemoryRequirementsInfo2</type>* <name>pInfo</name></param>
            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command name="vkGetImageMemoryRequirements2KHR"                       alias="vkGetImageMemoryRequirements2"/>
        <command export="vulkan">
            <proto><type>void</type> <name>vkGetImageSparseMemoryRequirements2</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImageSparseMemoryRequirementsInfo2</type>* <name>pInfo</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pSparseMemoryRequirementCount</name></param>
            <param optional="true" len="pSparseMemoryRequirementCount"><type>VkSparseImageMemoryRequirements2</type>* <name>pSparseMemoryRequirements</name></param>
        </command>
        <command name="vkGetImageSparseMemoryRequirements2KHR"                 alias="vkGetImageSparseMemoryRequirements2"/>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetDeviceBufferMemoryRequirements</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDeviceBufferMemoryRequirements</type>* <name>pInfo</name></param>
            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command name="vkGetDeviceBufferMemoryRequirementsKHR" alias="vkGetDeviceBufferMemoryRequirements"/>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetDeviceImageMemoryRequirements</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDeviceImageMemoryRequirements</type>* <name>pInfo</name></param>
            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command name="vkGetDeviceImageMemoryRequirementsKHR" alias="vkGetDeviceImageMemoryRequirements"/>
        <command export="vulkan">
            <proto><type>void</type> <name>vkGetDeviceImageSparseMemoryRequirements</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDeviceImageMemoryRequirements</type>* <name>pInfo</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pSparseMemoryRequirementCount</name></param>
            <param optional="true" len="pSparseMemoryRequirementCount"><type>VkSparseImageMemoryRequirements2</type>* <name>pSparseMemoryRequirements</name></param>
        </command>
        <command name="vkGetDeviceImageSparseMemoryRequirementsKHR" alias="vkGetDeviceImageSparseMemoryRequirements"/>
        <command export="vulkan,vulkansc" allownoqueues="true" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateSamplerYcbcrConversion</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSamplerYcbcrConversionCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSamplerYcbcrConversion</type>* <name>pYcbcrConversion</name></param>
        </command>
        <command name="vkCreateSamplerYcbcrConversionKHR"                      alias="vkCreateSamplerYcbcrConversion"/>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkDestroySamplerYcbcrConversion</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkSamplerYcbcrConversion</type> <name>ycbcrConversion</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command name="vkDestroySamplerYcbcrConversionKHR"                     alias="vkDestroySamplerYcbcrConversion"/>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetDeviceQueue2</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDeviceQueueInfo2</type>* <name>pQueueInfo</name></param>
            <param><type>VkQueue</type>* <name>pQueue</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateValidationCacheEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkValidationCacheCreateInfoEXT</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkValidationCacheEXT</type>* <name>pValidationCache</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyValidationCacheEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkValidationCacheEXT</type> <name>validationCache</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetValidationCacheDataEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkValidationCacheEXT</type> <name>validationCache</name></param>
            <param optional="false,true"><type>size_t</type>* <name>pDataSize</name></param>
            <param optional="true" len="pDataSize"><type>void</type>* <name>pData</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkMergeValidationCachesEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkValidationCacheEXT</type> <name>dstCache</name></param>
            <param><type>uint32_t</type> <name>srcCacheCount</name></param>
            <param len="srcCacheCount">const <type>VkValidationCacheEXT</type>* <name>pSrcCaches</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>void</type> <name>vkGetDescriptorSetLayoutSupport</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDescriptorSetLayoutCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkDescriptorSetLayoutSupport</type>* <name>pSupport</name></param>
        </command>
        <command name="vkGetDescriptorSetLayoutSupportKHR"                     alias="vkGetDescriptorSetLayoutSupport"/>
        <command>
            <proto><type>VkResult</type> <name>vkGetSwapchainGrallocUsageANDROID</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkImageUsageFlags</type> <name>imageUsage</name></param>
            <param><type>int</type>* <name>grallocUsage</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkGetSwapchainGrallocUsage2ANDROID</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkImageUsageFlags</type> <name>imageUsage</name></param>
            <param><type>VkSwapchainImageUsageFlagsANDROID</type> <name>swapchainImageUsage</name></param>
            <param><type>uint64_t</type>* <name>grallocConsumerUsage</name></param>
            <param><type>uint64_t</type>* <name>grallocProducerUsage</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkAcquireImageANDROID</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>int</type> <name>nativeFenceFd</name></param>
            <param optional="true"><type>VkSemaphore</type> <name>semaphore</name></param>
            <param optional="true"><type>VkFence</type> <name>fence</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkQueueSignalReleaseImageANDROID</name></proto>
            <param><type>VkQueue</type> <name>queue</name></param>
            <param><type>uint32_t</type> <name>waitSemaphoreCount</name></param>
            <param len="waitSemaphoreCount">const <type>VkSemaphore</type>* <name>pWaitSemaphores</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>int</type>* <name>pNativeFenceFd</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_FEATURE_NOT_PRESENT,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetShaderInfoAMD</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipeline</type> <name>pipeline</name></param>
            <param><type>VkShaderStageFlagBits</type> <name>shaderStage</name></param>
            <param><type>VkShaderInfoTypeAMD</type> <name>infoType</name></param>
            <param optional="false,true"><type>size_t</type>* <name>pInfoSize</name></param>
            <param optional="true" len="pInfoSize"><type>void</type>* <name>pInfo</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkSetLocalDimmingAMD</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkSwapchainKHR</type> <name>swapChain</name></param>
            <param><type>VkBool32</type> <name>localDimmingEnable</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceCalibrateableTimeDomainsKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pTimeDomainCount</name></param>
            <param optional="true" len="pTimeDomainCount"><type>VkTimeDomainKHR</type>* <name>pTimeDomains</name></param>
        </command>
        <command name="vkGetPhysicalDeviceCalibrateableTimeDomainsEXT" alias="vkGetPhysicalDeviceCalibrateableTimeDomainsKHR"/>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetCalibratedTimestampsKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>timestampCount</name></param>
            <param len="timestampCount">const <type>VkCalibratedTimestampInfoKHR</type>* <name>pTimestampInfos</name></param>
            <param len="timestampCount"><type>uint64_t</type>* <name>pTimestamps</name></param>
            <param><type>uint64_t</type>* <name>pMaxDeviation</name></param>
        </command>
        <command name="vkGetCalibratedTimestampsEXT" alias="vkGetCalibratedTimestampsKHR"/>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkSetDebugUtilsObjectNameEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="pNameInfo-&gt;objectHandle">const <type>VkDebugUtilsObjectNameInfoEXT</type>* <name>pNameInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkSetDebugUtilsObjectTagEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDebugUtilsObjectTagInfoEXT</type>* <name>pTagInfo</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkQueueBeginDebugUtilsLabelEXT</name></proto>
            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
            <param>const <type>VkDebugUtilsLabelEXT</type>* <name>pLabelInfo</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkQueueEndDebugUtilsLabelEXT</name></proto>
            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkQueueInsertDebugUtilsLabelEXT</name></proto>
            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
            <param>const <type>VkDebugUtilsLabelEXT</type>* <name>pLabelInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdBeginDebugUtilsLabelEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkDebugUtilsLabelEXT</type>* <name>pLabelInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdEndDebugUtilsLabelEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR,VK_QUEUE_OPTICAL_FLOW_BIT_NV" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdInsertDebugUtilsLabelEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkDebugUtilsLabelEXT</type>* <name>pLabelInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateDebugUtilsMessengerEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkDebugUtilsMessengerCreateInfoEXT</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDebugUtilsMessengerEXT</type>* <name>pMessenger</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyDebugUtilsMessengerEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param optional="true" externsync="true"><type>VkDebugUtilsMessengerEXT</type> <name>messenger</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkSubmitDebugUtilsMessageEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param><type>VkDebugUtilsMessageSeverityFlagBitsEXT</type> <name>messageSeverity</name></param>
            <param><type>VkDebugUtilsMessageTypeFlagsEXT</type> <name>messageTypes</name></param>
            <param>const <type>VkDebugUtilsMessengerCallbackDataEXT</type>* <name>pCallbackData</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetMemoryHostPointerPropertiesEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></param>
            <param>const <type>void</type>* <name>pHostPointer</name></param>
            <param><type>VkMemoryHostPointerPropertiesEXT</type>* <name>pMemoryHostPointerProperties</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdWriteBufferMarkerAMD</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param optional="true"><type>VkPipelineStageFlagBits</type> <name>pipelineStage</name></param>
            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
            <param><type>uint32_t</type> <name>marker</name></param>
        </command>
        <command export="vulkan,vulkansc" allownoqueues="true" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateRenderPass2</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkRenderPassCreateInfo2</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkRenderPass</type>* <name>pRenderPass</name></param>
        </command>
        <command name="vkCreateRenderPass2KHR"                                 alias="vkCreateRenderPass2"/>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="outside" cmdbufferlevel="primary" tasks="action,state,synchronization">
            <proto><type>void</type> <name>vkCmdBeginRenderPass2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkRenderPassBeginInfo</type>*      <name>pRenderPassBegin</name></param>
            <param>const <type>VkSubpassBeginInfo</type>*      <name>pSubpassBeginInfo</name></param>
        </command>
        <command name="vkCmdBeginRenderPass2KHR"                               alias="vkCmdBeginRenderPass2"/>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary" tasks="action,state,synchronization">
            <proto><type>void</type> <name>vkCmdNextSubpass2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkSubpassBeginInfo</type>*      <name>pSubpassBeginInfo</name></param>
            <param>const <type>VkSubpassEndInfo</type>*        <name>pSubpassEndInfo</name></param>
        </command>
        <command name="vkCmdNextSubpass2KHR"                                   alias="vkCmdNextSubpass2"/>
        <command conditionalrendering="false" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary" tasks="action,state,synchronization">
            <proto><type>void</type> <name>vkCmdEndRenderPass2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkSubpassEndInfo</type>*        <name>pSubpassEndInfo</name></param>
        </command>
        <command name="vkCmdEndRenderPass2KHR"                                 alias="vkCmdEndRenderPass2"/>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetSemaphoreCounterValue</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkSemaphore</type> <name>semaphore</name></param>
            <param><type>uint64_t</type>* <name>pValue</name></param>
        </command>
        <command name="vkGetSemaphoreCounterValueKHR"              alias="vkGetSemaphoreCounterValue"/>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS,VK_TIMEOUT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkWaitSemaphores</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSemaphoreWaitInfo</type>* <name>pWaitInfo</name></param>
            <param><type>uint64_t</type> <name>timeout</name></param>
        </command>
        <command name="vkWaitSemaphoresKHR"                        alias="vkWaitSemaphores"/>
        <command export="vulkan,vulkansc" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkSignalSemaphore</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSemaphoreSignalInfo</type>* <name>pSignalInfo</name></param>
        </command>
        <command name="vkSignalSemaphoreKHR"                       alias="vkSignalSemaphore"/>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetAndroidHardwareBufferPropertiesANDROID</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const struct <type>AHardwareBuffer</type>* <name>buffer</name></param>
            <param><type>VkAndroidHardwareBufferPropertiesANDROID</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetMemoryAndroidHardwareBufferANDROID</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkMemoryGetAndroidHardwareBufferInfoANDROID</type>* <name>pInfo</name></param>
            <param>struct <type>AHardwareBuffer</type>** <name>pBuffer</name></param>
        </command>
        <command conditionalrendering="true" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDrawIndirectCount</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkBuffer</type> <name>countBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>countBufferOffset</name></param>
            <param><type>uint32_t</type> <name>maxDrawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command name="vkCmdDrawIndirectCountKHR"                              alias="vkCmdDrawIndirectCount"/>
        <command name="vkCmdDrawIndirectCountAMD"                              alias="vkCmdDrawIndirectCount"/>
        <command conditionalrendering="true" export="vulkan,vulkansc" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDrawIndexedIndirectCount</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkBuffer</type> <name>countBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>countBufferOffset</name></param>
            <param><type>uint32_t</type> <name>maxDrawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command name="vkCmdDrawIndexedIndirectCountKHR"                       alias="vkCmdDrawIndexedIndirectCount"/>
        <command name="vkCmdDrawIndexedIndirectCountAMD"                       alias="vkCmdDrawIndexedIndirectCount"/>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdSetCheckpointNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param noautovalidity="true">const <type>void</type>* <name>pCheckpointMarker</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetQueueCheckpointDataNV</name></proto>
            <param><type>VkQueue</type> <name>queue</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pCheckpointDataCount</name></param>
            <param optional="true" len="pCheckpointDataCount"><type>VkCheckpointDataNV</type>* <name>pCheckpointData</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdBindTransformFeedbackBuffersEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstBinding</name></param>
            <param><type>uint32_t</type> <name>bindingCount</name></param>
            <param len="bindingCount">const <type>VkBuffer</type>* <name>pBuffers</name></param>
            <param len="bindingCount">const <type>VkDeviceSize</type>* <name>pOffsets</name></param>
            <param optional="true" len="bindingCount" noautovalidity="true">const <type>VkDeviceSize</type>* <name>pSizes</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdBeginTransformFeedbackEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstCounterBuffer</name></param>
            <param optional="true"><type>uint32_t</type> <name>counterBufferCount</name></param>
            <param noautovalidity="true" len="counterBufferCount">const <type>VkBuffer</type>* <name>pCounterBuffers</name></param>
            <param optional="true" len="counterBufferCount">const <type>VkDeviceSize</type>* <name>pCounterBufferOffsets</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdEndTransformFeedbackEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstCounterBuffer</name></param>
            <param optional="true"><type>uint32_t</type> <name>counterBufferCount</name></param>
            <param noautovalidity="true" len="counterBufferCount">const <type>VkBuffer</type>* <name>pCounterBuffers</name></param>
            <param optional="true" len="counterBufferCount">const <type>VkDeviceSize</type>* <name>pCounterBufferOffsets</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action,state">
            <proto><type>void</type> <name>vkCmdBeginQueryIndexedEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>query</name></param>
            <param optional="true"><type>VkQueryControlFlags</type> <name>flags</name></param>
            <param><type>uint32_t</type> <name>index</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action,state">
            <proto><type>void</type> <name>vkCmdEndQueryIndexedEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>query</name></param>
            <param><type>uint32_t</type> <name>index</name></param>
        </command>
        <command conditionalrendering="true" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDrawIndirectByteCountEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>instanceCount</name></param>
            <param><type>uint32_t</type> <name>firstInstance</name></param>
            <param><type>VkBuffer</type> <name>counterBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>counterBufferOffset</name></param>
            <param><type>uint32_t</type> <name>counterOffset</name></param>
            <param><type>uint32_t</type> <name>vertexStride</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetExclusiveScissorNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstExclusiveScissor</name></param>
            <param><type>uint32_t</type> <name>exclusiveScissorCount</name></param>
            <param len="exclusiveScissorCount">const <type>VkRect2D</type>* <name>pExclusiveScissors</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetExclusiveScissorEnableNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstExclusiveScissor</name></param>
            <param><type>uint32_t</type> <name>exclusiveScissorCount</name></param>
            <param len="exclusiveScissorCount">const <type>VkBool32</type>* <name>pExclusiveScissorEnables</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdBindShadingRateImageNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param optional="true"><type>VkImageView</type> <name>imageView</name></param>
            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetViewportShadingRatePaletteNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstViewport</name></param>
            <param><type>uint32_t</type> <name>viewportCount</name></param>
            <param len="viewportCount">const <type>VkShadingRatePaletteNV</type>* <name>pShadingRatePalettes</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetCoarseSampleOrderNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkCoarseSampleOrderTypeNV</type> <name>sampleOrderType</name></param>
            <param optional="true"><type>uint32_t</type> <name>customSampleOrderCount</name></param>
            <param len="customSampleOrderCount">const <type>VkCoarseSampleOrderCustomNV</type>* <name>pCustomSampleOrders</name></param>
        </command>
        <command conditionalrendering="true" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDrawMeshTasksNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>taskCount</name></param>
            <param><type>uint32_t</type> <name>firstTask</name></param>
        </command>
        <command conditionalrendering="true" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDrawMeshTasksIndirectNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>uint32_t</type> <name>drawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command conditionalrendering="true" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDrawMeshTasksIndirectCountNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkBuffer</type> <name>countBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>countBufferOffset</name></param>
            <param><type>uint32_t</type> <name>maxDrawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command conditionalrendering="true" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDrawMeshTasksEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>groupCountX</name></param>
            <param><type>uint32_t</type> <name>groupCountY</name></param>
            <param><type>uint32_t</type> <name>groupCountZ</name></param>
        </command>
        <command conditionalrendering="true" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDrawMeshTasksIndirectEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>uint32_t</type> <name>drawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command conditionalrendering="true" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDrawMeshTasksIndirectCountEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkBuffer</type> <name>countBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>countBufferOffset</name></param>
            <param><type>uint32_t</type> <name>maxDrawCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCompileDeferredNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipeline</type> <name>pipeline</name></param>
            <param><type>uint32_t</type> <name>shader</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateAccelerationStructureNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkAccelerationStructureCreateInfoNV</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkAccelerationStructureNV</type>* <name>pAccelerationStructure</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdBindInvocationMaskHUAWEI</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param optional="true"><type>VkImageView</type> <name>imageView</name></param>
            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyAccelerationStructureKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkAccelerationStructureKHR</type> <name>accelerationStructure</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyAccelerationStructureNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkAccelerationStructureNV</type> <name>accelerationStructure</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetAccelerationStructureMemoryRequirementsNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkAccelerationStructureMemoryRequirementsInfoNV</type>* <name>pInfo</name></param>
            <param><type>VkMemoryRequirements2KHR</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkBindAccelerationStructureMemoryNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>bindInfoCount</name></param>
            <param len="bindInfoCount">const <type>VkBindAccelerationStructureMemoryInfoNV</type>* <name>pBindInfos</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyAccelerationStructureNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkAccelerationStructureNV</type> <name>dst</name></param>
            <param><type>VkAccelerationStructureNV</type> <name>src</name></param>
            <param><type>VkCopyAccelerationStructureModeKHR</type> <name>mode</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyAccelerationStructureKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCopyAccelerationStructureInfoKHR</type>* <name>pInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCopyAccelerationStructureKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
            <param>const <type>VkCopyAccelerationStructureInfoKHR</type>* <name>pInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyAccelerationStructureToMemoryKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCopyAccelerationStructureToMemoryInfoKHR</type>* <name>pInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCopyAccelerationStructureToMemoryKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
            <param>const <type>VkCopyAccelerationStructureToMemoryInfoKHR</type>* <name>pInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyMemoryToAccelerationStructureKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCopyMemoryToAccelerationStructureInfoKHR</type>* <name>pInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCopyMemoryToAccelerationStructureKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
            <param>const <type>VkCopyMemoryToAccelerationStructureInfoKHR</type>* <name>pInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdWriteAccelerationStructuresPropertiesKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>accelerationStructureCount</name></param>
            <param len="accelerationStructureCount">const <type>VkAccelerationStructureKHR</type>* <name>pAccelerationStructures</name></param>
            <param><type>VkQueryType</type> <name>queryType</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>firstQuery</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdWriteAccelerationStructuresPropertiesNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>accelerationStructureCount</name></param>
            <param len="accelerationStructureCount">const <type>VkAccelerationStructureNV</type>* <name>pAccelerationStructures</name></param>
            <param><type>VkQueryType</type> <name>queryType</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>firstQuery</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdBuildAccelerationStructureNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkAccelerationStructureInfoNV</type>* <name>pInfo</name></param>
            <param optional="true"><type>VkBuffer</type> <name>instanceData</name></param>
            <param><type>VkDeviceSize</type> <name>instanceOffset</name></param>
            <param><type>VkBool32</type> <name>update</name></param>
            <param><type>VkAccelerationStructureNV</type> <name>dst</name></param>
            <param optional="true"><type>VkAccelerationStructureNV</type> <name>src</name></param>
            <param><type>VkBuffer</type> <name>scratch</name></param>
            <param><type>VkDeviceSize</type> <name>scratchOffset</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkWriteAccelerationStructuresPropertiesKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>accelerationStructureCount</name></param>
            <param len="accelerationStructureCount">const <type>VkAccelerationStructureKHR</type>* <name>pAccelerationStructures</name></param>
            <param><type>VkQueryType</type>  <name>queryType</name></param>
            <param><type>size_t</type>       <name>dataSize</name></param>
            <param len="dataSize"><type>void</type>* <name>pData</name></param>
            <param><type>size_t</type> <name>stride</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdTraceRaysKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pRaygenShaderBindingTable</name></param>
            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pMissShaderBindingTable</name></param>
            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pHitShaderBindingTable</name></param>
            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pCallableShaderBindingTable</name></param>
            <param><type>uint32_t</type> <name>width</name></param>
            <param><type>uint32_t</type> <name>height</name></param>
            <param><type>uint32_t</type> <name>depth</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdTraceRaysNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBuffer</type> <name>raygenShaderBindingTableBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>raygenShaderBindingOffset</name></param>
            <param optional="true"><type>VkBuffer</type> <name>missShaderBindingTableBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>missShaderBindingOffset</name></param>
            <param><type>VkDeviceSize</type> <name>missShaderBindingStride</name></param>
            <param optional="true"><type>VkBuffer</type> <name>hitShaderBindingTableBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>hitShaderBindingOffset</name></param>
            <param><type>VkDeviceSize</type> <name>hitShaderBindingStride</name></param>
            <param optional="true"><type>VkBuffer</type> <name>callableShaderBindingTableBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>callableShaderBindingOffset</name></param>
            <param><type>VkDeviceSize</type> <name>callableShaderBindingStride</name></param>
            <param><type>uint32_t</type> <name>width</name></param>
            <param><type>uint32_t</type> <name>height</name></param>
            <param><type>uint32_t</type> <name>depth</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetRayTracingShaderGroupHandlesKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipeline</type> <name>pipeline</name></param>
            <param><type>uint32_t</type> <name>firstGroup</name></param>
            <param><type>uint32_t</type> <name>groupCount</name></param>
            <param><type>size_t</type> <name>dataSize</name></param>
            <param len="dataSize"><type>void</type>* <name>pData</name></param>
        </command>
        <command name="vkGetRayTracingShaderGroupHandlesNV"                 alias="vkGetRayTracingShaderGroupHandlesKHR"/>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetRayTracingCaptureReplayShaderGroupHandlesKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipeline</type> <name>pipeline</name></param>
            <param><type>uint32_t</type> <name>firstGroup</name></param>
            <param><type>uint32_t</type> <name>groupCount</name></param>
            <param><type>size_t</type> <name>dataSize</name></param>
            <param len="dataSize"><type>void</type>* <name>pData</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetAccelerationStructureHandleNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkAccelerationStructureNV</type> <name>accelerationStructure</name></param>
            <param><type>size_t</type> <name>dataSize</name></param>
            <param len="dataSize"><type>void</type>* <name>pData</name></param>
        </command>
        <command api="vulkan,vulkanbase" allownoqueues="true" successcodes="VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateRayTracingPipelinesNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="maybe"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param><type>uint32_t</type> <name>createInfoCount</name></param>
            <param len="createInfoCount">const <type>VkRayTracingPipelineCreateInfoNV</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
        </command>
        <command api="vulkansc" allownoqueues="true" successcodes="VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NO_PIPELINE_MATCH,VK_ERROR_OUT_OF_POOL_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateRayTracingPipelinesNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="maybe"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param><type>uint32_t</type> <name>createInfoCount</name></param>
            <param len="createInfoCount">const <type>VkRayTracingPipelineCreateInfoNV</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
        </command>
        <command api="vulkan,vulkanbase" allownoqueues="true" successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateRayTracingPipelinesKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
            <param optional="true" externsync="maybe"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param><type>uint32_t</type> <name>createInfoCount</name></param>
            <param len="createInfoCount">const <type>VkRayTracingPipelineCreateInfoKHR</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
        </command>
        <command api="vulkansc" allownoqueues="true" successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS,VK_ERROR_NO_PIPELINE_MATCH,VK_ERROR_OUT_OF_POOL_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateRayTracingPipelinesKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
            <param externsync="maybe"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param><type>uint32_t</type> <name>createInfoCount</name></param>
            <param len="createInfoCount">const <type>VkRayTracingPipelineCreateInfoKHR</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceCooperativeMatrixPropertiesNV</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkCooperativeMatrixPropertiesNV</type>* <name>pProperties</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdTraceRaysIndirectKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pRaygenShaderBindingTable</name></param>
            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pMissShaderBindingTable</name></param>
            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pHitShaderBindingTable</name></param>
            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pCallableShaderBindingTable</name></param>
            <param><type>VkDeviceAddress</type> <name>indirectDeviceAddress</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdTraceRaysIndirect2KHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkDeviceAddress</type> <name>indirectDeviceAddress</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetClusterAccelerationStructureBuildSizesNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkClusterAccelerationStructureInputInfoNV</type>* <name>pInfo</name></param>
            <param><type>VkAccelerationStructureBuildSizesInfoKHR</type>* <name>pSizeInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdBuildClusterAccelerationStructureIndirectNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type>                     <name>commandBuffer</name></param>
            <param>const <type>VkClusterAccelerationStructureCommandsInfoNV</type>*  <name>pCommandInfos</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetDeviceAccelerationStructureCompatibilityKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkAccelerationStructureVersionInfoKHR</type>* <name>pVersionInfo</name></param>
            <param><type>VkAccelerationStructureCompatibilityKHR</type>* <name>pCompatibility</name></param>
        </command>
        <command>
            <proto><type>VkDeviceSize</type> <name>vkGetRayTracingShaderGroupStackSizeKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipeline</type> <name>pipeline</name></param>
            <param><type>uint32_t</type> <name>group</name></param>
            <param><type>VkShaderGroupShaderKHR</type> <name>groupShader</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetRayTracingPipelineStackSizeKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>pipelineStackSize</name></param>
        </command>
        <command>
            <proto><type>uint32_t</type> <name>vkGetImageViewHandleNVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImageViewHandleInfoNVX</type>* <name>pInfo</name></param>
        </command>
        <command>
            <proto><type>uint64_t</type> <name>vkGetImageViewHandle64NVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImageViewHandleInfoNVX</type>* <name>pInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetImageViewAddressNVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImageView</type> <name>imageView</name></param>
            <param><type>VkImageViewAddressPropertiesNVX</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfacePresentModes2EXT</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceSurfaceInfo2KHR</type>* <name>pSurfaceInfo</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPresentModeCount</name></param>
            <param optional="true" len="pPresentModeCount"><type>VkPresentModeKHR</type>* <name>pPresentModes</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetDeviceGroupSurfacePresentModes2EXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPhysicalDeviceSurfaceInfo2KHR</type>* <name>pSurfaceInfo</name></param>
            <param optional="false,true"><type>VkDeviceGroupPresentModeFlagsKHR</type>* <name>pModes</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkAcquireFullScreenExclusiveModeEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkReleaseFullScreenExclusiveModeEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pCounterCount</name></param>
            <param optional="true" len="pCounterCount"><type>VkPerformanceCounterKHR</type>* <name>pCounters</name></param>
            <param optional="true" len="pCounterCount"><type>VkPerformanceCounterDescriptionKHR</type>* <name>pCounterDescriptions</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkQueryPoolPerformanceCreateInfoKHR</type>* <name>pPerformanceQueryCreateInfo</name></param>
            <param><type>uint32_t</type>* <name>pNumPasses</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_TIMEOUT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkAcquireProfilingLockKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkAcquireProfilingLockInfoKHR</type>* <name>pInfo</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkReleaseProfilingLockKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetImageDrmFormatModifierPropertiesEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>VkImageDrmFormatModifierPropertiesEXT</type>* <name>pProperties</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>uint64_t</type> <name>vkGetBufferOpaqueCaptureAddress</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkBufferDeviceAddressInfo</type>* <name>pInfo</name></param>
        </command>
        <command name="vkGetBufferOpaqueCaptureAddressKHR" alias="vkGetBufferOpaqueCaptureAddress"/>
        <command export="vulkan,vulkansc">
            <proto><type>VkDeviceAddress</type> <name>vkGetBufferDeviceAddress</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkBufferDeviceAddressInfo</type>* <name>pInfo</name></param>
        </command>
        <command name="vkGetBufferDeviceAddressKHR"        alias="vkGetBufferDeviceAddress"/>
        <command name="vkGetBufferDeviceAddressEXT"        alias="vkGetBufferDeviceAddress"/>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateHeadlessSurfaceEXT</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const <type>VkHeadlessSurfaceCreateInfoEXT</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pCombinationCount</name></param>
            <param optional="true" len="pCombinationCount"><type>VkFramebufferMixedSamplesCombinationNV</type>* <name>pCombinations</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkInitializePerformanceApiINTEL</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkInitializePerformanceApiInfoINTEL</type>* <name>pInitializeInfo</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkUninitializePerformanceApiINTEL</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT" renderpass="both" cmdbufferlevel="primary,secondary" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED" tasks="action,state">
            <proto><type>VkResult</type> <name>vkCmdSetPerformanceMarkerINTEL</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkPerformanceMarkerInfoINTEL</type>* <name>pMarkerInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT" renderpass="both" cmdbufferlevel="primary,secondary" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED" tasks="action,state">
            <proto><type>VkResult</type> <name>vkCmdSetPerformanceStreamMarkerINTEL</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkPerformanceStreamMarkerInfoINTEL</type>* <name>pMarkerInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT" renderpass="both" cmdbufferlevel="primary,secondary" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED" tasks="state">
            <proto><type>VkResult</type> <name>vkCmdSetPerformanceOverrideINTEL</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkPerformanceOverrideInfoINTEL</type>* <name>pOverrideInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkAcquirePerformanceConfigurationINTEL</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPerformanceConfigurationAcquireInfoINTEL</type>* <name>pAcquireInfo</name></param>
            <param><type>VkPerformanceConfigurationINTEL</type>* <name>pConfiguration</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkReleasePerformanceConfigurationINTEL</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkPerformanceConfigurationINTEL</type> <name>configuration</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkQueueSetPerformanceConfigurationINTEL</name></proto>
            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
            <param><type>VkPerformanceConfigurationINTEL</type> <name>configuration</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPerformanceParameterINTEL</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPerformanceParameterTypeINTEL</type> <name>parameter</name></param>
            <param><type>VkPerformanceValueINTEL</type>* <name>pValue</name></param>
        </command>
        <command export="vulkan,vulkansc">
            <proto><type>uint64_t</type> <name>vkGetDeviceMemoryOpaqueCaptureAddress</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDeviceMemoryOpaqueCaptureAddressInfo</type>* <name>pInfo</name></param>
        </command>
        <command name="vkGetDeviceMemoryOpaqueCaptureAddressKHR"        alias="vkGetDeviceMemoryOpaqueCaptureAddress"/>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPipelineExecutablePropertiesKHR</name></proto>
            <param><type>VkDevice</type>                        <name>device</name></param>
            <param>const <type>VkPipelineInfoKHR</type>*        <name>pPipelineInfo</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pExecutableCount</name></param>
            <param optional="true" len="pExecutableCount"><type>VkPipelineExecutablePropertiesKHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPipelineExecutableStatisticsKHR</name></proto>
            <param><type>VkDevice</type>                        <name>device</name></param>
            <param>const <type>VkPipelineExecutableInfoKHR</type>*  <name>pExecutableInfo</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pStatisticCount</name></param>
            <param optional="true" len="pStatisticCount"><type>VkPipelineExecutableStatisticKHR</type>* <name>pStatistics</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPipelineExecutableInternalRepresentationsKHR</name></proto>
            <param><type>VkDevice</type>                        <name>device</name></param>
            <param>const <type>VkPipelineExecutableInfoKHR</type>*  <name>pExecutableInfo</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pInternalRepresentationCount</name></param>
            <param optional="true" len="pInternalRepresentationCount"><type>VkPipelineExecutableInternalRepresentationKHR</type>* <name>pInternalRepresentations</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetLineStipple</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>lineStippleFactor</name></param>
            <param><type>uint16_t</type> <name>lineStipplePattern</name></param>
        </command>
        <command name="vkCmdSetLineStippleKHR" alias="vkCmdSetLineStipple"/>
        <command name="vkCmdSetLineStippleEXT" alias="vkCmdSetLineStipple"/>
        <command export="vulkansc" successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetFaultData</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkFaultQueryBehavior</type> <name>faultQueryBehavior</name></param>
            <param><type>VkBool32</type>* <name>pUnrecordedFaults</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pFaultCount</name></param>
            <param optional="true" len="pFaultCount"><type>VkFaultData</type>* <name>pFaults</name></param>
        </command>
        <command export="vulkan" successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceToolProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pToolCount</name></param>
            <param optional="true" len="pToolCount"><type>VkPhysicalDeviceToolProperties</type>* <name>pToolProperties</name></param>
        </command>
        <command name="vkGetPhysicalDeviceToolPropertiesEXT" alias="vkGetPhysicalDeviceToolProperties"/>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateAccelerationStructureKHR</name></proto>
            <param><type>VkDevice</type>                                           <name>device</name></param>
            <param>const <type>VkAccelerationStructureCreateInfoKHR</type>*        <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>*       <name>pAllocator</name></param>
            <param><type>VkAccelerationStructureKHR</type>*                        <name>pAccelerationStructure</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdBuildAccelerationStructuresKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type>                                    <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>infoCount</name></param>
            <param len="infoCount">const <type>VkAccelerationStructureBuildGeometryInfoKHR</type>* <name>pInfos</name></param>
            <param len="infoCount">const <type>VkAccelerationStructureBuildRangeInfoKHR</type>* const* <name>ppBuildRangeInfos</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdBuildAccelerationStructuresIndirectKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type>                  <name>commandBuffer</name></param>
            <param><type>uint32_t</type>                                           <name>infoCount</name></param>
            <param len="infoCount">const <type>VkAccelerationStructureBuildGeometryInfoKHR</type>* <name>pInfos</name></param>
            <param len="infoCount">const <type>VkDeviceAddress</type>*             <name>pIndirectDeviceAddresses</name></param>
            <param len="infoCount">const <type>uint32_t</type>*                    <name>pIndirectStrides</name></param>
            <param len="infoCount">const <type>uint32_t</type>* const*             <name>ppMaxPrimitiveCounts</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkBuildAccelerationStructuresKHR</name></proto>
            <param><type>VkDevice</type>                                           <name>device</name></param>
            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
            <param><type>uint32_t</type> <name>infoCount</name></param>
            <param len="infoCount">const <type>VkAccelerationStructureBuildGeometryInfoKHR</type>* <name>pInfos</name></param>
            <param len="infoCount">const <type>VkAccelerationStructureBuildRangeInfoKHR</type>* const* <name>ppBuildRangeInfos</name></param>
        </command>
        <command>
            <proto><type>VkDeviceAddress</type> <name>vkGetAccelerationStructureDeviceAddressKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkAccelerationStructureDeviceAddressInfoKHR</type>* <name>pInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateDeferredOperationKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDeferredOperationKHR</type>* <name>pDeferredOperation</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyDeferredOperationKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkDeferredOperationKHR</type> <name>operation</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command>
            <proto><type>uint32_t</type> <name>vkGetDeferredOperationMaxConcurrencyKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDeferredOperationKHR</type> <name>operation</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_NOT_READY" errorcodes="VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetDeferredOperationResultKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDeferredOperationKHR</type> <name>operation</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_THREAD_DONE_KHR,VK_THREAD_IDLE_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkDeferredOperationJoinKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDeferredOperationKHR</type> <name>operation</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPipelineIndirectMemoryRequirementsNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkComputePipelineCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command>
            <proto><type>VkDeviceAddress</type> <name>vkGetPipelineIndirectDeviceAddressNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPipelineIndirectDeviceAddressInfoNV</type>* <name>pInfo</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkAntiLagUpdateAMD</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkAntiLagDataAMD</type>* <name>pData</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetCullMode</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param optional="true"><type>VkCullModeFlags</type> <name>cullMode</name></param>
        </command>
        <command name="vkCmdSetCullModeEXT" alias="vkCmdSetCullMode"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetFrontFace</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkFrontFace</type> <name>frontFace</name></param>
        </command>
        <command name="vkCmdSetFrontFaceEXT" alias="vkCmdSetFrontFace"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetPrimitiveTopology</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPrimitiveTopology</type> <name>primitiveTopology</name></param>
        </command>
        <command name="vkCmdSetPrimitiveTopologyEXT" alias="vkCmdSetPrimitiveTopology"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetViewportWithCount</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>viewportCount</name></param>
            <param len="viewportCount">const <type>VkViewport</type>* <name>pViewports</name></param>
        </command>
        <command name="vkCmdSetViewportWithCountEXT" alias="vkCmdSetViewportWithCount"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetScissorWithCount</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>scissorCount</name></param>
            <param len="scissorCount">const <type>VkRect2D</type>* <name>pScissors</name></param>
        </command>
        <command name="vkCmdSetScissorWithCountEXT" alias="vkCmdSetScissorWithCount"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdBindIndexBuffer2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param optional="true"><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkDeviceSize</type> <name>size</name></param>
            <param><type>VkIndexType</type> <name>indexType</name></param>
        </command>
        <command name="vkCmdBindIndexBuffer2KHR" alias="vkCmdBindIndexBuffer2"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdBindVertexBuffers2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstBinding</name></param>
            <param><type>uint32_t</type> <name>bindingCount</name></param>
            <param len="bindingCount" optional="false,true">const <type>VkBuffer</type>* <name>pBuffers</name></param>
            <param len="bindingCount">const <type>VkDeviceSize</type>* <name>pOffsets</name></param>
            <param optional="true" len="bindingCount">const <type>VkDeviceSize</type>* <name>pSizes</name></param>
            <param optional="true" len="bindingCount">const <type>VkDeviceSize</type>* <name>pStrides</name></param>
        </command>
        <command name="vkCmdBindVertexBuffers2EXT" alias="vkCmdBindVertexBuffers2"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetDepthTestEnable</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>depthTestEnable</name></param>
        </command>
        <command name="vkCmdSetDepthTestEnableEXT" alias="vkCmdSetDepthTestEnable"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetDepthWriteEnable</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>depthWriteEnable</name></param>
        </command>
        <command name="vkCmdSetDepthWriteEnableEXT" alias="vkCmdSetDepthWriteEnable"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetDepthCompareOp</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkCompareOp</type> <name>depthCompareOp</name></param>
        </command>
        <command name="vkCmdSetDepthCompareOpEXT" alias="vkCmdSetDepthCompareOp"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetDepthBoundsTestEnable</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>depthBoundsTestEnable</name></param>
        </command>
        <command name="vkCmdSetDepthBoundsTestEnableEXT" alias="vkCmdSetDepthBoundsTestEnable"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetStencilTestEnable</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>stencilTestEnable</name></param>
        </command>
        <command name="vkCmdSetStencilTestEnableEXT" alias="vkCmdSetStencilTestEnable"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetStencilOp</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
            <param><type>VkStencilOp</type> <name>failOp</name></param>
            <param><type>VkStencilOp</type> <name>passOp</name></param>
            <param><type>VkStencilOp</type> <name>depthFailOp</name></param>
            <param><type>VkCompareOp</type> <name>compareOp</name></param>
        </command>
        <command name="vkCmdSetStencilOpEXT" alias="vkCmdSetStencilOp"/>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetPatchControlPointsEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>patchControlPoints</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetRasterizerDiscardEnable</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>rasterizerDiscardEnable</name></param>
        </command>
        <command name="vkCmdSetRasterizerDiscardEnableEXT" alias="vkCmdSetRasterizerDiscardEnable"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetDepthBiasEnable</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>depthBiasEnable</name></param>
        </command>
        <command name="vkCmdSetDepthBiasEnableEXT" alias="vkCmdSetDepthBiasEnable"/>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetLogicOpEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkLogicOp</type> <name>logicOp</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetPrimitiveRestartEnable</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>primitiveRestartEnable</name></param>
        </command>
        <command name="vkCmdSetPrimitiveRestartEnableEXT" alias="vkCmdSetPrimitiveRestartEnable"/>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetTessellationDomainOriginEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkTessellationDomainOrigin</type> <name>domainOrigin</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetDepthClampEnableEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>depthClampEnable</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetPolygonModeEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPolygonMode</type> <name>polygonMode</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetRasterizationSamplesEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkSampleCountFlagBits</type>  <name>rasterizationSamples</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetSampleMaskEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkSampleCountFlagBits</type>  <name>samples</name></param>
            <param optional="true" len="latexmath:[\lceil{\mathit{samples} \over 32}\rceil]" altlen="(samples + 31) / 32">const <type>VkSampleMask</type>*    <name>pSampleMask</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetAlphaToCoverageEnableEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>alphaToCoverageEnable</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetAlphaToOneEnableEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>alphaToOneEnable</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetLogicOpEnableEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>logicOpEnable</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetColorBlendEnableEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstAttachment</name></param>
            <param><type>uint32_t</type> <name>attachmentCount</name></param>
            <param len="attachmentCount">const <type>VkBool32</type>* <name>pColorBlendEnables</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetColorBlendEquationEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstAttachment</name></param>
            <param><type>uint32_t</type> <name>attachmentCount</name></param>
            <param len="attachmentCount">const <type>VkColorBlendEquationEXT</type>* <name>pColorBlendEquations</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetColorWriteMaskEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstAttachment</name></param>
            <param><type>uint32_t</type> <name>attachmentCount</name></param>
            <param len="attachmentCount" optional="false,true">const <type>VkColorComponentFlags</type>* <name>pColorWriteMasks</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetRasterizationStreamEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>rasterizationStream</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetConservativeRasterizationModeEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkConservativeRasterizationModeEXT</type> <name>conservativeRasterizationMode</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetExtraPrimitiveOverestimationSizeEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>float</type> <name>extraPrimitiveOverestimationSize</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetDepthClipEnableEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>depthClipEnable</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetSampleLocationsEnableEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>sampleLocationsEnable</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetColorBlendAdvancedEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstAttachment</name></param>
            <param><type>uint32_t</type> <name>attachmentCount</name></param>
            <param len="attachmentCount">const <type>VkColorBlendAdvancedEXT</type>* <name>pColorBlendAdvanced</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetProvokingVertexModeEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkProvokingVertexModeEXT</type> <name>provokingVertexMode</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetLineRasterizationModeEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkLineRasterizationModeEXT</type> <name>lineRasterizationMode</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetLineStippleEnableEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>stippledLineEnable</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetDepthClipNegativeOneToOneEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>negativeOneToOne</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetViewportWScalingEnableNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>viewportWScalingEnable</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetViewportSwizzleNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>firstViewport</name></param>
            <param><type>uint32_t</type> <name>viewportCount</name></param>
            <param len="viewportCount">const <type>VkViewportSwizzleNV</type>* <name>pViewportSwizzles</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetCoverageToColorEnableNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>coverageToColorEnable</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetCoverageToColorLocationNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>coverageToColorLocation</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetCoverageModulationModeNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkCoverageModulationModeNV</type> <name>coverageModulationMode</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetCoverageModulationTableEnableNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>coverageModulationTableEnable</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetCoverageModulationTableNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>coverageModulationTableCount</name></param>
            <param len="coverageModulationTableCount">const <type>float</type>* <name>pCoverageModulationTable</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetShadingRateImageEnableNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>shadingRateImageEnable</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetCoverageReductionModeNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkCoverageReductionModeNV</type> <name>coverageReductionMode</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetRepresentativeFragmentTestEnableNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkBool32</type> <name>representativeFragmentTestEnable</name></param>
        </command>
        <command export="vulkan" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreatePrivateDataSlot</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPrivateDataSlotCreateInfo</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkPrivateDataSlot</type>* <name>pPrivateDataSlot</name></param>
        </command>
        <command name="vkCreatePrivateDataSlotEXT" alias="vkCreatePrivateDataSlot"/>
        <command export="vulkan">
            <proto><type>void</type> <name>vkDestroyPrivateDataSlot</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkPrivateDataSlot</type> <name>privateDataSlot</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command name="vkDestroyPrivateDataSlotEXT" alias="vkDestroyPrivateDataSlot"/>
        <command export="vulkan" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkSetPrivateData</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkObjectType</type> <name>objectType</name></param>
            <param objecttype="objectType"><type>uint64_t</type> <name>objectHandle</name></param>
            <param><type>VkPrivateDataSlot</type> <name>privateDataSlot</name></param>
            <param><type>uint64_t</type> <name>data</name></param>
        </command>
        <command name="vkSetPrivateDataEXT" alias="vkSetPrivateData"/>
        <command export="vulkan">
            <proto><type>void</type> <name>vkGetPrivateData</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkObjectType</type> <name>objectType</name></param>
            <param objecttype="objectType"><type>uint64_t</type> <name>objectHandle</name></param>
            <param><type>VkPrivateDataSlot</type> <name>privateDataSlot</name></param>
            <param><type>uint64_t</type>* <name>pData</name></param>
        </command>
        <command name="vkGetPrivateDataEXT" alias="vkGetPrivateData"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyBuffer2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCopyBufferInfo2</type>* <name>pCopyBufferInfo</name></param>
        </command>
        <command name="vkCmdCopyBuffer2KHR" alias="vkCmdCopyBuffer2"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyImage2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCopyImageInfo2</type>* <name>pCopyImageInfo</name></param>
        </command>
        <command name="vkCmdCopyImage2KHR" alias="vkCmdCopyImage2"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdBlitImage2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkBlitImageInfo2</type>* <name>pBlitImageInfo</name></param>
        </command>
        <command name="vkCmdBlitImage2KHR" alias="vkCmdBlitImage2"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyBufferToImage2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCopyBufferToImageInfo2</type>* <name>pCopyBufferToImageInfo</name></param>
        </command>
        <command name="vkCmdCopyBufferToImage2KHR" alias="vkCmdCopyBufferToImage2"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyImageToBuffer2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCopyImageToBufferInfo2</type>* <name>pCopyImageToBufferInfo</name></param>
        </command>
        <command name="vkCmdCopyImageToBuffer2KHR" alias="vkCmdCopyImageToBuffer2"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdResolveImage2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkResolveImageInfo2</type>* <name>pResolveImageInfo</name></param>
        </command>
        <command name="vkCmdResolveImage2KHR" alias="vkCmdResolveImage2"/>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdRefreshObjectsKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkRefreshObjectListKHR</type>* <name>pRefreshObjects</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceRefreshableObjectTypesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pRefreshableObjectTypeCount</name></param>
            <param optional="true" len="pRefreshableObjectTypeCount"><type>VkObjectType</type>* <name>pRefreshableObjectTypes</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetFragmentShadingRateKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type>           <name>commandBuffer</name></param>
            <param>const <type>VkExtent2D</type>*                           <name>pFragmentSize</name></param>
            <param>const <type>VkFragmentShadingRateCombinerOpKHR</type>    <name>combinerOps</name>[2]</param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceFragmentShadingRatesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pFragmentShadingRateCount</name></param>
            <param optional="true" len="pFragmentShadingRateCount"><type>VkPhysicalDeviceFragmentShadingRateKHR</type>* <name>pFragmentShadingRates</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetFragmentShadingRateEnumNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type>           <name>commandBuffer</name></param>
            <param><type>VkFragmentShadingRateNV</type>                     <name>shadingRate</name></param>
            <param>const <type>VkFragmentShadingRateCombinerOpKHR</type>    <name>combinerOps</name>[2]</param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetAccelerationStructureBuildSizesKHR</name></proto>
            <param><type>VkDevice</type>                                            <name>device</name></param>
            <param><type>VkAccelerationStructureBuildTypeKHR</type>                 <name>buildType</name></param>
            <param>const <type>VkAccelerationStructureBuildGeometryInfoKHR</type>*  <name>pBuildInfo</name></param>
            <param optional="true" len="pBuildInfo-&gt;geometryCount">const <type>uint32_t</type>*  <name>pMaxPrimitiveCounts</name></param>
            <param><type>VkAccelerationStructureBuildSizesInfoKHR</type>*           <name>pSizeInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetVertexInputEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param optional="true"><type>uint32_t</type> <name>vertexBindingDescriptionCount</name></param>
            <param len="vertexBindingDescriptionCount">const <type>VkVertexInputBindingDescription2EXT</type>* <name>pVertexBindingDescriptions</name></param>
            <param optional="true"><type>uint32_t</type> <name>vertexAttributeDescriptionCount</name></param>
            <param len="vertexAttributeDescriptionCount">const <type>VkVertexInputAttributeDescription2EXT</type>* <name>pVertexAttributeDescriptions</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type>                                    <name>vkCmdSetColorWriteEnableEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type>       <name>commandBuffer</name></param>
            <param><type>uint32_t</type>                                <name>attachmentCount</name></param>
            <param len="attachmentCount">const <type>VkBool32</type>*   <name>pColorWriteEnables</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR" renderpass="outside" videocoding="both" cmdbufferlevel="primary,secondary" tasks="synchronization">
            <proto><type>void</type> <name>vkCmdSetEvent2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
            <param><type>VkEvent</type>                                             <name>event</name></param>
            <param>const <type>VkDependencyInfo</type>*                             <name>pDependencyInfo</name></param>
        </command>
        <command name="vkCmdSetEvent2KHR" alias="vkCmdSetEvent2"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR" renderpass="outside" videocoding="both" cmdbufferlevel="primary,secondary" tasks="synchronization">
            <proto><type>void</type> <name>vkCmdResetEvent2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
            <param><type>VkEvent</type>                                             <name>event</name></param>
            <param optional="true"><type>VkPipelineStageFlags2</type>               <name>stageMask</name></param>
        </command>
        <command name="vkCmdResetEvent2KHR" alias="vkCmdResetEvent2"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="synchronization">
            <proto><type>void</type> <name>vkCmdWaitEvents2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
            <param><type>uint32_t</type>                                            <name>eventCount</name></param>
            <param len="eventCount">const <type>VkEvent</type>*                     <name>pEvents</name></param>
            <param len="eventCount">const <type>VkDependencyInfo</type>*            <name>pDependencyInfos</name></param>
        </command>
        <command name="vkCmdWaitEvents2KHR" alias="vkCmdWaitEvents2"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="synchronization">
            <proto><type>void</type> <name>vkCmdPipelineBarrier2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
            <param>const <type>VkDependencyInfo</type>*                             <name>pDependencyInfo</name></param>
        </command>
        <command name="vkCmdPipelineBarrier2KHR" alias="vkCmdPipelineBarrier2"/>
        <command export="vulkan" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkQueueSubmit2</name></proto>
            <param externsync="true"><type>VkQueue</type>                           <name>queue</name></param>
            <param optional="true"><type>uint32_t</type>                            <name>submitCount</name></param>
            <param len="submitCount">const <type>VkSubmitInfo2</type>*              <name>pSubmits</name></param>
            <param optional="true" externsync="true"><type>VkFence</type>           <name>fence</name></param>
        </command>
        <command name="vkQueueSubmit2KHR" alias="vkQueueSubmit2"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR" renderpass="both" videocoding="both" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdWriteTimestamp2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
            <param optional="true"><type>VkPipelineStageFlags2</type>               <name>stage</name></param>
            <param><type>VkQueryPool</type>                                         <name>queryPool</name></param>
            <param><type>uint32_t</type>                                            <name>query</name></param>
        </command>
        <command name="vkCmdWriteTimestamp2KHR" alias="vkCmdWriteTimestamp2"/>
        <command conditionalrendering="false" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdWriteBufferMarker2AMD</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
            <param optional="true"><type>VkPipelineStageFlags2</type>               <name>stage</name></param>
            <param><type>VkBuffer</type>                                            <name>dstBuffer</name></param>
            <param><type>VkDeviceSize</type>                                        <name>dstOffset</name></param>
            <param><type>uint32_t</type>                                            <name>marker</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetQueueCheckpointData2NV</name></proto>
            <param><type>VkQueue</type> <name>queue</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pCheckpointDataCount</name></param>
            <param optional="true" len="pCheckpointDataCount"><type>VkCheckpointData2NV</type>* <name>pCheckpointData</name></param>
        </command>
        <command export="vulkan" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCopyMemoryToImage</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkCopyMemoryToImageInfo</type>*    <name>pCopyMemoryToImageInfo</name></param>
        </command>
        <command name="vkCopyMemoryToImageEXT" alias="vkCopyMemoryToImage"/>
        <command export="vulkan" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCopyImageToMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkCopyImageToMemoryInfo</type>*    <name>pCopyImageToMemoryInfo</name></param>
        </command>
        <command name="vkCopyImageToMemoryEXT" alias="vkCopyImageToMemory"/>
        <command export="vulkan" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCopyImageToImage</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkCopyImageToImageInfo</type>*    <name>pCopyImageToImageInfo</name></param>
        </command>
        <command name="vkCopyImageToImageEXT" alias="vkCopyImageToImage"/>
        <command export="vulkan" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkTransitionImageLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>transitionCount</name></param>
            <param len="transitionCount">const <type>VkHostImageLayoutTransitionInfo</type>*    <name>pTransitions</name></param>
        </command>
        <command name="vkTransitionImageLayoutEXT" alias="vkTransitionImageLayout"/>
        <command export="vulkansc">
            <proto><type>void</type> <name>vkGetCommandPoolMemoryConsumption</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
            <param optional="true" externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkCommandPoolMemoryConsumption</type>* <name>pConsumption</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceVideoCapabilitiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkVideoProfileInfoKHR</type>* <name>pVideoProfile</name></param>
            <param><type>VkVideoCapabilitiesKHR</type>* <name>pCapabilities</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceVideoFormatPropertiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceVideoFormatInfoKHR</type>* <name>pVideoFormatInfo</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pVideoFormatPropertyCount</name></param>
            <param optional="true" len="pVideoFormatPropertyCount"><type>VkVideoFormatPropertiesKHR</type>* <name>pVideoFormatProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR,VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR</type>* <name>pQualityLevelInfo</name></param>
            <param><type>VkVideoEncodeQualityLevelPropertiesKHR</type>* <name>pQualityLevelProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR,VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateVideoSessionKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkVideoSessionCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkVideoSessionKHR</type>* <name>pVideoSession</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyVideoSessionKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkVideoSessionKHR</type> <name>videoSession</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateVideoSessionParametersKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkVideoSessionParametersCreateInfoKHR</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkVideoSessionParametersKHR</type>* <name>pVideoSessionParameters</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkUpdateVideoSessionParametersKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkVideoSessionParametersKHR</type> <name>videoSessionParameters</name></param>
            <param>const <type>VkVideoSessionParametersUpdateInfoKHR</type>* <name>pUpdateInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetEncodedVideoSessionParametersKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkVideoEncodeSessionParametersGetInfoKHR</type>* <name>pVideoSessionParametersInfo</name></param>
            <param optional="true"><type>VkVideoEncodeSessionParametersFeedbackInfoKHR</type>* <name>pFeedbackInfo</name></param>
            <param optional="false,true"><type>size_t</type>* <name>pDataSize</name></param>
            <param optional="true" len="pDataSize"><type>void</type>* <name>pData</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyVideoSessionParametersKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkVideoSessionParametersKHR</type> <name>videoSessionParameters</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetVideoSessionMemoryRequirementsKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkVideoSessionKHR</type> <name>videoSession</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pMemoryRequirementsCount</name></param>
            <param optional="true" len="pMemoryRequirementsCount"><type>VkVideoSessionMemoryRequirementsKHR</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkBindVideoSessionMemoryKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkVideoSessionKHR</type> <name>videoSession</name></param>
            <param><type>uint32_t</type> <name>bindSessionMemoryInfoCount</name></param>
            <param len="bindSessionMemoryInfoCount">const <type>VkBindVideoSessionMemoryInfoKHR</type>* <name>pBindSessionMemoryInfos</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_VIDEO_DECODE_BIT_KHR" renderpass="outside" videocoding="inside" cmdbufferlevel="primary" tasks="action">
            <proto><type>void</type> <name>vkCmdDecodeVideoKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkVideoDecodeInfoKHR</type>* <name>pDecodeInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR" renderpass="outside" videocoding="outside" cmdbufferlevel="primary" tasks="action,state">
            <proto><type>void</type> <name>vkCmdBeginVideoCodingKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkVideoBeginCodingInfoKHR</type>* <name>pBeginInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR" renderpass="outside" videocoding="inside" cmdbufferlevel="primary" tasks="action">
            <proto><type>void</type> <name>vkCmdControlVideoCodingKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkVideoCodingControlInfoKHR</type>* <name>pCodingControlInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_VIDEO_DECODE_BIT_KHR,VK_QUEUE_VIDEO_ENCODE_BIT_KHR" renderpass="outside" videocoding="inside" cmdbufferlevel="primary" tasks="action,state">
            <proto><type>void</type> <name>vkCmdEndVideoCodingKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkVideoEndCodingInfoKHR</type>* <name>pEndCodingInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_VIDEO_ENCODE_BIT_KHR" renderpass="outside" videocoding="inside" cmdbufferlevel="primary" tasks="action">
            <proto><type>void</type> <name>vkCmdEncodeVideoKHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkVideoEncodeInfoKHR</type>* <name>pEncodeInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDecompressMemoryNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>decompressRegionCount</name></param>
            <param len="decompressRegionCount">const <type>VkDecompressMemoryRegionNV</type>* <name>pDecompressMemoryRegions</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDecompressMemoryIndirectCountNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkDeviceAddress</type> <name>indirectCommandsAddress</name></param>
            <param><type>VkDeviceAddress</type> <name>indirectCommandsCountAddress</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPartitionedAccelerationStructuresBuildSizesNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPartitionedAccelerationStructureInstancesInputNV</type>* <name>pInfo</name></param>
            <param><type>VkAccelerationStructureBuildSizesInfoKHR</type>*                  <name>pSizeInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdBuildPartitionedAccelerationStructuresNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type>                     <name>commandBuffer</name></param>
            <param>const <type>VkBuildPartitionedAccelerationStructureInfoNV</type>*  <name>pBuildInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDecompressMemoryEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkDecompressMemoryInfoEXT</type>* <name>pDecompressMemoryInfoEXT</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDecompressMemoryIndirectCountEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkMemoryDecompressionMethodFlagsEXT</type> <name>decompressionMethod</name></param>
            <param><type>VkDeviceAddress</type> <name>indirectCommandsAddress</name></param>
            <param><type>VkDeviceAddress</type> <name>indirectCommandsCountAddress</name></param>
            <param><type>uint32_t</type> <name>maxDecompressionCount</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateCuModuleNVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkCuModuleCreateInfoNVX</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkCuModuleNVX</type>* <name>pModule</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateCuFunctionNVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkCuFunctionCreateInfoNVX</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkCuFunctionNVX</type>* <name>pFunction</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyCuModuleNVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkCuModuleNVX</type> <name>module</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyCuFunctionNVX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkCuFunctionNVX</type> <name>function</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCuLaunchKernelNVX</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCuLaunchInfoNVX</type>* <name>pLaunchInfo</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetDescriptorSetLayoutSizeEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDescriptorSetLayout</type> <name>layout</name></param>
            <param><type>VkDeviceSize</type>* <name>pLayoutSizeInBytes</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetDescriptorSetLayoutBindingOffsetEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDescriptorSetLayout</type> <name>layout</name></param>
            <param><type>uint32_t</type> <name>binding</name></param>
            <param><type>VkDeviceSize</type>* <name>pOffset</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetDescriptorEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDescriptorGetInfoEXT</type>* <name>pDescriptorInfo</name></param>
            <param><type>size_t</type> <name>dataSize</name></param>
            <param len="dataSize"><type>void</type>* <name>pDescriptor</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_DATA_GRAPH_BIT_ARM" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdBindDescriptorBuffersEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>bufferCount</name></param>
            <param len="bufferCount">const <type>VkDescriptorBufferBindingInfoEXT</type>* <name>pBindingInfos</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_DATA_GRAPH_BIT_ARM" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetDescriptorBufferOffsetsEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
            <param><type>VkPipelineLayout</type> <name>layout</name></param>
            <param><type>uint32_t</type> <name>firstSet</name></param>
            <param><type>uint32_t</type> <name>setCount</name></param>
            <param len="setCount">const <type>uint32_t</type>* <name>pBufferIndices</name></param>
            <param len="setCount">const <type>VkDeviceSize</type>* <name>pOffsets</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdBindDescriptorBufferEmbeddedSamplersEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
            <param><type>VkPipelineLayout</type> <name>layout</name></param>
            <param><type>uint32_t</type> <name>set</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetBufferOpaqueCaptureDescriptorDataEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkBufferCaptureDescriptorDataInfoEXT</type>* <name>pInfo</name></param>
            <param><type>void</type>* <name>pData</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetImageOpaqueCaptureDescriptorDataEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImageCaptureDescriptorDataInfoEXT</type>* <name>pInfo</name></param>
            <param><type>void</type>* <name>pData</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetImageViewOpaqueCaptureDescriptorDataEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImageViewCaptureDescriptorDataInfoEXT</type>* <name>pInfo</name></param>
            <param><type>void</type>* <name>pData</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetSamplerOpaqueCaptureDescriptorDataEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSamplerCaptureDescriptorDataInfoEXT</type>* <name>pInfo</name></param>
            <param><type>void</type>* <name>pData</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkAccelerationStructureCaptureDescriptorDataInfoEXT</type>* <name>pInfo</name></param>
            <param><type>void</type>* <name>pData</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkSetDeviceMemoryPriorityEXT</name></proto>
            <param><type>VkDevice</type>       <name>device</name></param>
            <param><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>float</type>          <name>priority</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkAcquireDrmDisplayEXT</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>int32_t</type> <name>drmFd</name></param>
            <param><type>VkDisplayKHR</type> <name>display</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetDrmDisplayEXT</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>int32_t</type> <name>drmFd</name></param>
            <param><type>uint32_t</type> <name>connectorId</name></param>
            <param><type>VkDisplayKHR</type>* <name>display</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_TIMEOUT,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkWaitForPresent2KHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param>const <type>VkPresentWait2InfoKHR</type>* <name>pPresentWait2Info</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_TIMEOUT,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkWaitForPresentKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param><type>uint64_t</type> <name>presentId</name></param>
            <param><type>uint64_t</type> <name>timeout</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateBufferCollectionFUCHSIA</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkBufferCollectionCreateInfoFUCHSIA</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkBufferCollectionFUCHSIA</type>* <name>pCollection</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkSetBufferCollectionBufferConstraintsFUCHSIA</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkBufferCollectionFUCHSIA</type> <name>collection</name></param>
            <param>const <type>VkBufferConstraintsInfoFUCHSIA</type>* <name>pBufferConstraintsInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkSetBufferCollectionImageConstraintsFUCHSIA</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkBufferCollectionFUCHSIA</type> <name>collection</name></param>
            <param>const <type>VkImageConstraintsInfoFUCHSIA</type>* <name>pImageConstraintsInfo</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyBufferCollectionFUCHSIA</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkBufferCollectionFUCHSIA</type> <name>collection</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetBufferCollectionPropertiesFUCHSIA</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkBufferCollectionFUCHSIA</type> <name>collection</name></param>
            <param><type>VkBufferCollectionPropertiesFUCHSIA</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateCudaModuleNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkCudaModuleCreateInfoNV</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkCudaModuleNV</type>* <name>pModule</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetCudaModuleCacheNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkCudaModuleNV</type> <name>module</name></param>
            <param optional="false,true"><type>size_t</type>* <name>pCacheSize</name></param>
            <param optional="true" len="pCacheSize"><type>void</type>* <name>pCacheData</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateCudaFunctionNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkCudaFunctionCreateInfoNV</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkCudaFunctionNV</type>* <name>pFunction</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyCudaModuleNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkCudaModuleNV</type> <name>module</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyCudaFunctionNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkCudaFunctionNV</type> <name>function</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCudaLaunchKernelNV</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCudaLaunchInfoNV</type>* <name>pLaunchInfo</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action,state">
            <proto><type>void</type> <name>vkCmdBeginRendering</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
            <param>const <type>VkRenderingInfo</type>*                              <name>pRenderingInfo</name></param>
        </command>
        <command name="vkCmdBeginRenderingKHR" alias="vkCmdBeginRendering"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action,state">
            <proto><type>void</type> <name>vkCmdEndRendering</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action,state">
            <proto><type>void</type> <name>vkCmdEndRendering2KHR</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
            <param optional="true">const <type>VkRenderingEndInfoKHR</type>*        <name>pRenderingEndInfo</name></param>
        </command>
        <command name="vkCmdEndRendering2EXT" alias="vkCmdEndRendering2KHR"/>
        <command name="vkCmdEndRenderingKHR" alias="vkCmdEndRendering"/>
        <command>
            <proto><type>void</type> <name>vkGetDescriptorSetLayoutHostMappingInfoVALVE</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDescriptorSetBindingReferenceVALVE</type>* <name>pBindingReference</name></param>
            <param><type>VkDescriptorSetLayoutHostMappingInfoVALVE</type>* <name>pHostMapping</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetDescriptorSetHostMappingVALVE</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDescriptorSet</type> <name>descriptorSet</name></param>
            <param><type>void</type>** <name>ppData</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateMicromapEXT</name></proto>
            <param><type>VkDevice</type>                                           <name>device</name></param>
            <param>const <type>VkMicromapCreateInfoEXT</type>*        <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>*       <name>pAllocator</name></param>
            <param><type>VkMicromapEXT</type>*                        <name>pMicromap</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdBuildMicromapsEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type>                                    <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>infoCount</name></param>
            <param len="infoCount">const <type>VkMicromapBuildInfoEXT</type>* <name>pInfos</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkBuildMicromapsEXT</name></proto>
            <param><type>VkDevice</type>                                           <name>device</name></param>
            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
            <param><type>uint32_t</type> <name>infoCount</name></param>
            <param len="infoCount">const <type>VkMicromapBuildInfoEXT</type>* <name>pInfos</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyMicromapEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkMicromapEXT</type> <name>micromap</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyMicromapEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCopyMicromapInfoEXT</type>* <name>pInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCopyMicromapEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
            <param>const <type>VkCopyMicromapInfoEXT</type>* <name>pInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyMicromapToMemoryEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCopyMicromapToMemoryInfoEXT</type>* <name>pInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCopyMicromapToMemoryEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
            <param>const <type>VkCopyMicromapToMemoryInfoEXT</type>* <name>pInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyMemoryToMicromapEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCopyMemoryToMicromapInfoEXT</type>* <name>pInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCopyMemoryToMicromapEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
            <param>const <type>VkCopyMemoryToMicromapInfoEXT</type>* <name>pInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdWriteMicromapsPropertiesEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>micromapCount</name></param>
            <param len="micromapCount">const <type>VkMicromapEXT</type>* <name>pMicromaps</name></param>
            <param><type>VkQueryType</type> <name>queryType</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>firstQuery</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkWriteMicromapsPropertiesEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>micromapCount</name></param>
            <param len="micromapCount">const <type>VkMicromapEXT</type>* <name>pMicromaps</name></param>
            <param><type>VkQueryType</type>  <name>queryType</name></param>
            <param><type>size_t</type>       <name>dataSize</name></param>
            <param len="dataSize"><type>void</type>* <name>pData</name></param>
            <param><type>size_t</type> <name>stride</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetDeviceMicromapCompatibilityEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkMicromapVersionInfoEXT</type>* <name>pVersionInfo</name></param>
            <param><type>VkAccelerationStructureCompatibilityKHR</type>* <name>pCompatibility</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetMicromapBuildSizesEXT</name></proto>
            <param><type>VkDevice</type>                                            <name>device</name></param>
            <param><type>VkAccelerationStructureBuildTypeKHR</type>                 <name>buildType</name></param>
            <param>const <type>VkMicromapBuildInfoEXT</type>*  <name>pBuildInfo</name></param>
            <param><type>VkMicromapBuildSizesInfoEXT</type>*           <name>pSizeInfo</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetShaderModuleIdentifierEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkShaderModule</type> <name>shaderModule</name></param>
            <param><type>VkShaderModuleIdentifierEXT</type>* <name>pIdentifier</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetShaderModuleCreateInfoIdentifierEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkShaderModuleCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkShaderModuleIdentifierEXT</type>* <name>pIdentifier</name></param>
        </command>
        <command export="vulkan">
            <proto><type>void</type> <name>vkGetImageSubresourceLayout2</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param>const <type>VkImageSubresource2</type>* <name>pSubresource</name></param>
            <param><type>VkSubresourceLayout2</type>* <name>pLayout</name></param>
        </command>
        <command name="vkGetImageSubresourceLayout2KHR" alias="vkGetImageSubresourceLayout2"/>
        <command name="vkGetImageSubresourceLayout2EXT"        alias="vkGetImageSubresourceLayout2"/>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPipelinePropertiesEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPipelineInfoEXT</type>* <name>pPipelineInfo</name></param>
            <param noautovalidity="true" validstructs="VkPipelinePropertiesIdentifierEXT"><type>VkBaseOutStructure</type>* <name>pPipelineProperties</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkExportMetalObjectsEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkExportMetalObjectsInfoEXT</type>* <name>pMetalObjectsInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdBindTileMemoryQCOM</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param optional="true">const <type>VkTileMemoryBindInfoQCOM</type>* <name>pTileMemoryBindInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetFramebufferTilePropertiesQCOM</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkFramebuffer</type> <name>framebuffer</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertiesCount</name></param>
            <param optional="true" len="pPropertiesCount"><type>VkTilePropertiesQCOM</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetDynamicRenderingTilePropertiesQCOM</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkRenderingInfo</type>* <name>pRenderingInfo</name></param>
            <param><type>VkTilePropertiesQCOM</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_FORMAT_NOT_SUPPORTED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceOpticalFlowImageFormatsNV</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkOpticalFlowImageFormatInfoNV</type>* <name>pOpticalFlowImageFormatInfo</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pFormatCount</name></param>
            <param optional="true" len="pFormatCount"><type>VkOpticalFlowImageFormatPropertiesNV</type>* <name>pImageFormatProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateOpticalFlowSessionNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkOpticalFlowSessionCreateInfoNV</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkOpticalFlowSessionNV</type>* <name>pSession</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyOpticalFlowSessionNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkOpticalFlowSessionNV</type> <name>session</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkBindOpticalFlowSessionImageNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkOpticalFlowSessionNV</type> <name>session</name></param>
            <param><type>VkOpticalFlowSessionBindingPointNV</type> <name>bindingPoint</name></param>
            <param optional="true"><type>VkImageView</type> <name>view</name></param>
            <param><type>VkImageLayout</type> <name>layout</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_OPTICAL_FLOW_BIT_NV" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdOpticalFlowExecuteNV</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkOpticalFlowSessionNV</type> <name>session</name></param>
            <param>const <type>VkOpticalFlowExecuteInfoNV</type>* <name>pExecuteInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetDeviceFaultInfoEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDeviceFaultCountsEXT</type>* <name>pFaultCounts</name></param>
            <param optional="true"><type>VkDeviceFaultInfoEXT</type>* <name>pFaultInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetDepthBias2EXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkDepthBiasInfoEXT</type>*         <name>pDepthBiasInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkReleaseSwapchainImagesKHR</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkReleaseSwapchainImagesInfoKHR</type>* <name>pReleaseInfo</name></param>
        </command>
        <command name="vkReleaseSwapchainImagesEXT" alias="vkReleaseSwapchainImagesKHR"/>
        <command export="vulkan">
            <proto><type>void</type> <name>vkGetDeviceImageSubresourceLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDeviceImageSubresourceInfo</type>* <name>pInfo</name></param>
            <param><type>VkSubresourceLayout2</type>* <name>pLayout</name></param>
        </command>
        <command name="vkGetDeviceImageSubresourceLayoutKHR" alias="vkGetDeviceImageSubresourceLayout"/>
        <command export="vulkan" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkMapMemory2</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkMemoryMapInfo</type>* <name>pMemoryMapInfo</name></param>
            <param optional="false,true"><type>void</type>** <name>ppData</name></param>
        </command>
        <command name="vkMapMemory2KHR" alias="vkMapMemory2"/>
        <command export="vulkan" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_MEMORY_MAP_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkUnmapMemory2</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkMemoryUnmapInfo</type>* <name>pMemoryUnmapInfo</name></param>
        </command>
        <command name="vkUnmapMemory2KHR" alias="vkUnmapMemory2"/>
        <command allownoqueues="true" successcodes="VK_SUCCESS,VK_INCOMPATIBLE_SHADER_BINARY_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateShadersEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>createInfoCount</name></param>
            <param len="createInfoCount">const <type>VkShaderCreateInfoEXT</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="createInfoCount"><type>VkShaderEXT</type>* <name>pShaders</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyShaderEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkShaderEXT</type> <name>shader</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetShaderBinaryDataEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkShaderEXT</type> <name>shader</name></param>
            <param optional="false,true"><type>size_t</type>* <name>pDataSize</name></param>
            <param optional="true" len="pDataSize"><type>void</type>* <name>pData</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdBindShadersEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>stageCount</name></param>
            <param len="stageCount">const <type>VkShaderStageFlagBits</type>* <name>pStages</name></param>
            <param optional="true,true" len="stageCount">const <type>VkShaderEXT</type>* <name>pShaders</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_NOT_READY" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkSetSwapchainPresentTimingQueueSizeEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param><type>uint32_t</type> <name>size</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_NOT_READY" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetSwapchainTimingPropertiesEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param><type>VkSwapchainTimingPropertiesEXT</type>* <name>pSwapchainTimingProperties</name></param>
            <param optional="true"><type>uint64_t</type>* <name>pSwapchainTimingPropertiesCounter</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetSwapchainTimeDomainPropertiesEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param><type>VkSwapchainTimeDomainPropertiesEXT</type>* <name>pSwapchainTimeDomainProperties</name></param>
            <param optional="true"><type>uint64_t</type>* <name>pTimeDomainsCounter</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPastPresentationTimingEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPastPresentationTimingInfoEXT</type>* <name>pPastPresentationTimingInfo</name></param>
            <param><type>VkPastPresentationTimingPropertiesEXT</type>* <name>pPastPresentationTimingProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetScreenBufferPropertiesQNX</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const struct <type>_screen_buffer</type>* <name>buffer</name></param>
            <param><type>VkScreenBufferPropertiesQNX</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkCooperativeMatrixPropertiesKHR</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetExecutionGraphPipelineScratchSizeAMDX</name></proto>
            <param><type>VkDevice</type>                                        <name>device</name></param>
            <param><type>VkPipeline</type>                                      <name>executionGraph</name></param>
            <param><type>VkExecutionGraphPipelineScratchSizeAMDX</type>*        <name>pSizeInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetExecutionGraphPipelineNodeIndexAMDX</name></proto>
            <param><type>VkDevice</type>                                        <name>device</name></param>
            <param><type>VkPipeline</type>                                      <name>executionGraph</name></param>
            <param>const <type>VkPipelineShaderStageNodeCreateInfoAMDX</type>*  <name>pNodeInfo</name></param>
            <param><type>uint32_t</type>*                                       <name>pNodeIndex</name></param>
        </command>
        <command allownoqueues="true" successcodes="VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateExecutionGraphPipelinesAMDX</name></proto>
            <param><type>VkDevice</type>                                        <name>device</name></param>
            <param optional="true" externsync="maybe"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param><type>uint32_t</type>                                        <name>createInfoCount</name></param>
            <param len="createInfoCount">const <type>VkExecutionGraphPipelineCreateInfoAMDX</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>*    <name>pAllocator</name></param>
            <param len="createInfoCount"><type>VkPipeline</type>*               <name>pPipelines</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" tasks="action" renderpass="both" cmdbufferlevel="primary">
            <proto><type>void</type> <name>vkCmdInitializeGraphScratchMemoryAMDX</name></proto>
            <param><type>VkCommandBuffer</type>                                 <name>commandBuffer</name></param>
            <param><type>VkPipeline</type>                                      <name>executionGraph</name></param>
            <param><type>VkDeviceAddress</type>                                 <name>scratch</name></param>
            <param><type>VkDeviceSize</type>                                    <name>scratchSize</name></param>
        </command>
        <command conditionalrendering="true" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" tasks="action" renderpass="both" cmdbufferlevel="primary">
            <proto><type>void</type> <name>vkCmdDispatchGraphAMDX</name></proto>
            <param><type>VkCommandBuffer</type>                                 <name>commandBuffer</name></param>
            <param><type>VkDeviceAddress</type>                                 <name>scratch</name></param>
            <param><type>VkDeviceSize</type>                                    <name>scratchSize</name></param>
            <param>const <type>VkDispatchGraphCountInfoAMDX</type>*             <name>pCountInfo</name></param>
        </command>
        <command conditionalrendering="true" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" tasks="action" renderpass="both" cmdbufferlevel="primary">
            <proto><type>void</type> <name>vkCmdDispatchGraphIndirectAMDX</name></proto>
            <param><type>VkCommandBuffer</type>                                 <name>commandBuffer</name></param>
            <param><type>VkDeviceAddress</type>                                 <name>scratch</name></param>
            <param><type>VkDeviceSize</type>                                    <name>scratchSize</name></param>
            <param>const <type>VkDispatchGraphCountInfoAMDX</type>*             <name>pCountInfo</name></param>
        </command>
        <command conditionalrendering="true" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" tasks="action" renderpass="both" cmdbufferlevel="primary">
            <proto><type>void</type> <name>vkCmdDispatchGraphIndirectCountAMDX</name></proto>
            <param><type>VkCommandBuffer</type>                                 <name>commandBuffer</name></param>
            <param><type>VkDeviceAddress</type>                                 <name>scratch</name></param>
            <param><type>VkDeviceSize</type>                                    <name>scratchSize</name></param>
            <param><type>VkDeviceAddress</type>                                 <name>countInfo</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdBindDescriptorSets2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkBindDescriptorSetsInfo</type>*   <name>pBindDescriptorSetsInfo</name></param>
        </command>
        <command name="vkCmdBindDescriptorSets2KHR" alias="vkCmdBindDescriptorSets2"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdPushConstants2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkPushConstantsInfo</type>*        <name>pPushConstantsInfo</name></param>
        </command>
        <command name="vkCmdPushConstants2KHR" alias="vkCmdPushConstants2"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdPushDescriptorSet2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkPushDescriptorSetInfo</type>*    <name>pPushDescriptorSetInfo</name></param>
        </command>
        <command name="vkCmdPushDescriptorSet2KHR" alias="vkCmdPushDescriptorSet2"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdPushDescriptorSetWithTemplate2</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkPushDescriptorSetWithTemplateInfo</type>* <name>pPushDescriptorSetWithTemplateInfo</name></param>
        </command>
        <command name="vkCmdPushDescriptorSetWithTemplate2KHR" alias="vkCmdPushDescriptorSetWithTemplate2"/>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_DATA_GRAPH_BIT_ARM" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetDescriptorBufferOffsets2EXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkSetDescriptorBufferOffsetsInfoEXT</type>* <name>pSetDescriptorBufferOffsetsInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdBindDescriptorBufferEmbeddedSamplers2EXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkBindDescriptorBufferEmbeddedSamplersInfoEXT</type>* <name>pBindDescriptorBufferEmbeddedSamplersInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkSetLatencySleepModeNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param>const <type>VkLatencySleepModeInfoNV</type>* <name>pSleepModeInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkLatencySleepNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param>const <type>VkLatencySleepInfoNV</type>* <name>pSleepInfo</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkSetLatencyMarkerNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param>const <type>VkSetLatencyMarkerInfoNV</type>* <name>pLatencyMarkerInfo</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetLatencyTimingsNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
            <param><type>VkGetLatencyMarkerInfoNV</type>* <name>pLatencyMarkerInfo</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkQueueNotifyOutOfBandNV</name></proto>
            <param><type>VkQueue</type> <name>queue</name></param>
            <param>const <type>VkOutOfBandQueueTypeInfoNV</type>* <name>pQueueTypeInfo</name></param>
        </command>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetRenderingAttachmentLocations</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkRenderingAttachmentLocationInfo</type>* <name>pLocationInfo</name></param>
        </command>
        <command name="vkCmdSetRenderingAttachmentLocationsKHR" alias="vkCmdSetRenderingAttachmentLocations"/>
        <command conditionalrendering="false" export="vulkan" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetRenderingInputAttachmentIndices</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkRenderingInputAttachmentIndexInfo</type>* <name>pInputAttachmentIndexInfo</name></param>
        </command>
        <command name="vkCmdSetRenderingInputAttachmentIndicesKHR" alias="vkCmdSetRenderingInputAttachmentIndices"/>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT" renderpass="both" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdSetDepthClampRangeEXT</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkDepthClampModeEXT</type> <name>depthClampMode</name></param>
            <param optional="true">const <type>VkDepthClampRangeEXT</type>* <name>pDepthClampRange</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkCooperativeMatrixFlexibleDimensionsPropertiesNV</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetMemoryMetalHandleEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkMemoryGetMetalHandleInfoEXT</type>* <name>pGetMetalHandleInfo</name></param>
            <param><type>void</type>** <name>pHandle</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetMemoryMetalHandlePropertiesEXT</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></param>
            <param>const <type>void</type>* <name>pHandle</name></param>
            <param><type>VkMemoryMetalHandlePropertiesEXT</type>* <name>pMemoryMetalHandleProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceCooperativeVectorPropertiesNV</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
            <param optional="true" len="pPropertyCount"><type>VkCooperativeVectorPropertiesNV</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkConvertCooperativeVectorMatrixNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkConvertCooperativeVectorMatrixInfoNV</type>* <name>pInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdConvertCooperativeVectorMatrixNV</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>uint32_t</type> <name>infoCount</name></param>
            <param len="infoCount">const <type>VkConvertCooperativeVectorMatrixInfoNV</type>* <name>pInfos</name></param>
        </command>
        <command conditionalrendering="true" queues="VK_QUEUE_COMPUTE_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDispatchTileQCOM</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkDispatchTileInfoQCOM</type>* <name>pDispatchTileInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdBeginPerTileExecutionQCOM</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkPerTileBeginInfoQCOM</type>* <name>pPerTileBeginInfo</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="inside" cmdbufferlevel="primary,secondary" tasks="state">
            <proto><type>void</type> <name>vkCmdEndPerTileExecutionQCOM</name></proto>
            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkPerTileEndInfoQCOM</type>* <name>pPerTileEndInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateExternalComputeQueueNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkExternalComputeQueueCreateInfoNV</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkExternalComputeQueueNV</type>* <name>pExternalQueue</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyExternalComputeQueueNV</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkExternalComputeQueueNV</type> <name>externalQueue</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetExternalComputeQueueDataNV</name></proto>
            <param><type>VkExternalComputeQueueNV</type> <name>externalQueue</name></param>
            <param><type>VkExternalComputeQueueDataParamsNV</type>* <name>params</name></param>
            <param><type>void</type>* <name>pData</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateTensorARM</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkTensorCreateInfoARM</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkTensorARM</type>* <name>pTensor</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyTensorARM</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkTensorARM</type> <name>tensor</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateTensorViewARM</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkTensorViewCreateInfoARM</type>* <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkTensorViewARM</type>* <name>pView</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyTensorViewARM</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param optional="true" externsync="true"><type>VkTensorViewARM</type> <name>tensorView</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetTensorMemoryRequirementsARM</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkTensorMemoryRequirementsInfoARM</type>* <name>pInfo</name></param>
            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkBindTensorMemoryARM</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>bindInfoCount</name></param>
            <param len="bindInfoCount">const <type>VkBindTensorMemoryInfoARM</type>* <name>pBindInfos</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetDeviceTensorMemoryRequirementsARM</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDeviceTensorMemoryRequirementsARM</type>* <name>pInfo</name></param>
            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command conditionalrendering="false" queues="VK_QUEUE_TRANSFER_BIT,VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdCopyTensorARM</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param>const <type>VkCopyTensorInfoARM</type>* <name>pCopyTensorInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetTensorOpaqueCaptureDescriptorDataARM</name></proto>
            <param><type>VkDevice</type>                                    <name>device</name></param>
            <param>const <type>VkTensorCaptureDescriptorDataInfoARM</type>* <name>pInfo</name></param>
            <param><type>void</type>*                                       <name>pData</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetTensorViewOpaqueCaptureDescriptorDataARM</name></proto>
            <param><type>VkDevice</type>                                        <name>device</name></param>
            <param>const <type>VkTensorViewCaptureDescriptorDataInfoARM</type>* <name>pInfo</name></param>
            <param><type>void</type>*                                           <name>pData</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceExternalTensorPropertiesARM</name></proto>
            <param><type>VkPhysicalDevice</type>                             <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceExternalTensorInfoARM</type>* <name>pExternalTensorInfo</name></param>
            <param><type>VkExternalTensorPropertiesARM</type>*               <name>pExternalTensorProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateDataGraphPipelinesARM</name></proto>
            <param><type>VkDevice</type>               <name>device</name></param>
            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
            <param optional="true"><type>VkPipelineCache</type>        <name>pipelineCache</name></param>
            <param><type>uint32_t</type>               <name>createInfoCount</name></param>
            <param len="createInfoCount">const <type>VkDataGraphPipelineCreateInfoARM</type>* <name>pCreateInfos</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param len="createInfoCount"><type>VkPipeline</type>*     <name>pPipelines</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkCreateDataGraphPipelineSessionARM</name></proto>
            <param><type>VkDevice</type>                                     <name>device</name></param>
            <param>const <type>VkDataGraphPipelineSessionCreateInfoARM</type>*   <name>pCreateInfo</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
            <param><type>VkDataGraphPipelineSessionARM</type>*                   <name>pSession</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetDataGraphPipelineSessionBindPointRequirementsARM</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDataGraphPipelineSessionBindPointRequirementsInfoARM</type>* <name>pInfo</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pBindPointRequirementCount</name></param>
            <param optional="true" len="pBindPointRequirementCount"><type>VkDataGraphPipelineSessionBindPointRequirementARM</type>* <name>pBindPointRequirements</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetDataGraphPipelineSessionMemoryRequirementsARM</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDataGraphPipelineSessionMemoryRequirementsInfoARM</type>* <name>pInfo</name></param>
            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkBindDataGraphPipelineSessionMemoryARM</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>bindInfoCount</name></param>
            <param len="bindInfoCount">const <type>VkBindDataGraphPipelineSessionMemoryInfoARM</type>* <name>pBindInfos</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkDestroyDataGraphPipelineSessionARM</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param externsync="true"><type>VkDataGraphPipelineSessionARM</type> <name>session</name></param>
            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
        </command>
        <command conditionalrendering="true" queues="VK_QUEUE_DATA_GRAPH_BIT_ARM" renderpass="outside" cmdbufferlevel="primary,secondary" tasks="action">
            <proto><type>void</type> <name>vkCmdDispatchDataGraphARM</name></proto>
            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
            <param><type>VkDataGraphPipelineSessionARM</type> <name>session</name></param>
            <param optional="true">const <type>VkDataGraphPipelineDispatchInfoARM</type>* <name>pInfo</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetDataGraphPipelineAvailablePropertiesARM</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDataGraphPipelineInfoARM</type>* <name>pPipelineInfo</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pPropertiesCount</name></param>
            <param optional="true" len="pPropertiesCount"><type>VkDataGraphPipelinePropertyARM</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetDataGraphPipelinePropertiesARM</name></proto>
            <param><type>VkDevice</type>                          <name>device</name></param>
            <param>const <type>VkDataGraphPipelineInfoARM</type>* <name>pPipelineInfo</name></param>
            <param><type>uint32_t</type>                          <name>propertiesCount</name></param>
            <param len="propertiesCount"><type>VkDataGraphPipelinePropertyQueryResultARM</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM</name></proto>
            <param><type>VkPhysicalDevice</type>                     <name>physicalDevice</name></param>
            <param><type>uint32_t</type>                             <name>queueFamilyIndex</name></param>
            <param optional="false,true"><type>uint32_t</type>*                            <name>pQueueFamilyDataGraphPropertyCount</name></param>
            <param optional="true" len="pQueueFamilyDataGraphPropertyCount"><type>VkQueueFamilyDataGraphPropertiesARM</type>* <name>pQueueFamilyDataGraphProperties</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM</name></proto>
            <param><type>VkPhysicalDevice</type>                                 <name>physicalDevice</name></param>
            <param>const <type>VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM</type>* <name>pQueueFamilyDataGraphProcessingEngineInfo</name></param>
            <param><type>VkQueueFamilyDataGraphProcessingEnginePropertiesARM</type>*               <name>pQueueFamilyDataGraphProcessingEngineProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetNativeBufferPropertiesOHOS</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const struct <type>OH_NativeBuffer</type>* <name>buffer</name></param>
            <param><type>VkNativeBufferPropertiesOHOS</type>* <name>pProperties</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetMemoryNativeBufferOHOS</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkMemoryGetNativeBufferInfoOHOS</type>* <name>pInfo</name></param>
            <param>struct <type>OH_NativeBuffer</type>** <name>pBuffer</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkGetSwapchainGrallocUsageOHOS</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkImageUsageFlags</type> <name>imageUsage</name></param>
            <param><type>uint64_t</type>* <name>grallocUsage</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkAcquireImageOHOS</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>int32_t</type> <name>nativeFenceFd</name></param>
            <param optional="true"><type>VkSemaphore</type> <name>semaphore</name></param>
            <param optional="true"><type>VkFence</type> <name>fence</name></param>
        </command>
        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkQueueSignalReleaseImageOHOS</name></proto>
            <param><type>VkQueue</type> <name>queue</name></param>
            <param><type>uint32_t</type> <name>waitSemaphoreCount</name></param>
            <param len="waitSemaphoreCount">const <type>VkSemaphore</type>* <name>pWaitSemaphores</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>int32_t</type>* <name>pNativeFenceFd</name></param>
        </command>
        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_UNKNOWN,VK_ERROR_VALIDATION_FAILED">
            <proto><type>VkResult</type> <name>vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param optional="false,true"><type>uint32_t</type>* <name>pCounterCount</name></param>
            <param optional="true" len="pCounterCount"><type>VkPerformanceCounterARM</type>* <name>pCounters</name></param>
            <param optional="true" len="pCounterCount"><type>VkPerformanceCounterDescriptionARM</type>* <name>pCounterDescriptions</name></param>
        </command>
    </commands>

    <feature api="vulkan,vulkansc,vulkanbase" apitype="internal" name="VK_BASE_VERSION_1_0" number="1.0" comment="Vulkan base API interface definitions">
        <require comment="Header boilerplate">
            <type name="vk_platform"/>
            <type name="VK_DEFINE_HANDLE"/>
            <type name="VK_USE_64_BIT_PTR_DEFINES"/>
            <type name="VK_DEFINE_NON_DISPATCHABLE_HANDLE"/>
            <type name="VK_NULL_HANDLE"/>
        </require>
        <require comment="Fundamental types used by many commands and structures">
            <type name="VkBool32"/>
            <type name="VkDeviceAddress"/>
            <type name="VkDeviceSize"/>
            <type name="VkExtent2D"/>
            <type name="VkExtent3D"/>
            <type name="VkFlags"/>
            <type name="VkOffset2D"/>
            <type name="VkOffset3D"/>
            <type name="VkRect2D"/>
            <type name="VkResult"/>
            <type name="VkStructureType"/>
        </require>
        <require comment="API constants">
            <enum name="VK_FALSE"/>
            <enum name="VK_LOD_CLAMP_NONE"/>
            <enum name="VK_QUEUE_FAMILY_IGNORED"/>
            <enum name="VK_REMAINING_ARRAY_LAYERS"/>
            <enum name="VK_REMAINING_MIP_LEVELS"/>
            <enum name="VK_TRUE"/>
            <enum name="VK_WHOLE_SIZE"/>
            <enum name="VK_MAX_MEMORY_TYPES"/>
            <enum name="VK_MAX_PHYSICAL_DEVICE_NAME_SIZE"/>
            <enum name="VK_UUID_SIZE"/>
            <enum name="VK_MAX_EXTENSION_NAME_SIZE"/>
            <enum name="VK_MAX_DESCRIPTION_SIZE"/>
            <enum name="VK_MAX_MEMORY_HEAPS"/>
        </require>
        <require comment="These types are part of the API, though not directly used in API commands or data structures">
            <type name="VkBaseInStructure"/>
            <type name="VkBaseOutStructure"/>
            <type name="VkBufferMemoryBarrier"/>
            <type name="VkImageMemoryBarrier"/>
            <type name="VkMemoryBarrier"/>
            <type name="VkObjectType"/>
            <type name="VkVendorId"/>
        </require>
        <require comment="API version macros">
            <type name="VK_API_VERSION"/>
            <type name="VK_HEADER_VERSION"/>
            <type name="VK_HEADER_VERSION_COMPLETE"/>
            <type name="VK_MAKE_VERSION"/>
            <type name="VK_VERSION_MAJOR"/>
            <type name="VK_VERSION_MINOR"/>
            <type name="VK_VERSION_PATCH"/>
            <type name="VK_MAKE_API_VERSION"/>
            <type name="VK_API_VERSION_VARIANT"/>
            <type name="VK_API_VERSION_MAJOR"/>
            <type name="VK_API_VERSION_MINOR"/>
            <type name="VK_API_VERSION_PATCH"/>
            <type name="VK_API_VERSION_1_0"/>
        </require>
        <deprecate explanationlink="legacy-version-macros">
            <type name="VK_API_VERSION"/>
            <type name="VK_MAKE_VERSION"/>
            <type name="VK_VERSION_MAJOR"/>
            <type name="VK_VERSION_MINOR"/>
            <type name="VK_VERSION_PATCH"/>
        </deprecate>
        <require comment="Device initialization">
            <type name="PFN_vkAllocationFunction"/>
            <type name="PFN_vkFreeFunction"/>
            <type name="PFN_vkInternalAllocationNotification"/>
            <type name="PFN_vkInternalFreeNotification"/>
            <type name="PFN_vkReallocationFunction"/>
            <type name="PFN_vkVoidFunction"/>
            <type name="VkAllocationCallbacks"/>
            <type name="VkApplicationInfo"/>
            <type name="VkFormat"/>
            <type name="VkFormatFeatureFlagBits"/>
            <type name="VkFormatFeatureFlags"/>
            <type name="VkFormatProperties"/>
            <type name="VkImageCreateFlagBits"/>
            <type name="VkImageCreateFlags"/>
            <type name="VkImageFormatProperties"/>
            <type name="VkImageTiling"/>
            <type name="VkImageType"/>
            <type name="VkImageUsageFlagBits"/>
            <type name="VkImageUsageFlags"/>
            <type name="VkInstance"/>
            <type name="VkInstanceCreateFlags"/>
            <type name="VkInstanceCreateFlagBits"/>
            <type name="VkInstanceCreateInfo"/>
            <type name="VkInternalAllocationType"/>
            <type name="VkMemoryHeap"/>
            <type name="VkMemoryHeapFlagBits"/>
            <type name="VkMemoryHeapFlags"/>
            <type name="VkMemoryPropertyFlagBits"/>
            <type name="VkMemoryPropertyFlags"/>
            <type name="VkMemoryType"/>
            <type name="VkPhysicalDevice"/>
            <type name="VkPhysicalDeviceFeatures"/>
            <type name="VkPhysicalDeviceLimits"/>
            <type name="VkPhysicalDeviceMemoryProperties"/>
            <type name="VkPhysicalDeviceProperties"/>
            <type name="VkPhysicalDeviceSparseProperties"/>
            <type name="VkPhysicalDeviceType"/>
            <type name="VkQueueFamilyProperties"/>
            <type name="VkQueueFlagBits"/>
            <type name="VkQueueFlags"/>
            <type name="VkSampleCountFlagBits"/>
            <type name="VkSampleCountFlags"/>
            <type name="VkSystemAllocationScope"/>
            <command name="vkCreateInstance"/>
            <command name="vkDestroyInstance"/>
            <command name="vkEnumeratePhysicalDevices"/>
            <command name="vkGetPhysicalDeviceFeatures"/>
            <command name="vkGetPhysicalDeviceFormatProperties"/>
            <command name="vkGetPhysicalDeviceImageFormatProperties"/>
            <command name="vkGetPhysicalDeviceProperties"/>
            <command name="vkGetPhysicalDeviceQueueFamilyProperties"/>
            <command name="vkGetPhysicalDeviceMemoryProperties"/>
            <command name="vkGetInstanceProcAddr"/>
            <command name="vkGetDeviceProcAddr"/>
        </require>
        <require comment="Device commands">
            <type name="VkDevice"/>
            <type name="VkDeviceCreateFlags" comment="Will add VkDeviceCreateFlagBits when bits are defined in the future"/>
            <type name="VkDeviceCreateInfo"/>
            <type name="VkDeviceQueueCreateFlags" comment="VkDeviceQueueCreateFlagBits was added later"/>
            <type name="VkDeviceQueueCreateInfo"/>
            <command name="vkCreateDevice"/>
            <command name="vkDestroyDevice"/>
        </require>
        <require comment="Extension discovery commands">
            <type name="VkExtensionProperties"/>
            <command name="vkEnumerateInstanceExtensionProperties"/>
            <command name="vkEnumerateDeviceExtensionProperties"/>
        </require>
        <require comment="Layer discovery commands">
            <type name="VkLayerProperties"/>
            <command name="vkEnumerateInstanceLayerProperties"/>
            <command name="vkEnumerateDeviceLayerProperties"/>
        </require>
        <deprecate explanationlink="legacy-devicelayers">
            <command name="vkEnumerateDeviceLayerProperties"/>
        </deprecate>
        <require comment="Queue commands">
            <type name="VkPipelineStageFlagBits"/>
            <type name="VkPipelineStageFlags"/>
            <type name="VkQueue"/>
            <type name="VkSubmitInfo"/>
            <command name="vkGetDeviceQueue"/>
            <command name="vkQueueSubmit"/>
            <command name="vkQueueWaitIdle"/>
            <command name="vkDeviceWaitIdle"/>
        </require>
        <require comment="Memory commands">
            <type name="VkMappedMemoryRange"/>
            <type name="VkMemoryAllocateInfo"/>
            <type name="VkMemoryMapFlagBits"/>
            <type name="VkMemoryMapFlags"/>
            <command name="vkAllocateMemory"/>
            <command name="vkFreeMemory"/>
            <command name="vkMapMemory"/>
            <command name="vkUnmapMemory"/>
            <command name="vkFlushMappedMemoryRanges"/>
            <command name="vkInvalidateMappedMemoryRanges"/>
            <command name="vkGetDeviceMemoryCommitment"/>
        </require>
        <require comment="Memory management API commands">
            <type name="VkDeviceMemory"/>
            <type name="VkMemoryRequirements"/>
            <command name="vkBindBufferMemory"/>
            <command name="vkBindImageMemory"/>
            <command name="vkGetBufferMemoryRequirements"/>
            <command name="vkGetImageMemoryRequirements"/>
        </require>
        <require comment="Sparse resource memory management API commands (optional)">
            <type name="VkBindSparseInfo"/>
            <type name="VkImageAspectFlagBits"/>
            <type name="VkImageAspectFlags"/>
            <type name="VkImageSubresource"/>
            <type name="VkSparseBufferMemoryBindInfo"/>
            <type name="VkSparseImageFormatFlagBits"/>
            <type name="VkSparseImageFormatFlags"/>
            <type name="VkSparseImageFormatProperties"/>
            <type name="VkSparseImageMemoryBind"/>
            <type name="VkSparseImageMemoryBindInfo"/>
            <type name="VkSparseImageMemoryRequirements"/>
            <type name="VkSparseImageOpaqueMemoryBindInfo"/>
            <type name="VkSparseMemoryBind"/>
            <type name="VkSparseMemoryBindFlagBits"/>
            <type name="VkSparseMemoryBindFlags"/>
            <command name="vkGetImageSparseMemoryRequirements"/>
            <command name="vkGetPhysicalDeviceSparseImageFormatProperties"/>
            <command name="vkQueueBindSparse"/>
        </require>
        <require comment="Fence commands">
            <type name="VkFence"/>
            <type name="VkFenceCreateFlagBits"/>
            <type name="VkFenceCreateFlags"/>
            <type name="VkFenceCreateInfo"/>
            <command name="vkCreateFence"/>
            <command name="vkDestroyFence"/>
            <command name="vkResetFences"/>
            <command name="vkGetFenceStatus"/>
            <command name="vkWaitForFences"/>
        </require>
        <require comment="Queue semaphore commands">
            <type name="VkSemaphore"/>
            <type name="VkSemaphoreCreateFlags" comment="Will add VkSemaphoreCreateFlagBits when bits are defined in the future"/>
            <type name="VkSemaphoreCreateInfo"/>
            <command name="vkCreateSemaphore"/>
            <command name="vkDestroySemaphore"/>
        </require>
        <require comment="Query commands">
            <type name="VkQueryPool"/>
            <type name="VkQueryPoolCreateFlagBits"/>
            <type name="VkQueryPoolCreateFlags"/>
            <type name="VkQueryPoolCreateInfo"/>
            <type name="VkQueryResultFlagBits"/>
            <type name="VkQueryResultFlags"/>
            <type name="VkQueryType"/>
            <command name="vkCreateQueryPool"/>
            <command name="vkDestroyQueryPool"/>
            <command name="vkGetQueryPoolResults"/>
        </require>
        <require comment="Buffer commands">
            <type name="VkBuffer"/>
            <type name="VkBufferCreateFlagBits"/>
            <type name="VkBufferCreateFlags"/>
            <type name="VkBufferCreateInfo"/>
            <type name="VkBufferUsageFlagBits"/>
            <type name="VkBufferUsageFlags"/>
            <type name="VkSharingMode"/>
            <command name="vkCreateBuffer"/>
            <command name="vkDestroyBuffer"/>
        </require>
        <require comment="Image commands">
            <type name="VkImage"/>
            <type name="VkImageCreateInfo"/>
            <type name="VkImageLayout"/>
            <type name="VkSubresourceLayout"/>
            <command name="vkCreateImage"/>
            <command name="vkDestroyImage"/>
            <command name="vkGetImageSubresourceLayout"/>
        </require>
        <require comment="Image view commands">
            <type name="VkComponentMapping"/>
            <type name="VkComponentSwizzle"/>
            <type name="VkImageSubresourceRange"/>
            <type name="VkImageView"/>
            <type name="VkImageViewCreateFlagBits"/>
            <type name="VkImageViewCreateFlags"/>
            <type name="VkImageViewCreateInfo"/>
            <type name="VkImageViewType"/>
            <command name="vkCreateImageView"/>
            <command name="vkDestroyImageView"/>
        </require>
        <require comment="Pass commands">
            <type name="VkAccessFlagBits"/>
            <type name="VkAccessFlags"/>
            <type name="VkDependencyFlagBits"/>
            <type name="VkDependencyFlags"/>
        </require>
        <require comment="Command pool commands">
            <type name="VkCommandPool"/>
            <type name="VkCommandPoolCreateFlagBits"/>
            <type name="VkCommandPoolCreateFlags"/>
            <type name="VkCommandPoolCreateInfo"/>
            <type name="VkCommandPoolResetFlagBits"/>
            <type name="VkCommandPoolResetFlags"/>
            <command name="vkCreateCommandPool"/>
            <command name="vkDestroyCommandPool"/>
            <command name="vkResetCommandPool"/>
        </require>
        <require comment="Command buffer commands">
            <type name="VkCommandBuffer"/>
            <type name="VkCommandBufferAllocateInfo"/>
            <type name="VkCommandBufferBeginInfo"/>
            <type name="VkCommandBufferInheritanceInfo"/>
            <type name="VkCommandBufferLevel"/>
            <type name="VkCommandBufferResetFlagBits"/>
            <type name="VkCommandBufferResetFlags"/>
            <type name="VkCommandBufferUsageFlagBits"/>
            <type name="VkCommandBufferUsageFlags"/>
            <type name="VkQueryControlFlagBits"/>
            <type name="VkQueryControlFlags"/>
            <command name="vkAllocateCommandBuffers"/>
            <command name="vkFreeCommandBuffers"/>
            <command name="vkBeginCommandBuffer"/>
            <command name="vkEndCommandBuffer"/>
            <command name="vkResetCommandBuffer"/>
        </require>
        <require comment="Command buffer building commands">
            <type name="VkBufferCopy"/>
            <type name="VkBufferImageCopy"/>
            <type name="VkImageCopy"/>
            <type name="VkImageSubresourceLayers"/>
            <type name="VkIndexType"/>
            <command name="vkCmdCopyBuffer"/>
            <command name="vkCmdCopyImage"/>
            <command name="vkCmdCopyBufferToImage"/>
            <command name="vkCmdCopyImageToBuffer"/>
            <command name="vkCmdUpdateBuffer"/>
            <command name="vkCmdFillBuffer"/>
            <command name="vkCmdPipelineBarrier"/>
            <command name="vkCmdBeginQuery"/>
            <command name="vkCmdEndQuery"/>
            <command name="vkCmdResetQueryPool"/>
            <command name="vkCmdWriteTimestamp"/>
            <command name="vkCmdCopyQueryPoolResults"/>
            <command name="vkCmdExecuteCommands"/>
        </require>
        <require comment="Retroactively promoted from VK_EXT_debug_report for compatibility with VulkanSC">
            <enum offset="1" extnumber="12" extends="VkResult" dir="-"  name="VK_ERROR_VALIDATION_FAILED"/>
        </require>
    </feature>
    <feature api="vulkan,vulkansc,vulkanbase" apitype="internal" name="VK_COMPUTE_VERSION_1_0" number="1.0" depends="VK_BASE_VERSION_1_0" comment="Vulkan compute API interface definitions">
        <require comment="These types are part of the API, though not directly used in API commands or data structures">
            <type name="VkDispatchIndirectCommand"/>
            <type name="VkPipelineCacheHeaderVersion"/>
            <type name="VkPipelineCacheHeaderVersionOne"/>
        </require>
        <require comment="Event commands">
            <type name="VkEvent"/>
            <type name="VkEventCreateFlags"/>
            <type name="VkEventCreateFlagBits"/>
            <type name="VkEventCreateInfo"/>
            <command name="vkCreateEvent"/>
            <command name="vkDestroyEvent"/>
            <command name="vkGetEventStatus"/>
            <command name="vkSetEvent"/>
            <command name="vkResetEvent"/>
        </require>
        <require comment="Buffer view commands">
            <type name="VkBufferView"/>
            <type name="VkBufferViewCreateFlags" comment="Will add VkBufferViewFlagBits when bits are defined in the future"/>
            <type name="VkBufferViewCreateInfo"/>
            <command name="vkCreateBufferView"/>
            <command name="vkDestroyBufferView"/>
        </require>
        <require comment="Shader commands">
            <type name="VkShaderModule"/>
            <type name="VkShaderModuleCreateFlags"/>
            <type name="VkShaderModuleCreateInfo"/>
            <command name="vkCreateShaderModule"/>
            <command name="vkDestroyShaderModule"/>
        </require>
        <require comment="Pipeline Cache commands">
            <type name="VkPipelineCache"/>
            <type name="VkPipelineCacheCreateFlags" comment="VkPipelineCacheCreateFlagBits was added later"/>
            <type name="VkPipelineCacheCreateInfo"/>
            <command name="vkCreatePipelineCache"/>
            <command name="vkDestroyPipelineCache"/>
            <command name="vkGetPipelineCacheData"/>
            <command name="vkMergePipelineCaches"/>
        </require>
        <require comment="Compute Pipeline commands">
            <type name="VkComputePipelineCreateInfo"/>
            <type name="VkPipeline"/>
            <type name="VkPipelineCreateFlagBits"/>
            <type name="VkPipelineCreateFlags"/>
            <type name="VkPipelineLayoutCreateFlags" comment="Will add VkPipelineLayoutCreateFlagBits when bits are defined in the future"/>
            <type name="VkPipelineShaderStageCreateFlagBits"/>
            <type name="VkPipelineShaderStageCreateFlags"/>
            <type name="VkPipelineShaderStageCreateInfo"/>
            <type name="VkShaderStageFlagBits"/>
            <type name="VkShaderStageFlags"/>
            <type name="VkSpecializationInfo"/>
            <type name="VkSpecializationMapEntry"/>
            <command name="vkCreateComputePipelines"/>
            <command name="vkDestroyPipeline"/>
        </require>
        <require comment="Pipeline layout commands">
            <type name="VkPipelineLayout"/>
            <type name="VkPipelineLayoutCreateInfo"/>
            <type name="VkPushConstantRange"/>
            <command name="vkCreatePipelineLayout"/>
            <command name="vkDestroyPipelineLayout"/>
        </require>
        <require comment="Sampler commands">
            <type name="VkBorderColor"/>
            <type name="VkFilter"/>
            <type name="VkSampler"/>
            <type name="VkSamplerAddressMode"/>
            <type name="VkSamplerCreateFlagBits"/>
            <type name="VkSamplerCreateFlags"/>
            <type name="VkSamplerCreateInfo"/>
            <type name="VkSamplerMipmapMode"/>
            <command name="vkCreateSampler"/>
            <command name="vkDestroySampler"/>
        </require>
        <require comment="Descriptor set commands">
            <type name="VkCopyDescriptorSet"/>
            <type name="VkDescriptorBufferInfo"/>
            <type name="VkDescriptorImageInfo"/>
            <type name="VkDescriptorPool"/>
            <type name="VkDescriptorPoolCreateFlagBits"/>
            <type name="VkDescriptorPoolCreateFlags"/>
            <type name="VkDescriptorPoolCreateInfo"/>
            <type name="VkDescriptorPoolResetFlags"/>
            <type name="VkDescriptorPoolSize"/>
            <type name="VkDescriptorSet"/>
            <type name="VkDescriptorSetAllocateInfo"/>
            <type name="VkDescriptorSetLayout"/>
            <type name="VkDescriptorSetLayoutBinding"/>
            <type name="VkDescriptorSetLayoutCreateFlagBits"/>
            <type name="VkDescriptorSetLayoutCreateFlags"/>
            <type name="VkDescriptorSetLayoutCreateInfo"/>
            <type name="VkDescriptorType"/>
            <type name="VkWriteDescriptorSet"/>
            <command name="vkCreateDescriptorSetLayout"/>
            <command name="vkDestroyDescriptorSetLayout"/>
            <command name="vkCreateDescriptorPool"/>
            <command name="vkDestroyDescriptorPool"/>
            <command name="vkResetDescriptorPool"/>
            <command name="vkAllocateDescriptorSets"/>
            <command name="vkFreeDescriptorSets"/>
            <command name="vkUpdateDescriptorSets"/>
        </require>
        <require comment="Query commands">
            <type name="VkQueryPipelineStatisticFlagBits"/>
            <type name="VkQueryPipelineStatisticFlags"/>
        </require>
        <require comment="Pass commands">
            <type name="VkPipelineBindPoint"/>
        </require>
        <require comment="Command buffer building commands">
            <type name="VkClearColorValue"/>
            <command name="vkCmdBindPipeline"/>
            <command name="vkCmdBindDescriptorSets"/>
            <command name="vkCmdClearColorImage"/>
            <command name="vkCmdDispatch"/>
            <command name="vkCmdDispatchIndirect"/>
            <command name="vkCmdSetEvent"/>
            <command name="vkCmdResetEvent"/>
            <command name="vkCmdWaitEvents"/>
            <command name="vkCmdPushConstants"/>
        </require>
    </feature>
    <feature api="vulkan,vulkansc,vulkanbase" apitype="internal" name="VK_GRAPHICS_VERSION_1_0" number="1.0" depends="VK_COMPUTE_VERSION_1_0" comment="Vulkan graphics API interface definitions">
        <require comment="API constants">
            <enum name="VK_ATTACHMENT_UNUSED"/>
            <enum name="VK_SUBPASS_EXTERNAL"/>
        </require>
        <require comment="These types are part of the API, though not directly used in API commands or data structures">
            <type name="VkDrawIndexedIndirectCommand"/>
            <type name="VkDrawIndirectCommand"/>
        </require>
        <require comment="Graphics Pipeline commands">
            <type name="VkBlendFactor"/>
            <type name="VkBlendOp"/>
            <type name="VkColorComponentFlagBits"/>
            <type name="VkColorComponentFlags"/>
            <type name="VkCompareOp"/>
            <type name="VkCullModeFlagBits"/>
            <type name="VkCullModeFlags"/>
            <type name="VkDynamicState"/>
            <type name="VkFrontFace"/>
            <type name="VkGraphicsPipelineCreateInfo"/>
            <type name="VkLogicOp"/>
            <type name="VkPipelineColorBlendAttachmentState"/>
            <type name="VkPipelineColorBlendStateCreateFlags" comment="Will add VkPipeline*StateFlagBits when bits are defined in the future"/>
            <type name="VkPipelineColorBlendStateCreateInfo"/>
            <type name="VkPipelineDepthStencilStateCreateFlags" comment="Will add VkPipeline*StateFlagBits when bits are defined in the future"/>
            <type name="VkPipelineDepthStencilStateCreateInfo"/>
            <type name="VkPipelineDynamicStateCreateFlags" comment="Will add VkPipeline*StateFlagBits when bits are defined in the future"/>
            <type name="VkPipelineDynamicStateCreateInfo"/>
            <type name="VkPipelineInputAssemblyStateCreateFlags" comment="Will add VkPipeline*StateFlagBits when bits are defined in the future"/>
            <type name="VkPipelineInputAssemblyStateCreateInfo"/>
            <type name="VkPipelineMultisampleStateCreateFlags" comment="Will add VkPipelineMultisampleStateCreateFlagBits when bits are defined in the future"/>
            <type name="VkPipelineMultisampleStateCreateInfo"/>
            <type name="VkPipelineRasterizationStateCreateFlags" comment="Will add VkPipelineRasterizationStateCreateFlagBits when bits are defined in the future"/>
            <type name="VkPipelineRasterizationStateCreateInfo"/>
            <type name="VkPipelineTessellationStateCreateFlags" comment="Will add VkPipelineTessellationStateCreateFlagBits when bits are defined in the future"/>
            <type name="VkPipelineTessellationStateCreateInfo"/>
            <type name="VkPipelineVertexInputStateCreateFlags" comment="Will add VkPipelineVertexInputStateCreateFlagBits when bits are defined in the future"/>
            <type name="VkPipelineVertexInputStateCreateInfo"/>
            <type name="VkPipelineViewportStateCreateFlags" comment="Will add VkPipelineViewportStateCreateFlagBits when bits are defined in the future"/>
            <type name="VkPipelineViewportStateCreateInfo"/>
            <type name="VkPolygonMode"/>
            <type name="VkPrimitiveTopology"/>
            <type name="VkSampleMask"/>
            <type name="VkStencilOp"/>
            <type name="VkStencilOpState"/>
            <type name="VkVertexInputAttributeDescription"/>
            <type name="VkVertexInputBindingDescription"/>
            <type name="VkVertexInputRate"/>
            <type name="VkViewport"/>
            <command name="vkCreateGraphicsPipelines"/>
        </require>
        <require comment="Pass commands">
            <type name="VkAttachmentDescription"/>
            <type name="VkAttachmentDescriptionFlagBits"/>
            <type name="VkAttachmentDescriptionFlags"/>
            <type name="VkAttachmentLoadOp"/>
            <type name="VkAttachmentReference"/>
            <type name="VkAttachmentStoreOp"/>
            <type name="VkFramebuffer"/>
            <type name="VkFramebufferCreateFlagBits"/>
            <type name="VkFramebufferCreateFlags"/>
            <type name="VkFramebufferCreateInfo"/>
            <type name="VkRenderPass"/>
            <type name="VkRenderPassCreateFlagBits"/>
            <type name="VkRenderPassCreateFlags"/>
            <type name="VkRenderPassCreateInfo"/>
            <type name="VkSubpassDependency"/>
            <type name="VkSubpassDescription"/>
            <type name="VkSubpassDescriptionFlagBits"/>
            <type name="VkSubpassDescriptionFlags"/>
            <command name="vkCreateFramebuffer"/>
            <command name="vkDestroyFramebuffer"/>
            <command name="vkCreateRenderPass"/>
            <command name="vkDestroyRenderPass"/>
            <command name="vkGetRenderAreaGranularity"/>
        </require>
        <require comment="Command buffer building commands">
            <type name="VkClearAttachment"/>
            <type name="VkClearDepthStencilValue"/>
            <type name="VkClearRect"/>
            <type name="VkClearValue"/>
            <type name="VkImageBlit"/>
            <type name="VkImageResolve"/>
            <type name="VkRenderPassBeginInfo"/>
            <type name="VkStencilFaceFlagBits"/>
            <type name="VkStencilFaceFlags"/>
            <type name="VkSubpassContents"/>
            <command name="vkCmdSetViewport"/>
            <command name="vkCmdSetScissor"/>
            <command name="vkCmdSetLineWidth"/>
            <command name="vkCmdSetDepthBias"/>
            <command name="vkCmdSetBlendConstants"/>
            <command name="vkCmdSetDepthBounds"/>
            <command name="vkCmdSetStencilCompareMask"/>
            <command name="vkCmdSetStencilWriteMask"/>
            <command name="vkCmdSetStencilReference"/>
            <command name="vkCmdBindIndexBuffer"/>
            <command name="vkCmdBindVertexBuffers"/>
            <command name="vkCmdDraw"/>
            <command name="vkCmdDrawIndexed"/>
            <command name="vkCmdDrawIndirect"/>
            <command name="vkCmdDrawIndexedIndirect"/>
            <command name="vkCmdBlitImage"/>
            <command name="vkCmdClearDepthStencilImage"/>
            <command name="vkCmdClearAttachments"/>
            <command name="vkCmdResolveImage"/>
            <command name="vkCmdBeginRenderPass"/>
            <command name="vkCmdNextSubpass"/>
            <command name="vkCmdEndRenderPass"/>
        </require>
    </feature>
    <feature api="vulkan,vulkansc,vulkanbase" name="VK_VERSION_1_0" number="1.0" depends="VK_GRAPHICS_VERSION_1_0" comment="Vulkan core API interface definitions">
        <require comment="Feature requirements">
            <feature name="robustBufferAccess" struct="VkPhysicalDeviceFeatures"/>
        </require>
    </feature>
    <feature api="vulkan,vulkansc,vulkanbase" apitype="internal" name="VK_BASE_VERSION_1_1" number="1.1" depends="VK_BASE_VERSION_1_0" comment="Vulkan base 1.1 API interface definitions.">
        <require comment="API version macros">
            <type name="VK_API_VERSION_1_1"/>
        </require>
        <require comment="Device Initialization">
            <command name="vkEnumerateInstanceVersion"/>
        </require>
        <require comment="Promoted from VK_KHR_bind_memory2">
            <command name="vkBindBufferMemory2"/>
            <command name="vkBindImageMemory2"/>
            <enum extends="VkStructureType" extnumber="158" offset="0"          name="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO"/>
            <enum extends="VkStructureType" extnumber="158" offset="1"          name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO"/>
            <enum bitpos="10" extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_ALIAS_BIT"/>
            <type name="VkBindBufferMemoryInfo"/>
            <type name="VkBindImageMemoryInfo"/>
        </require>
        <require comment="Promoted from VK_KHR_dedicated_allocation">
            <enum extends="VkStructureType" extnumber="128" offset="0"          name="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS"/>
            <enum extends="VkStructureType" extnumber="128" offset="1"          name="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO"/>
            <type name="VkMemoryDedicatedRequirements"/>
            <type name="VkMemoryDedicatedAllocateInfo"/>
        </require>
        <require comment="Promoted from VK_KHR_device_group">
            <enum extends="VkStructureType" extnumber="61"  offset="0"          name="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO"/>
            <comment>offset 1 reserved for the old VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHX enum</comment>
            <comment>offset 2 reserved for the old VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHX enum</comment>
            <enum extends="VkStructureType" extnumber="61"  offset="4"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO"/>
            <enum extends="VkStructureType" extnumber="61"  offset="5"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO"/>
            <enum extends="VkStructureType" extnumber="61"  offset="6"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO"/>
            <type name="VkPeerMemoryFeatureFlags"/>
            <type name="VkPeerMemoryFeatureFlagBits"/>
            <type name="VkMemoryAllocateFlags"/>
            <type name="VkMemoryAllocateFlagBits"/>
            <type name="VkMemoryAllocateFlagsInfo"/>
            <type name="VkDeviceGroupCommandBufferBeginInfo"/>
            <type name="VkDeviceGroupSubmitInfo"/>
            <type name="VkDeviceGroupBindSparseInfo"/>
            <command name="vkGetDeviceGroupPeerMemoryFeatures"/>
            <command name="vkCmdSetDeviceMask"/>
            <enum bitpos="2"  extends="VkDependencyFlagBits"                    name="VK_DEPENDENCY_DEVICE_GROUP_BIT" comment="Dependency is across devices"/>
        </require>
        <require comment="Promoted from VK_KHR_device_group + VK_KHR_bind_memory2">
            <enum extends="VkStructureType" extnumber="61"  offset="13"         name="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO"/>
            <enum extends="VkStructureType" extnumber="61"  offset="14"         name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO"/>
            <type name="VkBindBufferMemoryDeviceGroupInfo"/>
            <type name="VkBindImageMemoryDeviceGroupInfo"/>
            <enum bitpos="6"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT" comment="Allows using VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions when binding memory to the image"/>
        </require>
        <require comment="Promoted from VK_KHR_device_group_creation">
            <enum extends="VkStructureType" extnumber="71"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES"/>
            <enum extends="VkStructureType" extnumber="71"  offset="1"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO"/>
            <enum name="VK_MAX_DEVICE_GROUP_SIZE"/>
            <type name="VkPhysicalDeviceGroupProperties"/>
            <type name="VkDeviceGroupDeviceCreateInfo"/>
            <command name="vkEnumeratePhysicalDeviceGroups"/>
            <enum bitpos="1"  extends="VkMemoryHeapFlagBits"                    name="VK_MEMORY_HEAP_MULTI_INSTANCE_BIT" comment="If set, heap allocations allocate multiple instances by default"/>
        </require>
        <require comment="Promoted from VK_KHR_get_memory_requirements2">
            <enum extends="VkStructureType" extnumber="147" offset="0"          name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2"/>
            <enum extends="VkStructureType" extnumber="147" offset="1"          name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2"/>
            <enum extends="VkStructureType" extnumber="147" offset="2"          name="VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2"/>
            <enum extends="VkStructureType" extnumber="147" offset="3"          name="VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2"/>
            <enum extends="VkStructureType" extnumber="147" offset="4"          name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2"/>
            <type name="VkBufferMemoryRequirementsInfo2"/>
            <type name="VkImageMemoryRequirementsInfo2"/>
            <type name="VkImageSparseMemoryRequirementsInfo2"/>
            <type name="VkMemoryRequirements2"/>
            <type name="VkSparseImageMemoryRequirements2"/>
            <command name="vkGetImageMemoryRequirements2"/>
            <command name="vkGetBufferMemoryRequirements2"/>
            <command name="vkGetImageSparseMemoryRequirements2"/>
        </require>
        <require comment="Promoted from VK_KHR_get_physical_device_properties2">
            <enum extends="VkStructureType" extnumber="60"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2"/>
            <enum extends="VkStructureType" extnumber="60"  offset="1"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2"/>
            <enum extends="VkStructureType" extnumber="60"  offset="2"          name="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2"/>
            <enum extends="VkStructureType" extnumber="60"  offset="3"          name="VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2"/>
            <enum extends="VkStructureType" extnumber="60"  offset="4"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2"/>
            <enum extends="VkStructureType" extnumber="60"  offset="5"          name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2"/>
            <enum extends="VkStructureType" extnumber="60"  offset="6"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2"/>
            <enum extends="VkStructureType" extnumber="60"  offset="7"          name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2"/>
            <enum extends="VkStructureType" extnumber="60"  offset="8"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2"/>
            <type name="VkPhysicalDeviceFeatures2"/>
            <type name="VkPhysicalDeviceProperties2"/>
            <type name="VkFormatProperties2"/>
            <type name="VkImageFormatProperties2"/>
            <type name="VkPhysicalDeviceImageFormatInfo2"/>
            <type name="VkQueueFamilyProperties2"/>
            <type name="VkPhysicalDeviceMemoryProperties2"/>
            <type name="VkSparseImageFormatProperties2"/>
            <type name="VkPhysicalDeviceSparseImageFormatInfo2"/>
            <command name="vkGetPhysicalDeviceFeatures2"/>
            <command name="vkGetPhysicalDeviceProperties2"/>
            <command name="vkGetPhysicalDeviceFormatProperties2"/>
            <command name="vkGetPhysicalDeviceImageFormatProperties2"/>
            <command name="vkGetPhysicalDeviceQueueFamilyProperties2"/>
            <command name="vkGetPhysicalDeviceMemoryProperties2"/>
            <command name="vkGetPhysicalDeviceSparseImageFormatProperties2"/>
        </require>
        <require comment="Promoted from VK_KHR_maintenance1">
            <enum extends="VkResult"        extnumber="70"  offset="0"  dir="-" name="VK_ERROR_OUT_OF_POOL_MEMORY"/>
            <enum bitpos="14" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_TRANSFER_SRC_BIT" comment="Format can be used as the source image of image transfer commands"/>
            <enum bitpos="15" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_TRANSFER_DST_BIT" comment="Format can be used as the destination image of image transfer commands"/>
            <enum bitpos="5"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT" comment="The 3D image can be viewed as a 2D or 2D array image"/>
            <command name="vkTrimCommandPool"/>
            <comment>Additional dependent types / tokens extending enumerants, not explicitly mentioned</comment>
            <type name="VkCommandPoolTrimFlags"/>
        </require>
        <require comment="Promoted from VK_KHR_maintenance2">
            <enum bitpos="7"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT"/>
            <enum bitpos="8"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_EXTENDED_USAGE_BIT"/>
            <enum extends="VkStructureType" extnumber="118" offset="2"          name="VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO"/>
            <type name="VkImageViewUsageCreateInfo"/>
        </require>
        <require comment="Originally based on VK_KHR_protected_memory (extension 146), which was never published; thus the mystifying large value= numbers below. These are not aliased since they were not actually promoted from an extension.">
            <enum extends="VkStructureType" extnumber="146" offset="0"          name="VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO"/>
            <enum extends="VkStructureType" extnumber="146" offset="1"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES"/>
            <enum extends="VkStructureType" extnumber="146" offset="2"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES"/>
            <enum extends="VkStructureType" extnumber="146" offset="3"          name="VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2"/>
            <enum bitpos="4"  extends="VkQueueFlagBits"                         name="VK_QUEUE_PROTECTED_BIT" comment="Queues may support protected operations"/>
            <enum bitpos="0"  extends="VkDeviceQueueCreateFlagBits"             name="VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT" comment="Queue is a protected-capable device queue"/>
            <enum bitpos="5"  extends="VkMemoryPropertyFlagBits"                name="VK_MEMORY_PROPERTY_PROTECTED_BIT" comment="Memory is protected"/>
            <enum bitpos="3"  extends="VkBufferCreateFlagBits"                  name="VK_BUFFER_CREATE_PROTECTED_BIT" comment="Buffer requires protected memory"/>
            <enum bitpos="11" extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_PROTECTED_BIT" comment="Image requires protected memory"/>
            <enum bitpos="2"  extends="VkCommandPoolCreateFlagBits"             name="VK_COMMAND_POOL_CREATE_PROTECTED_BIT" comment="Command buffers allocated from pool are protected command buffers"/>
            <type name="VkDeviceQueueCreateFlagBits"/>
            <type name="VkPhysicalDeviceProtectedMemoryFeatures"/>
            <type name="VkPhysicalDeviceProtectedMemoryProperties"/>
            <type name="VkDeviceQueueInfo2"/>
            <type name="VkProtectedSubmitInfo"/>
            <command name="vkGetDeviceQueue2"/>
        </require>
        <require comment="Promoted from VK_KHR_sampler_ycbcr_conversion">
            <enum extends="VkFormat"        extnumber="157" offset="0"          name="VK_FORMAT_G8B8G8R8_422_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="1"          name="VK_FORMAT_B8G8R8G8_422_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="2"          name="VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="3"          name="VK_FORMAT_G8_B8R8_2PLANE_420_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="4"          name="VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="5"          name="VK_FORMAT_G8_B8R8_2PLANE_422_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="6"          name="VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="7"          name="VK_FORMAT_R10X6_UNORM_PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="8"          name="VK_FORMAT_R10X6G10X6_UNORM_2PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="9"          name="VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="10"         name="VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="11"         name="VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="12"         name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="13"         name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="14"         name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="15"         name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="16"         name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="17"         name="VK_FORMAT_R12X4_UNORM_PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="18"         name="VK_FORMAT_R12X4G12X4_UNORM_2PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="19"         name="VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="20"         name="VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="21"         name="VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="22"         name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="23"         name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="24"         name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="25"         name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="26"         name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16"/>
            <enum extends="VkFormat"        extnumber="157" offset="27"         name="VK_FORMAT_G16B16G16R16_422_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="28"         name="VK_FORMAT_B16G16R16G16_422_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="29"         name="VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="30"         name="VK_FORMAT_G16_B16R16_2PLANE_420_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="31"         name="VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="32"         name="VK_FORMAT_G16_B16R16_2PLANE_422_UNORM"/>
            <enum extends="VkFormat"        extnumber="157" offset="33"         name="VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM"/>
            <enum bitpos="4"  extends="VkImageAspectFlagBits"                   name="VK_IMAGE_ASPECT_PLANE_0_BIT"/>
            <enum bitpos="5"  extends="VkImageAspectFlagBits"                   name="VK_IMAGE_ASPECT_PLANE_1_BIT"/>
            <enum bitpos="6"  extends="VkImageAspectFlagBits"                   name="VK_IMAGE_ASPECT_PLANE_2_BIT"/>
            <enum bitpos="9"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_DISJOINT_BIT"/>
            <type name="VkBindImagePlaneMemoryInfo"/>
            <type name="VkImagePlaneMemoryRequirementsInfo"/>
        </require>
        <require comment="Promoted from VK_KHR_external_memory_capabilities">
            <enum extends="VkStructureType" extnumber="72"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO"/>
            <enum extends="VkStructureType" extnumber="72"  offset="1"          name="VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES"/>
            <enum extends="VkStructureType" extnumber="72"  offset="2"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO"/>
            <enum extends="VkStructureType" extnumber="72"  offset="3"          name="VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES"/>
            <enum extends="VkStructureType" extnumber="72"  offset="4"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"/>
            <enum name="VK_LUID_SIZE"/>
            <type name="VkExternalMemoryHandleTypeFlags"/>
            <type name="VkExternalMemoryHandleTypeFlagBits"/>
            <type name="VkExternalMemoryFeatureFlags"/>
            <type name="VkExternalMemoryFeatureFlagBits"/>
            <type name="VkExternalMemoryProperties"/>
            <type name="VkPhysicalDeviceExternalImageFormatInfo"/>
            <type name="VkExternalImageFormatProperties"/>
            <type name="VkPhysicalDeviceExternalBufferInfo"/>
            <type name="VkExternalBufferProperties"/>
            <type name="VkPhysicalDeviceIDProperties"/>
            <command name="vkGetPhysicalDeviceExternalBufferProperties"/>
        </require>
        <require comment="Promoted from VK_KHR_external_memory">
            <enum extends="VkStructureType" extnumber="73"  offset="0"          name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO"/>
            <enum extends="VkStructureType" extnumber="73"  offset="1"          name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO"/>
            <enum extends="VkStructureType" extnumber="73"  offset="2"          name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO"/>
            <enum extends="VkResult"        extnumber="73"  offset="3"  dir="-" name="VK_ERROR_INVALID_EXTERNAL_HANDLE"/>
            <enum name="VK_QUEUE_FAMILY_EXTERNAL"/>
            <type name="VkExternalMemoryImageCreateInfo"/>
            <type name="VkExternalMemoryBufferCreateInfo"/>
            <type name="VkExportMemoryAllocateInfo"/>
        </require>
        <require comment="Promoted from VK_KHR_external_fence_capabilities">
            <enum extends="VkStructureType" extnumber="113" offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO"/>
            <enum extends="VkStructureType" extnumber="113" offset="1"          name="VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES"/>
            <type name="VkExternalFenceHandleTypeFlags"/>
            <type name="VkExternalFenceHandleTypeFlagBits"/>
            <type name="VkExternalFenceFeatureFlags"/>
            <type name="VkExternalFenceFeatureFlagBits"/>
            <type name="VkPhysicalDeviceExternalFenceInfo"/>
            <type name="VkExternalFenceProperties"/>
            <command name="vkGetPhysicalDeviceExternalFenceProperties"/>
        </require>
        <require comment="Promoted from VK_KHR_external_fence">
            <enum extends="VkStructureType" extnumber="114" offset="0"          name="VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO"/>
            <type name="VkFenceImportFlags"/>
            <type name="VkFenceImportFlagBits"/>
            <type name="VkExportFenceCreateInfo"/>
        </require>
        <require comment="Promoted from VK_KHR_external_semaphore">
            <enum extends="VkStructureType" extnumber="78"  offset="0"          name="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO"/>
            <type name="VkSemaphoreImportFlags"/>
            <type name="VkSemaphoreImportFlagBits"/>
            <type name="VkExportSemaphoreCreateInfo"/>
        </require>
        <require comment="Promoted from VK_KHR_external_semaphore_capabilities">
            <enum extends="VkStructureType" extnumber="77"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO"/>
            <enum extends="VkStructureType" extnumber="77"  offset="1"          name="VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES"/>
            <type name="VkExternalSemaphoreHandleTypeFlags"/>
            <type name="VkExternalSemaphoreHandleTypeFlagBits"/>
            <type name="VkExternalSemaphoreFeatureFlags"/>
            <type name="VkExternalSemaphoreFeatureFlagBits"/>
            <type name="VkPhysicalDeviceExternalSemaphoreInfo"/>
            <type name="VkExternalSemaphoreProperties"/>
            <command name="vkGetPhysicalDeviceExternalSemaphoreProperties"/>
        </require>
        <deprecate explanationlink="legacy-gpdp2">
            <command name="vkGetPhysicalDeviceFeatures"/>
            <command name="vkGetPhysicalDeviceProperties"/>
            <command name="vkGetPhysicalDeviceFormatProperties"/>
            <command name="vkGetPhysicalDeviceImageFormatProperties"/>
            <command name="vkGetPhysicalDeviceQueueFamilyProperties"/>
            <command name="vkGetPhysicalDeviceMemoryProperties"/>
            <command name="vkGetPhysicalDeviceSparseImageFormatProperties"/>
        </deprecate>
    </feature>
    <feature api="vulkan,vulkansc,vulkanbase" apitype="internal" name="VK_COMPUTE_VERSION_1_1" number="1.1" depends="VK_COMPUTE_VERSION_1_0,VK_BASE_VERSION_1_1" comment="Vulkan compute 1.1 API interface definitions.">
        <require comment="Promoted from VK_KHR_relaxed_block_layout, which has no API"/>
        <require comment="Promoted from VK_KHR_storage_buffer_storage_class, which has no API"/>
        <require comment="Originally based on VK_KHR_subgroup (extension 94), but the actual enum block used was, incorrectly, that of extension 95">
            <enum extends="VkStructureType" extnumber="95"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES"/>
            <type                                       name="VkPhysicalDeviceSubgroupProperties"/>
            <type                                       name="VkSubgroupFeatureFlags"/>
            <type                                       name="VkSubgroupFeatureFlagBits"/>
        </require>
        <require comment="Promoted from VK_KHR_16bit_storage">
            <enum extends="VkStructureType" extnumber="84"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"/>
            <type name="VkPhysicalDevice16BitStorageFeatures"/>
        </require>
        <require comment="Promoted from VK_KHR_device_group">
            <command name="vkCmdDispatchBase"/>
            <enum bitpos="4"  extends="VkPipelineCreateFlagBits"                name="VK_PIPELINE_CREATE_DISPATCH_BASE_BIT"/>
            <enum extends="VkPipelineCreateFlagBits"                            name="VK_PIPELINE_CREATE_DISPATCH_BASE" alias="VK_PIPELINE_CREATE_DISPATCH_BASE_BIT" deprecated="aliased"/>
        </require>
        <require comment="Promoted from VK_KHR_variable_pointers">
            <enum extends="VkStructureType" extnumber="121" offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"/>
            <enum api="vulkan" extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"/>
            <type name="VkPhysicalDeviceVariablePointerFeatures"/>
            <type name="VkPhysicalDeviceVariablePointersFeatures"/>
        </require>
        <require comment="Promoted from VK_KHR_descriptor_update_template">
            <enum extends="VkStructureType" extnumber="86"  offset="0"          name="VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"/>
            <enum extends="VkObjectType"    extnumber="86"  offset="0"          name="VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE"/>
            <command name="vkCreateDescriptorUpdateTemplate"/>
            <command name="vkDestroyDescriptorUpdateTemplate"/>
            <command name="vkUpdateDescriptorSetWithTemplate"/>
            <type name="VkDescriptorUpdateTemplate"/>
            <type name="VkDescriptorUpdateTemplateCreateFlags"/>
            <type name="VkDescriptorUpdateTemplateType"/>
            <type name="VkDescriptorUpdateTemplateEntry"/>
            <type name="VkDescriptorUpdateTemplateCreateInfo"/>
        </require>
        <require comment="Promoted from VK_KHR_maintenance3">
            <enum extends="VkStructureType" extnumber="169" offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"/>
            <enum extends="VkStructureType" extnumber="169" offset="1"          name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT"/>
            <type name="VkPhysicalDeviceMaintenance3Properties"/>
            <type name="VkDescriptorSetLayoutSupport"/>
            <command name="vkGetDescriptorSetLayoutSupport"/>
        </require>
        <require comment="Promoted from VK_KHR_sampler_ycbcr_conversion">
            <enum extends="VkStructureType" extnumber="157" offset="0"          name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO"/>
            <enum extends="VkStructureType" extnumber="157" offset="1"          name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO"/>
            <enum extends="VkStructureType" extnumber="157" offset="2"          name="VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO"/>
            <enum extends="VkStructureType" extnumber="157" offset="3"          name="VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO"/>
            <enum extends="VkStructureType" extnumber="157" offset="4"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"/>
            <enum extends="VkStructureType" extnumber="157" offset="5"          name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES"/>
            <enum extends="VkObjectType"    extnumber="157" offset="0"          name="VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION"/>
            <enum bitpos="17" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT" comment="Format can have midpoint rather than cosited chroma samples"/>
            <enum bitpos="18" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT" comment="Format can be used with linear filtering whilst color conversion is enabled"/>
            <enum bitpos="19" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT" comment="Format can have different chroma, min and mag filters"/>
            <enum bitpos="20" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT"/>
            <enum bitpos="21" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT"/>
            <enum bitpos="22" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_DISJOINT_BIT" comment="Format supports disjoint planes"/>
            <enum bitpos="23" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT" comment="Format can have cosited rather than midpoint chroma samples"/>
            <type name="VkSamplerYcbcrConversionCreateInfo"/>
            <type name="VkSamplerYcbcrConversionInfo"/>
            <type name="VkPhysicalDeviceSamplerYcbcrConversionFeatures"/>
            <type name="VkSamplerYcbcrConversionImageFormatProperties"/>
            <command name="vkCreateSamplerYcbcrConversion"/>
            <command name="vkDestroySamplerYcbcrConversion"/>
            <comment>Additional dependent types / tokens extending enumerants, not explicitly mentioned</comment>
            <type name="VkSamplerYcbcrConversion"/>
            <type name="VkSamplerYcbcrModelConversion"/>
            <type name="VkSamplerYcbcrRange"/>
            <type name="VkChromaLocation"/>
        </require>
    </feature>
    <feature api="vulkan,vulkansc,vulkanbase" apitype="internal" name="VK_GRAPHICS_VERSION_1_1" number="1.1" depends="VK_GRAPHICS_VERSION_1_0,VK_COMPUTE_VERSION_1_1" comment="Vulkan graphics 1.1 API interface definitions.">
        <require comment="Promoted from VK_KHR_device_group">
            <enum extends="VkStructureType" extnumber="61"  offset="3"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO"/>
            <type name="VkDeviceGroupRenderPassBeginInfo"/>
            <enum bitpos="3"  extends="VkPipelineCreateFlagBits"                name="VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT"/>
        </require>
        <require comment="Promoted from VK_KHR_maintenance2">
            <enum extends="VkStructureType" extnumber="118" offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"/>
            <enum extends="VkStructureType" extnumber="118" offset="1"          name="VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO"/>
            <enum extends="VkStructureType" extnumber="118" offset="3"          name="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO"/>
            <enum extends="VkImageLayout"   extnumber="118" offset="0"          name="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL"/>
            <enum extends="VkImageLayout"   extnumber="118" offset="1"          name="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL"/>
            <type name="VkPhysicalDevicePointClippingProperties"/>
            <type name="VkPointClippingBehavior"/>
            <type name="VkRenderPassInputAttachmentAspectCreateInfo"/>
            <type name="VkInputAttachmentAspectReference"/>
            <type name="VkTessellationDomainOrigin"/>
            <type name="VkPipelineTessellationDomainOriginStateCreateInfo"/>
        </require>
        <require comment="Promoted from VK_KHR_multiview">
            <enum extends="VkStructureType" extnumber="54"  offset="0"          name="VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO"/>
            <enum extends="VkStructureType" extnumber="54"  offset="1"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES"/>
            <enum extends="VkStructureType" extnumber="54"  offset="2"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"/>
            <enum bitpos="1"  extends="VkDependencyFlagBits"                    name="VK_DEPENDENCY_VIEW_LOCAL_BIT"/>
            <type name="VkRenderPassMultiviewCreateInfo"/>
            <type name="VkPhysicalDeviceMultiviewFeatures"/>
            <type name="VkPhysicalDeviceMultiviewProperties"/>
        </require>
        <require comment="Promoted from VK_KHR_shader_draw_parameters, with a feature support query added">
            <enum extends="VkStructureType" extnumber="64"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES"/>
            <enum api="vulkan" extends="VkStructureType"                                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES"/>
            <type name="VkPhysicalDeviceShaderDrawParameterFeatures"/>
            <type name="VkPhysicalDeviceShaderDrawParametersFeatures"/>
        </require>
    </feature>
    <feature api="vulkan,vulkansc,vulkanbase" name="VK_VERSION_1_1" number="1.1" depends="VK_VERSION_1_0,VK_GRAPHICS_VERSION_1_1" comment="Vulkan 1.1 core API interface definitions">
        <require comment="Feature requirements">
            <feature name="multiview" struct="VkPhysicalDeviceMultiviewFeatures"/>
        </require>
        <require depends="VkPhysicalDevice16BitStorageFeatures::uniformAndStorageBuffer16BitAccess">
            <feature name="storageBuffer16BitAccess" struct="VkPhysicalDevice16BitStorageFeatures"/>
        </require>
        <require depends="VK_KHR_shader_draw_parameters">
            <feature name="shaderDrawParameters" struct="VkPhysicalDeviceShaderDrawParametersFeatures"/>
        </require>
    </feature>
    <feature api="vulkan,vulkansc,vulkanbase" apitype="internal" name="VK_BASE_VERSION_1_2" number="1.2" depends="VK_BASE_VERSION_1_1" comment="Vulkan base 1.2 API interface definitions.">
        <require comment="API version macros">
            <type name="VK_API_VERSION_1_2"/>
        </require>
        <require>
            <enum extends="VkStructureType" value="49" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES"/>
            <enum extends="VkStructureType" value="50" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES"/>
            <enum extends="VkStructureType" value="51" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES"/>
            <enum extends="VkStructureType" value="52" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES"/>
            <type name="VkPhysicalDeviceVulkan11Features"/>
            <type name="VkPhysicalDeviceVulkan11Properties"/>
            <type name="VkPhysicalDeviceVulkan12Features"/>
            <type name="VkPhysicalDeviceVulkan12Properties"/>
        </require>
        <require comment="Promoted from VK_KHR_image_format_list (extension 148)">
            <enum offset="0" extends="VkStructureType"  extnumber="148"         name="VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO"/>
            <type name="VkImageFormatListCreateInfo"/>
        </require>
        <require comment="Promoted from VK_KHR_sampler_mirror_clamp_to_edge (extension 15)">
            <enum value="4" extends="VkSamplerAddressMode"                      name="VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE" comment="No need to add an extnumber attribute, since this uses a core enum value"/>
        </require>
        <require comment="Promoted from VK_KHR_driver_properties (extension 197)">
            <enum offset="0" extends="VkStructureType" extnumber="197"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES"/>
            <enum name="VK_MAX_DRIVER_NAME_SIZE"/>
            <enum name="VK_MAX_DRIVER_INFO_SIZE"/>
            <type name="VkDriverId"/>
            <type name="VkConformanceVersion"/>
            <type name="VkPhysicalDeviceDriverProperties"/>
        </require>
        <require comment="Promoted from VK_KHR_vulkan_memory_model (extension 212)">
            <enum offset="0" extends="VkStructureType" extnumber="212"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES"/>
            <type name="VkPhysicalDeviceVulkanMemoryModelFeatures"/>
        </require>
        <require comment="Promoted from VK_EXT_host_query_reset (extension 262)">
            <enum offset="0" extends="VkStructureType" extnumber="262"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES"/>
            <type name="VkPhysicalDeviceHostQueryResetFeatures"/>
            <command name="vkResetQueryPool"/>
        </require>
        <require comment="Promoted from VK_KHR_timeline_semaphore (extension 208)">
            <enum offset="0" extends="VkStructureType" extnumber="208"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES"/>
            <enum offset="1" extends="VkStructureType" extnumber="208"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES"/>
            <enum offset="2" extends="VkStructureType" extnumber="208"          name="VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO"/>
            <enum offset="3" extends="VkStructureType" extnumber="208"          name="VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO"/>
            <enum offset="4" extends="VkStructureType" extnumber="208"          name="VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO"/>
            <enum offset="5" extends="VkStructureType" extnumber="208"          name="VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO"/>
            <type name="VkSemaphoreType"/>
            <type name="VkPhysicalDeviceTimelineSemaphoreFeatures"/>
            <type name="VkPhysicalDeviceTimelineSemaphoreProperties"/>
            <type name="VkSemaphoreTypeCreateInfo"/>
            <type name="VkTimelineSemaphoreSubmitInfo"/>
            <type name="VkSemaphoreWaitFlagBits"/>
            <type name="VkSemaphoreWaitFlags"/>
            <type name="VkSemaphoreWaitInfo"/>
            <type name="VkSemaphoreSignalInfo"/>
            <command name="vkGetSemaphoreCounterValue"/>
            <command name="vkWaitSemaphores"/>
            <command name="vkSignalSemaphore"/>
        </require>
        <require comment="Promoted from VK_KHR_buffer_device_address (extension 258)">
            <enum offset="0" extends="VkStructureType" extnumber="258"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES"/>
            <enum offset="1" extends="VkStructureType" extnumber="245"          name="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO"/>
            <enum offset="2" extends="VkStructureType" extnumber="258"          name="VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO"/>
            <enum offset="3" extends="VkStructureType" extnumber="258"          name="VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO"/>
            <enum offset="4" extends="VkStructureType" extnumber="258"          name="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO"/>
            <enum bitpos="17" extends="VkBufferUsageFlagBits"                   name="VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT"/>
            <enum bitpos="4"  extends="VkBufferCreateFlagBits"                  name="VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"/>
            <enum bitpos="1" extends="VkMemoryAllocateFlagBits"                 name="VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT"/>
            <enum bitpos="2" extends="VkMemoryAllocateFlagBits"                 name="VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"/>
            <enum offset="0" dir="-" extends="VkResult" extnumber="258"         name="VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS"/>
            <type name="VkPhysicalDeviceBufferDeviceAddressFeatures"/>
            <type name="VkBufferDeviceAddressInfo"/>
            <type name="VkBufferOpaqueCaptureAddressCreateInfo"/>
            <type name="VkMemoryOpaqueCaptureAddressAllocateInfo"/>
            <type name="VkDeviceMemoryOpaqueCaptureAddressInfo"/>
            <command name="vkGetBufferDeviceAddress"/>
            <command name="vkGetBufferOpaqueCaptureAddress"/>
            <command name="vkGetDeviceMemoryOpaqueCaptureAddress"/>
        </require>
    </feature>
    <feature api="vulkan,vulkansc,vulkanbase" apitype="internal" name="VK_COMPUTE_VERSION_1_2" number="1.2" depends="VK_COMPUTE_VERSION_1_1,VK_BASE_VERSION_1_2" comment="Vulkan compute 1.2 API interface definitions.">
        <require comment="Promoted from VK_KHR_8bit_storage (extension 178)">
            <enum offset="0" extends="VkStructureType" extnumber="178"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES"/>
            <type name="VkPhysicalDevice8BitStorageFeatures"/>
        </require>
        <require comment="Promoted from VK_KHR_shader_atomic_int64 (extension 181)">
            <enum offset="0" extends="VkStructureType" extnumber="181"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES"/>
            <type name="VkPhysicalDeviceShaderAtomicInt64Features"/>
        </require>
        <require comment="Promoted from VK_KHR_shader_float16_int8 (extension 83)">
            <enum offset="0" extends="VkStructureType" extnumber="83"           name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"/>
            <type name="VkPhysicalDeviceShaderFloat16Int8Features"/>
        </require>
        <require comment="Promoted from VK_KHR_shader_float_controls (extension 198)">
            <enum offset="0" extends="VkStructureType" extnumber="198"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES"/>
            <type name="VkPhysicalDeviceFloatControlsProperties"/>
            <type name="VkShaderFloatControlsIndependence"/>
        </require>
        <require comment="Promoted from VK_EXT_descriptor_indexing (extension 162)">
            <enum offset="0" extends="VkStructureType" extnumber="162"          name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO"/>
            <enum offset="1" extends="VkStructureType" extnumber="162"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES"/>
            <enum offset="2" extends="VkStructureType" extnumber="162"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES"/>
            <enum offset="3" extends="VkStructureType" extnumber="162"          name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO"/>
            <enum offset="4" extends="VkStructureType" extnumber="162"          name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT"/>
            <enum bitpos="1" extends="VkDescriptorPoolCreateFlagBits"           name="VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT"/>
            <enum bitpos="1" extends="VkDescriptorSetLayoutCreateFlagBits"      name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT"/>
            <enum offset="0" dir="-" extends="VkResult" extnumber="162"         name="VK_ERROR_FRAGMENTATION"/>
            <type name="VkDescriptorSetLayoutBindingFlagsCreateInfo"/>
            <type name="VkPhysicalDeviceDescriptorIndexingFeatures"/>
            <type name="VkPhysicalDeviceDescriptorIndexingProperties"/>
            <type name="VkDescriptorSetVariableDescriptorCountAllocateInfo"/>
            <type name="VkDescriptorSetVariableDescriptorCountLayoutSupport"/>
            <type name="VkDescriptorBindingFlagBits"/>
            <type name="VkDescriptorBindingFlags"/>
        </require>
        <require comment="Promoted from VK_EXT_scalar_block_layout (extension 222))">
            <type                                                               name="VkPhysicalDeviceScalarBlockLayoutFeatures"/>
            <enum offset="0" extends="VkStructureType" extnumber="222"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES"/>
        </require>
        <require comment="Promoted from VK_EXT_sampler_filter_minmax (extension 131)">
            <enum offset="0" extends="VkStructureType" extnumber="131"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES"/>
            <enum offset="1" extends="VkStructureType" extnumber="131"          name="VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO"/>
            <enum bitpos="16" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT" comment="Format can be used with min/max reduction filtering"/>
            <type name="VkSamplerReductionMode"/>
            <type name="VkSamplerReductionModeCreateInfo"/>
            <type name="VkPhysicalDeviceSamplerFilterMinmaxProperties"/>
        </require>
        <require comment="Promoted from VK_KHR_uniform_buffer_standard_layout (extension 254)">
            <type name="VkPhysicalDeviceUniformBufferStandardLayoutFeatures"/>
            <enum offset="0" extends="VkStructureType" extnumber="254"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES"/>
        </require>
        <require comment="Promoted from VK_KHR_shader_subgroup_extended_types (extension 176)">
            <enum offset="0" extends="VkStructureType" extnumber="176"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES"/>
            <type name="VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures"/>
        </require>
        <require comment="Promoted from VK_KHR_spirv_1_4 (extension 237)">
        </require>
    </feature>
    <feature api="vulkan,vulkansc,vulkanbase" apitype="internal" name="VK_GRAPHICS_VERSION_1_2" number="1.2" depends="VK_GRAPHICS_VERSION_1_1,VK_COMPUTE_VERSION_1_2" comment="Vulkan graphics 1.2 API interface definitions.">
        <require comment="Promoted from VK_KHR_draw_indirect_count (extension 170)">
            <command name="vkCmdDrawIndirectCount"/>
            <command name="vkCmdDrawIndexedIndirectCount"/>
        </require>
        <require comment="Promoted from VK_KHR_create_renderpass2 (extension 110)">
            <enum offset="0" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2"/>
            <enum offset="1" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2"/>
            <enum offset="2" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2"/>
            <enum offset="3" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2"/>
            <enum offset="4" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2"/>
            <enum offset="5" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO"/>
            <enum offset="6" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_SUBPASS_END_INFO"/>
            <command name="vkCreateRenderPass2"/>
            <command name="vkCmdBeginRenderPass2"/>
            <command name="vkCmdNextSubpass2"/>
            <command name="vkCmdEndRenderPass2"/>
            <type name="VkRenderPassCreateInfo2"/>
            <type name="VkAttachmentDescription2"/>
            <type name="VkAttachmentReference2"/>
            <type name="VkSubpassDescription2"/>
            <type name="VkSubpassDependency2"/>
            <type name="VkSubpassBeginInfo"/>
            <type name="VkSubpassEndInfo"/>
        </require>
        <require comment="Promoted from VK_KHR_depth_stencil_resolve (extension 200)">
            <enum offset="0" extends="VkStructureType" extnumber="200"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES"/>
            <enum offset="1" extends="VkStructureType" extnumber="200"          name="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE"/>
            <type name="VkSubpassDescriptionDepthStencilResolve"/>
            <type name="VkPhysicalDeviceDepthStencilResolveProperties"/>
            <type name="VkResolveModeFlagBits"/>
            <type name="VkResolveModeFlags"/>
        </require>
        <require comment="Promoted from VK_EXT_separate_stencil_usage (extension 247)">
            <enum offset="0" extends="VkStructureType" extnumber="247"          name="VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO"/>
            <type name="VkImageStencilUsageCreateInfo"/>
        </require>
        <require comment="Promoted from VK_KHR_imageless_framebuffer (extension 109)">
            <type name="VkPhysicalDeviceImagelessFramebufferFeatures"/>
            <type name="VkFramebufferAttachmentsCreateInfo"/>
            <type name="VkFramebufferAttachmentImageInfo"/>
            <type name="VkRenderPassAttachmentBeginInfo"/>
            <enum offset="0" extends="VkStructureType" extnumber="109"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES"/>
            <enum offset="1" extends="VkStructureType" extnumber="109"          name="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO"/>
            <enum offset="2" extends="VkStructureType" extnumber="109"          name="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO"/>
            <enum offset="3" extends="VkStructureType" extnumber="109"          name="VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO"/>
            <enum bitpos="0" extends="VkFramebufferCreateFlagBits"              name="VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT"/>
        </require>
        <require comment="Promoted from VK_KHR_separate_depth_stencil_layouts (extension 242)">
            <enum offset="0" extends="VkStructureType" extnumber="242"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES"/>
            <enum offset="1" extends="VkStructureType" extnumber="242"          name="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT"/>
            <enum offset="2" extends="VkStructureType" extnumber="242"          name="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT"/>
            <enum offset="0" extends="VkImageLayout"   extnumber="242"          name="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL"/>
            <enum offset="1" extends="VkImageLayout"   extnumber="242"          name="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL"/>
            <enum offset="2" extends="VkImageLayout"   extnumber="242"          name="VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL"/>
            <enum offset="3" extends="VkImageLayout"   extnumber="242"          name="VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL"/>
            <type name="VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures"/>
            <type name="VkAttachmentReferenceStencilLayout"/>
            <type name="VkAttachmentDescriptionStencilLayout"/>
        </require>
        <deprecate explanationlink="legacy-renderpass2">
            <command name="vkCreateRenderPass"/>
            <type name="VkRenderPassCreateInfo"/>
            <type name="VkRenderPassCreateFlags"/>
            <type name="VkRenderPassCreateFlagBits"/>
            <type name="VkAttachmentDescription"/>
            <type name="VkAttachmentDescriptionFlags"/>
            <type name="VkAttachmentDescriptionFlagBits"/>
            <type name="VkSubpassDescription"/>
            <type name="VkSubpassDescriptionFlags"/>
            <type name="VkSubpassDescriptionFlagBits"/>
            <type name="VkAttachmentReference"/>
            <type name="VkSubpassDependency"/>
            <type name="VkRenderPassInputAttachmentAspectCreateInfo"/>
            <type name="VkInputAttachmentAspectReference"/>
            <type name="VkRenderPassMultiviewCreateInfo"/>
            <command name="vkCmdBeginRenderPass"/>
            <command name="vkCmdNextSubpass"/>
            <command name="vkCmdEndRenderPass"/>
        </deprecate>
    </feature>
    <feature api="vulkan,vulkansc,vulkanbase" name="VK_VERSION_1_2" number="1.2" depends="VK_VERSION_1_1,VK_GRAPHICS_VERSION_1_2" comment="Vulkan 1.2 core API interface definitions">
        <require comment="Feature requirements">
            <feature name="subgroupBroadcastDynamicId" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="imagelessFramebuffer" struct="VkPhysicalDeviceImagelessFramebufferFeatures"/>
            <feature name="imagelessFramebuffer" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="uniformBufferStandardLayout" struct="VkPhysicalDeviceUniformBufferStandardLayoutFeatures"/>
            <feature name="uniformBufferStandardLayout" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="shaderSubgroupExtendedTypes" struct="VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures"/>
            <feature name="shaderSubgroupExtendedTypes" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="separateDepthStencilLayouts" struct="VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures"/>
            <feature name="separateDepthStencilLayouts" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="hostQueryReset" struct="VkPhysicalDeviceHostQueryResetFeatures"/>
            <feature name="hostQueryReset" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="timelineSemaphore" struct="VkPhysicalDeviceTimelineSemaphoreFeatures"/>
            <feature name="timelineSemaphore" struct="VkPhysicalDeviceVulkan12Features"/>
        </require>
        <require depends="VK_KHR_sampler_mirror_clamp_to_edge">
            <feature name="samplerMirrorClampToEdge" struct="VkPhysicalDeviceVulkan12Features"/>
        </require>
        <require depends="VK_KHR_draw_indirect_count">
            <feature name="drawIndirectCount" struct="VkPhysicalDeviceVulkan12Features"/>
        </require>
        <require depends="VkPhysicalDevice8BitStorageFeatures::uniformAndStorageBuffer8BitAccess">
            <feature name="storageBuffer8BitAccess" struct="VkPhysicalDevice8BitStorageFeatures"/>
            <feature name="storageBuffer8BitAccess" struct="VkPhysicalDeviceVulkan12Features"/>
        </require>
        <require depends="VkPhysicalDeviceShaderAtomicInt64Features::shaderSharedInt64Atomics,VkPhysicalDeviceShaderAtomicInt64Features::shaderBufferInt64Atomics">
            <feature name="shaderInt64" struct="VkPhysicalDeviceFeatures"/>
        </require>
        <require depends="VK_EXT_descriptor_indexing">
            <feature name="descriptorIndexing" struct="VkPhysicalDeviceVulkan12Features"/>
        </require>
        <require depends="VkPhysicalDeviceVulkan12Features::descriptorIndexing">
            <feature name="shaderSampledImageArrayDynamicIndexing" struct="VkPhysicalDeviceFeatures"/>
            <feature name="shaderStorageBufferArrayDynamicIndexing" struct="VkPhysicalDeviceFeatures"/>
            <feature name="shaderUniformTexelBufferArrayDynamicIndexing" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="shaderStorageTexelBufferArrayDynamicIndexing" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="shaderSampledImageArrayNonUniformIndexing" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="shaderStorageBufferArrayNonUniformIndexing" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="shaderUniformTexelBufferArrayNonUniformIndexing" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="descriptorBindingSampledImageUpdateAfterBind" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="descriptorBindingStorageImageUpdateAfterBind" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="descriptorBindingStorageBufferUpdateAfterBind" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="descriptorBindingUniformTexelBufferUpdateAfterBind" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="descriptorBindingStorageTexelBufferUpdateAfterBind" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="descriptorBindingUpdateUnusedWhilePending" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="descriptorBindingPartiallyBound" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="runtimeDescriptorArray" struct="VkPhysicalDeviceVulkan12Features"/>
        </require>
        <require depends="VK_EXT_shader_viewport_index_layer">
            <feature name="shaderOutputViewportIndex" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="shaderOutputLayer" struct="VkPhysicalDeviceVulkan12Features"/>
        </require>
        <require depends="VK_EXT_sampler_filter_minmax">
            <feature name="samplerFilterMinmax" struct="VkPhysicalDeviceVulkan12Features"/>
        </require>
    </feature>
    <feature api="vulkan,vulkansc,vulkanbase" apitype="internal" name="VK_BASE_VERSION_1_3" number="1.3" depends="VK_BASE_VERSION_1_2" comment="Vulkan base 1.3 API interface definitions.">
        <require comment="API version macros">
            <type name="VK_API_VERSION_1_3"/>
        </require>
        <require>
            <type name="VkFlags64"/>
        </require>
        <require>
            <enum extends="VkStructureType" value="53"                          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES"/>
            <enum extends="VkStructureType" value="54"                          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES"/>
            <type name="VkPhysicalDeviceVulkan13Features"/>
            <type name="VkPhysicalDeviceVulkan13Properties"/>
        </require>
        <require comment="Promoted from VK_EXT_tooling_info (extension 246)">
            <enum offset="0" extends="VkStructureType"  extnumber="246"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES"/>
            <type name="VkToolPurposeFlagBits"/>
            <type name="VkToolPurposeFlags"/>
            <type name="VkPhysicalDeviceToolProperties"/>
            <command name="vkGetPhysicalDeviceToolProperties"/>
        </require>
        <require comment="Promoted from VK_EXT_private_data (extension 296)">
            <enum offset="0" extends="VkStructureType"  extnumber="296"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES"/>
            <enum offset="1" extends="VkStructureType"  extnumber="296"         name="VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO"/>
            <enum offset="2" extends="VkStructureType"  extnumber="296"         name="VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO"/>
            <enum offset="0" extends="VkObjectType"     extnumber="296"         name="VK_OBJECT_TYPE_PRIVATE_DATA_SLOT"/>
            <type name="VkPhysicalDevicePrivateDataFeatures"/>
            <type name="VkDevicePrivateDataCreateInfo"/>
            <type name="VkPrivateDataSlotCreateInfo"/>
            <type name="VkPrivateDataSlot"/>
            <type name="VkPrivateDataSlotCreateFlags" comment="Will add VkPrivateDataSlotCreateFlagBits when bits are defined in the future"/>
            <command name="vkCreatePrivateDataSlot"/>
            <command name="vkDestroyPrivateDataSlot"/>
            <command name="vkSetPrivateData"/>
            <command name="vkGetPrivateData"/>
        </require>
        <require comment="Promoted from VK_KHR_synchronization2 (extension 315)">
            <enum offset="0" extends="VkStructureType"  extnumber="315"         name="VK_STRUCTURE_TYPE_MEMORY_BARRIER_2"/>
            <enum offset="1" extends="VkStructureType"  extnumber="315"         name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2"/>
            <enum offset="2" extends="VkStructureType"  extnumber="315"         name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2"/>
            <enum offset="3" extends="VkStructureType"  extnumber="315"         name="VK_STRUCTURE_TYPE_DEPENDENCY_INFO"/>
            <enum offset="4" extends="VkStructureType"  extnumber="315"         name="VK_STRUCTURE_TYPE_SUBMIT_INFO_2"/>
            <enum offset="5" extends="VkStructureType"  extnumber="315"         name="VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO"/>
            <enum offset="6" extends="VkStructureType"  extnumber="315"         name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO"/>
            <enum offset="7" extends="VkStructureType"  extnumber="315"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES"/>
            <enum offset="0" extends="VkImageLayout"    extnumber="315"         name="VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL"/>
            <enum offset="1" extends="VkImageLayout"    extnumber="315"         name="VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL"/>
            <enum value="0"  extends="VkPipelineStageFlagBits"                  name="VK_PIPELINE_STAGE_NONE"/>
            <enum value="0"  extends="VkAccessFlagBits"                         name="VK_ACCESS_NONE"/>
            <type name="VkPipelineStageFlags2"/>
            <type name="VkPipelineStageFlagBits2"/>
            <type name="VkAccessFlags2"/>
            <type name="VkAccessFlagBits2"/>
            <type name="VkMemoryBarrier2"/>
            <type name="VkBufferMemoryBarrier2"/>
            <type name="VkImageMemoryBarrier2"/>
            <type name="VkDependencyInfo"/>
            <type name="VkSubmitInfo2"/>
            <type name="VkSemaphoreSubmitInfo"/>
            <type name="VkCommandBufferSubmitInfo"/>
            <type name="VkSubmitFlagBits"/>
            <type name="VkSubmitFlags"/>
            <type name="VkPhysicalDeviceSynchronization2Features"/>
            <command name="vkCmdPipelineBarrier2"/>
            <command name="vkCmdWriteTimestamp2"/>
            <command name="vkQueueSubmit2"/>
        </require>
        <require comment="Promoted from VK_KHR_copy_commands2 (extension 338)">
            <enum offset="0" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2"/>
            <enum offset="1" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2"/>
            <enum offset="2" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2"/>
            <enum offset="3" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2"/>
            <enum offset="6" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_BUFFER_COPY_2"/>
            <enum offset="7" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_IMAGE_COPY_2"/>
            <enum offset="9" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2"/>
            <type name="VkCopyBufferInfo2"/>
            <type name="VkCopyImageInfo2"/>
            <type name="VkCopyBufferToImageInfo2"/>
            <type name="VkCopyImageToBufferInfo2"/>
            <type name="VkBufferCopy2"/>
            <type name="VkImageCopy2"/>
            <type name="VkBufferImageCopy2"/>
            <command name="vkCmdCopyBuffer2"/>
            <command name="vkCmdCopyImage2"/>
            <command name="vkCmdCopyBufferToImage2"/>
            <command name="vkCmdCopyImageToBuffer2"/>
        </require>
        <require comment="Promoted from VK_EXT_ycbcr_2plane_444_formats (does not promote the Feature struct, just the formats) (extension 331)">
            <enum offset="0" extends="VkFormat" extnumber="331"                 name="VK_FORMAT_G8_B8R8_2PLANE_444_UNORM"/>
            <enum offset="1" extends="VkFormat" extnumber="331"                 name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16"/>
            <enum offset="2" extends="VkFormat" extnumber="331"                 name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16"/>
            <enum offset="3" extends="VkFormat" extnumber="331"                 name="VK_FORMAT_G16_B16R16_2PLANE_444_UNORM"/>
        </require>
        <require comment="Promoted from VK_EXT_4444_formats (does not promote the Feature struct, just the formats) (extension 341)">
            <enum offset="0" extends="VkFormat" extnumber="341"                 name="VK_FORMAT_A4R4G4B4_UNORM_PACK16"/>
            <enum offset="1" extends="VkFormat" extnumber="341"                 name="VK_FORMAT_A4B4G4R4_UNORM_PACK16"/>
        </require>
        <require comment="Promoted from VK_EXT_texture_compression_astc_hdr (Feature struct is promoted, but becomes optional) (extension 67)">
            <enum offset="0"  extends="VkStructureType" extnumber="67"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES"/>
            <type name="VkPhysicalDeviceTextureCompressionASTCHDRFeatures"/>
            <enum offset="0"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK"/>
            <enum offset="1"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK"/>
            <enum offset="2"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK"/>
            <enum offset="3"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK"/>
            <enum offset="4"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK"/>
            <enum offset="5"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK"/>
            <enum offset="6"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK"/>
            <enum offset="7"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK"/>
            <enum offset="8"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK"/>
            <enum offset="9"  extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK"/>
            <enum offset="10" extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK"/>
            <enum offset="11" extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK"/>
            <enum offset="12" extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK"/>
            <enum offset="13" extends="VkFormat" extnumber="67"                 name="VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK"/>
        </require>
        <require comment="Promoted from VK_KHR_format_feature_flags2 (extension 361)">
            <enum offset="0" extends="VkStructureType" extnumber="361"          name="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3"/>
            <type name="VkFormatFeatureFlags2"/>
            <type name="VkFormatFeatureFlagBits2"/>
            <type name="VkFormatProperties3"/>
            <enum bitpos="13" extends="VkFormatFeatureFlagBits2"                name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT" comment="This is an interaction with EXT_filter_cubic, though not tagged that way"/>
        </require>
        <require comment="Promoted from VK_KHR_maintenance4 (extension 414)">
            <enum offset="0" extends="VkStructureType" extnumber="414"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES"/>
            <enum offset="1" extends="VkStructureType" extnumber="414"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES"/>
            <enum offset="2" extends="VkStructureType" extnumber="414"          name="VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS"/>
            <enum offset="3" extends="VkStructureType" extnumber="414"          name="VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS"/>
            <enum value="0"  extends="VkImageAspectFlagBits"                    name="VK_IMAGE_ASPECT_NONE"/>
            <type name="VkPhysicalDeviceMaintenance4Features"/>
            <type name="VkPhysicalDeviceMaintenance4Properties"/>
            <type name="VkDeviceBufferMemoryRequirements"/>
            <type name="VkDeviceImageMemoryRequirements"/>
            <command name="vkGetDeviceBufferMemoryRequirements"/>
            <command name="vkGetDeviceImageMemoryRequirements"/>
            <command name="vkGetDeviceImageSparseMemoryRequirements"/>
        </require>
    </feature>
    <feature api="vulkan,vulkansc,vulkanbase" apitype="internal" name="VK_COMPUTE_VERSION_1_3" number="1.3" depends="VK_COMPUTE_VERSION_1_2,VK_BASE_VERSION_1_3" comment="Vulkan compute 1.3 API interface definitions.">
        <require comment="Promoted from VK_EXT_pipeline_creation_feedback (extension 193)">
            <enum offset="0" extends="VkStructureType"  extnumber="193"         name="VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO"/>
            <type name="VkPipelineCreationFeedbackFlagBits"/>
            <type name="VkPipelineCreationFeedbackFlags"/>
            <type name="VkPipelineCreationFeedbackCreateInfo"/>
            <type name="VkPipelineCreationFeedback"/>
        </require>
        <require comment="Promoted from VK_KHR_shader_terminate_invocation (extension 216)">
            <enum offset="0" extends="VkStructureType"  extnumber="216"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES"/>
            <type name="VkPhysicalDeviceShaderTerminateInvocationFeatures"/>
        </require>
        <require comment="Promoted from VK_EXT_shader_demote_to_helper_invocation (extension 277)">
            <enum offset="0" extends="VkStructureType"  extnumber="277"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES"/>
            <type name="VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures"/>
        </require>
        <require comment="Promoted from VK_KHR_shader_non_semantic_info (extension 294)">
        </require>
        <require comment="Promoted from VK_EXT_pipeline_creation_cache_control (extension 298)">
            <enum offset="0" extends="VkStructureType"  extnumber="298"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES"/>
            <type name="VkPhysicalDevicePipelineCreationCacheControlFeatures"/>
            <enum bitpos="8" extends="VkPipelineCreateFlagBits"                 name="VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT"/>
            <enum bitpos="9" extends="VkPipelineCreateFlagBits"                 name="VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT"/>
            <enum offset="0" extends="VkResult"         extnumber="298"         name="VK_PIPELINE_COMPILE_REQUIRED"/>
            <enum bitpos="0" extends="VkPipelineCacheCreateFlagBits"            name="VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT"/>
            <type name="VkPipelineCacheCreateFlagBits"/>
        </require>
        <require comment="Promoted from VK_KHR_synchronization2 (extension 315)">
            <enum bitpos="0" extends="VkEventCreateFlagBits"                    name="VK_EVENT_CREATE_DEVICE_ONLY_BIT"/>
            <command name="vkCmdSetEvent2"/>
            <command name="vkCmdResetEvent2"/>
            <command name="vkCmdWaitEvents2"/>
        </require>
        <require comment="Promoted from VK_KHR_zero_initialize_workgroup_memory (extension 326)">
            <enum offset="0" extends="VkStructureType"  extnumber="326"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES"/>
            <type name="VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures"/>
        </require>
        <require comment="Promoted from VK_EXT_image_robustness (extension 336)">
            <enum offset="0" extends="VkStructureType"  extnumber="336"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES"/>
            <type name="VkPhysicalDeviceImageRobustnessFeatures"/>
        </require>
        <require comment="Promoted from VK_EXT_subgroup_size_control (STDPROMOTE/PROPLIMCHANGE) (extension 226)">
            <type name="VkPhysicalDeviceSubgroupSizeControlFeatures"/>
            <type name="VkPhysicalDeviceSubgroupSizeControlProperties"/>
            <type name="VkPipelineShaderStageRequiredSubgroupSizeCreateInfo"/>
            <enum offset="0" extends="VkStructureType"  extnumber="226"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES"/>
            <enum offset="1" extends="VkStructureType"  extnumber="226"         name="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO"/>
            <enum offset="2" extends="VkStructureType"  extnumber="226"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES"/>
            <enum bitpos="0" extends="VkPipelineShaderStageCreateFlagBits"      name="VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT"/>
            <enum bitpos="1" extends="VkPipelineShaderStageCreateFlagBits"      name="VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT"/>
        </require>
        <require comment="Promoted from VK_EXT_inline_uniform_block (STDPROMOTE/PROPLIMCHANGE) (extension 139)">
            <enum offset="0" extends="VkDescriptorType" extnumber="139"         name="VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK"/>
            <enum offset="0" extends="VkStructureType" extnumber="139"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES"/>
            <enum offset="1" extends="VkStructureType" extnumber="139"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES"/>
            <enum offset="2" extends="VkStructureType" extnumber="139"          name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK"/>
            <enum offset="3" extends="VkStructureType" extnumber="139"          name="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO"/>
            <type name="VkPhysicalDeviceInlineUniformBlockFeatures"/>
            <type name="VkPhysicalDeviceInlineUniformBlockProperties"/>
            <type name="VkWriteDescriptorSetInlineUniformBlock"/>
            <type name="VkDescriptorPoolInlineUniformBlockCreateInfo"/>
        </require>
        <require comment="Promoted from VK_KHR_shader_integer_dot_product (extension 281)">
            <enum offset="0" extends="VkStructureType" extnumber="281"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES"/>
            <enum offset="1" extends="VkStructureType" extnumber="281"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES"/>
            <type name="VkPhysicalDeviceShaderIntegerDotProductFeatures"/>
            <type name="VkPhysicalDeviceShaderIntegerDotProductProperties"/>
        </require>
        <require comment="Promoted from VK_EXT_texel_buffer_alignment (extension 282)">
            <enum offset="1" extends="VkStructureType" extnumber="282"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES"/>
            <type name="VkPhysicalDeviceTexelBufferAlignmentProperties"/>
        </require>
    </feature>
    <feature api="vulkan,vulkansc,vulkanbase" apitype="internal" name="VK_GRAPHICS_VERSION_1_3" number="1.3" depends="VK_GRAPHICS_VERSION_1_2,VK_COMPUTE_VERSION_1_3" comment="Vulkan graphics 1.3 API interface definitions.">
        <require comment="Promoted from VK_KHR_copy_commands2 (extension 338)">
            <enum offset="4" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2"/>
            <enum offset="5" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2"/>
            <enum offset="8" extends="VkStructureType"  extnumber="338"         name="VK_STRUCTURE_TYPE_IMAGE_BLIT_2"/>
            <enum offset="10" extends="VkStructureType" extnumber="338"         name="VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2"/>
            <type name="VkBlitImageInfo2"/>
            <type name="VkImageBlit2"/>
            <type name="VkResolveImageInfo2"/>
            <type name="VkImageResolve2"/>
            <command name="vkCmdBlitImage2"/>
            <command name="vkCmdResolveImage2"/>
        </require>
        <require comment="Promoted from VK_KHR_dynamic_rendering (extension 45)">
            <command name="vkCmdBeginRendering"/>
            <command name="vkCmdEndRendering"/>
            <enum offset="0" extends="VkStructureType" extnumber="45"           name="VK_STRUCTURE_TYPE_RENDERING_INFO"/>
            <enum offset="1" extends="VkStructureType" extnumber="45"           name="VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO"/>
            <enum offset="2" extends="VkStructureType" extnumber="45"           name="VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO"/>
            <enum offset="3" extends="VkStructureType" extnumber="45"           name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES"/>
            <enum offset="4" extends="VkStructureType" extnumber="45"           name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO"/>
            <enum offset="0" extends="VkAttachmentStoreOp" extnumber="302"      name="VK_ATTACHMENT_STORE_OP_NONE"/>
            <type name="VkRenderingInfo"/>
            <type name="VkRenderingAttachmentInfo"/>
            <type name="VkPipelineRenderingCreateInfo"/>
            <type name="VkPhysicalDeviceDynamicRenderingFeatures"/>
            <type name="VkCommandBufferInheritanceRenderingInfo"/>
            <type name="VkRenderingFlags"/>
            <type name="VkRenderingFlagBits"/>
        </require>
        <require comment="Promoted from VK_EXT_extended_dynamic_state (Feature struct is not promoted) (extension 268)">
            <enum offset="0" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_CULL_MODE"/>
            <enum offset="1" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_FRONT_FACE"/>
            <enum offset="2" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY"/>
            <enum offset="3" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT"/>
            <enum offset="4" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT"/>
            <enum offset="5" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE"/>
            <enum offset="6" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE"/>
            <enum offset="7" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE"/>
            <enum offset="8" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_DEPTH_COMPARE_OP"/>
            <enum offset="9" extends="VkDynamicState"  extnumber="268"          name="VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE"/>
            <enum offset="10" extends="VkDynamicState" extnumber="268"          name="VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE"/>
            <enum offset="11" extends="VkDynamicState" extnumber="268"          name="VK_DYNAMIC_STATE_STENCIL_OP"/>
            <command name="vkCmdSetCullMode"/>
            <command name="vkCmdSetFrontFace"/>
            <command name="vkCmdSetPrimitiveTopology"/>
            <command name="vkCmdSetViewportWithCount"/>
            <command name="vkCmdSetScissorWithCount"/>
            <command name="vkCmdBindVertexBuffers2"/>
            <command name="vkCmdSetDepthTestEnable"/>
            <command name="vkCmdSetDepthWriteEnable"/>
            <command name="vkCmdSetDepthCompareOp"/>
            <command name="vkCmdSetDepthBoundsTestEnable"/>
            <command name="vkCmdSetStencilTestEnable"/>
            <command name="vkCmdSetStencilOp"/>
        </require>
        <require comment="Promoted from VK_EXT_extended_dynamic_state2 (Feature struct and optional state are not promoted) (extension 378)">
            <enum offset="1" extends="VkDynamicState"  extnumber="378"          name="VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE"/>
            <enum offset="2" extends="VkDynamicState"  extnumber="378"          name="VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE"/>
            <enum offset="4" extends="VkDynamicState"  extnumber="378"          name="VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE"/>
            <command name="vkCmdSetRasterizerDiscardEnable"/>
            <command name="vkCmdSetDepthBiasEnable"/>
            <command name="vkCmdSetPrimitiveRestartEnable"/>
        </require>
    </feature>
    <feature api="vulkan,vulkansc,vulkanbase" name="VK_VERSION_1_3" number="1.3" depends="VK_VERSION_1_2,VK_GRAPHICS_VERSION_1_3" comment="Vulkan 1.3 core API interface definitions">
        <require comment="Feature requirements">
            <feature name="shaderTerminateInvocation" struct="VkPhysicalDeviceShaderTerminateInvocationFeatures"/>
            <feature name="shaderTerminateInvocation" struct="VkPhysicalDeviceVulkan13Features"/>
            <feature name="shaderDemoteToHelperInvocation" struct="VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures"/>
            <feature name="shaderDemoteToHelperInvocation" struct="VkPhysicalDeviceVulkan13Features"/>
            <feature name="privateData" struct="VkPhysicalDevicePrivateDataFeatures"/>
            <feature name="privateData" struct="VkPhysicalDeviceVulkan13Features"/>
            <feature name="pipelineCreationCacheControl" struct="VkPhysicalDevicePipelineCreationCacheControlFeatures"/>
            <feature name="pipelineCreationCacheControl" struct="VkPhysicalDeviceVulkan13Features"/>
            <feature name="synchronization2" struct="VkPhysicalDeviceSynchronization2Features"/>
            <feature name="synchronization2" struct="VkPhysicalDeviceVulkan13Features"/>
            <feature name="shaderZeroInitializeWorkgroupMemory" struct="VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures"/>
            <feature name="shaderZeroInitializeWorkgroupMemory" struct="VkPhysicalDeviceVulkan13Features"/>
            <feature name="robustImageAccess" struct="VkPhysicalDeviceImageRobustnessFeatures"/>
            <feature name="robustImageAccess" struct="VkPhysicalDeviceVulkan13Features"/>
            <feature name="subgroupSizeControl" struct="VkPhysicalDeviceSubgroupSizeControlFeatures"/>
            <feature name="computeFullSubgroups" struct="VkPhysicalDeviceSubgroupSizeControlFeatures"/>
            <feature name="subgroupSizeControl" struct="VkPhysicalDeviceVulkan13Features"/>
            <feature name="computeFullSubgroups" struct="VkPhysicalDeviceVulkan13Features"/>
            <feature name="dynamicRendering" struct="VkPhysicalDeviceDynamicRenderingFeatures"/>
            <feature name="dynamicRendering" struct="VkPhysicalDeviceVulkan13Features"/>
            <feature name="shaderIntegerDotProduct" struct="VkPhysicalDeviceShaderIntegerDotProductFeatures"/>
            <feature name="shaderIntegerDotProduct" struct="VkPhysicalDeviceVulkan13Features"/>
            <feature name="maintenance4" struct="VkPhysicalDeviceMaintenance4Features"/>
            <feature name="maintenance4" struct="VkPhysicalDeviceVulkan13Features"/>
            <feature name="vulkanMemoryModel" struct="VkPhysicalDeviceVulkanMemoryModelFeatures"/>
            <feature name="vulkanMemoryModelDeviceScope" struct="VkPhysicalDeviceVulkanMemoryModelFeatures"/>
            <feature name="inlineUniformBlock" struct="VkPhysicalDeviceInlineUniformBlockFeatures"/>
            <feature name="bufferDeviceAddress" struct="VkPhysicalDeviceBufferDeviceAddressFeatures"/>
            <feature name="vulkanMemoryModel" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="vulkanMemoryModelDeviceScope" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="inlineUniformBlock" struct="VkPhysicalDeviceVulkan13Features"/>
            <feature name="bufferDeviceAddress" struct="VkPhysicalDeviceVulkan12Features"/>
        </require>
        <require depends="VK_EXT_descriptor_indexing,VkPhysicalDeviceVulkan12Features::descriptorIndexing">
            <feature name="descriptorBindingInlineUniformBlockUpdateAfterBind" struct="VkPhysicalDeviceInlineUniformBlockFeatures"/>
            <feature name="descriptorBindingInlineUniformBlockUpdateAfterBind" struct="VkPhysicalDeviceVulkan13Features"/>
        </require>
    </feature>
    <feature api="vulkan,vulkansc,vulkanbase" apitype="internal" name="VK_BASE_VERSION_1_4" number="1.4" depends="VK_BASE_VERSION_1_3" comment="Vulkan base 1.4 API interface definitions.">
        <require comment="API version macros">
            <type name="VK_API_VERSION_1_4"/>
        </require>
        <require>
            <enum extends="VkStructureType" value="55"                          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES"/>
            <enum extends="VkStructureType" value="56"                          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES"/>
            <type name="VkPhysicalDeviceVulkan14Features"/>
            <type name="VkPhysicalDeviceVulkan14Properties"/>
        </require>
        <require comment="Promoted from VK_KHR_global_priority (extension 189)">
            <enum offset="0" extends="VkStructureType" extnumber="175"      name="VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO"/>
            <enum offset="0" extends="VkStructureType" extnumber="389"      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES"/>
            <enum offset="1" extends="VkStructureType" extnumber="389"      name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES"/>
            <enum extends="VkResult" extnumber="175" offset="1" dir="-"     name="VK_ERROR_NOT_PERMITTED"/>
            <enum                                                           name="VK_MAX_GLOBAL_PRIORITY_SIZE"/>
            <type name="VkDeviceQueueGlobalPriorityCreateInfo"/>
            <type name="VkQueueGlobalPriority"/>
            <type name="VkPhysicalDeviceGlobalPriorityQueryFeatures"/>
            <type name="VkQueueFamilyGlobalPriorityProperties"/>
        </require>
        <require comment="Promoted from VK_KHR_index_type_uint8 (extension 534) 'Roadmap 2024'">
            <enum offset="0"  extends="VkStructureType" extnumber="266"     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES"/>
            <enum offset="0"  extends="VkIndexType" extnumber="266"         name="VK_INDEX_TYPE_UINT8"/>
            <type name="VkPhysicalDeviceIndexTypeUint8Features"/>
        </require>
        <require comment="Promoted from VK_KHR_map_memory2 (extension 272) 'Roadmap 2024'">
            <enum offset="0"  extends="VkStructureType" extnumber="272"     name="VK_STRUCTURE_TYPE_MEMORY_MAP_INFO"/>
            <enum offset="1"  extends="VkStructureType" extnumber="272"     name="VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO"/>
            <type name="VkMemoryMapInfo"/>
            <type name="VkMemoryUnmapInfo"/>
            <type name="VkMemoryUnmapFlagBits"/>
            <type name="VkMemoryUnmapFlags"/>
            <command name="vkMapMemory2"/>
            <command name="vkUnmapMemory2"/>
        </require>
        <require comment="Promoted from VK_KHR_maintenance5 (extension 471) 'Roadmap 2024'">
            <enum offset="0"  extends="VkStructureType" extnumber="471"     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES"/>
            <enum offset="1"  extends="VkStructureType" extnumber="471"     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES"/>
            <enum offset="4"  extends="VkStructureType" extnumber="471"     name="VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO"/>
            <type name="VkPhysicalDeviceMaintenance5Features"/>
            <type name="VkPhysicalDeviceMaintenance5Properties"/>
            <enum offset="0"  extends="VkFormat" extnumber="471"            name="VK_FORMAT_A1B5G5R5_UNORM_PACK16"/>
            <enum offset="1"  extends="VkFormat" extnumber="471"            name="VK_FORMAT_A8_UNORM"/>
            <command name="vkGetDeviceImageSubresourceLayout"/>
            <command name="vkGetImageSubresourceLayout2"/>
            <type name="VkDeviceImageSubresourceInfo"/>
            <type name="VkImageSubresource2"/>
            <type name="VkSubresourceLayout2"/>
            <enum offset="2"  extends="VkStructureType" extnumber="339"     name="VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2"/>
            <enum offset="3"  extends="VkStructureType" extnumber="339"     name="VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2"/>
            <type name="VkBufferUsageFlags2"/>
            <type name="VkBufferUsageFlagBits2"/>
            <type name="VkBufferUsageFlags2CreateInfo"/>
            <enum offset="6"  extends="VkStructureType" extnumber="471"     name="VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO"/>
            <enum bitpos="17" extends="VkBufferUsageFlagBits2"              name="VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT"/>
        </require>
        <require comment="Promoted from VK_KHR_maintenance6 (extension 546) 'additional functionality'">
            <enum offset="0"  extends="VkStructureType" extnumber="546"     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES"/>
            <enum offset="1"  extends="VkStructureType" extnumber="546"     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES"/>
            <enum offset="2"  extends="VkStructureType" extnumber="546"     name="VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS"/>
            <type name="VkPhysicalDeviceMaintenance6Features"/>
            <type name="VkPhysicalDeviceMaintenance6Properties"/>
            <type name="VkBindMemoryStatus"/>
        </require>
        <require comment="Promoted (as optional feature) from VK_EXT_host_image_copy (extension 271) 'streaming transfers'">
            <enum offset="0"  extends="VkStructureType" extnumber="271"     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES"/>
            <enum offset="1"  extends="VkStructureType" extnumber="271"     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES"/>
            <enum offset="2"  extends="VkStructureType" extnumber="271"     name="VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY"/>
            <enum offset="3"  extends="VkStructureType" extnumber="271"     name="VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY"/>
            <enum offset="4"  extends="VkStructureType" extnumber="271"     name="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO"/>
            <enum offset="5"  extends="VkStructureType" extnumber="271"     name="VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO"/>
            <enum offset="6"  extends="VkStructureType" extnumber="271"     name="VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO"/>
            <enum offset="7"  extends="VkStructureType" extnumber="271"     name="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO"/>
            <enum offset="8"  extends="VkStructureType" extnumber="271"     name="VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE"/>
            <enum offset="9"  extends="VkStructureType" extnumber="271"     name="VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY"/>
            <enum bitpos="22" extends="VkImageUsageFlagBits"                name="VK_IMAGE_USAGE_HOST_TRANSFER_BIT"/>
            <enum bitpos="46" extends="VkFormatFeatureFlagBits2"            name="VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT"/>
            <type name="VkPhysicalDeviceHostImageCopyFeatures"/>
            <type name="VkPhysicalDeviceHostImageCopyProperties"/>
            <type name="VkHostImageCopyFlagBits"/>
            <type name="VkHostImageCopyFlags"/>
            <type name="VkMemoryToImageCopy"/>
            <type name="VkImageToMemoryCopy"/>
            <type name="VkCopyMemoryToImageInfo"/>
            <type name="VkCopyImageToMemoryInfo"/>
            <type name="VkCopyImageToImageInfo"/>
            <type name="VkHostImageLayoutTransitionInfo"/>
            <type name="VkSubresourceHostMemcpySize"/>
            <type name="VkHostImageCopyDevicePerformanceQuery"/>
            <command name="vkCopyMemoryToImage"/>
            <command name="vkCopyImageToMemory"/>
            <command name="vkCopyImageToImage"/>
            <command name="vkTransitionImageLayout"/>
            <!-- type name="VkSubresourceLayout2"               comment="Also promoted from KHR in VK_KHR_maintenance5"/ !-->
            <!-- type name="VkImageSubresource2"                comment="Also promoted from KHR in VK_KHR_maintenance5"/ !-->
            <!-- command name="vkGetImageSubresourceLayout2"    comment="Also promoted from KHR in VK_KHR_maintenance5"/ !-->
        </require>
    </feature>
    <feature api="vulkan,vulkansc,vulkanbase" apitype="internal" name="VK_COMPUTE_VERSION_1_4" number="1.4" depends="VK_COMPUTE_VERSION_1_3,VK_BASE_VERSION_1_4" comment="Vulkan compute 1.4 API interface definitions.">
        <require comment="Promoted from VK_KHR_shader_subgroup_rotate (extension 417) 'Roadmap 2024'">
            <enum offset="0"  extends="VkStructureType" extnumber="417"     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES"/>
            <enum bitpos="9"  extends="VkSubgroupFeatureFlagBits"           name="VK_SUBGROUP_FEATURE_ROTATE_BIT"/>
            <enum bitpos="10" extends="VkSubgroupFeatureFlagBits"           name="VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT"/>
            <type name="VkPhysicalDeviceShaderSubgroupRotateFeatures"/>
        </require>
        <require comment="Promoted from VK_KHR_shader_float_controls2 (extension 529) 'Roadmap 2024'">
            <enum offset="0"  extends="VkStructureType" extnumber="529"     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES"/>
            <type name="VkPhysicalDeviceShaderFloatControls2Features"/>
        </require>
        <require comment="Promoted from VK_KHR_shader_expect_assume (extension 545) 'Roadmap 2024'">
            <enum offset="0"  extends="VkStructureType" extnumber="545"     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES"/>
            <type name="VkPhysicalDeviceShaderExpectAssumeFeatures"/>
        </require>
        <require comment="Promoted from VK_KHR_maintenance5 (extension 471) 'Roadmap 2024'">
            <type name="VkPipelineCreateFlags2"/>
            <type name="VkPipelineCreateFlagBits2"/>
            <type name="VkPipelineCreateFlags2CreateInfo"/>
            <enum offset="5"  extends="VkStructureType" extnumber="471"     name="VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO"/>
            <!-- enum bitpos="4"    name="VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT"                       comment="Included in base enum"/ !-->
            <!-- enum bitpos="8"    name="VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT"   comment="Included in base enum"/ !-->
            <!-- enum bitpos="9"    name="VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT"             comment="Included in base enum"/ !-->
        </require>
        <require comment="Promoted as an interaction between VK_KHR_maintenance5 (extension 471) 'Roadmap 2024' and VK_EXT_pipeline_protected_access (extension 467) 'additional functionality'">
            <!-- enum bitpos="27"   name="VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT"                 comment="Included in base enum"/ !-->
            <!-- enum bitpos="30"   name="VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT"               comment="Included in base enum"/ !-->
        </require>
        <require comment="Promoted from VK_KHR_push_descriptor (extension 81) 'Roadmap 2024'">
            <enum offset="0"  extends="VkStructureType" extnumber="81"      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES"/>
            <enum bitpos="0"  extends="VkDescriptorSetLayoutCreateFlagBits" name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT"/>
            <command name="vkCmdPushDescriptorSet"/>
            <type name="VkPhysicalDevicePushDescriptorProperties"/>
            <command name="vkCmdPushDescriptorSetWithTemplate"/>
            <enum value="1"   extends="VkDescriptorUpdateTemplateType"      name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS"/>
        </require>
        <require comment="Promoted from VK_KHR_maintenance6 (extension 546) 'additional functionality'">
            <enum offset="3"  extends="VkStructureType" extnumber="546"     name="VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO"/>
            <enum offset="4"  extends="VkStructureType" extnumber="546"     name="VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO"/>
            <type name="VkBindDescriptorSetsInfo"/>
            <type name="VkPushConstantsInfo"/>
            <command name="vkCmdBindDescriptorSets2"/>
            <command name="vkCmdPushConstants2"/>
            <enum offset="5"  extends="VkStructureType" extnumber="546"     name="VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO"/>
            <enum offset="6"  extends="VkStructureType" extnumber="546"     name="VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO"/>
            <type name="VkPushDescriptorSetInfo"/>
            <type name="VkPushDescriptorSetWithTemplateInfo"/>
            <command name="vkCmdPushDescriptorSet2"/>
            <command name="vkCmdPushDescriptorSetWithTemplate2"/>
        </require>
        <require comment="Promoted from VK_EXT_pipeline_protected_access (extension 467) 'additional functionality'">
            <enum offset="0"  extends="VkStructureType" extnumber="467"     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES"/>
            <enum bitpos="27" extends="VkPipelineCreateFlagBits"            name="VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT"/>
            <enum bitpos="30" extends="VkPipelineCreateFlagBits"            name="VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT"/>
            <type name="VkPhysicalDevicePipelineProtectedAccessFeatures"/>
        </require>
        <require comment="Promoted from VK_EXT_pipeline_robustness (extension 69) 'additional functionality'">
            <enum offset="0"  extends="VkStructureType" extnumber="69"      name="VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO"/>
            <enum offset="1"  extends="VkStructureType" extnumber="69"      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES"/>
            <enum offset="2"  extends="VkStructureType" extnumber="69"      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES"/>
            <type name="VkPhysicalDevicePipelineRobustnessFeatures"/>
            <type name="VkPhysicalDevicePipelineRobustnessProperties"/>
            <type name="VkPipelineRobustnessCreateInfo"/>
            <type name="VkPipelineRobustnessBufferBehavior"/>
            <type name="VkPipelineRobustnessImageBehavior"/>
        </require>
    </feature>
    <feature api="vulkan,vulkansc,vulkanbase" apitype="internal" name="VK_GRAPHICS_VERSION_1_4" number="1.4" depends="VK_GRAPHICS_VERSION_1_3,VK_COMPUTE_VERSION_1_4" comment="Vulkan graphics 1.4 API interface definitions.">
        <require comment="Promoted from VK_KHR_load_store_op_none (extension 527) 'Roadmap 2024' (VK_ATTACHMENT_STORE_OP_NONE is defined in Vulkan 1.3)">
            <enum offset="0"  extends="VkAttachmentLoadOp" extnumber="401"  name="VK_ATTACHMENT_LOAD_OP_NONE"/>
        </require>
        <require comment="Promoted from VK_KHR_line_rasterization (extension 535) 'Roadmap 2024'">
            <enum offset="0"  extends="VkStructureType" extnumber="260"     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES"/>
            <enum offset="1"  extends="VkStructureType" extnumber="260"     name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO"/>
            <enum offset="2"  extends="VkStructureType" extnumber="260"     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES"/>
            <enum offset="0"  extends="VkDynamicState"  extnumber="260"     name="VK_DYNAMIC_STATE_LINE_STIPPLE"/>
            <type name="VkPhysicalDeviceLineRasterizationFeatures"/>
            <type name="VkPhysicalDeviceLineRasterizationProperties"/>
            <type name="VkPipelineRasterizationLineStateCreateInfo"/>
            <type name="VkLineRasterizationMode"/>
            <command name="vkCmdSetLineStipple"/>
        </require>
        <require comment="Promoted from VK_KHR_vertex_attribute_divisor (extension 526) 'Roadmap 2024'">
            <enum offset="0"  extends="VkStructureType" extnumber="526"     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES"/>
            <enum offset="1"  extends="VkStructureType" extnumber="191"     name="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO"/>
            <enum offset="2"  extends="VkStructureType" extnumber="191"     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES"/>
            <type name="VkPhysicalDeviceVertexAttributeDivisorProperties"/>
            <type name="VkVertexInputBindingDivisorDescription"/>
            <type name="VkPipelineVertexInputDivisorStateCreateInfo"/>
            <type name="VkPhysicalDeviceVertexAttributeDivisorFeatures"/>
        </require>
        <require comment="Promoted from VK_KHR_maintenance5 (extension 471) 'Roadmap 2024'">
            <enum offset="3"  extends="VkStructureType" extnumber="471"     name="VK_STRUCTURE_TYPE_RENDERING_AREA_INFO"/>
            <command name="vkCmdBindIndexBuffer2"/>
            <command name="vkGetRenderingAreaGranularity"/>
            <type name="VkRenderingAreaInfo"/>
            <!-- enum bitpos="3"    name="VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT"        comment="Included in base enum"/ !-->
        </require>
        <require comment="Promoted from VK_KHR_dynamic_rendering_local_read (extension 233) 'Roadmap 2024'">
            <enum offset="0" extends="VkImageLayout" extnumber="233"        name="VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ"/>
            <command name="vkCmdSetRenderingAttachmentLocations"/>
            <command name="vkCmdSetRenderingInputAttachmentIndices"/>
            <type name="VkPhysicalDeviceDynamicRenderingLocalReadFeatures"/>
            <type name="VkRenderingAttachmentLocationInfo"/>
            <type name="VkRenderingInputAttachmentIndexInfo"/>
            <enum offset="0" extends="VkStructureType" extnumber="233"      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES"/>
            <enum offset="1" extends="VkStructureType" extnumber="233"      name="VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO"/>
            <enum offset="2" extends="VkStructureType" extnumber="233"      name="VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO"/>
        </require>
        <deprecate explanationlink="legacy-dynamicrendering">
            <type name="VkRenderPass"/>
            <type name="VkRenderPassFragmentDensityMapCreateInfoEXT"/>
            <command name="vkCreateRenderPass2"/>
            <type name="VkRenderPassCreateInfo2"/>
            <type name="VkRenderPassCreationControlEXT"/>
            <type name="VkRenderPassCreationFeedbackCreateInfoEXT"/>
            <type name="VkRenderPassCreationFeedbackInfoEXT"/>
            <type name="VkAttachmentDescription2"/>
            <type name="VkAttachmentDescriptionStencilLayout"/>
            <type name="VkSubpassDescription2"/>
            <type name="VkFragmentShadingRateAttachmentInfoKHR"/>
            <type name="VkRenderPassSubpassFeedbackCreateInfoEXT"/>
            <type name="VkRenderPassSubpassFeedbackInfoEXT"/>
            <type name="VkSubpassDescriptionDepthStencilResolve"/>
            <type name="VkAttachmentReference2"/>
            <type name="VkSubpassDependency2"/>
            <command name="vkDestroyRenderPass"/>
            <type name="VkFramebuffer"/>
            <command name="vkCreateFramebuffer"/>
            <type name="VkFramebufferCreateInfo"/>
            <type name="VkFramebufferCreateFlagBits"/>
            <type name="VkFramebufferCreateFlags"/>
            <type name="VkFramebufferAttachmentsCreateInfo"/>
            <type name="VkFramebufferAttachmentImageInfo"/>
            <command name="vkDestroyFramebuffer"/>
            <command name="vkGetRenderAreaGranularity"/>
            <type name="VkRenderPassBeginInfo"/>
            <type name="VkRenderPassAttachmentBeginInfo"/>
            <type name="VkRenderPassSampleLocationsBeginInfoEXT"/>
            <type name="VkAttachmentSampleLocationsEXT"/>
            <type name="VkSubpassSampleLocationsEXT"/>
            <type name="VkSubpassContents"/>
            <command name="vkCmdBeginRenderPass2"/>
            <command name="vkCmdNextSubpass2"/>
            <type name="VkSubpassBeginInfo"/>
            <type name="VkSubpassEndInfo"/>
            <command name="vkCmdEndRenderPass2"/>
        </deprecate>
    </feature>
    <feature api="vulkan,vulkansc,vulkanbase" name="VK_VERSION_1_4" number="1.4" depends="VK_VERSION_1_3,VK_GRAPHICS_VERSION_1_4" comment="Vulkan 1.4 core API interface definitions">
        <require comment="Feature requirements">
            <feature name="fullDrawIndexUint32" struct="VkPhysicalDeviceFeatures"/>
            <feature name="imageCubeArray" struct="VkPhysicalDeviceFeatures"/>
            <feature name="independentBlend" struct="VkPhysicalDeviceFeatures"/>
            <feature name="sampleRateShading" struct="VkPhysicalDeviceFeatures"/>
            <feature name="drawIndirectFirstInstance" struct="VkPhysicalDeviceFeatures"/>
            <feature name="depthClamp" struct="VkPhysicalDeviceFeatures"/>
            <feature name="depthBiasClamp" struct="VkPhysicalDeviceFeatures"/>
            <feature name="samplerAnisotropy" struct="VkPhysicalDeviceFeatures"/>
            <feature name="fragmentStoresAndAtomics" struct="VkPhysicalDeviceFeatures"/>
            <feature name="shaderStorageImageExtendedFormats" struct="VkPhysicalDeviceFeatures"/>
            <feature name="shaderUniformBufferArrayDynamicIndexing" struct="VkPhysicalDeviceFeatures"/>
            <feature name="shaderSampledImageArrayDynamicIndexing" struct="VkPhysicalDeviceFeatures"/>
            <feature name="shaderStorageBufferArrayDynamicIndexing" struct="VkPhysicalDeviceFeatures"/>
            <feature name="shaderStorageImageArrayDynamicIndexing" struct="VkPhysicalDeviceFeatures"/>
            <feature name="shaderImageGatherExtended" struct="VkPhysicalDeviceFeatures"/>
            <feature name="shaderInt16" struct="VkPhysicalDeviceFeatures"/>
            <feature name="largePoints" struct="VkPhysicalDeviceFeatures"/>
            <feature name="samplerYcbcrConversion" struct="VkPhysicalDeviceVulkan11Features"/>
            <feature name="storageBuffer16BitAccess" struct="VkPhysicalDeviceVulkan11Features"/>
            <feature name="variablePointers" struct="VkPhysicalDeviceVulkan11Features"/>
            <feature name="variablePointersStorageBuffer" struct="VkPhysicalDeviceVulkan11Features"/>
            <feature name="samplerMirrorClampToEdge" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="scalarBlockLayout" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="shaderUniformTexelBufferArrayDynamicIndexing" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="shaderStorageTexelBufferArrayDynamicIndexing" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="shaderInt8" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="storageBuffer8BitAccess" struct="VkPhysicalDeviceVulkan12Features"/>
            <feature name="globalPriorityQuery" struct="VkPhysicalDeviceGlobalPriorityQueryFeatures"/>
            <feature name="shaderSubgroupRotate" struct="VkPhysicalDeviceShaderSubgroupRotateFeatures"/>
            <feature name="shaderSubgroupRotateClustered" struct="VkPhysicalDeviceShaderSubgroupRotateFeatures"/>
            <feature name="shaderFloatControls2" struct="VkPhysicalDeviceShaderFloatControls2Features"/>
            <feature name="shaderExpectAssume" struct="VkPhysicalDeviceShaderExpectAssumeFeatures"/>
            <feature name="bresenhamLines" struct="VkPhysicalDeviceLineRasterizationFeatures"/>
            <feature name="vertexAttributeInstanceRateDivisor" struct="VkPhysicalDeviceVertexAttributeDivisorFeatures"/>
            <feature name="indexTypeUint8" struct="VkPhysicalDeviceIndexTypeUint8Features"/>
            <feature name="maintenance5" struct="VkPhysicalDeviceMaintenance5Features"/>
            <feature name="pushDescriptor" struct="VkPhysicalDeviceVulkan14Features"/>
            <feature name="dynamicRenderingLocalRead" struct="VkPhysicalDeviceDynamicRenderingLocalReadFeatures"/>
            <feature name="maintenance6" struct="VkPhysicalDeviceMaintenance6Features"/>
            <feature name="pipelineRobustness" struct="VkPhysicalDevicePipelineRobustnessFeatures"/>
        </require>
        <require depends="VkPhysicalDeviceProtectedMemoryFeatures::protectedMemory">
            <feature name="pipelineProtectedAccess" struct="VkPhysicalDevicePipelineProtectedAccessFeatures"/>
            <feature name="pipelineProtectedAccess" struct="VkPhysicalDeviceVulkan14Features"/>
        </require>
    </feature>
    <feature api="vulkansc" name="VKSC_VERSION_1_0" number="1.0" depends="VK_VERSION_1_2" comment="Vulkan SC core API interface definitions">
        <require>
            <type name="VKSC_API_VARIANT"/>
            <type name="VKSC_API_VERSION_1_0"/>
            <type name="VkPhysicalDeviceVulkanSC10Features"/>
            <type name="VkPhysicalDeviceVulkanSC10Properties"/>
            <enum offset="0" extnumber="299" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES"/>
            <enum offset="1" extnumber="299" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_PROPERTIES"/>
        </require>
        <require comment="static memory functionality">
            <type name="VkDeviceObjectReservationCreateInfo"/>
            <type name="VkCommandPoolMemoryReservationCreateInfo"/>
            <type name="VkCommandPoolMemoryConsumption"/>
            <type name="VkPipelinePoolSize"/>
            <command name="vkGetCommandPoolMemoryConsumption"/>
            <enum offset="2" extnumber="299" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_DEVICE_OBJECT_RESERVATION_CREATE_INFO"/>
            <enum offset="3" extnumber="299" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_RESERVATION_CREATE_INFO"/>
            <enum offset="4" extnumber="299" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_COMMAND_POOL_MEMORY_CONSUMPTION"/>
            <enum offset="5" extnumber="299" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PIPELINE_POOL_SIZE"/>
        </require>
        <require comment="fault handling functionality">
            <enum offset="7" extnumber="299" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_FAULT_DATA"/>
            <enum offset="8" extnumber="299" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_FAULT_CALLBACK_INFO"/>
            <type name="VkFaultData"/>
            <type name="VkFaultCallbackInfo"/>
            <type name="VkFaultLevel"/>
            <type name="VkFaultType"/>
            <type name="VkFaultQueryBehavior"/>
            <type name="PFN_vkFaultCallbackFunction"/>
            <command name="vkGetFaultData"/>
        </require>
        <require comment="pipeline offline create info">
            <enum offset="10" extnumber="299" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PIPELINE_OFFLINE_CREATE_INFO"/>
            <type name="VkPipelineOfflineCreateInfo"/>
            <type name="VkPipelineMatchControl"/>
        </require>
        <require comment="pipeline cache functionality">
            <enum offset="0" extnumber="299" extends="VkResult" dir="-" name="VK_ERROR_INVALID_PIPELINE_CACHE_DATA"/>
            <enum offset="1" extnumber="299" extends="VkResult" dir="-" name="VK_ERROR_NO_PIPELINE_MATCH"/>
            <enum bitpos="1" extends="VkPipelineCacheCreateFlagBits"    name="VK_PIPELINE_CACHE_CREATE_READ_ONLY_BIT"/>
            <enum bitpos="2" extends="VkPipelineCacheCreateFlagBits"    name="VK_PIPELINE_CACHE_CREATE_USE_APPLICATION_STORAGE_BIT"/>
            <type name="VkPipelineCacheCreateFlagBits"/>
        </require>
        <require comment="seu safe memory functionality">
            <enum bitpos="2" extends="VkMemoryHeapFlagBits"             name="VK_MEMORY_HEAP_SEU_SAFE_BIT"/>
        </require>
        <require comment="pipeline cache header - These types are part of the API, though not all directly used in API commands or data structures">
            <enum offset="1" extnumber="299" extends="VkPipelineCacheHeaderVersion"    name="VK_PIPELINE_CACHE_HEADER_VERSION_SAFETY_CRITICAL_ONE"/>
            <type name="VkPipelineCacheValidationVersion"/>
            <type name="VkPipelineCacheStageValidationIndexEntry"/>
            <type name="VkPipelineCacheSafetyCriticalIndexEntry"/>
            <type name="VkPipelineCacheHeaderVersionSafetyCriticalOne"/>
        </require>
        <require depends="VK_VERSION_1_2">
            <feature name="vulkanMemoryModel" struct="VkPhysicalDeviceVulkanMemoryModelFeatures"/>
            <feature name="vulkanMemoryModel" struct="VkPhysicalDeviceVulkan12Features"/>
        </require>
        <remove comment="SC 1.0 removes some features from Vulkan 1.0/1.1/1.2">
            <enum name="VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"/>
            <!--enum name="VK_OBJECT_TYPE_SHADER_MODULE" comment="leave this present for compatibility"/-->
            <enum name="VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT"/>
            <enum name="VK_PIPELINE_CREATE_DERIVATIVE_BIT"/>
            <enum name="VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT"/>
            <!-- Remove Vulkan and deprecated macros -->
            <type name="VK_API_VERSION"/>
            <type name="VK_MAKE_VERSION"/>
            <type name="VK_VERSION_MAJOR"/>
            <type name="VK_VERSION_MINOR"/>
            <type name="VK_VERSION_PATCH"/>
            <!--type name="VkShaderModule" comment="leave this present for compatibility"/-->
            <type name="VkShaderModuleCreateFlags"/>
            <type name="VkShaderModuleCreateFlagBits"/>
            <type name="VkShaderModuleCreateInfo"/>
            <type name="VkCommandPoolTrimFlags"/>
            <command name="vkCreateShaderModule"/>
            <command name="vkDestroyShaderModule"/>
            <command name="vkMergePipelineCaches"/>
            <command name="vkGetPipelineCacheData"/>
            <command name="vkTrimCommandPool"/>
            <command name="vkDestroyCommandPool"/>
            <command name="vkDestroyDescriptorPool"/>
            <command name="vkDestroyQueryPool"/>
            <command name="vkDestroySwapchainKHR"/>
            <command name="vkFreeMemory"/>
            <!-- Descriptor update templates are unsupported -->
            <enum name="VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"/>
            <enum name="VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE"/>
            <command name="vkCreateDescriptorUpdateTemplate"/>
            <command name="vkDestroyDescriptorUpdateTemplate"/>
            <command name="vkUpdateDescriptorSetWithTemplate"/>
            <type name="VkDescriptorUpdateTemplate"/>
            <type name="VkDescriptorUpdateTemplateCreateFlags"/>
            <type name="VkDescriptorUpdateTemplateType"/>
            <type name="VkDescriptorUpdateTemplateEntry"/>
            <type name="VkDescriptorUpdateTemplateCreateInfo"/>
            <enum name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET"/>
            <enum name="VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO"/>
            <type name="VkPushDescriptorSetWithTemplateInfo"/>
            <command name="vkCmdPushDescriptorSetWithTemplate"/>
            <command name="vkCmdPushDescriptorSetWithTemplate2"/>
            <!-- Sparse resources are unsupported -->
            <enum name="VK_QUEUE_SPARSE_BINDING_BIT"/>
            <!--type name="VkPhysicalDeviceSparseProperties" comment="needed for VkPhysicalDeviceProperties"/-->
            <type name="VkSparseImageFormatProperties"/>
            <type name="VkSparseImageFormatFlagBits"/>
            <type name="VkSparseImageFormatFlags"/>
            <command name="vkGetPhysicalDeviceSparseImageFormatProperties"/>
            <command name="vkGetPhysicalDeviceSparseImageFormatProperties2"/>
            <type name="VkPhysicalDeviceSparseImageFormatInfo2"/>
            <enum name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2"/>
            <type name="VkSparseImageFormatProperties2"/>
            <enum name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2"/>
            <type name="VkSparseImageMemoryRequirements"/>
            <command name="vkGetImageSparseMemoryRequirements"/>
            <command name="vkGetImageSparseMemoryRequirements2"/>
            <type name="VkImageSparseMemoryRequirementsInfo2"/>
            <enum name="VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2"/>
            <type name="VkSparseImageMemoryRequirements2"/>
            <enum name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2"/>
            <type name="VkSparseMemoryBind"/>
            <type name="VkSparseMemoryBindFlagBits"/>
            <type name="VkSparseMemoryBindFlags"/>
            <type name="VkSparseBufferMemoryBindInfo"/>
            <type name="VkSparseImageOpaqueMemoryBindInfo"/>
            <type name="VkSparseImageMemoryBindInfo"/>
            <type name="VkSparseImageMemoryBind"/>
            <command name="vkQueueBindSparse"/>
            <type name="VkBindSparseInfo"/>
            <enum name="VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"/>
            <type name="VkDeviceGroupBindSparseInfo"/>
            <enum name="VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO"/>
            <command name="vkDestroySemaphoreSciSyncPoolNV"/>
        </remove>
        <remove reasonlink="SCID-8">
            <feature name="multiview" struct="VkPhysicalDeviceMultiviewFeatures"/>
            <feature name="multiview" struct="VkPhysicalDeviceVulkan11Features"/>
            <feature name="timelineSemaphore" struct="VkPhysicalDeviceTimelineSemaphoreFeatures"/>
            <feature name="timelineSemaphore" struct="VkPhysicalDeviceVulkan12Features"/>
        </remove>
    </feature>
    <extensions comment="Vulkan extension interface definitions">
        <extension name="VK_KHR_surface" number="1" type="instance" author="KHR" contact="James Jones @cubanismo,Ian Elliott @ianelliottus" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="25"                                                name="VK_KHR_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_surface&quot;"                        name="VK_KHR_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkResult" dir="-"                     name="VK_ERROR_SURFACE_LOST_KHR"/>
                <enum offset="1" extends="VkResult" dir="-"                     name="VK_ERROR_NATIVE_WINDOW_IN_USE_KHR"/>
                <enum offset="0" extends="VkObjectType"                         name="VK_OBJECT_TYPE_SURFACE_KHR"/>
                <type name="VkSurfaceKHR"/>
                <type name="VkSurfaceTransformFlagBitsKHR"/>
                <type name="VkPresentModeKHR"/>
                <type name="VkColorSpaceKHR"/>
                <type name="VkCompositeAlphaFlagBitsKHR"/>
                <type name="VkCompositeAlphaFlagsKHR"/>
                <type name="VkSurfaceCapabilitiesKHR"/>
                <type name="VkSurfaceFormatKHR"/>
                <command name="vkDestroySurfaceKHR"/>
                <command name="vkGetPhysicalDeviceSurfaceSupportKHR"/>
                <command name="vkGetPhysicalDeviceSurfaceCapabilitiesKHR"/>
                <command name="vkGetPhysicalDeviceSurfaceFormatsKHR"/>
                <command name="vkGetPhysicalDeviceSurfacePresentModesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_swapchain" number="2" type="device" depends="VK_KHR_surface" author="KHR" contact="James Jones @cubanismo,Ian Elliott @ianelliottus" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="70"                                                name="VK_KHR_SWAPCHAIN_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_swapchain&quot;"                      name="VK_KHR_SWAPCHAIN_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"/>
                <enum offset="2" extends="VkImageLayout"                        name="VK_IMAGE_LAYOUT_PRESENT_SRC_KHR"/>
                <enum offset="3" extends="VkResult"                             name="VK_SUBOPTIMAL_KHR"/>
                <enum offset="4" extends="VkResult" dir="-"                     name="VK_ERROR_OUT_OF_DATE_KHR"/>
                <enum offset="0" extends="VkObjectType"                         name="VK_OBJECT_TYPE_SWAPCHAIN_KHR"/>
                <type name="VkSwapchainCreateFlagBitsKHR"/>
                <type name="VkSwapchainCreateFlagsKHR"/>
                <type name="VkSwapchainCreateInfoKHR"/>
                <type name="VkSwapchainKHR"/>
                <type name="VkPresentInfoKHR"/>
                <command name="vkCreateSwapchainKHR"/>
                <command name="vkDestroySwapchainKHR"/>
                <command name="vkGetSwapchainImagesKHR"/>
                <command name="vkAcquireNextImageKHR"/>
                <command name="vkQueuePresentKHR"/>
            </require>
            <require depends="VK_VERSION_1_1">
                <comment>This duplicates definitions in VK_KHR_device_group below</comment>
                <enum extends="VkStructureType" extnumber="61"  offset="7"      name="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"/>
                <enum extends="VkStructureType" extnumber="61"  offset="8"      name="VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR"/>
                <enum extends="VkStructureType" extnumber="61"  offset="9"      name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"/>
                <enum extends="VkStructureType" extnumber="61"  offset="10"     name="VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR"/>
                <enum extends="VkStructureType" extnumber="61"  offset="11"     name="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR"/>
                <enum extends="VkStructureType" extnumber="61"  offset="12"     name="VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"/>
                <enum bitpos="0" extends="VkSwapchainCreateFlagBitsKHR"         name="VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR" comment="Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT"/>
                <type name="VkImageSwapchainCreateInfoKHR"/>
                <type name="VkBindImageMemorySwapchainInfoKHR"/>
                <type name="VkAcquireNextImageInfoKHR"/>
                <type name="VkDeviceGroupPresentModeFlagBitsKHR"/>
                <type name="VkDeviceGroupPresentModeFlagsKHR"/>
                <type name="VkDeviceGroupPresentCapabilitiesKHR"/>
                <type name="VkDeviceGroupPresentInfoKHR"/>
                <type name="VkDeviceGroupSwapchainCreateInfoKHR"/>
                <command name="vkGetDeviceGroupPresentCapabilitiesKHR"/>
                <command name="vkGetDeviceGroupSurfacePresentModesKHR"/>
                <command name="vkGetPhysicalDevicePresentRectanglesKHR"/>
                <command name="vkAcquireNextImage2KHR"/>
                <enum bitpos="1" extends="VkSwapchainCreateFlagBitsKHR"         name="VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR" comment="Swapchain is protected"/>
            </require>
        </extension>
        <extension name="VK_KHR_display" number="3" type="instance" depends="VK_KHR_surface" author="KHR" contact="James Jones @cubanismo,Norbert Nopper @FslNopper" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="23"                                                name="VK_KHR_DISPLAY_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_display&quot;"                        name="VK_KHR_DISPLAY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"/>
                <enum offset="0" extends="VkObjectType"                         name="VK_OBJECT_TYPE_DISPLAY_KHR"/>
                <enum offset="1" extends="VkObjectType"                         name="VK_OBJECT_TYPE_DISPLAY_MODE_KHR"/>
                <type name="VkDisplayKHR"/>
                <type name="VkDisplayModeCreateFlagsKHR"/>
                <type name="VkDisplayModeCreateInfoKHR"/>
                <type name="VkDisplayModeKHR"/>
                <type name="VkDisplayModeParametersKHR"/>
                <type name="VkDisplayModePropertiesKHR"/>
                <type name="VkDisplayPlaneAlphaFlagBitsKHR"/>
                <type name="VkDisplayPlaneAlphaFlagsKHR"/>
                <type name="VkDisplayPlaneCapabilitiesKHR"/>
                <type name="VkDisplayPlanePropertiesKHR"/>
                <type name="VkDisplayPropertiesKHR"/>
                <type name="VkDisplaySurfaceCreateFlagsKHR"/>
                <type name="VkDisplaySurfaceCreateInfoKHR"/>
                <type name="VkSurfaceTransformFlagsKHR"/>
                <command name="vkGetPhysicalDeviceDisplayPropertiesKHR"/>
                <command name="vkGetPhysicalDeviceDisplayPlanePropertiesKHR"/>
                <command name="vkGetDisplayPlaneSupportedDisplaysKHR"/>
                <command name="vkGetDisplayModePropertiesKHR"/>
                <command name="vkCreateDisplayModeKHR"/>
                <command name="vkGetDisplayPlaneCapabilitiesKHR"/>
                <command name="vkCreateDisplayPlaneSurfaceKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_display_swapchain" number="4" type="device" depends="VK_KHR_swapchain+VK_KHR_display" author="KHR" contact="James Jones @cubanismo" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="10"                                                name="VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_display_swapchain&quot;"              name="VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"/>
                <enum offset="1" extends="VkResult" dir="-"                     name="VK_ERROR_INCOMPATIBLE_DISPLAY_KHR"/>
                <type name="VkDisplayPresentInfoKHR"/>
                <command name="vkCreateSharedSwapchainsKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_xlib_surface" number="5" type="instance" depends="VK_KHR_surface" platform="xlib" author="KHR" contact="Jesse Hall @critsec,Ian Elliott @ianelliottus" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="6"                                                 name="VK_KHR_XLIB_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_xlib_surface&quot;"                   name="VK_KHR_XLIB_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkXlibSurfaceCreateFlagsKHR"/>
                <type name="VkXlibSurfaceCreateInfoKHR"/>
                <command name="vkCreateXlibSurfaceKHR"/>
                <command name="vkGetPhysicalDeviceXlibPresentationSupportKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_xcb_surface" number="6" type="instance" depends="VK_KHR_surface" platform="xcb" author="KHR" contact="Jesse Hall @critsec,Ian Elliott @ianelliottus" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="6"                                                 name="VK_KHR_XCB_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_xcb_surface&quot;"                    name="VK_KHR_XCB_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkXcbSurfaceCreateFlagsKHR"/>
                <type name="VkXcbSurfaceCreateInfoKHR"/>
                <command name="vkCreateXcbSurfaceKHR"/>
                <command name="vkGetPhysicalDeviceXcbPresentationSupportKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_wayland_surface" number="7" type="instance" depends="VK_KHR_surface" platform="wayland" author="KHR" contact="Jesse Hall @critsec,Ian Elliott @ianelliottus" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="6"                                                 name="VK_KHR_WAYLAND_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_wayland_surface&quot;"                name="VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkWaylandSurfaceCreateFlagsKHR"/>
                <type name="VkWaylandSurfaceCreateInfoKHR"/>
                <command name="vkCreateWaylandSurfaceKHR"/>
                <command name="vkGetPhysicalDeviceWaylandPresentationSupportKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_mir_surface" number="8" type="instance" depends="VK_KHR_surface" author="KHR" supported="disabled" comment="Extension permanently disabled. Extension number should not be reused" ratified="vulkan">
            <require>
                <enum value="4"                                                 name="VK_KHR_MIR_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_mir_surface&quot;"                    name="VK_KHR_MIR_SURFACE_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_android_surface" number="9" type="instance" depends="VK_KHR_surface" platform="android" author="KHR" contact="Jesse Hall @critsec" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="6"                                                 name="VK_KHR_ANDROID_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_android_surface&quot;"                name="VK_KHR_ANDROID_SURFACE_EXTENSION_NAME"/>
                <type name="ANativeWindow"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkAndroidSurfaceCreateFlagsKHR"/>
                <type name="VkAndroidSurfaceCreateInfoKHR"/>
                <command name="vkCreateAndroidSurfaceKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_win32_surface" number="10" type="instance" depends="VK_KHR_surface" platform="win32" author="KHR" contact="Jesse Hall @critsec,Ian Elliott @ianelliottus" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="6"                                                 name="VK_KHR_WIN32_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_win32_surface&quot;"                  name="VK_KHR_WIN32_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR"/>
                <type name="VkWin32SurfaceCreateFlagsKHR"/>
                <type name="VkWin32SurfaceCreateInfoKHR"/>
                <command name="vkCreateWin32SurfaceKHR"/>
                <command name="vkGetPhysicalDeviceWin32PresentationSupportKHR"/>
            </require>
        </extension>
        <extension name="VK_ANDROID_native_buffer" number="11" type="device" author="ANDROID" platform="android" contact="Jesse Hall @critsec" supported="disabled">
            <require>
                <comment>VK_ANDROID_native_buffer is used between the Android Vulkan loader and drivers to implement the WSI extensions. It is not exposed to applications and uses types that are not part of Android's stable public API, so it is left disabled to keep it out of the standard Vulkan headers.</comment>
                <enum value="8"                                                 name="VK_ANDROID_NATIVE_BUFFER_SPEC_VERSION"/>
                <enum value="11"                                                name="VK_ANDROID_NATIVE_BUFFER_NUMBER"/>
                <enum value="&quot;VK_ANDROID_native_buffer&quot;"              name="VK_ANDROID_NATIVE_BUFFER_EXTENSION_NAME"/>
                <enum                                                           name="VK_ANDROID_NATIVE_BUFFER_NAME" alias="VK_ANDROID_NATIVE_BUFFER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID"/>
                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID"/>
                <type name="VkNativeBufferANDROID"/>
                <type name="VkSwapchainImageCreateInfoANDROID"/>
                <type name="VkPhysicalDevicePresentationPropertiesANDROID"/>
                <type name="VkNativeBufferUsage2ANDROID"/>
                <type name="VkSwapchainImageUsageFlagBitsANDROID"/>
                <type name="VkSwapchainImageUsageFlagsANDROID"/>
                <command name="vkGetSwapchainGrallocUsageANDROID"/>
                <command name="vkAcquireImageANDROID"/>
                <command name="vkQueueSignalReleaseImageANDROID"/>
                <command name="vkGetSwapchainGrallocUsage2ANDROID"/>
            </require>
        </extension>
        <extension name="VK_EXT_debug_report" number="12" type="instance" author="GOOGLE" contact="Courtney Goeltzenleuchter @courtney-g" specialuse="debugging" supported="vulkan" deprecatedby="VK_EXT_debug_utils" nofeatures="true">
            <require>
                <enum value="10"                                                name="VK_EXT_DEBUG_REPORT_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_debug_report&quot;"                   name="VK_EXT_DEBUG_REPORT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"/>
                <enum alias="VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT" extends="VkStructureType" name="VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT" deprecated="aliased"/>
                <enum extends="VkResult"                                        name="VK_ERROR_VALIDATION_FAILED_EXT" alias="VK_ERROR_VALIDATION_FAILED"/>
                <enum offset="0" extends="VkObjectType"                         name="VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT"/>
                <type name="VkDebugReportCallbackEXT"/>
                <type name="PFN_vkDebugReportCallbackEXT"/>
                <type name="VkDebugReportFlagBitsEXT"/>
                <type name="VkDebugReportFlagsEXT"/>
                <type name="VkDebugReportObjectTypeEXT"/>
                <type name="VkDebugReportCallbackCreateInfoEXT"/>
                <command name="vkCreateDebugReportCallbackEXT"/>
                <command name="vkDestroyDebugReportCallbackEXT"/>
                <command name="vkDebugReportMessageEXT"/>
            </require>
            <require depends="VK_VERSION_1_1">
                <comment>This duplicates definitions in other extensions, below</comment>
                <enum extends="VkDebugReportObjectTypeEXT" extnumber="157" offset="0"  name="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT"/>
                <enum extends="VkDebugReportObjectTypeEXT" extnumber="86"  offset="0"  name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT"/>
            </require>
        </extension>
        <extension name="VK_NV_glsl_shader" number="13" type="device" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan" deprecatedby="" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_NV_GLSL_SHADER_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_glsl_shader&quot;"                     name="VK_NV_GLSL_SHADER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkResult" dir="-"                     name="VK_ERROR_INVALID_SHADER_NV"/>
            </require>
        </extension>
        <extension name="VK_EXT_depth_range_unrestricted" type="device" number="14" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_depth_range_unrestricted&quot;"       name="VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_sampler_mirror_clamp_to_edge" type="device" number="15" author="KHR" contact="Tobias Hector @tobski" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="3"                                                 name="VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_sampler_mirror_clamp_to_edge&quot;"   name="VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME"/>
                <enum value="4" extends="VkSamplerAddressMode"                  name="VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE" comment="Note that this defines what was previously a core enum, and so uses the 'value' attribute rather than 'offset', and does not have a suffix. This is a special case, and should not be repeated"/>
                <enum           extends="VkSamplerAddressMode"                  name="VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR" alias="VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE"  deprecated="aliased" comment="Introduced for consistency with extension suffixing rules"/>
            </require>
        </extension>
        <extension name="VK_IMG_filter_cubic" number="16" type="device" author="IMG" contact="Tobias Hector @tobski" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_IMG_FILTER_CUBIC_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_filter_cubic&quot;"                   name="VK_IMG_FILTER_CUBIC_EXTENSION_NAME"/>
                <enum extends="VkFilter"                                        name="VK_FILTER_CUBIC_IMG" alias="VK_FILTER_CUBIC_EXT"/>
                <enum extends="VkFormatFeatureFlagBits"                         name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT" comment="Format can be filtered with VK_FILTER_CUBIC_IMG when being sampled"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_17" number="17" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_17_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_17&quot;"                   name="VK_AMD_EXTENSION_17_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_18" number="18" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_18_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_18&quot;"                   name="VK_AMD_EXTENSION_18_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_rasterization_order" number="19" type="device" author="AMD" contact="Daniel Rakos @drakos-amd" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_rasterization_order&quot;"            name="VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"/>
                <type name="VkRasterizationOrderAMD"/>
                <type name="VkPipelineRasterizationStateRasterizationOrderAMD"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_20" number="20" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_20_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_20&quot;"                   name="VK_AMD_EXTENSION_20_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_shader_trinary_minmax" number="21" type="device" author="AMD" contact="Qun Lin @linqun" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_shader_trinary_minmax&quot;"          name="VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_shader_explicit_vertex_parameter" number="22" type="device" author="AMD" contact="Qun Lin @linqun" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_shader_explicit_vertex_parameter&quot;" name="VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_debug_marker" number="23" type="device" depends="VK_EXT_debug_report" author="Baldur Karlsson" contact="Baldur Karlsson @baldurk" specialuse="debugging" supported="vulkan" promotedto="VK_EXT_debug_utils" nofeatures="true">
            <require>
                <enum value="4"                                                 name="VK_EXT_DEBUG_MARKER_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_debug_marker&quot;"                   name="VK_EXT_DEBUG_MARKER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"/>
                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"/>
                <type name="VkDebugReportObjectTypeEXT"/>
                <type name="VkDebugMarkerObjectNameInfoEXT"/>
                <type name="VkDebugMarkerObjectTagInfoEXT"/>
                <type name="VkDebugMarkerMarkerInfoEXT"/>
                <command name="vkDebugMarkerSetObjectTagEXT"/>
                <command name="vkDebugMarkerSetObjectNameEXT"/>
                <command name="vkCmdDebugMarkerBeginEXT"/>
                <command name="vkCmdDebugMarkerEndEXT"/>
                <command name="vkCmdDebugMarkerInsertEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_video_queue" number="24" type="device" depends="(VK_VERSION_1_1+VK_KHR_synchronization2),VK_VERSION_1_3" author="KHR" contact="Tony Zlatinski @tzlatinski" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="8"                                         name="VK_KHR_VIDEO_QUEUE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_video_queue&quot;"            name="VK_KHR_VIDEO_QUEUE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR"/>
                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR"/>
                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR"/>
                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR"/>
                <enum offset="6" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR"/>
                <enum offset="7" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR"/>
                <enum offset="8" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR"/>
                <enum offset="9" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR"/>
                <enum offset="10" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR"/>
                <enum offset="11" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR"/>
                <enum offset="12" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR"/>
                <enum offset="13" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR"/>
                <enum offset="14" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR"/>
                <enum offset="15" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR"/>
                <enum offset="16" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR"/>
                <enum offset="0"  extends="VkObjectType"                name="VK_OBJECT_TYPE_VIDEO_SESSION_KHR" comment="VkVideoSessionKHR"/>
                <enum offset="1"  extends="VkObjectType"                name="VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR" comment="VkVideoSessionParametersKHR"/>
                <enum offset="0" extends="VkQueryType"                  name="VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR"/>
                <enum bitpos="4" extends="VkQueryResultFlagBits"        name="VK_QUERY_RESULT_WITH_STATUS_BIT_KHR"/>
                <enum offset="0" extends="VkResult" dir="-"             name="VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR"/>
                <enum offset="1" extends="VkResult" dir="-"             name="VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR"/>
                <enum offset="2" extends="VkResult" dir="-"             name="VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR"/>
                <enum offset="3" extends="VkResult" dir="-"             name="VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR"/>
                <enum offset="4" extends="VkResult" dir="-"             name="VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR"/>
                <enum offset="5" extends="VkResult" dir="-"             name="VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR"/>
                <type name="VkVideoSessionKHR"/>
                <type name="VkVideoSessionParametersKHR"/>
                <type name="VkVideoCodecOperationFlagBitsKHR"/>
                <type name="VkVideoCodecOperationFlagsKHR"/>
                <type name="VkVideoChromaSubsamplingFlagBitsKHR"/>
                <type name="VkVideoChromaSubsamplingFlagsKHR"/>
                <type name="VkVideoComponentBitDepthFlagBitsKHR"/>
                <type name="VkVideoComponentBitDepthFlagsKHR"/>
                <type name="VkVideoCapabilityFlagBitsKHR"/>
                <type name="VkVideoCapabilityFlagsKHR"/>
                <type name="VkVideoSessionCreateFlagBitsKHR"/>
                <type name="VkVideoSessionCreateFlagsKHR"/>
                <type name="VkVideoSessionParametersCreateFlagsKHR"/>
                <type name="VkVideoBeginCodingFlagsKHR"/>
                <type name="VkVideoEndCodingFlagsKHR"/>
                <type name="VkVideoCodingControlFlagBitsKHR"/>
                <type name="VkVideoCodingControlFlagsKHR"/>
                <type name="VkQueueFamilyQueryResultStatusPropertiesKHR"/>
                <type name="VkQueryResultStatusKHR"/>
                <type name="VkQueueFamilyVideoPropertiesKHR"/>
                <type name="VkVideoProfileInfoKHR"/>
                <type name="VkVideoProfileListInfoKHR"/>
                <type name="VkVideoCapabilitiesKHR"/>
                <type name="VkPhysicalDeviceVideoFormatInfoKHR"/>
                <type name="VkVideoFormatPropertiesKHR"/>
                <type name="VkVideoPictureResourceInfoKHR"/>
                <type name="VkVideoReferenceSlotInfoKHR"/>
                <type name="VkVideoSessionMemoryRequirementsKHR"/>
                <type name="VkBindVideoSessionMemoryInfoKHR"/>
                <type name="VkVideoSessionCreateInfoKHR"/>
                <type name="VkVideoSessionParametersCreateInfoKHR"/>
                <type name="VkVideoSessionParametersUpdateInfoKHR"/>
                <type name="VkVideoBeginCodingInfoKHR"/>
                <type name="VkVideoEndCodingInfoKHR"/>
                <type name="VkVideoCodingControlInfoKHR"/>
                <command name="vkGetPhysicalDeviceVideoCapabilitiesKHR"/>
                <command name="vkGetPhysicalDeviceVideoFormatPropertiesKHR"/>
                <command name="vkCreateVideoSessionKHR"/>
                <command name="vkDestroyVideoSessionKHR"/>
                <command name="vkGetVideoSessionMemoryRequirementsKHR"/>
                <command name="vkBindVideoSessionMemoryKHR"/>
                <command name="vkCreateVideoSessionParametersKHR"/>
                <command name="vkUpdateVideoSessionParametersKHR"/>
                <command name="vkDestroyVideoSessionParametersKHR"/>
                <command name="vkCmdBeginVideoCodingKHR"/>
                <command name="vkCmdEndVideoCodingKHR"/>
                <command name="vkCmdControlVideoCodingKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_video_decode_queue" number="25" type="device" depends="VK_KHR_video_queue+(VK_KHR_synchronization2,VK_VERSION_1_3)" author="KHR" contact="jake.beju@amd.com" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="8"                                         name="VK_KHR_VIDEO_DECODE_QUEUE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_video_decode_queue&quot;"     name="VK_KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR"/>
                <enum bitpos="5" extends="VkQueueFlagBits"              name="VK_QUEUE_VIDEO_DECODE_BIT_KHR"/>
                <!-- VkPipelineStageFlagBits bitpos="26" is reserved by this extension, but not used -->
                <enum bitpos="26" extends="VkPipelineStageFlagBits2"    name="VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR"/>
                <enum bitpos="35" extends="VkAccessFlagBits2"           name="VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR"/>
                <enum bitpos="36" extends="VkAccessFlagBits2"           name="VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR"/>
                <enum bitpos="13" extends="VkBufferUsageFlagBits"       name="VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR"/>
                <enum bitpos="14" extends="VkBufferUsageFlagBits"       name="VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR"/>
                <enum bitpos="10" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR"/>
                <enum bitpos="11" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR"/>
                <enum bitpos="12" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR"/>
                <enum bitpos="25" extends="VkFormatFeatureFlagBits"     name="VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR"/>
                <enum bitpos="26" extends="VkFormatFeatureFlagBits"     name="VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR"/>
                <enum offset="0" extends="VkImageLayout"                name="VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR"/>
                <enum offset="1" extends="VkImageLayout"                name="VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR"/>
                <enum offset="2" extends="VkImageLayout"                name="VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR"/>
                <type name="VkVideoDecodeCapabilityFlagBitsKHR"/>
                <type name="VkVideoDecodeCapabilityFlagsKHR"/>
                <type name="VkVideoDecodeCapabilitiesKHR"/>
                <type name="VkVideoDecodeUsageFlagBitsKHR"/>
                <type name="VkVideoDecodeUsageFlagsKHR"/>
                <type name="VkVideoDecodeUsageInfoKHR"/>
                <type name="VkVideoDecodeFlagsKHR"/>
                <type name="VkVideoDecodeInfoKHR"/>
                <command name="vkCmdDecodeVideoKHR"/>
            </require>
            <require depends="VK_KHR_format_feature_flags2,VK_VERSION_1_3">
                <enum bitpos="25" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR"/>
                <enum bitpos="26" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR"/>
            </require>
        </extension>
        <extension name="VK_AMD_gcn_shader" number="26" type="device" author="AMD" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_AMD_GCN_SHADER_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_gcn_shader&quot;"                     name="VK_AMD_GCN_SHADER_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_dedicated_allocation" number="27" type="device" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan" deprecatedby="VK_KHR_dedicated_allocation" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_dedicated_allocation&quot;"            name="VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"/>
                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"/>
                <type name="VkDedicatedAllocationImageCreateInfoNV"/>
                <type name="VkDedicatedAllocationBufferCreateInfoNV"/>
                <type name="VkDedicatedAllocationMemoryAllocateInfoNV"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_28" number="28" author="NV" contact="Piers Daniell @pdaniell-nv" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_EXT_EXTENSION_28_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_28&quot;"                   name="VK_EXT_EXTENSION_28_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_transform_feedback" number="29" type="device" author="NV" contact="Piers Daniell @pdaniell-nv" specialuse="glemulation,d3demulation,devtools" supported="vulkan" ratified="vulkan" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1">
            <require>
                <enum value="1"                                                 name="VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_transform_feedback&quot;"             name="VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME"/>
                <command name="vkCmdBindTransformFeedbackBuffersEXT"/>
                <command name="vkCmdBeginTransformFeedbackEXT"/>
                <command name="vkCmdEndTransformFeedbackEXT"/>
                <command name="vkCmdBeginQueryIndexedEXT"/>
                <command name="vkCmdEndQueryIndexedEXT"/>
                <command name="vkCmdDrawIndirectByteCountEXT"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT"/>
                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT"/>
                <enum offset="4" extends="VkQueryType"                          name="VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT"/>
                <enum bitpos="11" extends="VkBufferUsageFlagBits"               name="VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT"/>
                <enum bitpos="12" extends="VkBufferUsageFlagBits"               name="VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT"/>
                <enum bitpos="25" extends="VkAccessFlagBits"                    name="VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT"/>
                <enum bitpos="26" extends="VkAccessFlagBits"                    name="VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT"/>
                <enum bitpos="27" extends="VkAccessFlagBits"                    name="VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT"/>
                <enum bitpos="24" extends="VkPipelineStageFlagBits"             name="VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT"/>
                <type name="VkPhysicalDeviceTransformFeedbackFeaturesEXT"/>
                <type name="VkPhysicalDeviceTransformFeedbackPropertiesEXT"/>
                <type name="VkPipelineRasterizationStateStreamCreateInfoEXT"/>
                <type name="VkPipelineRasterizationStateStreamCreateFlagsEXT"/>
                <feature name="transformFeedback" struct="VkPhysicalDeviceTransformFeedbackFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_NVX_binary_import" number="30" type="device" author="NVX" contact="Eric Werness @ewerness-nv,Liam Middlebrook @liam-middlebrook" supported="vulkan" nofeatures="true">
            <require>
                <enum value="2"                                                 name="VK_NVX_BINARY_IMPORT_SPEC_VERSION"/>
                <enum value="&quot;VK_NVX_binary_import&quot;"                  name="VK_NVX_BINARY_IMPORT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX"/>
                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX"/>
                <enum offset="4" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX"/>
                <enum offset="0" extends="VkObjectType"                         name="VK_OBJECT_TYPE_CU_MODULE_NVX"/>
                <enum offset="1" extends="VkObjectType"                         name="VK_OBJECT_TYPE_CU_FUNCTION_NVX"/>
                <type name="VkCuModuleNVX"/>
                <type name="VkCuFunctionNVX"/>
                <type name="VkCuModuleCreateInfoNVX"/>
                <type name="VkCuModuleTexturingModeCreateInfoNVX"/>
                <type name="VkCuFunctionCreateInfoNVX"/>
                <type name="VkCuLaunchInfoNVX"/>
                <command name="vkCreateCuModuleNVX"/>
                <command name="vkCreateCuFunctionNVX"/>
                <command name="vkDestroyCuModuleNVX"/>
                <command name="vkDestroyCuFunctionNVX"/>
                <command name="vkCmdCuLaunchKernelNVX"/>
            </require>
            <require depends="VK_EXT_debug_report">
                <enum offset="0" extends="VkDebugReportObjectTypeEXT"           name="VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT"/>
                <enum offset="1" extends="VkDebugReportObjectTypeEXT"           name="VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT"/>
            </require>
        </extension>
        <extension name="VK_NVX_image_view_handle" number="31" type="device" author="NVX" contact="Eric Werness @ewerness-nv" supported="vulkan" nofeatures="true">
            <require>
                <enum value="3"                                                 name="VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION"/>
                <enum value="&quot;VK_NVX_image_view_handle&quot;"              name="VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX"/>
                <type name="VkImageViewHandleInfoNVX"/>
                <type name="VkImageViewAddressPropertiesNVX"/>
                <command name="vkGetImageViewHandleNVX"/>
                <command name="vkGetImageViewHandle64NVX"/>
                <command name="vkGetImageViewAddressNVX"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_32" number="32" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_32_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_32&quot;"                   name="VK_AMD_EXTENSION_32_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_33" number="33" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_33_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_33&quot;"                   name="VK_AMD_EXTENSION_33_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_draw_indirect_count" number="34" type="device" author="AMD" contact="Daniel Rakos @drakos-amd" supported="vulkan" promotedto="VK_KHR_draw_indirect_count" nofeatures="true">
            <require>
                <enum value="2"                                                 name="VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_draw_indirect_count&quot;"            name="VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME"/>
                <command name="vkCmdDrawIndirectCountAMD"/>
                <command name="vkCmdDrawIndexedIndirectCountAMD"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_35" number="35" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_35_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_35&quot;"                   name="VK_AMD_EXTENSION_35_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_negative_viewport_height" number="36" type="device" author="AMD" contact="Matthaeus G. Chajdas @anteru" supported="vulkan" obsoletedby="VK_KHR_maintenance1" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_negative_viewport_height&quot;"       name="VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_gpu_shader_half_float" number="37" type="device" author="AMD" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan" deprecatedby="VK_KHR_shader_float16_int8" nofeatures="true">
            <require>
                <enum value="2"                                                 name="VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_gpu_shader_half_float&quot;"          name="VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_shader_ballot" number="38" type="device" author="AMD" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_AMD_SHADER_BALLOT_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_shader_ballot&quot;"                  name="VK_AMD_SHADER_BALLOT_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_video_encode_h264" number="39" type="device" depends="VK_KHR_video_encode_queue" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="14"                                                name="VK_KHR_VIDEO_ENCODE_H264_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_video_encode_h264&quot;"              name="VK_KHR_VIDEO_ENCODE_H264_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR"/>
                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR"/>
                <enum offset="3" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR"/>
                <enum offset="4" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR"/>
                <enum offset="5" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR"/>
                <enum offset="6" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR"/>
                <enum offset="7" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR"/>
                <enum offset="8" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR"/>
                <enum offset="9" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR"/>
                <enum offset="10" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR"/>
                <enum offset="11" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR"/>
                <enum offset="12" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR"/>
                <enum offset="13" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR"/>
                <enum bitpos="16" extends="VkVideoCodecOperationFlagBitsKHR"    name="VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR"/>
                <type name="VkVideoEncodeH264CapabilityFlagBitsKHR"/>
                <type name="VkVideoEncodeH264CapabilityFlagsKHR"/>
                <type name="VkVideoEncodeH264StdFlagBitsKHR"/>
                <type name="VkVideoEncodeH264StdFlagsKHR"/>
                <type name="VkVideoEncodeH264CapabilitiesKHR"/>
                <type name="VkVideoEncodeH264QualityLevelPropertiesKHR"/>
                <type name="VkVideoEncodeH264SessionCreateInfoKHR"/>
                <type name="VkVideoEncodeH264SessionParametersCreateInfoKHR"/>
                <type name="VkVideoEncodeH264SessionParametersAddInfoKHR"/>
                <type name="VkVideoEncodeH264SessionParametersGetInfoKHR"/>
                <type name="VkVideoEncodeH264SessionParametersFeedbackInfoKHR"/>
                <type name="VkVideoEncodeH264PictureInfoKHR"/>
                <type name="VkVideoEncodeH264DpbSlotInfoKHR"/>
                <type name="VkVideoEncodeH264NaluSliceInfoKHR"/>
                <type name="VkVideoEncodeH264ProfileInfoKHR"/>
                <type name="VkVideoEncodeH264RateControlInfoKHR"/>
                <type name="VkVideoEncodeH264RateControlFlagBitsKHR"/>
                <type name="VkVideoEncodeH264RateControlFlagsKHR"/>
                <type name="VkVideoEncodeH264RateControlLayerInfoKHR"/>
                <type name="VkVideoEncodeH264QpKHR"/>
                <type name="VkVideoEncodeH264FrameSizeKHR"/>
                <type name="VkVideoEncodeH264GopRemainingFrameInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_video_encode_h265" number="40" type="device" depends="VK_KHR_video_encode_queue" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="14"                                             name="VK_KHR_VIDEO_ENCODE_H265_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_video_encode_h265&quot;"           name="VK_KHR_VIDEO_ENCODE_H265_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR"/>
                <enum offset="1" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR"/>
                <enum offset="2" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR"/>
                <enum offset="3" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR"/>
                <enum offset="4" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR"/>
                <enum offset="5" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR"/>
                <enum offset="6" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR"/>
                <enum offset="7" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR"/>
                <enum offset="9" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR"/>
                <enum offset="10" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR"/>
                <enum offset="11" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR"/>
                <enum offset="12" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR"/>
                <enum offset="13" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR"/>
                <enum offset="14" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR"/>
                <enum bitpos="17" extends="VkVideoCodecOperationFlagBitsKHR" name="VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR"/>
                <type name="VkVideoEncodeH265CapabilityFlagBitsKHR"/>
                <type name="VkVideoEncodeH265CapabilityFlagsKHR"/>
                <type name="VkVideoEncodeH265StdFlagBitsKHR"/>
                <type name="VkVideoEncodeH265StdFlagsKHR"/>
                <type name="VkVideoEncodeH265CtbSizeFlagBitsKHR"/>
                <type name="VkVideoEncodeH265CtbSizeFlagsKHR"/>
                <type name="VkVideoEncodeH265TransformBlockSizeFlagBitsKHR"/>
                <type name="VkVideoEncodeH265TransformBlockSizeFlagsKHR"/>
                <type name="VkVideoEncodeH265CapabilitiesKHR"/>
                <type name="VkVideoEncodeH265SessionCreateInfoKHR"/>
                <type name="VkVideoEncodeH265QualityLevelPropertiesKHR"/>
                <type name="VkVideoEncodeH265SessionParametersCreateInfoKHR"/>
                <type name="VkVideoEncodeH265SessionParametersAddInfoKHR"/>
                <type name="VkVideoEncodeH265SessionParametersGetInfoKHR"/>
                <type name="VkVideoEncodeH265SessionParametersFeedbackInfoKHR"/>
                <type name="VkVideoEncodeH265PictureInfoKHR"/>
                <type name="VkVideoEncodeH265DpbSlotInfoKHR"/>
                <type name="VkVideoEncodeH265NaluSliceSegmentInfoKHR"/>
                <type name="VkVideoEncodeH265ProfileInfoKHR"/>
                <type name="VkVideoEncodeH265RateControlInfoKHR"/>
                <type name="VkVideoEncodeH265RateControlFlagBitsKHR"/>
                <type name="VkVideoEncodeH265RateControlFlagsKHR"/>
                <type name="VkVideoEncodeH265RateControlLayerInfoKHR"/>
                <type name="VkVideoEncodeH265QpKHR"/>
                <type name="VkVideoEncodeH265FrameSizeKHR"/>
                <type name="VkVideoEncodeH265GopRemainingFrameInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_video_decode_h264" number="41" type="device" depends="VK_KHR_video_decode_queue" author="KHR" contact="peter.fang@amd.com" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="9"                                              name="VK_KHR_VIDEO_DECODE_H264_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_video_decode_h264&quot;"           name="VK_KHR_VIDEO_DECODE_H264_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR"/>
                <enum offset="1" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR"/>
                <enum offset="3" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR"/>
                <enum offset="4" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR"/>
                <enum offset="5" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR"/>
                <enum offset="6" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR"/>
                <enum bitpos="0" extends="VkVideoCodecOperationFlagBitsKHR"  name="VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR"/>
                <type name="VkVideoDecodeH264PictureLayoutFlagBitsKHR"/>
                <type name="VkVideoDecodeH264PictureLayoutFlagsKHR"/>
                <type name="VkVideoDecodeH264ProfileInfoKHR"/>
                <type name="VkVideoDecodeH264CapabilitiesKHR"/>
                <type name="VkVideoDecodeH264SessionParametersCreateInfoKHR"/>
                <type name="VkVideoDecodeH264SessionParametersAddInfoKHR"/>
                <type name="VkVideoDecodeH264PictureInfoKHR"/>
                <type name="VkVideoDecodeH264DpbSlotInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_AMD_texture_gather_bias_lod" number="42" author="AMD" contact="Rex Xu @amdrexu" supported="vulkan" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_texture_gather_bias_lod&quot;"        name="VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD"/>
                <type name="VkTextureLODGatherFormatPropertiesAMD"/>
            </require>
        </extension>
        <extension name="VK_AMD_shader_info" number="43" author="AMD" contact="Jaakko Konttinen @jaakkoamd" supported="vulkan" specialuse="devtools" type="device" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_AMD_SHADER_INFO_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_shader_info&quot;"                    name="VK_AMD_SHADER_INFO_EXTENSION_NAME"/>
                <type name="VkShaderInfoTypeAMD"/>
                <type name="VkShaderResourceUsageAMD"/>
                <type name="VkShaderStatisticsInfoAMD"/>
                <command name="vkGetShaderInfoAMD"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_44" number="44" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_44_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_44&quot;"                   name="VK_AMD_EXTENSION_44_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_dynamic_rendering" number="45" author="KHR" type="device" depends="((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_depth_stencil_resolve),VK_VERSION_1_2" contact="Tobias Hector @tobski" supported="vulkan" promotedto="VK_VERSION_1_3" ratified="vulkan">
            <require>
                <enum value="1"                                                 name="VK_KHR_DYNAMIC_RENDERING_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_dynamic_rendering&quot;"              name="VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME"/>
                <command name="vkCmdBeginRenderingKHR"/>
                <command name="vkCmdEndRenderingKHR"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_RENDERING_INFO_KHR" alias="VK_STRUCTURE_TYPE_RENDERING_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR" alias="VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR" alias="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO"/>
                <enum extends="VkAttachmentStoreOp"                             name="VK_ATTACHMENT_STORE_OP_NONE_KHR" alias="VK_ATTACHMENT_STORE_OP_NONE"/>
                <enum extends="VkRenderingFlagBits"                             name="VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR" alias="VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT"/>
                <enum extends="VkRenderingFlagBits"                             name="VK_RENDERING_SUSPENDING_BIT_KHR" alias="VK_RENDERING_SUSPENDING_BIT"/>
                <enum extends="VkRenderingFlagBits"                             name="VK_RENDERING_RESUMING_BIT_KHR" alias="VK_RENDERING_RESUMING_BIT"/>
                <type name="VkRenderingInfoKHR"/>
                <type name="VkRenderingAttachmentInfoKHR"/>
                <type name="VkPipelineRenderingCreateInfoKHR"/>
                <type name="VkPhysicalDeviceDynamicRenderingFeaturesKHR"/>
                <type name="VkCommandBufferInheritanceRenderingInfoKHR"/>
                <type name="VkRenderingFlagsKHR"/>
                <type name="VkRenderingFlagBitsKHR"/>
                <feature name="dynamicRendering" struct="VkPhysicalDeviceDynamicRenderingFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_46" number="46" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_AMD_EXTENSION_46_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_46&quot;"                   name="VK_AMD_EXTENSION_46_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_shader_image_load_store_lod" number="47" author="AMD" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan" type="device" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_shader_image_load_store_lod&quot;"    name="VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NVX_extension_48" number="48" author="NVX" contact="James Jones @cubanismo" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_NVX_EXTENSION_48_SPEC_VERSION"/>
                <enum value="&quot;VK_NVX_extension_48&quot;"                   name="VK_NVX_EXTENSION_48_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_extension_49" number="49" author="GOOGLE" contact="Jean-Francois Roy @jfroy" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_GOOGLE_EXTENSION_49_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_extension_49&quot;"                name="VK_GOOGLE_EXTENSION_49_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GGP_stream_descriptor_surface" number="50" type="instance" depends="VK_KHR_surface" platform="ggp" author="GGP" contact="Jean-Francois Roy @jfroy" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_GGP_stream_descriptor_surface&quot;"      name="VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP"/>
                <type name="VkStreamDescriptorSurfaceCreateFlagsGGP"/>
                <type name="VkStreamDescriptorSurfaceCreateInfoGGP"/>
                <command name="vkCreateStreamDescriptorSurfaceGGP"/>
            </require>
        </extension>
        <extension name="VK_NV_corner_sampled_image" number="51" author="NV" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Daniel Koch @dgkoch" supported="vulkan">
            <require>
                <enum value="2"                                                 name="VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_corner_sampled_image&quot;"            name="VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME"/>
                <enum bitpos="13" extends="VkImageCreateFlagBits"               name="VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV"/>
                <type name="VkPhysicalDeviceCornerSampledImageFeaturesNV"/>
                <feature name="cornerSampledImage" struct="VkPhysicalDeviceCornerSampledImageFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_private_vendor_info" number="52" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkansc" nofeatures="true">
            <require>
                <enum value="2"                                                 name="VK_NV_PRIVATE_VENDOR_INFO_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_private_vendor_info&quot;"             name="VK_NV_PRIVATE_VENDOR_INFO_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PRIVATE_VENDOR_INFO_PLACEHOLDER_OFFSET_0_NV"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_53" number="53" author="NV" contact="Jeff Bolz @jeffbolznv" supported="disabled">
            <require>
                <enum value="0"                                                 name="VK_NV_EXTENSION_53_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_53&quot;"                    name="VK_NV_EXTENSION_53_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_multiview" number="54" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
            <require>
                <enum value="1"                                                 name="VK_KHR_MULTIVIEW_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_multiview&quot;"                      name="VK_KHR_MULTIVIEW_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"/>
                <enum extends="VkDependencyFlagBits"                            name="VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR" alias="VK_DEPENDENCY_VIEW_LOCAL_BIT"/>
                <type name="VkRenderPassMultiviewCreateInfoKHR"/>
                <type name="VkPhysicalDeviceMultiviewFeaturesKHR"/>
                <type name="VkPhysicalDeviceMultiviewPropertiesKHR"/>
                <feature name="multiview" struct="VkPhysicalDeviceMultiviewFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_IMG_format_pvrtc" number="55" type="device" author="IMG" contact="Stuart Smith" supported="vulkan" deprecatedby="" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_IMG_FORMAT_PVRTC_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_format_pvrtc&quot;"                   name="VK_IMG_FORMAT_PVRTC_EXTENSION_NAME"/>
                <enum offset="0" extends="VkFormat"                             name="VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG"/>
                <enum offset="1" extends="VkFormat"                             name="VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG"/>
                <enum offset="2" extends="VkFormat"                             name="VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG"/>
                <enum offset="3" extends="VkFormat"                             name="VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG"/>
                <enum offset="4" extends="VkFormat"                             name="VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG"/>
                <enum offset="5" extends="VkFormat"                             name="VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG"/>
                <enum offset="6" extends="VkFormat"                             name="VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG"/>
                <enum offset="7" extends="VkFormat"                             name="VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG"/>
            </require>
        </extension>
        <extension name="VK_NV_external_memory_capabilities" number="56" type="instance" author="NV" contact="James Jones @cubanismo" supported="vulkan" deprecatedby="VK_KHR_external_memory_capabilities" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_external_memory_capabilities&quot;"    name="VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME"/>
                <type name="VkExternalMemoryHandleTypeFlagsNV"/>
                <type name="VkExternalMemoryHandleTypeFlagBitsNV"/>
                <type name="VkExternalMemoryFeatureFlagsNV"/>
                <type name="VkExternalMemoryFeatureFlagBitsNV"/>
                <type name="VkExternalImageFormatPropertiesNV"/>
                <command name="vkGetPhysicalDeviceExternalImageFormatPropertiesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_external_memory" number="57" type="device" depends="VK_NV_external_memory_capabilities" author="NV" contact="James Jones @cubanismo" supported="vulkan" deprecatedby="VK_KHR_external_memory" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_NV_EXTERNAL_MEMORY_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_external_memory&quot;"                 name="VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV"/>
                <type name="VkExternalMemoryImageCreateInfoNV"/>
                <type name="VkExportMemoryAllocateInfoNV"/>
            </require>
        </extension>
        <extension name="VK_NV_external_memory_win32" number="58" type="device" depends="VK_NV_external_memory" author="NV" contact="James Jones @cubanismo" platform="win32" supported="vulkan" deprecatedby="VK_KHR_external_memory_win32" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_external_memory_win32&quot;"           name="VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV"/>
                <type name="VkImportMemoryWin32HandleInfoNV"/>
                <type name="VkExportMemoryWin32HandleInfoNV"/>
                <command name="vkGetMemoryWin32HandleNV"/>
            </require>
        </extension>
        <extension name="VK_NV_win32_keyed_mutex" number="59" type="device" depends="VK_NV_external_memory_win32" author="NV" contact="Carsten Rohde @crohde" platform="win32" supported="vulkan" promotedto="VK_KHR_win32_keyed_mutex" nofeatures="true">
            <require>
                <enum value="2"                                                 name="VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_win32_keyed_mutex&quot;"               name="VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV"/>
                <type name="VkWin32KeyedMutexAcquireReleaseInfoNV"/>
            </require>
        </extension>
        <extension name="VK_KHR_get_physical_device_properties2" number="60" type="instance" author="KHR" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="2"                                                 name="VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_get_physical_device_properties2&quot;" name="VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2"/>
                <type name="VkPhysicalDeviceFeatures2KHR"/>
                <type name="VkPhysicalDeviceProperties2KHR"/>
                <type name="VkFormatProperties2KHR"/>
                <type name="VkImageFormatProperties2KHR"/>
                <type name="VkPhysicalDeviceImageFormatInfo2KHR"/>
                <type name="VkQueueFamilyProperties2KHR"/>
                <type name="VkPhysicalDeviceMemoryProperties2KHR"/>
                <type name="VkSparseImageFormatProperties2KHR"/>
                <type name="VkPhysicalDeviceSparseImageFormatInfo2KHR"/>
                <command name="vkGetPhysicalDeviceFeatures2KHR"/>
                <command name="vkGetPhysicalDeviceProperties2KHR"/>
                <command name="vkGetPhysicalDeviceFormatProperties2KHR"/>
                <command name="vkGetPhysicalDeviceImageFormatProperties2KHR"/>
                <command name="vkGetPhysicalDeviceQueueFamilyProperties2KHR"/>
                <command name="vkGetPhysicalDeviceMemoryProperties2KHR"/>
                <command name="vkGetPhysicalDeviceSparseImageFormatProperties2KHR"/>
            </require>
            <deprecate explanationlink="legacy-gpdp2">
                <command name="vkGetPhysicalDeviceFeatures"/>
                <command name="vkGetPhysicalDeviceProperties"/>
                <command name="vkGetPhysicalDeviceFormatProperties"/>
                <command name="vkGetPhysicalDeviceImageFormatProperties"/>
                <command name="vkGetPhysicalDeviceQueueFamilyProperties"/>
                <command name="vkGetPhysicalDeviceMemoryProperties"/>
                <command name="vkGetPhysicalDeviceSparseImageFormatProperties"/>
            </deprecate>
        </extension>
        <extension name="VK_KHR_device_group" number="61" type="device" author="KHR" depends="VK_KHR_device_group_creation" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="4"                                                 name="VK_KHR_DEVICE_GROUP_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_device_group&quot;"                   name="VK_KHR_DEVICE_GROUP_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO"/>
                <type name="VkPeerMemoryFeatureFlagsKHR"/>
                <type name="VkPeerMemoryFeatureFlagBitsKHR"/>
                <enum extends="VkPeerMemoryFeatureFlagBits"                     name="VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR" alias="VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT"/>
                <enum extends="VkPeerMemoryFeatureFlagBits"                     name="VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR" alias="VK_PEER_MEMORY_FEATURE_COPY_DST_BIT"/>
                <enum extends="VkPeerMemoryFeatureFlagBits"                     name="VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR" alias="VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT"/>
                <enum extends="VkPeerMemoryFeatureFlagBits"                     name="VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR" alias="VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT"/>
                <type name="VkMemoryAllocateFlagsKHR"/>
                <type name="VkMemoryAllocateFlagBitsKHR"/>
                <enum extends="VkMemoryAllocateFlagBits"                        name="VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR" alias="VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT"/>
                <type name="VkMemoryAllocateFlagsInfoKHR"/>
                <type name="VkDeviceGroupRenderPassBeginInfoKHR"/>
                <type name="VkDeviceGroupCommandBufferBeginInfoKHR"/>
                <type name="VkDeviceGroupSubmitInfoKHR"/>
                <type name="VkDeviceGroupBindSparseInfoKHR"/>
                <command name="vkGetDeviceGroupPeerMemoryFeaturesKHR"/>
                <command name="vkCmdSetDeviceMaskKHR"/>
                <command name="vkCmdDispatchBaseKHR"/>
                <enum extends="VkPipelineCreateFlagBits"                        name="VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR" alias="VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT"/>
                <enum extends="VkPipelineCreateFlagBits"                        name="VK_PIPELINE_CREATE_DISPATCH_BASE_BIT_KHR" alias="VK_PIPELINE_CREATE_DISPATCH_BASE_BIT"/>
                <enum extends="VkPipelineCreateFlagBits"                        name="VK_PIPELINE_CREATE_DISPATCH_BASE_KHR" alias="VK_PIPELINE_CREATE_DISPATCH_BASE_BIT" deprecated="aliased"/>
                <enum extends="VkDependencyFlagBits"                            name="VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR" alias="VK_DEPENDENCY_DEVICE_GROUP_BIT"/>
            </require>
            <require depends="VK_KHR_bind_memory2">
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO"/>
                <type name="VkBindBufferMemoryDeviceGroupInfoKHR"/>
                <type name="VkBindImageMemoryDeviceGroupInfoKHR"/>
                <enum extends="VkImageCreateFlagBits"                           name="VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR" alias="VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT"/>
            </require>
            <require depends="VK_KHR_surface">
                <enum offset="7" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"/>
                <type name="VkDeviceGroupPresentModeFlagBitsKHR"/>
                <type name="VkDeviceGroupPresentModeFlagsKHR"/>
                <type name="VkDeviceGroupPresentCapabilitiesKHR"/>
                <command name="vkGetDeviceGroupPresentCapabilitiesKHR"/>
                <command name="vkGetDeviceGroupSurfacePresentModesKHR"/>
                <command name="vkGetPhysicalDevicePresentRectanglesKHR"/>
            </require>
            <require depends="VK_KHR_swapchain">
                <enum offset="8" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR"/>
                <enum offset="9" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"/>
                <enum offset="10" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR"/>
                <enum offset="11" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR"/>
                <enum offset="12" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"/>
                <enum bitpos="0" extends="VkSwapchainCreateFlagBitsKHR"         name="VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR" comment="Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT"/>
                <type name="VkImageSwapchainCreateInfoKHR"/>
                <type name="VkBindImageMemorySwapchainInfoKHR"/>
                <type name="VkAcquireNextImageInfoKHR"/>
                <type name="VkDeviceGroupPresentInfoKHR"/>
                <type name="VkDeviceGroupSwapchainCreateInfoKHR"/>
                <command name="vkAcquireNextImage2KHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_validation_flags" number="62" type="instance" author="GOOGLE" contact="Tobin Ehlis @tobine" specialuse="debugging" supported="vulkan" deprecatedby="VK_EXT_layer_settings" nofeatures="true">
            <require>
                <enum value="3"                                                 name="VK_EXT_VALIDATION_FLAGS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_validation_flags&quot;"               name="VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT"/>
                <type name="VkValidationFlagsEXT"/>
                <type name="VkValidationCheckEXT"/>
            </require>
        </extension>
        <extension name="VK_NN_vi_surface" number="63" type="instance" author="NN" contact="Mathias Heyer gitlab:@mheyer" depends="VK_KHR_surface" platform="vi" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_NN_VI_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_NN_vi_surface&quot;"                      name="VK_NN_VI_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN"/>
                <type name="VkViSurfaceCreateFlagsNN"/>
                <type name="VkViSurfaceCreateInfoNN"/>
                <command name="vkCreateViSurfaceNN"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_draw_parameters" number="64" type="device" author="KHR" contact="Daniel Koch @dgkoch" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_draw_parameters&quot;"         name="VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_subgroup_ballot" number="65" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan" deprecatedby="VK_VERSION_1_2" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_subgroup_ballot&quot;"         name="VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_subgroup_vote" number="66" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan" deprecatedby="VK_VERSION_1_1" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_subgroup_vote&quot;"           name="VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_texture_compression_astc_hdr" number="67" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3" ratified="vulkansc">
            <require>
                <enum value="1"                                                 name="VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_texture_compression_astc_hdr&quot;"   name="VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES"/>
                <type name="VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT"/>
                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK"/>
                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK"/>
                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK"/>
                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK"/>
                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK"/>
                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK"/>
                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK"/>
                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK"/>
                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK"/>
                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK"/>
                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK"/>
                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK"/>
                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK"/>
                <enum extends="VkFormat"                                        name="VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT" alias="VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK"/>
                <feature name="textureCompressionASTC_HDR" struct="VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_astc_decode_mode" number="68" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_astc_decode_mode&quot;"               name="VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT"/>
                <type name="VkImageViewASTCDecodeModeEXT"/>
                <type name="VkPhysicalDeviceASTCDecodeFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_pipeline_robustness" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" number="69" type="device" author="IMG" contact="Jarred Davies" supported="vulkan" ratified="vulkan" promotedto="VK_VERSION_1_4">
            <require>
                <enum value="1"                                                 name="VK_EXT_PIPELINE_ROBUSTNESS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_pipeline_robustness&quot;"            name="VK_EXT_PIPELINE_ROBUSTNESS_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES"/>
                <enum extends="VkPipelineRobustnessBufferBehavior"              name="VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT" alias="VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT"/>
                <enum extends="VkPipelineRobustnessBufferBehavior"              name="VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT" alias="VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED"/>
                <enum extends="VkPipelineRobustnessBufferBehavior"              name="VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT" alias="VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS"/>
                <enum extends="VkPipelineRobustnessBufferBehavior"              name="VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT" alias="VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2"/>
                <enum extends="VkPipelineRobustnessImageBehavior"               name="VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT" alias="VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT"/>
                <enum extends="VkPipelineRobustnessImageBehavior"               name="VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT" alias="VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED"/>
                <enum extends="VkPipelineRobustnessImageBehavior"               name="VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT" alias="VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS"/>
                <enum extends="VkPipelineRobustnessImageBehavior"               name="VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT" alias="VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2"/>
                <type name="VkPhysicalDevicePipelineRobustnessFeaturesEXT"/>
                <type name="VkPhysicalDevicePipelineRobustnessPropertiesEXT"/>
                <type name="VkPipelineRobustnessCreateInfoEXT"/>
                <type name="VkPipelineRobustnessBufferBehaviorEXT"/>
                <type name="VkPipelineRobustnessImageBehaviorEXT"/>
                <feature name="pipelineRobustness" struct="VkPhysicalDevicePipelineRobustnessFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_maintenance1" number="70" type="device" author="KHR" contact="Piers Daniell @pdaniell-nv" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="2"                                                 name="VK_KHR_MAINTENANCE_1_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_maintenance1&quot;"                   name="VK_KHR_MAINTENANCE_1_EXTENSION_NAME"/>
                <enum alias="VK_KHR_MAINTENANCE_1_SPEC_VERSION"                 name="VK_KHR_MAINTENANCE1_SPEC_VERSION" deprecated="aliased"/>
                <enum alias="VK_KHR_MAINTENANCE_1_EXTENSION_NAME"               name="VK_KHR_MAINTENANCE1_EXTENSION_NAME" deprecated="aliased"/>
                <enum extends="VkResult"                                        name="VK_ERROR_OUT_OF_POOL_MEMORY_KHR" alias="VK_ERROR_OUT_OF_POOL_MEMORY"/>
                <enum extends="VkFormatFeatureFlagBits"                         name="VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR" alias="VK_FORMAT_FEATURE_TRANSFER_SRC_BIT"/>
                <enum extends="VkFormatFeatureFlagBits"                         name="VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR" alias="VK_FORMAT_FEATURE_TRANSFER_DST_BIT"/>
                <enum extends="VkImageCreateFlagBits"                           name="VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR" alias="VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT"/>
                <type name="VkCommandPoolTrimFlagsKHR"/>
                <command name="vkTrimCommandPoolKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_device_group_creation" number="71" type="instance" author="KHR" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_device_group_creation&quot;"          name="VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO"/>
                <enum                                                           name="VK_MAX_DEVICE_GROUP_SIZE_KHR" alias="VK_MAX_DEVICE_GROUP_SIZE"/>
                <type name="VkPhysicalDeviceGroupPropertiesKHR"/>
                <type name="VkDeviceGroupDeviceCreateInfoKHR"/>
                <command name="vkEnumeratePhysicalDeviceGroupsKHR"/>
                <enum extends="VkMemoryHeapFlagBits"                            name="VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR" alias="VK_MEMORY_HEAP_MULTI_INSTANCE_BIT"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_memory_capabilities" number="72" type="instance" author="KHR" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_memory_capabilities&quot;"   name="VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"/>
                <enum                                                           name="VK_LUID_SIZE_KHR" alias="VK_LUID_SIZE"/>
                <type name="VkExternalMemoryHandleTypeFlagsKHR"/>
                <type name="VkExternalMemoryHandleTypeFlagBitsKHR"/>
                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT"/>
                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT"/>
                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT"/>
                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT"/>
                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT"/>
                <type name="VkExternalMemoryFeatureFlagsKHR"/>
                <type name="VkExternalMemoryFeatureFlagBitsKHR"/>
                <enum extends="VkExternalMemoryFeatureFlagBits"                 name="VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR" alias="VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT"/>
                <enum extends="VkExternalMemoryFeatureFlagBits"                 name="VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR" alias="VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT"/>
                <enum extends="VkExternalMemoryFeatureFlagBits"                 name="VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR" alias="VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT"/>
                <type name="VkExternalMemoryPropertiesKHR"/>
                <type name="VkPhysicalDeviceExternalImageFormatInfoKHR"/>
                <type name="VkExternalImageFormatPropertiesKHR"/>
                <type name="VkPhysicalDeviceExternalBufferInfoKHR"/>
                <type name="VkExternalBufferPropertiesKHR"/>
                <type name="VkPhysicalDeviceIDPropertiesKHR"/>
                <command name="vkGetPhysicalDeviceExternalBufferPropertiesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_memory" number="73" type="device" depends="VK_KHR_external_memory_capabilities,VK_VERSION_1_1" author="KHR" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_memory&quot;"                name="VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO"/>
                <enum extends="VkResult"                                        name="VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR" alias="VK_ERROR_INVALID_EXTERNAL_HANDLE"/>
                <enum                                                           name="VK_QUEUE_FAMILY_EXTERNAL_KHR" alias="VK_QUEUE_FAMILY_EXTERNAL"/>
                <type name="VkExternalMemoryImageCreateInfoKHR"/>
                <type name="VkExternalMemoryBufferCreateInfoKHR"/>
                <type name="VkExportMemoryAllocateInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_memory_win32" number="74" type="device" depends="VK_KHR_external_memory,VK_VERSION_1_1" author="KHR" contact="James Jones @cubanismo" platform="win32" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_memory_win32&quot;"          name="VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR"/>
                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR"/>
                <enum offset="3" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR"/>
                <type name="VkImportMemoryWin32HandleInfoKHR"/>
                <type name="VkExportMemoryWin32HandleInfoKHR"/>
                <type name="VkMemoryWin32HandlePropertiesKHR"/>
                <type name="VkMemoryGetWin32HandleInfoKHR"/>
                <command name="vkGetMemoryWin32HandleKHR"/>
                <command name="vkGetMemoryWin32HandlePropertiesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_memory_fd" number="75" type="device" depends="VK_KHR_external_memory,VK_VERSION_1_1" author="KHR" contact="James Jones @cubanismo" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_memory_fd&quot;"             name="VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR"/>
                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR"/>
                <type name="VkImportMemoryFdInfoKHR"/>
                <type name="VkMemoryFdPropertiesKHR"/>
                <type name="VkMemoryGetFdInfoKHR"/>
                <command name="vkGetMemoryFdKHR"/>
                <command name="vkGetMemoryFdPropertiesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_win32_keyed_mutex" number="76" type="device" depends="VK_KHR_external_memory_win32" author="KHR" contact="Carsten Rohde @crohde" platform="win32" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_win32_keyed_mutex&quot;"              name="VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"/>
                <type name="VkWin32KeyedMutexAcquireReleaseInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_semaphore_capabilities" number="77" type="instance" author="KHR" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_semaphore_capabilities&quot;" name="VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"/>
                <enum name="VK_LUID_SIZE_KHR"/>
                <type name="VkExternalSemaphoreHandleTypeFlagsKHR"/>
                <type name="VkExternalSemaphoreHandleTypeFlagBitsKHR"/>
                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT"/>
                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT"/>
                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT"/>
                <type name="VkExternalSemaphoreFeatureFlagsKHR"/>
                <type name="VkExternalSemaphoreFeatureFlagBitsKHR"/>
                <enum extends="VkExternalSemaphoreFeatureFlagBits"          name="VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT"/>
                <enum extends="VkExternalSemaphoreFeatureFlagBits"          name="VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT"/>
                <type name="VkPhysicalDeviceExternalSemaphoreInfoKHR"/>
                <type name="VkExternalSemaphorePropertiesKHR"/>
                <type name="VkPhysicalDeviceIDPropertiesKHR"/>
                <command name="vkGetPhysicalDeviceExternalSemaphorePropertiesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_semaphore" number="78" type="device" depends="VK_KHR_external_semaphore_capabilities" author="KHR" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_semaphore&quot;"         name="VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO"/>
                <type name="VkSemaphoreImportFlagsKHR"/>
                <type name="VkSemaphoreImportFlagBitsKHR"/>
                <enum extends="VkSemaphoreImportFlagBits"                   name="VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR" alias="VK_SEMAPHORE_IMPORT_TEMPORARY_BIT"/>
                <type name="VkExportSemaphoreCreateInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_semaphore_win32" number="79" type="device" depends="VK_KHR_external_semaphore" author="KHR" contact="James Jones @cubanismo" platform="win32" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_semaphore_win32&quot;"   name="VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR"/>
                <type name="VkImportSemaphoreWin32HandleInfoKHR"/>
                <type name="VkExportSemaphoreWin32HandleInfoKHR"/>
                <type name="VkD3D12FenceSubmitInfoKHR"/>
                <type name="VkSemaphoreGetWin32HandleInfoKHR"/>
                <command name="vkImportSemaphoreWin32HandleKHR"/>
                <command name="vkGetSemaphoreWin32HandleKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_semaphore_fd" number="80" type="device" depends="VK_KHR_external_semaphore,VK_VERSION_1_1" author="KHR" contact="James Jones @cubanismo" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_semaphore_fd&quot;"      name="VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR"/>
                <type name="VkImportSemaphoreFdInfoKHR"/>
                <type name="VkSemaphoreGetFdInfoKHR"/>
                <command name="vkImportSemaphoreFdKHR"/>
                <command name="vkGetSemaphoreFdKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_push_descriptor" number="81" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_4" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="2"                                             name="VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_push_descriptor&quot;"            name="VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                           name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES"/>
                <enum extends="VkDescriptorSetLayoutCreateFlagBits"       name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR" alias="VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT" comment="Descriptors are pushed via flink:vkCmdPushDescriptorSet"/>
                <command name="vkCmdPushDescriptorSetKHR"/>
                <type name="VkPhysicalDevicePushDescriptorPropertiesKHR"/>
            </require>
            <require depends="VK_VERSION_1_1,VK_KHR_descriptor_update_template">
                <command name="vkCmdPushDescriptorSetWithTemplateKHR"/>
                <enum extends="VkDescriptorUpdateTemplateType"              name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR" alias="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS" comment="Create descriptor update template for pushed descriptor updates"/>
            </require>
        </extension>
        <extension name="VK_EXT_conditional_rendering" number="82" type="device" author="NV" contact="Vikram Kushwaha @vkushwaha" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="2"                                             name="VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_conditional_rendering&quot;"      name="VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT"/>
                <type name="VkConditionalRenderingFlagsEXT"/>
                <type name="VkConditionalRenderingFlagBitsEXT"/>
                <enum bitpos="20" extends="VkAccessFlagBits"                name="VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT" comment="read access flag for reading conditional rendering predicate"/>
                <enum bitpos="9"  extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT" comment="Specifies the buffer can be used as predicate in conditional rendering"/>
                <enum bitpos="18" extends="VkPipelineStageFlagBits"         name="VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT" comment="A pipeline stage for conditional rendering predicate fetch"/>
                <command name="vkCmdBeginConditionalRenderingEXT"/>
                <command name="vkCmdEndConditionalRenderingEXT"/>
                <type name="VkConditionalRenderingBeginInfoEXT"/>
                <type name="VkPhysicalDeviceConditionalRenderingFeaturesEXT"/>
                <type name="VkCommandBufferInheritanceConditionalRenderingInfoEXT"/>
                <feature name="conditionalRendering" struct="VkPhysicalDeviceConditionalRenderingFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_float16_int8" number="83" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="KHR" contact="Alexander Galazin @alegal-arm" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_float16_int8&quot;"        name="VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"/>
                <type name="VkPhysicalDeviceShaderFloat16Int8FeaturesKHR"/>
                <type name="VkPhysicalDeviceFloat16Int8FeaturesKHR"/>
                <feature name="shaderFloat16,shaderInt8" struct="VkPhysicalDeviceShaderFloat16Int8FeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_16bit_storage" number="84" type="device" depends="(VK_KHR_get_physical_device_properties2+VK_KHR_storage_buffer_storage_class),VK_VERSION_1_1" author="KHR" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_16BIT_STORAGE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_16bit_storage&quot;"              name="VK_KHR_16BIT_STORAGE_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"/>
                <type name="VkPhysicalDevice16BitStorageFeaturesKHR"/>
                <feature name="storageBuffer16BitAccess" struct="VkPhysicalDevice16BitStorageFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_incremental_present" number="85" type="device" author="KHR" depends="VK_KHR_swapchain" contact="Ian Elliott @ianelliottus" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="2"                                             name="VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_incremental_present&quot;"        name="VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR"/>
                <type name="VkPresentRegionsKHR"/>
                <type name="VkPresentRegionKHR"/>
                <type name="VkRectLayerKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_descriptor_update_template" number="86" type="device" author="KHR" contact="Markus Tavenrath @mtavenrath" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_descriptor_update_template&quot;" name="VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"/>
                <enum extends="VkObjectType"                                name="VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR" alias="VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE"/>
                <command name="vkCreateDescriptorUpdateTemplateKHR"/>
                <command name="vkDestroyDescriptorUpdateTemplateKHR"/>
                <command name="vkUpdateDescriptorSetWithTemplateKHR"/>
                <type name="VkDescriptorUpdateTemplateKHR"/>
                <type name="VkDescriptorUpdateTemplateCreateFlagsKHR"/>
                <type name="VkDescriptorUpdateTemplateTypeKHR"/>
                <type name="VkDescriptorUpdateTemplateEntryKHR"/>
                <type name="VkDescriptorUpdateTemplateCreateInfoKHR"/>
                <enum extends="VkDescriptorUpdateTemplateType"              name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR" alias="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET"/>
            </require>
            <require depends="VK_KHR_push_descriptor">
                <command name="vkCmdPushDescriptorSetWithTemplateKHR"/>
                <enum extends="VkDescriptorUpdateTemplateType"    name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR" alias="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS" comment="Create descriptor update template for pushed descriptor updates"/>
            </require>
            <require depends="VK_EXT_debug_report">
                <enum extends="VkDebugReportObjectTypeEXT"                  name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT" alias="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT"/>
            </require>
        </extension>
        <extension name="VK_NVX_device_generated_commands" number="87" type="device" author="NVX" contact="Christoph Kubisch @pixeljetstream" supported="disabled">
            <require>
                <enum value="3"                                             name="VK_NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION"/>
                <enum value="&quot;VK_NVX_device_generated_commands&quot;"  name="VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_clip_space_w_scaling" number="88" type="device" author="NV" contact="Eric Werness @ewerness-nv" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_clip_space_w_scaling&quot;"        name="VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV"/>
                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV"/>
                <type name="VkViewportWScalingNV"/>
                <type name="VkPipelineViewportWScalingStateCreateInfoNV"/>
                <command name="vkCmdSetViewportWScalingNV"/>
            </require>
        </extension>
        <extension name="VK_EXT_direct_mode_display" number="89" type="instance" depends="VK_KHR_display" author="NV" contact="James Jones @cubanismo" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_direct_mode_display&quot;"        name="VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME"/>
                <command name="vkReleaseDisplayEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_acquire_xlib_display" number="90" type="instance" depends="VK_EXT_direct_mode_display" author="NV" contact="James Jones @cubanismo" platform="xlib_xrandr" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_acquire_xlib_display&quot;"       name="VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME"/>
                <command name="vkAcquireXlibDisplayEXT"/>
                <command name="vkGetRandROutputDisplayEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_display_surface_counter" number="91" type="instance" depends="VK_KHR_display" author="NV" contact="James Jones @cubanismo" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_display_surface_counter&quot;"    name="VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME"/>
                <enum offset="0"                                           extends="VkStructureType" name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT"/>
                <enum api="vulkan" extends="VkStructureType" name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT" alias="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT" deprecated="aliased"/>
                <type name="VkSurfaceCounterFlagsEXT"/>
                <type name="VkSurfaceCounterFlagBitsEXT"/>
                <type name="VkSurfaceCapabilities2EXT"/>
                <command name="vkGetPhysicalDeviceSurfaceCapabilities2EXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_display_control" number="92" type="device" depends="VK_EXT_display_surface_counter+VK_KHR_swapchain" author="NV" contact="James Jones @cubanismo" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_DISPLAY_CONTROL_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_display_control&quot;"            name="VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT"/>
                <type name="VkDisplayPowerStateEXT"/>
                <type name="VkDeviceEventTypeEXT"/>
                <type name="VkDisplayEventTypeEXT"/>
                <type name="VkDisplayPowerInfoEXT"/>
                <type name="VkDeviceEventInfoEXT"/>
                <type name="VkDisplayEventInfoEXT"/>
                <type name="VkSwapchainCounterCreateInfoEXT"/>
                <command name="vkDisplayPowerControlEXT"/>
                <command name="vkRegisterDeviceEventEXT"/>
                <command name="vkRegisterDisplayEventEXT"/>
                <command name="vkGetSwapchainCounterEXT"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_display_timing" number="93" type="device" author="GOOGLE" depends="VK_KHR_swapchain" contact="Ian Elliott @ianelliottus" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_display_timing&quot;"          name="VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE"/>
                <type name="VkRefreshCycleDurationGOOGLE"/>
                <type name="VkPastPresentationTimingGOOGLE"/>
                <type name="VkPresentTimesInfoGOOGLE"/>
                <type name="VkPresentTimeGOOGLE"/>
                <command name="vkGetRefreshCycleDurationGOOGLE"/>
                <command name="vkGetPastPresentationTimingGOOGLE"/>
            </require>
        </extension>
        <extension name="VK_RESERVED_do_not_use_94" number="94" supported="disabled" comment="Used for functionality subsumed into Vulkan 1.1 and not published as an extension">
            <require>
                <enum value="1"                                             name="VK_RESERVED_DO_NOT_USE_94_SPEC_VERSION"/>
                <enum value="&quot;VK_RESERVED_do_not_use_94&quot;"         name="VK_RESERVED_DO_NOT_USE_94_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_sample_mask_override_coverage" number="95" type="device" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_sample_mask_override_coverage&quot;" name="VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME"/>
                <comment>
                    enum offset=0 was mistakenly used for the 1.1 core enum
                    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES
                    (value=1000094000). Fortunately, no conflict resulted.
                </comment>
            </require>
        </extension>
        <extension name="VK_NV_geometry_shader_passthrough" number="96" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_geometry_shader_passthrough&quot;" name="VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_viewport_array2" number="97" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_viewport_array2&quot;"             name="VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME"/>
                <enum alias="VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION"           name="VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION" deprecated="aliased"/>
                <enum alias="VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME"         name="VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME" deprecated="aliased"/>
            </require>
        </extension>
        <extension name="VK_NVX_multiview_per_view_attributes" number="98" type="device" depends="VK_KHR_multiview,VK_VERSION_1_1" author="NVX" contact="Jeff Bolz @jeffbolznv" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION"/>
                <enum value="&quot;VK_NVX_multiview_per_view_attributes&quot;" name="VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX"/>
                <enum bitpos="0" extends="VkSubpassDescriptionFlagBits"     name="VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX"/>
                <enum bitpos="1" extends="VkSubpassDescriptionFlagBits"     name="VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX"/>
                <type name="VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX"/>
            </require>
            <require depends="VK_VERSION_1_3,VK_KHR_dynamic_rendering">
                <enum offset="9" extends="VkStructureType" extnumber="45"   name="VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX"/>
                <type name="VkMultiviewPerViewAttributesInfoNVX"/>
            </require>
        </extension>
        <extension name="VK_NV_viewport_swizzle" number="99" type="device" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_viewport_swizzle&quot;"            name="VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV"/>
                <type name="VkViewportSwizzleNV"/>
                <type name="VkViewportCoordinateSwizzleNV"/>
                <type name="VkPipelineViewportSwizzleStateCreateInfoNV"/>
                <type name="VkPipelineViewportSwizzleStateCreateFlagsNV"/>
            </require>
        </extension>
        <extension name="VK_EXT_discard_rectangles" number="100" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="2"                                             name="VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_discard_rectangles&quot;"         name="VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT"/>
                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT"/>
                <enum offset="1" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT"/>
                <enum offset="2" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT"/>
                <type name="VkPhysicalDeviceDiscardRectanglePropertiesEXT"/>
                <type name="VkPipelineDiscardRectangleStateCreateInfoEXT"/>
                <type name="VkPipelineDiscardRectangleStateCreateFlagsEXT"/>
                <type name="VkDiscardRectangleModeEXT"/>
                <command name="vkCmdSetDiscardRectangleEXT"/>
                <command name="vkCmdSetDiscardRectangleEnableEXT"/>
                <command name="vkCmdSetDiscardRectangleModeEXT"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_101" number="101" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_101_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_101&quot;"               name="VK_NV_EXTENSION_101_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_conservative_rasterization" number="102" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_conservative_rasterization&quot;" name="VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT"/>
                <type name="VkPhysicalDeviceConservativeRasterizationPropertiesEXT"/>
                <type name="VkPipelineRasterizationConservativeStateCreateInfoEXT"/>
                <type name="VkPipelineRasterizationConservativeStateCreateFlagsEXT"/>
                <type name="VkConservativeRasterizationModeEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_depth_clip_enable" number="103" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Piers Daniell @pdaniell-nv" specialuse="d3demulation" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
            <require>
                <enum value="1"                                             name="VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_depth_clip_enable&quot;"          name="VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT"/>
                <type name="VkPhysicalDeviceDepthClipEnableFeaturesEXT"/>
                <type name="VkPipelineRasterizationDepthClipStateCreateInfoEXT"/>
                <type name="VkPipelineRasterizationDepthClipStateCreateFlagsEXT"/>
                <feature name="depthClipEnable" struct="VkPhysicalDeviceDepthClipEnableFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_104" number="104" author="NV" contact="Mathias Schott gitlab:@mschott" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_104_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_104&quot;"               name="VK_NV_EXTENSION_104_EXTENSION_NAME"/>
                <enum bitpos="0"  extends="VkPrivateDataSlotCreateFlagBits" name="VK_PRIVATE_DATA_SLOT_CREATE_RESERVED_0_BIT_NV"/>
            </require>
        </extension>
        <extension name="VK_EXT_swapchain_colorspace" number="105" type="instance" depends="VK_KHR_surface" author="GOOGLE" contact="Courtney Goeltzenleuchter @courtney-g" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="5"                                             name="VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_swapchain_colorspace&quot;"       name="VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME"/>
                <enum offset="1" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT"/>
                <enum offset="2" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT"/>
                <enum offset="3" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT"/>
                <enum offset="4" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT"/>
                <enum offset="5" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_BT709_LINEAR_EXT"/>
                <enum offset="6" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_BT709_NONLINEAR_EXT"/>
                <enum offset="7" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_BT2020_LINEAR_EXT"/>
                <enum offset="8" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_HDR10_ST2084_EXT"/>
                <enum offset="9" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_DOLBYVISION_EXT" deprecated="true"/>
                <enum offset="10" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_HDR10_HLG_EXT"/>
                <enum offset="11" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT"/>
                <enum offset="12" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT"/>
                <enum offset="13" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_PASS_THROUGH_EXT"/>
                <enum offset="14" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT"/>
                <enum api="vulkan" extends="VkColorSpaceKHR"                name="VK_COLOR_SPACE_DCI_P3_LINEAR_EXT" alias="VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT" deprecated="aliased"/>
            </require>
        </extension>
        <extension name="VK_EXT_hdr_metadata" number="106" type="device" depends="VK_KHR_swapchain" author="GOOGLE" contact="Courtney Goeltzenleuchter @courtney-g" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="3"                                             name="VK_EXT_HDR_METADATA_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_hdr_metadata&quot;"               name="VK_EXT_HDR_METADATA_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_HDR_METADATA_EXT"/>
                <type name="VkHdrMetadataEXT"/>
                <type name="VkXYColorEXT"/>
                <command name="vkSetHdrMetadataEXT"/>
            </require>
        </extension>
        <extension name="VK_IMG_extension_107" number="107" author="IMG" contact="Jarred Davies" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_IMG_EXTENSION_107_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_extension_107&quot;"              name="VK_IMG_EXTENSION_107_EXTENSION_NAME"/>
                <enum bitpos="7" extends="VkBufferCreateFlagBits"           name="VK_BUFFER_CREATE_RESERVED_7_BIT_IMG" />
                <enum bitpos="21"  extends="VkImageCreateFlagBits"          name="VK_IMAGE_CREATE_RESERVED_21_BIT_IMG" />
                <enum bitpos="46" extends="VkPipelineCreateFlagBits2"       name="VK_PIPELINE_CREATE_2_RESERVED_46_BIT_IMG" />
                <enum bitpos="17" extends="VkShaderCreateFlagBitsEXT"       name="VK_SHADER_CREATE_RESERVED_17_BIT_IMG" />
                <enum bitpos="9" extends="VkRenderingFlagBits"              name="VK_RENDERING_RESERVED_9_BIT_IMG" />
                <enum bitpos="3" extends="VkRenderPassCreateFlagBits"       name="VK_RENDER_PASS_CREATE_RESERVED_3_BIT_IMG" />
            </require>
        </extension>
        <extension name="VK_IMG_extension_108" number="108" author="IMG" contact="Michael Worcester @michaelworcester" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_IMG_EXTENSION_108_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_extension_108&quot;"              name="VK_IMG_EXTENSION_108_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_imageless_framebuffer" depends="(((VK_KHR_get_physical_device_properties2+VK_KHR_maintenance2),VK_VERSION_1_1)+VK_KHR_image_format_list),VK_VERSION_1_2" number="109" author="KHR" contact="Tobias Hector @tobias" type="device" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_imageless_framebuffer&quot;"      name="VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME"/>
                <type name="VkPhysicalDeviceImagelessFramebufferFeaturesKHR"/>
                <type name="VkFramebufferAttachmentsCreateInfoKHR"/>
                <type name="VkFramebufferAttachmentImageInfoKHR"/>
                <type name="VkRenderPassAttachmentBeginInfoKHR"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR" alias="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR" alias="VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO"/>
                <enum extends="VkFramebufferCreateFlagBits"                 name="VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR" alias="VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT"/>
                <feature name="imagelessFramebuffer" struct="VkPhysicalDeviceImagelessFramebufferFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_create_renderpass2" depends="(VK_KHR_multiview+VK_KHR_maintenance2),VK_VERSION_1_1" number="110" author="KHR" contact="Tobias Hector @tobias" type="device" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_create_renderpass2&quot;"         name="VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR" alias="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR" alias="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR" alias="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR" alias="VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR" alias="VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR" alias="VK_STRUCTURE_TYPE_SUBPASS_END_INFO"/>
                <command name="vkCreateRenderPass2KHR"/>
                <command name="vkCmdBeginRenderPass2KHR"/>
                <command name="vkCmdNextSubpass2KHR"/>
                <command name="vkCmdEndRenderPass2KHR"/>
                <type name="VkRenderPassCreateInfo2KHR"/>
                <type name="VkAttachmentDescription2KHR"/>
                <type name="VkAttachmentReference2KHR"/>
                <type name="VkSubpassDescription2KHR"/>
                <type name="VkSubpassDependency2KHR"/>
                <type name="VkSubpassBeginInfoKHR"/>
                <type name="VkSubpassEndInfoKHR"/>
            </require>
            <deprecate explanationlink="legacy-renderpass2">
                <command name="vkCreateRenderPass"/>
                <type name="VkRenderPassCreateInfo"/>
                <type name="VkRenderPassCreateFlags"/>
                <type name="VkRenderPassCreateFlagBits"/>
                <type name="VkAttachmentDescription"/>
                <type name="VkAttachmentDescriptionFlags"/>
                <type name="VkAttachmentDescriptionFlagBits"/>
                <type name="VkSubpassDescription"/>
                <type name="VkSubpassDescriptionFlags"/>
                <type name="VkSubpassDescriptionFlagBits"/>
                <type name="VkAttachmentReference"/>
                <type name="VkSubpassDependency"/>
                <type name="VkRenderPassInputAttachmentAspectCreateInfo"/>
                <type name="VkInputAttachmentAspectReference"/>
                <type name="VkRenderPassMultiviewCreateInfo"/>
                <command name="vkCmdBeginRenderPass"/>
                <command name="vkCmdNextSubpass"/>
                <command name="vkCmdEndRenderPass"/>
            </deprecate>
        </extension>
        <extension name="VK_IMG_relaxed_line_rasterization" number="111" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="IMG" contact="James Fitzpatrick @jamesfitzpatrick" supported="vulkan" specialuse="glemulation">
            <require>
                <enum value="1"                                             name="VK_IMG_RELAXED_LINE_RASTERIZATION_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_relaxed_line_rasterization&quot;" name="VK_IMG_RELAXED_LINE_RASTERIZATION_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG"/>
                <type name="VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG"/>
                <feature name="relaxedLineRasterization" struct="VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG"/>
            </require>
        </extension>
        <extension name="VK_KHR_shared_presentable_image" number="112" type="device" depends="VK_KHR_swapchain+VK_KHR_get_surface_capabilities2+(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)" author="KHR" contact="Alon Or-bach @alonorbach" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shared_presentable_image&quot;"   name="VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR"/>
                <enum offset="0" extends="VkPresentModeKHR"                 name="VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR"/>
                <enum offset="1" extends="VkPresentModeKHR"                 name="VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR"/>
                <enum offset="0" extends="VkImageLayout"                    name="VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"/>
                <type name="VkSharedPresentSurfaceCapabilitiesKHR"/>
                <command name="vkGetSwapchainStatusKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_fence_capabilities" number="113" type="instance" author="KHR" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Jesse Hall @critsec" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_fence_capabilities&quot;" name="VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"/>
                <enum name="VK_LUID_SIZE_KHR"/>
                <type name="VkExternalFenceHandleTypeFlagsKHR"/>
                <type name="VkExternalFenceHandleTypeFlagBitsKHR"/>
                <enum extends="VkExternalFenceHandleTypeFlagBits"           name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR" alias="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT"/>
                <enum extends="VkExternalFenceHandleTypeFlagBits"           name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR" alias="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
                <enum extends="VkExternalFenceHandleTypeFlagBits"           name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR" alias="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
                <enum extends="VkExternalFenceHandleTypeFlagBits"           name="VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR" alias="VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT"/>
                <type name="VkExternalFenceFeatureFlagsKHR"/>
                <type name="VkExternalFenceFeatureFlagBitsKHR"/>
                <enum extends="VkExternalFenceFeatureFlagBits"              name="VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR" alias="VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT"/>
                <enum extends="VkExternalFenceFeatureFlagBits"              name="VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR" alias="VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT"/>
                <type name="VkPhysicalDeviceExternalFenceInfoKHR"/>
                <type name="VkExternalFencePropertiesKHR"/>
                <type name="VkPhysicalDeviceIDPropertiesKHR"/>
                <command name="vkGetPhysicalDeviceExternalFencePropertiesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_fence" number="114" type="device" depends="VK_KHR_external_fence_capabilities" author="KHR" contact="Jesse Hall @critsec" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_EXTERNAL_FENCE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_fence&quot;"             name="VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO"/>
                <type name="VkFenceImportFlagsKHR"/>
                <type name="VkFenceImportFlagBitsKHR"/>
                <enum extends="VkFenceImportFlagBits"                       name="VK_FENCE_IMPORT_TEMPORARY_BIT_KHR" alias="VK_FENCE_IMPORT_TEMPORARY_BIT"/>
                <type name="VkExportFenceCreateInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_fence_win32" number="115" type="device" depends="VK_KHR_external_fence" author="KHR" contact="Jesse Hall @critsec" platform="win32" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_fence_win32&quot;"       name="VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR"/>
                <type name="VkImportFenceWin32HandleInfoKHR"/>
                <type name="VkExportFenceWin32HandleInfoKHR"/>
                <type name="VkFenceGetWin32HandleInfoKHR"/>
                <command name="vkImportFenceWin32HandleKHR"/>
                <command name="vkGetFenceWin32HandleKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_external_fence_fd" number="116" type="device" depends="VK_KHR_external_fence,VK_VERSION_1_1" author="KHR" contact="Jesse Hall @critsec" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_external_fence_fd&quot;"          name="VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR"/>
                <type name="VkImportFenceFdInfoKHR"/>
                <type name="VkFenceGetFdInfoKHR"/>
                <command name="vkImportFenceFdKHR"/>
                <command name="vkGetFenceFdKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_performance_query" number="117" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="KHR" contact="Alon Or-bach @alonorbach" specialuse="devtools" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
            <require>
                <enum value="1"                                    name="VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_performance_query&quot;" name="VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkQueryType"             name="VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR"/>
                <enum offset="0" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR"/>
                <enum offset="1" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR"/>
                <enum offset="2" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR"/>
                <enum offset="3" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR"/>
                <enum offset="4" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR"/>
                <enum offset="5" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR"/>
                <enum offset="6" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR"/>
                <type name="VkPhysicalDevicePerformanceQueryFeaturesKHR"/>
                <type name="VkPhysicalDevicePerformanceQueryPropertiesKHR"/>
                <type name="VkPerformanceCounterKHR"/>
                <type name="VkPerformanceCounterDescriptionKHR"/>
                <type name="VkPerformanceCounterDescriptionFlagsKHR"/>
                <type name="VkPerformanceCounterDescriptionFlagBitsKHR"/>
                <type name="VkQueryPoolPerformanceCreateInfoKHR"/>
                <type name="VkPerformanceCounterScopeKHR"/>
                <type name="VkPerformanceCounterStorageKHR"/>
                <type name="VkPerformanceCounterUnitKHR"/>
                <type name="VkPerformanceCounterResultKHR"/>
                <type name="VkAcquireProfilingLockInfoKHR"/>
                <type name="VkAcquireProfilingLockFlagsKHR"/>
                <type name="VkAcquireProfilingLockFlagBitsKHR"/>
                <type name="VkPerformanceQuerySubmitInfoKHR"/>
                <command name="vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR"/>
                <command name="vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR"/>
                <command name="vkAcquireProfilingLockKHR"/>
                <command name="vkReleaseProfilingLockKHR"/>
                <feature name="performanceCounterQueryPools" struct="VkPhysicalDevicePerformanceQueryFeaturesKHR"/>
            </require>
            <require depends="VKSC_VERSION_1_0" api="vulkansc">
                <enum offset="7" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR"/>
                <type name="VkPerformanceQueryReservationInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_maintenance2" number="118" type="device" author="KHR" contact="Michael Worcester @michaelworcester" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_MAINTENANCE_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_maintenance2&quot;"               name="VK_KHR_MAINTENANCE_2_EXTENSION_NAME"/>
                <enum alias="VK_KHR_MAINTENANCE_2_SPEC_VERSION"             name="VK_KHR_MAINTENANCE2_SPEC_VERSION" deprecated="aliased"/>
                <enum alias="VK_KHR_MAINTENANCE_2_EXTENSION_NAME"           name="VK_KHR_MAINTENANCE2_EXTENSION_NAME" deprecated="aliased"/>
                <enum extends="VkImageCreateFlagBits"                       name="VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR" alias="VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT"/>
                <enum extends="VkImageCreateFlagBits"                       name="VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR" alias="VK_IMAGE_CREATE_EXTENDED_USAGE_BIT"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO"/>
                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL"/>
                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL"/>
                <type name="VkPhysicalDevicePointClippingPropertiesKHR"/>
                <type name="VkPointClippingBehaviorKHR"/>
                <enum extends="VkPointClippingBehavior"                     name="VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR" alias="VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES"/>
                <enum extends="VkPointClippingBehavior"                     name="VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR" alias="VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY"/>
                <type name="VkRenderPassInputAttachmentAspectCreateInfoKHR"/>
                <type name="VkInputAttachmentAspectReferenceKHR"/>
                <type name="VkImageViewUsageCreateInfoKHR"/>
                <type name="VkTessellationDomainOriginKHR"/>
                <enum extends="VkTessellationDomainOrigin"                  name="VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR" alias="VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT"/>
                <enum extends="VkTessellationDomainOrigin"                  name="VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR" alias="VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT"/>
                <type name="VkPipelineTessellationDomainOriginStateCreateInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_119" number="119" author="KHR" contact="Michael Worcester @michaelworcester" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_119_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_119&quot;"              name="VK_KHR_EXTENSION_119_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_get_surface_capabilities2" number="120" type="instance" depends="VK_KHR_surface" author="KHR" contact="James Jones @cubanismo" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_get_surface_capabilities2&quot;"  name="VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR"/>
                <type name="VkPhysicalDeviceSurfaceInfo2KHR"/>
                <type name="VkSurfaceCapabilities2KHR"/>
                <type name="VkSurfaceFormat2KHR"/>
                <command name="vkGetPhysicalDeviceSurfaceCapabilities2KHR"/>
                <command name="vkGetPhysicalDeviceSurfaceFormats2KHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_variable_pointers" number="121" type="device" author="KHR" contact="Jesse Hall @critsec" depends="(VK_KHR_get_physical_device_properties2+VK_KHR_storage_buffer_storage_class),VK_VERSION_1_1" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_VARIABLE_POINTERS_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_variable_pointers&quot;"          name="VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR"/>
                <type name="VkPhysicalDeviceVariablePointerFeaturesKHR"/>
                <type name="VkPhysicalDeviceVariablePointersFeaturesKHR"/>
                <feature name="variablePointersStorageBuffer" struct="VkPhysicalDeviceVariablePointerFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_get_display_properties2" number="122" type="instance" depends="VK_KHR_display" author="KHR" contact="James Jones @cubanismo" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_get_display_properties2&quot;"    name="VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR"/>
                <type name="VkDisplayProperties2KHR"/>
                <type name="VkDisplayPlaneProperties2KHR"/>
                <type name="VkDisplayModeProperties2KHR"/>
                <type name="VkDisplayPlaneInfo2KHR"/>
                <type name="VkDisplayPlaneCapabilities2KHR"/>
                <command name="vkGetPhysicalDeviceDisplayProperties2KHR"/>
                <command name="vkGetPhysicalDeviceDisplayPlaneProperties2KHR"/>
                <command name="vkGetDisplayModeProperties2KHR"/>
                <command name="vkGetDisplayPlaneCapabilities2KHR"/>
            </require>
        </extension>
        <extension name="VK_MVK_ios_surface" number="123" type="instance" depends="VK_KHR_surface" platform="ios" supported="vulkan" author="MVK" contact="Bill Hollings @billhollings" deprecatedby="VK_EXT_metal_surface" nofeatures="true">
            <require>
                <enum value="3"                                             name="VK_MVK_IOS_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_MVK_ios_surface&quot;"                name="VK_MVK_IOS_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK"/>
                <type name="VkIOSSurfaceCreateFlagsMVK"/>
                <type name="VkIOSSurfaceCreateInfoMVK"/>
                <command name="vkCreateIOSSurfaceMVK"/>
            </require>
        </extension>
        <extension name="VK_MVK_macos_surface" number="124" type="instance" depends="VK_KHR_surface" platform="macos" supported="vulkan" author="MVK" contact="Bill Hollings @billhollings" deprecatedby="VK_EXT_metal_surface" nofeatures="true">
            <require>
                <enum value="3"                                             name="VK_MVK_MACOS_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_MVK_macos_surface&quot;"              name="VK_MVK_MACOS_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK"/>
                <type name="VkMacOSSurfaceCreateFlagsMVK"/>
                <type name="VkMacOSSurfaceCreateInfoMVK"/>
                <command name="vkCreateMacOSSurfaceMVK"/>
            </require>
        </extension>
        <extension name="VK_MVK_moltenvk" number="125" type="instance" author="MVK" contact="Bill Hollings @billhollings" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_MVK_MOLTENVK_SPEC_VERSION"/>
                <enum value="&quot;VK_MVK_moltenvk&quot;"                   name="VK_MVK_MOLTENVK_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_external_memory_dma_buf" number="126" type="device" depends="VK_KHR_external_memory_fd" author="EXT" contact="James Jones @cubanismo" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_external_memory_dma_buf&quot;"    name="VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME"/>
                <enum bitpos="9" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_queue_family_foreign" number="127" type="device" author="EXT" depends="VK_KHR_external_memory,VK_VERSION_1_1" contact="James Jones @cubanismo" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_queue_family_foreign&quot;"       name="VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME"/>
                <enum                                                       name="VK_QUEUE_FAMILY_FOREIGN_EXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_dedicated_allocation" number="128" type="device" author="KHR" depends="VK_KHR_get_memory_requirements2,VK_VERSION_1_1" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="3"                                             name="VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_dedicated_allocation&quot;"       name="VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO"/>
                <type name="VkMemoryDedicatedRequirementsKHR"/>
                <type name="VkMemoryDedicatedAllocateInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_debug_utils" number="129" type="instance" author="EXT" contact="Mark Young @marky-lunarg" specialuse="debugging" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="2"                                             name="VK_EXT_DEBUG_UTILS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_debug_utils&quot;"                name="VK_EXT_DEBUG_UTILS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT"/>
                <enum offset="0" extends="VkObjectType"                     name="VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT"/>
                <type name="PFN_vkDebugUtilsMessengerCallbackEXT"/>
                <type name="VkDebugUtilsLabelEXT"/>
                <type name="VkDebugUtilsMessageSeverityFlagBitsEXT"/>
                <type name="VkDebugUtilsMessageSeverityFlagsEXT"/>
                <type name="VkDebugUtilsMessageTypeFlagBitsEXT"/>
                <type name="VkDebugUtilsMessageTypeFlagsEXT"/>
                <type name="VkDebugUtilsMessengerCallbackDataEXT"/>
                <type name="VkDebugUtilsMessengerCallbackDataFlagsEXT"/>
                <type name="VkDebugUtilsMessengerCreateFlagsEXT"/>
                <type name="VkDebugUtilsMessengerCreateInfoEXT"/>
                <type name="VkDebugUtilsMessengerEXT"/>
                <type name="VkDebugUtilsObjectNameInfoEXT"/>
                <type name="VkDebugUtilsObjectTagInfoEXT"/>
                <command name="vkSetDebugUtilsObjectNameEXT"/>
                <command name="vkSetDebugUtilsObjectTagEXT"/>
                <command name="vkQueueBeginDebugUtilsLabelEXT"/>
                <command name="vkQueueEndDebugUtilsLabelEXT"/>
                <command name="vkQueueInsertDebugUtilsLabelEXT"/>
                <command name="vkCmdBeginDebugUtilsLabelEXT"/>
                <command name="vkCmdEndDebugUtilsLabelEXT"/>
                <command name="vkCmdInsertDebugUtilsLabelEXT"/>
                <command name="vkCreateDebugUtilsMessengerEXT"/>
                <command name="vkDestroyDebugUtilsMessengerEXT"/>
                <command name="vkSubmitDebugUtilsMessageEXT"/>
            </require>
        </extension>
        <extension name="VK_ANDROID_external_memory_android_hardware_buffer" number="130" type="device" author="ANDROID" depends="((VK_KHR_sampler_ycbcr_conversion+VK_KHR_external_memory+VK_KHR_dedicated_allocation),VK_VERSION_1_1)+VK_EXT_queue_family_foreign" platform="android" contact="Jesse Hall @critsec" supported="vulkan" nofeatures="true">
            <require>
                <enum value="5"                                             name="VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION"/>
                <enum value="&quot;VK_ANDROID_external_memory_android_hardware_buffer&quot;" name="VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME"/>
                <enum bitpos="10" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"/>
                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID"/>
                <type name="VkAndroidHardwareBufferUsageANDROID"/>
                <type name="VkAndroidHardwareBufferPropertiesANDROID"/>
                <type name="VkAndroidHardwareBufferFormatPropertiesANDROID"/>
                <type name="VkImportAndroidHardwareBufferInfoANDROID"/>
                <type name="VkMemoryGetAndroidHardwareBufferInfoANDROID"/>
                <type name="VkExternalFormatANDROID"/>
                <command name="vkGetAndroidHardwareBufferPropertiesANDROID"/>
                <command name="vkGetMemoryAndroidHardwareBufferANDROID"/>
                <type name="AHardwareBuffer"/>
            </require>
            <require depends="VK_KHR_format_feature_flags2,VK_VERSION_1_3">
                <type name="VkAndroidHardwareBufferFormatProperties2ANDROID"/>
                <enum offset="6" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID"/>
            </require>
        </extension>
        <extension name="VK_EXT_sampler_filter_minmax" number="131" type="device" author="NV" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_2" nofeatures="true">
            <require>
                <enum value="2"                                             name="VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_sampler_filter_minmax&quot;"      name="VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO"/>
                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT"/>
                <enum extends="VkSamplerReductionMode"                      name="VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT" alias="VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE"/>
                <enum extends="VkSamplerReductionMode"                      name="VK_SAMPLER_REDUCTION_MODE_MIN_EXT" alias="VK_SAMPLER_REDUCTION_MODE_MIN"/>
                <enum extends="VkSamplerReductionMode"                      name="VK_SAMPLER_REDUCTION_MODE_MAX_EXT" alias="VK_SAMPLER_REDUCTION_MODE_MAX"/>
                <type name="VkSamplerReductionModeEXT"/>
                <type name="VkSamplerReductionModeCreateInfoEXT"/>
                <type name="VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_storage_buffer_storage_class" number="132" type="device" author="KHR" contact="Alexander Galazin @alegal-arm" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_storage_buffer_storage_class&quot;" name="VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_gpu_shader_int16" number="133" type="device" author="AMD" contact="Qun Lin @linqun" supported="vulkan" deprecatedby="VK_KHR_shader_float16_int8" nofeatures="true">
            <require>
                <enum value="2"                                             name="VK_AMD_GPU_SHADER_INT16_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_gpu_shader_int16&quot;"           name="VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_134" number="134" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_134_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_134&quot;"              name="VK_AMD_EXTENSION_134_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMDX_shader_enqueue" number="135" author="AMD" depends="((VK_KHR_synchronization2+VK_KHR_spirv_1_4+VK_EXT_extended_dynamic_state),VK_VERSION_1_3)+VK_KHR_maintenance5+VK_KHR_pipeline_library" type="device" contact="Tobias Hector @tobski" provisional="true" platform="provisional" supported="vulkan">
            <require>
                <enum value="2"                                             name="VK_AMDX_SHADER_ENQUEUE_SPEC_VERSION"/>
                <enum value="&quot;VK_AMDX_shader_enqueue&quot;"            name="VK_AMDX_SHADER_ENQUEUE_EXTENSION_NAME"/>
                <enum                                                       name="VK_SHADER_INDEX_UNUSED_AMDX"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum bitpos="25" extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum offset="0" extends="VkPipelineBindPoint"              name="VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <type name="VkPhysicalDeviceShaderEnqueueFeaturesAMDX"/>
                <type name="VkPhysicalDeviceShaderEnqueuePropertiesAMDX"/>
                <type name="VkExecutionGraphPipelineScratchSizeAMDX"/>
                <type name="VkExecutionGraphPipelineCreateInfoAMDX"/>
                <type name="VkDispatchGraphInfoAMDX"/>
                <type name="VkDispatchGraphCountInfoAMDX"/>
                <type name="VkPipelineShaderStageNodeCreateInfoAMDX"/>
                <type name="VkDeviceOrHostAddressConstAMDX"/>
                <command name="vkCreateExecutionGraphPipelinesAMDX"/>
                <command name="vkGetExecutionGraphPipelineScratchSizeAMDX"/>
                <command name="vkGetExecutionGraphPipelineNodeIndexAMDX"/>
                <command name="vkCmdInitializeGraphScratchMemoryAMDX"/>
                <command name="vkCmdDispatchGraphAMDX"/>
                <command name="vkCmdDispatchGraphIndirectAMDX"/>
                <command name="vkCmdDispatchGraphIndirectCountAMDX"/>
                <feature name="shaderEnqueue" struct="VkPhysicalDeviceShaderEnqueueFeaturesAMDX"/>
            </require>
            <require depends="VK_KHR_maintenance5,VK_VERSION_1_4">
                <enum bitpos="25" extends="VkBufferUsageFlagBits2"       name="VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum bitpos="32" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_EXECUTION_GRAPH_BIT_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
            </require>
            <require depends="VK_EXT_mesh_shader">
                <feature name="shaderMeshEnqueue" struct="VkPhysicalDeviceShaderEnqueueFeaturesAMDX"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_136" number="136" type="device" depends="VK_KHR_maintenance5" author="KHR" contact="Tobias Hector @tobski" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_136_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_136&quot;"              name="VK_KHR_EXTENSION_136_EXTENSION_NAME"/>
                <enum bitpos="28" extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_RESERVED_28_BIT_KHR"/>
                <enum bitpos="36" extends="VkPipelineCreateFlagBits2"       name="VK_PIPELINE_CREATE_RESERVED_36_BIT_KHR"/>
                <enum bitpos="39" extends="VkPipelineCreateFlagBits2"       name="VK_PIPELINE_CREATE_RESERVED_39_BIT_KHR"/>
                <enum bitpos="57" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_RESERVED_57_BIT_KHR"/>
                <enum bitpos="58" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_RESERVED_58_BIT_KHR"/>
                <enum bitpos="59" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_RESERVED_59_BIT_KHR"/>
            </require>
            <require depends="VK_KHR_maintenance5,VK_VERSION_1_4">
                <enum bitpos="28" extends="VkBufferUsageFlagBits2"          name="VK_BUFFER_USAGE_2_RESERVED_28_BIT_KHR"/>
            </require>
            <require depends="VK_EXT_shader_object">
                <enum bitpos="10"  extends="VkShaderCreateFlagBitsEXT"       name="VK_SHADER_CREATE_RESERVED_10_BIT_KHR"/>
                <enum bitpos="11"  extends="VkShaderCreateFlagBitsEXT"       name="VK_SHADER_CREATE_RESERVED_11_BIT_KHR"/>
            </require>
            <require depends="VK_ARM_tensors">
                <enum bitpos="3"  extends="VkTensorCreateFlagBitsARM"       name="VK_TENSOR_CREATE_RESERVED_3_BIT_ARM"/>
            </require>
        </extension>
        <extension name="VK_AMD_mixed_attachment_samples" number="137" type="device" author="AMD" contact="Matthaeus G. Chajdas @anteru" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_mixed_attachment_samples&quot;"   name="VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME"/>
            </require>
            <require depends="VK_VERSION_1_3,VK_KHR_dynamic_rendering">
                <enum offset="8" extends="VkStructureType" extnumber="45"           name="VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD"/>
                <type name="VkAttachmentSampleCountInfoAMD"/>
            </require>
        </extension>
        <extension name="VK_AMD_shader_fragment_mask" number="138" author="AMD" contact="Aaron Hagan @AaronHaganAMD" supported="vulkan" type="device" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_shader_fragment_mask&quot;"       name="VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_inline_uniform_block" number="139" type="device" author="EXT" depends="(VK_KHR_get_physical_device_properties2+VK_KHR_maintenance1),VK_VERSION_1_1" contact="Daniel Rakos @aqnuep" supported="vulkan" promotedto="VK_VERSION_1_3">
            <require>
                <enum value="1"                                             name="VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_inline_uniform_block&quot;"       name="VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME"/>
                <enum extends="VkDescriptorType"                            name="VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT" alias="VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT" alias="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO"/>
                <type name="VkPhysicalDeviceInlineUniformBlockFeaturesEXT"/>
                <type name="VkPhysicalDeviceInlineUniformBlockPropertiesEXT"/>
                <type name="VkWriteDescriptorSetInlineUniformBlockEXT"/>
                <type name="VkDescriptorPoolInlineUniformBlockCreateInfoEXT"/>
                <feature name="inlineUniformBlock" struct="VkPhysicalDeviceInlineUniformBlockFeaturesEXT"/>
            </require>
            <require depends="VK_EXT_descriptor_indexing">
                <feature name="descriptorBindingInlineUniformBlockUpdateAfterBind" struct="VkPhysicalDeviceInlineUniformBlockFeatures"/>
            </require>
            <require depends="VK_VERSION_1_2+VkPhysicalDeviceVulkan12Features::descriptorIndexing">
                <feature name="descriptorBindingInlineUniformBlockUpdateAfterBind" struct="VkPhysicalDeviceInlineUniformBlockFeatures"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_140" number="140" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_140_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_140&quot;"              name="VK_AMD_EXTENSION_140_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_stencil_export" number="141" type="device" author="EXT" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_stencil_export&quot;"      name="VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_bfloat16" number="142" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="KHR" contact="Tobias Hector @tobski" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_SHADER_BFLOAT16_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_bfloat16&quot;"            name="VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR"/>
                <type                                                       name="VkPhysicalDeviceShaderBfloat16FeaturesKHR"/>
                <feature name="shaderBFloat16Type" struct="VkPhysicalDeviceShaderBfloat16FeaturesKHR"/>
                <feature name="shaderBFloat16CooperativeMatrix,shaderBFloat16DotProduct" struct="VkPhysicalDeviceShaderBfloat16FeaturesKHR"/>
            </require>
            <require depends="VK_KHR_cooperative_matrix">
                <enum offset="0" extends="VkComponentTypeKHR"               name="VK_COMPONENT_TYPE_BFLOAT16_KHR"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_143" number="143" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_143_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_143&quot;"              name="VK_AMD_EXTENSION_143_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_sample_locations" number="144" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="AMD" contact="Daniel Rakos @drakos-amd" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_sample_locations&quot;"           name="VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME"/>
                <enum bitpos="12" extends="VkImageCreateFlagBits"           name="VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT"/>
                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT"/>
                <type name="VkSampleLocationEXT"/>
                <type name="VkSampleLocationsInfoEXT"/>
                <type name="VkAttachmentSampleLocationsEXT"/>
                <type name="VkSubpassSampleLocationsEXT"/>
                <type name="VkRenderPassSampleLocationsBeginInfoEXT"/>
                <type name="VkPipelineSampleLocationsStateCreateInfoEXT"/>
                <type name="VkPhysicalDeviceSampleLocationsPropertiesEXT"/>
                <type name="VkMultisamplePropertiesEXT"/>
                <command name="vkCmdSetSampleLocationsEXT"/>
                <command name="vkGetPhysicalDeviceMultisamplePropertiesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_relaxed_block_layout" number="145" type="device" author="KHR" contact="John Kessenich @johnkslang" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_relaxed_block_layout&quot;"       name="VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_RESERVED_do_not_use_146" number="146" supported="disabled" comment="Used for functionality subsumed into Vulkan 1.1 and not published as an extension">
            <require>
                <enum value="1"                                             name="VK_RESERVED_DO_NOT_USE_146_SPEC_VERSION"/>
                <enum value="&quot;VK_RESERVED_do_not_use_146&quot;"        name="VK_RESERVED_DO_NOT_USE_146_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_get_memory_requirements2" number="147" type="device" author="KHR" contact="Faith Ekstrand @gfxstrand" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1" name="VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_get_memory_requirements2&quot;"   name="VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR" alias="VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2"/>
                <type name="VkBufferMemoryRequirementsInfo2KHR"/>
                <type name="VkImageMemoryRequirementsInfo2KHR"/>
                <type name="VkImageSparseMemoryRequirementsInfo2KHR"/>
                <type name="VkMemoryRequirements2KHR"/>
                <type name="VkSparseImageMemoryRequirements2KHR"/>
                <command name="vkGetImageMemoryRequirements2KHR"/>
                <command name="vkGetBufferMemoryRequirements2KHR"/>
                <command name="vkGetImageSparseMemoryRequirements2KHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_image_format_list" number="148" type="device" author="KHR" contact="Faith Ekstrand @gfxstrand" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_image_format_list&quot;"          name="VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO"/>
                <type name="VkImageFormatListCreateInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_blend_operation_advanced" number="149" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="2"                                             name="VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_blend_operation_advanced&quot;"   name="VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT"/>
                <type name="VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT"/>
                <type name="VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT"/>
                <type name="VkPipelineColorBlendAdvancedStateCreateInfoEXT"/>
                <type name="VkBlendOverlapEXT"/>
                <enum offset="0" extends="VkBlendOp"                        name="VK_BLEND_OP_ZERO_EXT"/>
                <enum offset="1" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_EXT"/>
                <enum offset="2" extends="VkBlendOp"                        name="VK_BLEND_OP_DST_EXT"/>
                <enum offset="3" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_OVER_EXT"/>
                <enum offset="4" extends="VkBlendOp"                        name="VK_BLEND_OP_DST_OVER_EXT"/>
                <enum offset="5" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_IN_EXT"/>
                <enum offset="6" extends="VkBlendOp"                        name="VK_BLEND_OP_DST_IN_EXT"/>
                <enum offset="7" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_OUT_EXT"/>
                <enum offset="8" extends="VkBlendOp"                        name="VK_BLEND_OP_DST_OUT_EXT"/>
                <enum offset="9" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_ATOP_EXT"/>
                <enum offset="10" extends="VkBlendOp"                       name="VK_BLEND_OP_DST_ATOP_EXT"/>
                <enum offset="11" extends="VkBlendOp"                       name="VK_BLEND_OP_XOR_EXT"/>
                <enum offset="12" extends="VkBlendOp"                       name="VK_BLEND_OP_MULTIPLY_EXT"/>
                <enum offset="13" extends="VkBlendOp"                       name="VK_BLEND_OP_SCREEN_EXT"/>
                <enum offset="14" extends="VkBlendOp"                       name="VK_BLEND_OP_OVERLAY_EXT"/>
                <enum offset="15" extends="VkBlendOp"                       name="VK_BLEND_OP_DARKEN_EXT"/>
                <enum offset="16" extends="VkBlendOp"                       name="VK_BLEND_OP_LIGHTEN_EXT"/>
                <enum offset="17" extends="VkBlendOp"                       name="VK_BLEND_OP_COLORDODGE_EXT"/>
                <enum offset="18" extends="VkBlendOp"                       name="VK_BLEND_OP_COLORBURN_EXT"/>
                <enum offset="19" extends="VkBlendOp"                       name="VK_BLEND_OP_HARDLIGHT_EXT"/>
                <enum offset="20" extends="VkBlendOp"                       name="VK_BLEND_OP_SOFTLIGHT_EXT"/>
                <enum offset="21" extends="VkBlendOp"                       name="VK_BLEND_OP_DIFFERENCE_EXT"/>
                <enum offset="22" extends="VkBlendOp"                       name="VK_BLEND_OP_EXCLUSION_EXT"/>
                <enum offset="23" extends="VkBlendOp"                       name="VK_BLEND_OP_INVERT_EXT"/>
                <enum offset="24" extends="VkBlendOp"                       name="VK_BLEND_OP_INVERT_RGB_EXT"/>
                <enum offset="25" extends="VkBlendOp"                       name="VK_BLEND_OP_LINEARDODGE_EXT"/>
                <enum offset="26" extends="VkBlendOp"                       name="VK_BLEND_OP_LINEARBURN_EXT"/>
                <enum offset="27" extends="VkBlendOp"                       name="VK_BLEND_OP_VIVIDLIGHT_EXT"/>
                <enum offset="28" extends="VkBlendOp"                       name="VK_BLEND_OP_LINEARLIGHT_EXT"/>
                <enum offset="29" extends="VkBlendOp"                       name="VK_BLEND_OP_PINLIGHT_EXT"/>
                <enum offset="30" extends="VkBlendOp"                       name="VK_BLEND_OP_HARDMIX_EXT"/>
                <enum offset="31" extends="VkBlendOp"                       name="VK_BLEND_OP_HSL_HUE_EXT"/>
                <enum offset="32" extends="VkBlendOp"                       name="VK_BLEND_OP_HSL_SATURATION_EXT"/>
                <enum offset="33" extends="VkBlendOp"                       name="VK_BLEND_OP_HSL_COLOR_EXT"/>
                <enum offset="34" extends="VkBlendOp"                       name="VK_BLEND_OP_HSL_LUMINOSITY_EXT"/>
                <enum offset="35" extends="VkBlendOp"                       name="VK_BLEND_OP_PLUS_EXT"/>
                <enum offset="36" extends="VkBlendOp"                       name="VK_BLEND_OP_PLUS_CLAMPED_EXT"/>
                <enum offset="37" extends="VkBlendOp"                       name="VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT"/>
                <enum offset="38" extends="VkBlendOp"                       name="VK_BLEND_OP_PLUS_DARKER_EXT"/>
                <enum offset="39" extends="VkBlendOp"                       name="VK_BLEND_OP_MINUS_EXT"/>
                <enum offset="40" extends="VkBlendOp"                       name="VK_BLEND_OP_MINUS_CLAMPED_EXT"/>
                <enum offset="41" extends="VkBlendOp"                       name="VK_BLEND_OP_CONTRAST_EXT"/>
                <enum offset="42" extends="VkBlendOp"                       name="VK_BLEND_OP_INVERT_OVG_EXT"/>
                <enum offset="43" extends="VkBlendOp"                       name="VK_BLEND_OP_RED_EXT"/>
                <enum offset="44" extends="VkBlendOp"                       name="VK_BLEND_OP_GREEN_EXT"/>
                <enum offset="45" extends="VkBlendOp"                       name="VK_BLEND_OP_BLUE_EXT"/>
                <enum bitpos="19" extends="VkAccessFlagBits"                name="VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT"/>
            </require>
        </extension>
        <extension name="VK_NV_fragment_coverage_to_color" number="150" type="device" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_fragment_coverage_to_color&quot;"  name="VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV"/>
                <type name="VkPipelineCoverageToColorStateCreateFlagsNV"/>
                <type name="VkPipelineCoverageToColorStateCreateInfoNV"/>
            </require>
        </extension>
        <extension name="VK_KHR_acceleration_structure" number="151" type="device" depends="((VK_VERSION_1_1+VK_EXT_descriptor_indexing+VK_KHR_buffer_device_address),VK_VERSION_1_2)+VK_KHR_deferred_host_operations" author="KHR" contact="Daniel Koch @dgkoch" supported="vulkan" sortorder="1" ratified="vulkan">
            <require>
                <enum value="13"                                            name="VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_acceleration_structure&quot;"     name="VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME"/>
                <enum offset="7"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR"/>
                <enum offset="0"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR"/>
                <enum offset="2"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR"/>
                <enum offset="3"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR"/>
                <enum offset="4"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR"/>
                <enum offset="5"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR"/>
                <enum offset="6"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR"/>
                <enum offset="9"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR"/>
                <enum offset="10" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR"/>
                <enum offset="11" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR"/>
                <enum offset="12" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR"/>
                <enum offset="13" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR"/>
                <enum offset="14" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR"/>
                <enum offset="17" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR"/>
                <enum offset="20" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR"/>
                <enum bitpos="25" extends="VkPipelineStageFlagBits"         name="VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"/>
                <enum offset="0"  extends="VkDescriptorType"                name="VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR"/>
                <enum bitpos="21" extends="VkAccessFlagBits"                name="VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR"/>
                <enum bitpos="22" extends="VkAccessFlagBits"                name="VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR"/>
                <enum offset="0"  extends="VkQueryType"                     name="VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR"/>
                <enum offset="1"  extends="VkQueryType"                     name="VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR"/>
                <enum offset="0"  extends="VkObjectType"                    name="VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR"/>
                <enum offset="0"  extends="VkIndexType" extnumber="166"     name="VK_INDEX_TYPE_NONE_KHR"/>
                <enum bitpos="29" extends="VkFormatFeatureFlagBits"         name="VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR"/>
                <enum bitpos="19" extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR"/>
                <enum bitpos="20" extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR"/>
                <enum value="2" extends="VkCopyAccelerationStructureModeKHR" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR"/>
                <enum value="3" extends="VkCopyAccelerationStructureModeKHR" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR"/>
                <type name="VkAccelerationStructureTypeKHR"/>
                <type name="VkDeviceOrHostAddressKHR"/>
                <type name="VkDeviceOrHostAddressConstKHR"/>
                <type name="VkAccelerationStructureBuildRangeInfoKHR"/>
                <type name="VkAabbPositionsKHR"/>
                <type name="VkAccelerationStructureGeometryTrianglesDataKHR"/>
                <type name="VkTransformMatrixKHR"/>
                <type name="VkAccelerationStructureBuildGeometryInfoKHR"/>
                <type name="VkAccelerationStructureBuildTypeKHR"/>
                <type name="VkAccelerationStructureGeometryAabbsDataKHR"/>
                <type name="VkAccelerationStructureInstanceKHR"/>
                <type name="VkAccelerationStructureGeometryInstancesDataKHR"/>
                <type name="VkAccelerationStructureGeometryDataKHR"/>
                <type name="VkAccelerationStructureGeometryKHR"/>
                <type name="VkGeometryFlagsKHR"/>
                <type name="VkGeometryInstanceFlagsKHR"/>
                <type name="VkGeometryFlagBitsKHR"/>
                <type name="VkGeometryInstanceFlagBitsKHR"/>
                <type name="VkAccelerationStructureCreateInfoKHR"/>
                <type name="VkAccelerationStructureKHR"/>
                <type name="VkBuildAccelerationStructureFlagBitsKHR"/>
                <type name="VkBuildAccelerationStructureFlagsKHR"/>
                <type name="VkCopyAccelerationStructureModeKHR"/>
                <type name="VkGeometryTypeKHR"/>
                <type name="VkWriteDescriptorSetAccelerationStructureKHR"/>
                <type name="VkPhysicalDeviceAccelerationStructureFeaturesKHR"/>
                <type name="VkPhysicalDeviceAccelerationStructurePropertiesKHR"/>
                <type name="VkAccelerationStructureDeviceAddressInfoKHR"/>
                <type name="VkAccelerationStructureVersionInfoKHR"/>
                <type name="VkCopyAccelerationStructureToMemoryInfoKHR"/>
                <type name="VkCopyMemoryToAccelerationStructureInfoKHR"/>
                <type name="VkCopyAccelerationStructureInfoKHR"/>
                <type name="VkAccelerationStructureCompatibilityKHR"/>
                <type name="VkAccelerationStructureCreateFlagBitsKHR"/>
                <type name="VkAccelerationStructureCreateFlagsKHR"/>
                <type name="VkBuildAccelerationStructureModeKHR"/>
                <type name="VkAccelerationStructureBuildSizesInfoKHR"/>
                <command name="vkCreateAccelerationStructureKHR"/>
                <command name="vkDestroyAccelerationStructureKHR"/>
                <command name="vkCmdBuildAccelerationStructuresKHR"/>
                <command name="vkCmdBuildAccelerationStructuresIndirectKHR"/>
                <command name="vkBuildAccelerationStructuresKHR"/>
                <command name="vkCopyAccelerationStructureKHR"/>
                <command name="vkCopyAccelerationStructureToMemoryKHR"/>
                <command name="vkCopyMemoryToAccelerationStructureKHR"/>
                <command name="vkWriteAccelerationStructuresPropertiesKHR"/>
                <command name="vkCmdCopyAccelerationStructureKHR"/>
                <command name="vkCmdCopyAccelerationStructureToMemoryKHR"/>
                <command name="vkCmdCopyMemoryToAccelerationStructureKHR"/>
                <command name="vkGetAccelerationStructureDeviceAddressKHR"/>
                <command name="vkCmdWriteAccelerationStructuresPropertiesKHR"/>
                <command name="vkGetDeviceAccelerationStructureCompatibilityKHR"/>
                <command name="vkGetAccelerationStructureBuildSizesKHR"/>
                <feature name="accelerationStructure" struct="VkPhysicalDeviceAccelerationStructureFeaturesKHR"/>
                <feature name="bufferDeviceAddress" struct="VkPhysicalDeviceBufferDeviceAddressFeatures"/>
                <feature name="descriptorBindingAccelerationStructureUpdateAfterBind" struct="VkPhysicalDeviceAccelerationStructureFeaturesKHR"/>
            </require>
            <require depends="VK_KHR_format_feature_flags2,VK_VERSION_1_3">
                <enum bitpos="29" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR"/>
            </require>
            <require depends="VK_EXT_debug_report">
                <enum offset="0"  extends="VkDebugReportObjectTypeEXT"      name="VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT"/>
            </require>
            <require depends="VK_VERSION_1_2">
                <feature name="descriptorIndexing" struct="VkPhysicalDeviceVulkan12Features"/>
            </require>
        </extension>
        <extension name="VK_KHR_ray_tracing_pipeline" number="348" type="device" depends="(VK_KHR_spirv_1_4,VK_VERSION_1_2)+VK_KHR_acceleration_structure" author="KHR" contact="Daniel Koch @dgkoch" supported="vulkan" sortorder="1" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_ray_tracing_pipeline&quot;"       name="VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME"/>
                <enum                                                       name="VK_SHADER_UNUSED_KHR"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR"/>
                <enum offset="15" extends="VkStructureType" extnumber="151" name="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR"/>
                <enum offset="16" extends="VkStructureType" extnumber="151" name="VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR"/>
                <enum offset="18" extends="VkStructureType" extnumber="151" name="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR"/>
                <enum bitpos="8"  extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_RAYGEN_BIT_KHR"/>
                <enum bitpos="9"  extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_ANY_HIT_BIT_KHR"/>
                <enum bitpos="10" extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR"/>
                <enum bitpos="11" extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_MISS_BIT_KHR"/>
                <enum bitpos="12" extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_INTERSECTION_BIT_KHR"/>
                <enum bitpos="13" extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_CALLABLE_BIT_KHR"/>
                <enum bitpos="21" extends="VkPipelineStageFlagBits"         name="VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR"/>
                <enum bitpos="10" extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR"/>
                <enum offset="0"  extends="VkPipelineBindPoint" extnumber="166" name="VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR"/>
                <enum bitpos="14" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR"/>
                <enum bitpos="15" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR"/>
                <enum bitpos="16" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR"/>
                <enum bitpos="17" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR"/>
                <enum bitpos="12" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR"/>
                <enum bitpos="13" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR"/>
                <enum bitpos="19" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR"/>
                <enum offset="0"  extends="VkDynamicState"                  name="VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR"/>
                <enum extends="VkPipelineCreateFlagBits2"                   name="VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_BUILT_IN_PRIMITIVES_BIT_KHR" alias="VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR"/>
                <type name="VkRayTracingShaderGroupCreateInfoKHR"/>
                <type name="VkRayTracingShaderGroupTypeKHR"/>
                <type name="VkRayTracingPipelineCreateInfoKHR"/>
                <type name="VkPhysicalDeviceRayTracingPipelineFeaturesKHR"/>
                <type name="VkPhysicalDeviceRayTracingPipelinePropertiesKHR"/>
                <type name="VkStridedDeviceAddressRegionKHR"/>
                <type name="VkTraceRaysIndirectCommandKHR"/>
                <type name="VkRayTracingPipelineInterfaceCreateInfoKHR"/>
                <type name="VkShaderGroupShaderKHR"/>
                <command name="vkCmdTraceRaysKHR"/>
                <command name="vkCreateRayTracingPipelinesKHR"/>
                <command name="vkGetRayTracingShaderGroupHandlesKHR"/>
                <command name="vkGetRayTracingCaptureReplayShaderGroupHandlesKHR"/>
                <command name="vkCmdTraceRaysIndirectKHR"/>
                <command name="vkGetRayTracingShaderGroupStackSizeKHR"/>
                <command name="vkCmdSetRayTracingPipelineStackSizeKHR"/>
                <feature name="rayTracingPipeline" struct="VkPhysicalDeviceRayTracingPipelineFeaturesKHR"/>
                <feature name="rayTracingPipelineTraceRaysIndirect" struct="VkPhysicalDeviceRayTracingPipelineFeaturesKHR"/>
            </require>
            <require depends="VK_KHR_ray_query">
                <feature name="rayTraversalPrimitiveCulling" struct="VkPhysicalDeviceRayTracingPipelineFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_ray_query" number="349" type="device" depends="(VK_KHR_spirv_1_4,VK_VERSION_1_2)+VK_KHR_acceleration_structure" author="KHR" contact="Daniel Koch @dgkoch" supported="vulkan" sortorder="1" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_RAY_QUERY_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_ray_query&quot;"                  name="VK_KHR_RAY_QUERY_EXTENSION_NAME"/>
                <enum offset="13" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR"/>
                <type name="VkPhysicalDeviceRayQueryFeaturesKHR"/>
                <feature name="rayQuery" struct="VkPhysicalDeviceRayQueryFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_152" number="152" author="NV" contact="Jeff Bolz @jeffbolznv" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_152_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_152&quot;"               name="VK_NV_EXTENSION_152_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_framebuffer_mixed_samples" number="153" type="device" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_framebuffer_mixed_samples&quot;"   name="VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV"/>
                <type name="VkPipelineCoverageModulationStateCreateInfoNV"/>
                <type name="VkPipelineCoverageModulationStateCreateFlagsNV"/>
                <type name="VkCoverageModulationModeNV"/>
            </require>
            <require depends="VK_VERSION_1_3,VK_KHR_dynamic_rendering">
                <enum extends="VkStructureType" name="VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV" alias="VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD"/>
                <type name="VkAttachmentSampleCountInfoNV"/>
            </require>
        </extension>
        <extension name="VK_NV_fill_rectangle" number="154" type="device" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_NV_FILL_RECTANGLE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_fill_rectangle&quot;"              name="VK_NV_FILL_RECTANGLE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkPolygonMode"                    name="VK_POLYGON_MODE_FILL_RECTANGLE_NV"/>
            </require>
        </extension>
        <extension name="VK_NV_shader_sm_builtins" number="155" type="device" depends="VK_VERSION_1_1" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_shader_sm_builtins&quot;"          name="VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV"/>
                <type name="VkPhysicalDeviceShaderSMBuiltinsPropertiesNV"/>
                <type name="VkPhysicalDeviceShaderSMBuiltinsFeaturesNV"/>
                <feature name="shaderSMBuiltins" struct="VkPhysicalDeviceShaderSMBuiltinsFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_EXT_post_depth_coverage" number="156" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_post_depth_coverage&quot;"        name="VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_sampler_ycbcr_conversion" number="157" type="device" depends="(VK_KHR_maintenance1+VK_KHR_bind_memory2+VK_KHR_get_memory_requirements2+VK_KHR_get_physical_device_properties2),VK_VERSION_1_1" author="KHR" contact="Andrew Garrard @fluppeteer" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan">
            <require>
                <enum value="14"                                            name="VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_sampler_ycbcr_conversion&quot;"   name="VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR" alias="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES"/>
                <enum extends="VkObjectType"                                name="VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR" alias="VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G8B8G8R8_422_UNORM_KHR" alias="VK_FORMAT_G8B8G8R8_422_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_B8G8R8G8_422_UNORM_KHR" alias="VK_FORMAT_B8G8R8G8_422_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR" alias="VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR" alias="VK_FORMAT_G8_B8R8_2PLANE_420_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR" alias="VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR" alias="VK_FORMAT_G8_B8R8_2PLANE_422_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR" alias="VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_R10X6_UNORM_PACK16_KHR" alias="VK_FORMAT_R10X6_UNORM_PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR" alias="VK_FORMAT_R10X6G10X6_UNORM_2PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR" alias="VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR" alias="VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR" alias="VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_R12X4_UNORM_PACK16_KHR" alias="VK_FORMAT_R12X4_UNORM_PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR" alias="VK_FORMAT_R12X4G12X4_UNORM_2PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR" alias="VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR" alias="VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR" alias="VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G16B16G16R16_422_UNORM_KHR" alias="VK_FORMAT_G16B16G16R16_422_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_B16G16R16G16_422_UNORM_KHR" alias="VK_FORMAT_B16G16R16G16_422_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR" alias="VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR" alias="VK_FORMAT_G16_B16R16_2PLANE_420_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR" alias="VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR" alias="VK_FORMAT_G16_B16R16_2PLANE_422_UNORM"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR" alias="VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM"/>
                <enum extends="VkImageAspectFlagBits"                       name="VK_IMAGE_ASPECT_PLANE_0_BIT_KHR" alias="VK_IMAGE_ASPECT_PLANE_0_BIT"/>
                <enum extends="VkImageAspectFlagBits"                       name="VK_IMAGE_ASPECT_PLANE_1_BIT_KHR" alias="VK_IMAGE_ASPECT_PLANE_1_BIT"/>
                <enum extends="VkImageAspectFlagBits"                       name="VK_IMAGE_ASPECT_PLANE_2_BIT_KHR" alias="VK_IMAGE_ASPECT_PLANE_2_BIT"/>
                <enum extends="VkImageCreateFlagBits"                       name="VK_IMAGE_CREATE_DISJOINT_BIT_KHR" alias="VK_IMAGE_CREATE_DISJOINT_BIT"/>
                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR" alias="VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT"/>
                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT"/>
                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT"/>
                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT"/>
                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT"/>
                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_DISJOINT_BIT_KHR" alias="VK_FORMAT_FEATURE_DISJOINT_BIT"/>
                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR" alias="VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT"/>
                <type name="VkSamplerYcbcrConversionCreateInfoKHR"/>
                <type name="VkSamplerYcbcrConversionInfoKHR"/>
                <type name="VkBindImagePlaneMemoryInfoKHR"/>
                <type name="VkImagePlaneMemoryRequirementsInfoKHR"/>
                <type name="VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR"/>
                <type name="VkSamplerYcbcrConversionImageFormatPropertiesKHR"/>
                <command name="vkCreateSamplerYcbcrConversionKHR"/>
                <command name="vkDestroySamplerYcbcrConversionKHR"/>
                <type name="VkSamplerYcbcrConversionKHR"/>
                <type name="VkSamplerYcbcrModelConversionKHR"/>
                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY"/>
                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY"/>
                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709"/>
                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601"/>
                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020"/>
                <type name="VkSamplerYcbcrRangeKHR"/>
                <enum extends="VkSamplerYcbcrRange"                         name="VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR" alias="VK_SAMPLER_YCBCR_RANGE_ITU_FULL"/>
                <enum extends="VkSamplerYcbcrRange"                         name="VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR" alias="VK_SAMPLER_YCBCR_RANGE_ITU_NARROW"/>
                <type name="VkChromaLocationKHR"/>
                <enum extends="VkChromaLocation"                            name="VK_CHROMA_LOCATION_COSITED_EVEN_KHR" alias="VK_CHROMA_LOCATION_COSITED_EVEN"/>
                <enum extends="VkChromaLocation"                            name="VK_CHROMA_LOCATION_MIDPOINT_KHR" alias="VK_CHROMA_LOCATION_MIDPOINT"/>
                <feature name="samplerYcbcrConversion" struct="VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR"/>
            </require>
            <require depends="VK_EXT_debug_report">
                <enum extends="VkDebugReportObjectTypeEXT" offset="0"       name="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT"/>
                <enum extends="VkDebugReportObjectTypeEXT"                  name="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT" alias="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_bind_memory2" number="158" type="device" author="KHR" contact="Tobias Hector @tobski" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_BIND_MEMORY_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_bind_memory2&quot;"               name="VK_KHR_BIND_MEMORY_2_EXTENSION_NAME"/>
                <command name="vkBindBufferMemory2KHR"/>
                <command name="vkBindImageMemory2KHR"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO"/>
                <enum extends="VkImageCreateFlagBits"                       name="VK_IMAGE_CREATE_ALIAS_BIT_KHR" alias="VK_IMAGE_CREATE_ALIAS_BIT"/>
                <type name="VkBindBufferMemoryInfoKHR"/>
                <type name="VkBindImageMemoryInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_image_drm_format_modifier" number="159" type="device" depends="(((VK_KHR_bind_memory2+VK_KHR_get_physical_device_properties2+VK_KHR_sampler_ycbcr_conversion),VK_VERSION_1_1)+VK_KHR_image_format_list),VK_VERSION_1_2" author="EXT" contact="James Jones @cubanismo" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="2"                                             name="VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_image_drm_format_modifier&quot;"  name="VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME"/>
                <enum offset="0" dir="-" extends="VkResult"                 name="VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT"/>
                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT"/>
                <enum offset="0" extends="VkImageTiling"                    name="VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT"/>
                <enum bitpos="7"  extends="VkImageAspectFlagBits"           name="VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT"/>
                <enum bitpos="8"  extends="VkImageAspectFlagBits"           name="VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT"/>
                <enum bitpos="9"  extends="VkImageAspectFlagBits"           name="VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT"/>
                <enum bitpos="10" extends="VkImageAspectFlagBits"           name="VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT"/>
                <type name="VkDrmFormatModifierPropertiesListEXT"/>
                <type name="VkDrmFormatModifierPropertiesEXT"/>
                <type name="VkPhysicalDeviceImageDrmFormatModifierInfoEXT"/>
                <type name="VkImageDrmFormatModifierListCreateInfoEXT"/>
                <type name="VkImageDrmFormatModifierExplicitCreateInfoEXT"/>
                <type name="VkImageDrmFormatModifierPropertiesEXT"/>
                <command name="vkGetImageDrmFormatModifierPropertiesEXT"/>
            </require>
            <require depends="VK_KHR_format_feature_flags2,VK_VERSION_1_3">
                <type name="VkDrmFormatModifierPropertiesList2EXT"/>
                <type name="VkDrmFormatModifierProperties2EXT"/>
                <enum offset="6" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_160" number="160" author="EXT" contact="Mark Young @marky-lunarg" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_160_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_160&quot;"              name="VK_EXT_EXTENSION_160_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_validation_cache" number="161" type="device" author="GOOGLE" contact="Cort Stratton @cdwfs" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_VALIDATION_CACHE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_validation_cache&quot;"           name="VK_EXT_VALIDATION_CACHE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT"/>
                <enum offset="0" extends="VkObjectType"                     name="VK_OBJECT_TYPE_VALIDATION_CACHE_EXT"/>
                <type name="VkValidationCacheEXT"/>
                <type name="VkValidationCacheCreateInfoEXT"/>
                <type name="VkShaderModuleValidationCacheCreateInfoEXT"/>
                <type name="VkValidationCacheHeaderVersionEXT"/>
                <type name="VkValidationCacheCreateFlagsEXT"/>
                <command name="vkCreateValidationCacheEXT"/>
                <command name="vkDestroyValidationCacheEXT"/>
                <command name="vkMergeValidationCachesEXT"/>
                <command name="vkGetValidationCacheDataEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_descriptor_indexing" number="162" type="device" depends="(VK_KHR_get_physical_device_properties2+VK_KHR_maintenance3),VK_VERSION_1_1" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan" ratified="vulkan" promotedto="VK_VERSION_1_2">
            <require>
                <enum value="2"                                             name="VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_descriptor_indexing&quot;"        name="VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT" alias="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT"/>
                <enum extends="VkDescriptorBindingFlagBits"                 name="VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT" alias="VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT"/>
                <enum extends="VkDescriptorBindingFlagBits"                 name="VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT" alias="VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT"/>
                <enum extends="VkDescriptorBindingFlagBits"                 name="VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT" alias="VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT"/>
                <enum extends="VkDescriptorBindingFlagBits"                 name="VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT" alias="VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT"/>
                <enum extends="VkDescriptorPoolCreateFlagBits"              name="VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT" alias="VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT"/>
                <enum extends="VkDescriptorSetLayoutCreateFlagBits"         name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT" alias="VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT"/>
                <enum extends="VkResult"                                    name="VK_ERROR_FRAGMENTATION_EXT" alias="VK_ERROR_FRAGMENTATION"/>
                <type name="VkDescriptorSetLayoutBindingFlagsCreateInfoEXT"/>
                <type name="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"/>
                <type name="VkPhysicalDeviceDescriptorIndexingPropertiesEXT"/>
                <type name="VkDescriptorSetVariableDescriptorCountAllocateInfoEXT"/>
                <type name="VkDescriptorSetVariableDescriptorCountLayoutSupportEXT"/>
                <type name="VkDescriptorBindingFlagBitsEXT"/>
                <type name="VkDescriptorBindingFlagsEXT"/>
                <feature name="shaderSampledImageArrayDynamicIndexing" struct="VkPhysicalDeviceFeatures"/>
                <feature name="shaderStorageBufferArrayDynamicIndexing" struct="VkPhysicalDeviceFeatures"/>
                <feature name="shaderUniformTexelBufferArrayDynamicIndexing" struct="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"/>
                <feature name="shaderStorageTexelBufferArrayDynamicIndexing" struct="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"/>
                <feature name="shaderSampledImageArrayNonUniformIndexing" struct="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"/>
                <feature name="shaderStorageBufferArrayNonUniformIndexing" struct="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"/>
                <feature name="shaderUniformTexelBufferArrayNonUniformIndexing" struct="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"/>
                <feature name="descriptorBindingSampledImageUpdateAfterBind" struct="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"/>
                <feature name="descriptorBindingStorageImageUpdateAfterBind" struct="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"/>
                <feature name="descriptorBindingStorageBufferUpdateAfterBind" struct="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"/>
                <feature name="descriptorBindingUniformTexelBufferUpdateAfterBind" struct="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"/>
                <feature name="descriptorBindingStorageTexelBufferUpdateAfterBind" struct="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"/>
                <feature name="descriptorBindingUpdateUnusedWhilePending" struct="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"/>
                <feature name="descriptorBindingPartiallyBound" struct="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"/>
                <feature name="runtimeDescriptorArray" struct="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_viewport_index_layer" number="163" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan" promotedto="VK_VERSION_1_2" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_viewport_index_layer&quot;" name="VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_portability_subset" number="164" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="KHR" contact="Bill Hollings @billhollings" platform="provisional" supported="vulkan" provisional="true" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_PORTABILITY_SUBSET_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_portability_subset&quot;"         name="VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <type name="VkPhysicalDevicePortabilitySubsetFeaturesKHR"/>
                <type name="VkPhysicalDevicePortabilitySubsetPropertiesKHR"/>
            </require>
            <remove>
                <feature name="robustBufferAccess" struct="VkPhysicalDeviceFeatures"/>
            </remove>
        </extension>
        <extension name="VK_NV_shading_rate_image" number="165" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
            <require>
                <enum value="3"                                             name="VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_shading_rate_image&quot;"          name="VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV"/>
                <enum            extends="VkImageLayout"                    name="VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV" alias="VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR"/>
                <enum offset="4" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV"/>
                <enum            extends="VkAccessFlagBits"                 name="VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV" alias="VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR"/>
                <enum            extends="VkImageUsageFlagBits"             name="VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV" alias="VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
                <enum            extends="VkPipelineStageFlagBits"          name="VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV" alias="VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV"/>
                <enum offset="6" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV"/>
                <type name="VkShadingRatePaletteEntryNV"/>
                <type name="VkShadingRatePaletteNV"/>
                <type name="VkPipelineViewportShadingRateImageStateCreateInfoNV"/>
                <type name="VkPhysicalDeviceShadingRateImageFeaturesNV"/>
                <type name="VkPhysicalDeviceShadingRateImagePropertiesNV"/>
                <type name="VkCoarseSampleLocationNV"/>
                <type name="VkCoarseSampleOrderCustomNV"/>
                <type name="VkPipelineViewportCoarseSampleOrderStateCreateInfoNV"/>
                <type name="VkCoarseSampleOrderTypeNV"/>
                <command name="vkCmdBindShadingRateImageNV"/>
                <command name="vkCmdSetViewportShadingRatePaletteNV"/>
                <command name="vkCmdSetCoarseSampleOrderNV"/>
                <feature name="shadingRateImage" struct="VkPhysicalDeviceShadingRateImageFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_ray_tracing" number="166" type="device" depends="(VK_KHR_get_physical_device_properties2+VK_KHR_get_memory_requirements2),VK_VERSION_1_1" author="NV" contact="Eric Werness @ewerness-nv" supported="vulkan" deprecatedby="VK_KHR_ray_tracing_pipeline" nofeatures="true">
            <require>
                <enum value="3"                               name="VK_NV_RAY_TRACING_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_ray_tracing&quot;"   name="VK_NV_RAY_TRACING_EXTENSION_NAME"/>
                <enum                                         name="VK_SHADER_UNUSED_NV" alias="VK_SHADER_UNUSED_KHR"/>
                <enum offset="0"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV"/>
                <enum offset="1"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV"/>
                <enum offset="3"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_GEOMETRY_NV"/>
                <enum offset="4"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV"/>
                <enum offset="5"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV"/>
                <enum offset="6"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV"/>
                <enum offset="7"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV"/>
                <enum offset="8"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV"/>
                <enum offset="9"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV"/>
                <enum offset="11" extends="VkStructureType"   name="VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV"/>
                <enum offset="12" extends="VkStructureType"   name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV"/>
                <enum extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_RAYGEN_BIT_NV" alias="VK_SHADER_STAGE_RAYGEN_BIT_KHR"/>
                <enum extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_ANY_HIT_BIT_NV" alias="VK_SHADER_STAGE_ANY_HIT_BIT_KHR"/>
                <enum extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV" alias="VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR"/>
                <enum extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_MISS_BIT_NV" alias="VK_SHADER_STAGE_MISS_BIT_KHR"/>
                <enum extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_INTERSECTION_BIT_NV" alias="VK_SHADER_STAGE_INTERSECTION_BIT_KHR"/>
                <enum extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_CALLABLE_BIT_NV" alias="VK_SHADER_STAGE_CALLABLE_BIT_KHR"/>
                <enum extends="VkPipelineStageFlagBits"       name="VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV" alias="VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR"/>
                <enum extends="VkPipelineStageFlagBits"       name="VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV" alias="VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"/>
                <enum extends="VkBufferUsageFlagBits"         name="VK_BUFFER_USAGE_RAY_TRACING_BIT_NV" alias="VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR"/>
                <enum extends="VkPipelineBindPoint"           name="VK_PIPELINE_BIND_POINT_RAY_TRACING_NV" alias="VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR"/>
                <enum offset="0" extends="VkDescriptorType"   name="VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV"/>
                <enum extends="VkAccessFlagBits"              name="VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV" alias="VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR"/>
                <enum extends="VkAccessFlagBits"              name="VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV" alias="VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR"/>
                <enum offset="0" extends="VkQueryType"        name="VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV"/>
                <enum bitpos="5" extends="VkPipelineCreateFlagBits"      name="VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV"/>
                <enum offset="0" extends="VkObjectType"       name="VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV"/>
                <enum extends="VkIndexType"                   name="VK_INDEX_TYPE_NONE_NV" alias="VK_INDEX_TYPE_NONE_KHR"/>
                <type name="VkRayTracingShaderGroupCreateInfoNV"/>
                <type name="VkRayTracingShaderGroupTypeNV"/>
                <enum extends="VkRayTracingShaderGroupTypeKHR" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV" alias="VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR"/>
                <enum extends="VkRayTracingShaderGroupTypeKHR" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV" alias="VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR"/>
                <enum extends="VkRayTracingShaderGroupTypeKHR" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV" alias="VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR"/>
                <type name="VkRayTracingPipelineCreateInfoNV"/>
                <type name="VkGeometryTypeNV"/>
                <enum extends="VkGeometryTypeKHR" name="VK_GEOMETRY_TYPE_TRIANGLES_NV" alias="VK_GEOMETRY_TYPE_TRIANGLES_KHR"/>
                <enum extends="VkGeometryTypeKHR" name="VK_GEOMETRY_TYPE_AABBS_NV" alias="VK_GEOMETRY_TYPE_AABBS_KHR"/>
                <type name="VkAccelerationStructureTypeNV"/>
                <enum extends="VkAccelerationStructureTypeKHR" name="VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV" alias="VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR"/>
                <enum extends="VkAccelerationStructureTypeKHR" name="VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV" alias="VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR"/>
                <type name="VkGeometryTrianglesNV"/>
                <type name="VkGeometryAABBNV"/>
                <type name="VkGeometryDataNV"/>
                <type name="VkGeometryNV"/>
                <type name="VkGeometryFlagsNV"/>
                <type name="VkGeometryFlagBitsNV"/>
                <enum extends="VkGeometryFlagBitsKHR" name="VK_GEOMETRY_OPAQUE_BIT_NV" alias="VK_GEOMETRY_OPAQUE_BIT_KHR"/>
                <enum extends="VkGeometryFlagBitsKHR" name="VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV" alias="VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR"/>
                <type name="VkGeometryInstanceFlagsNV"/>
                <type name="VkGeometryInstanceFlagBitsNV"/>
                <enum extends="VkGeometryInstanceFlagBitsKHR" name="VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV" alias="VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR"/>
                <enum extends="VkGeometryInstanceFlagBitsKHR" name="VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV" alias="VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR"/>
                <enum extends="VkGeometryInstanceFlagBitsKHR" name="VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV" alias="VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR"/>
                <enum extends="VkGeometryInstanceFlagBitsKHR" name="VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV" alias="VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR"/>
                <type name="VkAccelerationStructureInfoNV"/>
                <type name="VkAccelerationStructureCreateInfoNV"/>
                <type name="VkAccelerationStructureNV"/>
                <type name="VkBuildAccelerationStructureFlagBitsNV"/>
                <enum extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV" alias="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR"/>
                <enum extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV" alias="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR"/>
                <enum extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV" alias="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR"/>
                <enum extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV" alias="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR"/>
                <enum extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV" alias="VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR"/>
                <type name="VkBuildAccelerationStructureFlagsNV"/>
                <type name="VkCopyAccelerationStructureModeNV"/>
                <enum extends="VkCopyAccelerationStructureModeKHR" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV" alias="VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR"/>
                <enum extends="VkCopyAccelerationStructureModeKHR" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV" alias="VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR"/>
                <type name="VkBindAccelerationStructureMemoryInfoNV"/>
                <type name="VkWriteDescriptorSetAccelerationStructureNV"/>
                <type name="VkAccelerationStructureMemoryRequirementsInfoNV"/>
                <type name="VkPhysicalDeviceRayTracingPropertiesNV"/>
                <type name="VkAccelerationStructureMemoryRequirementsTypeNV"/>
                <type name="VkTransformMatrixNV"/>
                <type name="VkAabbPositionsNV"/>
                <type name="VkAccelerationStructureInstanceNV"/>
                <command name="vkCreateAccelerationStructureNV"/>
                <command name="vkDestroyAccelerationStructureNV"/>
                <command name="vkGetAccelerationStructureMemoryRequirementsNV"/>
                <command name="vkBindAccelerationStructureMemoryNV"/>
                <command name="vkCmdBuildAccelerationStructureNV"/>
                <command name="vkCmdCopyAccelerationStructureNV"/>
                <command name="vkCmdTraceRaysNV"/>
                <command name="vkCreateRayTracingPipelinesNV"/>
                <command name="vkGetRayTracingShaderGroupHandlesNV"/>
                <command name="vkGetAccelerationStructureHandleNV"/>
                <command name="vkCmdWriteAccelerationStructuresPropertiesNV"/>
                <command name="vkCompileDeferredNV"/>
            </require>
            <require depends="VK_KHR_get_memory_requirements2,VK_VERSION_1_1">
                <type name="VkMemoryRequirements2KHR"/>
            </require>
            <require depends="VK_EXT_debug_report">
                <enum offset="0" extends="VkDebugReportObjectTypeEXT" name="VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT"/>
            </require>
        </extension>
        <extension name="VK_NV_representative_fragment_test" number="167" type="device" author="NV" contact="Kedarnath Thangudu @kthangudu" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" supported="vulkan">
            <require>
                <enum value="2"                                             name="VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_representative_fragment_test&quot;" name="VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV"/>
                <type name="VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV"/>
                <type name="VkPipelineRepresentativeFragmentTestStateCreateInfoNV"/>
                <feature name="representativeFragmentTest" struct="VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_168" number="168" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_168_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_168&quot;"               name="VK_NV_EXTENSION_168_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_maintenance3" number="169" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="KHR" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_MAINTENANCE_3_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_maintenance3&quot;"               name="VK_KHR_MAINTENANCE_3_EXTENSION_NAME"/>
                <enum alias="VK_KHR_MAINTENANCE_3_SPEC_VERSION"             name="VK_KHR_MAINTENANCE3_SPEC_VERSION" deprecated="aliased"/>
                <enum alias="VK_KHR_MAINTENANCE_3_EXTENSION_NAME"           name="VK_KHR_MAINTENANCE3_EXTENSION_NAME" deprecated="aliased"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR" alias="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT"/>
                <type name="VkPhysicalDeviceMaintenance3PropertiesKHR"/>
                <type name="VkDescriptorSetLayoutSupportKHR"/>
                <command name="vkGetDescriptorSetLayoutSupportKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_draw_indirect_count" number="170" type="device" author="KHR" contact="Piers Daniell @pdaniell-nv" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_draw_indirect_count&quot;"        name="VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME"/>
                <command name="vkCmdDrawIndirectCountKHR"/>
                <command name="vkCmdDrawIndexedIndirectCountKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_filter_cubic" number="171" type="device" author="QCOM" contact="Matthew Netsch @mnetsch" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="3"                                             name="VK_EXT_FILTER_CUBIC_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_filter_cubic&quot;"               name="VK_EXT_FILTER_CUBIC_EXTENSION_NAME"/>
                <enum offset="0" extends="VkFilter" extnumber="16"          name="VK_FILTER_CUBIC_EXT"/>
                <enum bitpos="13" extends="VkFormatFeatureFlagBits"         name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT"/>
                <type name="VkPhysicalDeviceImageViewImageFormatInfoEXT"/>
                <type name="VkFilterCubicImageViewImageFormatPropertiesEXT"/>
            </require>
        </extension>
        <extension name="VK_QCOM_render_pass_shader_resolve" number="172" type="device" author="QCOM" contact="Matthew Netsch @mnetsch" supported="vulkan" nofeatures="true" promotedto="VK_EXT_custom_resolve">
            <require>
                <enum value="4"                                                 name="VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_render_pass_shader_resolve&quot;"    name="VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME"/>
                <enum extends="VkSubpassDescriptionFlagBits"                    name="VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM" alias="VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_EXT"/>
                <enum extends="VkSubpassDescriptionFlagBits"                    name="VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM" alias="VK_SUBPASS_DESCRIPTION_CUSTOM_RESOLVE_BIT_EXT"/>
            </require>
        </extension>
        <extension name="VK_QCOM_extension_173" number="173" author="QCOM" contact="Matthew Netsch @mnetsch" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_QCOM_EXTENSION_173_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_extension_173&quot;"             name="VK_QCOM_EXTENSION_173_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_QCOM_extension_174" number="174" author="QCOM" contact="Matthew Netsch @mnetsch" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_QCOM_EXTENSION_174_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_extension_174&quot;"             name="VK_QCOM_EXTENSION_174_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_global_priority" number="175" type="device" author="EXT" contact="Andres Rodriguez @lostgoat" supported="vulkan" promotedto="VK_KHR_global_priority" nofeatures="true">
            <require>
                <enum value="2"                                             name="VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_global_priority&quot;"            name="VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO"/>
                <enum extends="VkResult"                                    name="VK_ERROR_NOT_PERMITTED_EXT" alias="VK_ERROR_NOT_PERMITTED"/>
                <enum extends="VkQueueGlobalPriority"                       name="VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT" alias="VK_QUEUE_GLOBAL_PRIORITY_LOW"/>
                <enum extends="VkQueueGlobalPriority"                       name="VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT" alias="VK_QUEUE_GLOBAL_PRIORITY_MEDIUM"/>
                <enum extends="VkQueueGlobalPriority"                       name="VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT" alias="VK_QUEUE_GLOBAL_PRIORITY_HIGH"/>
                <enum extends="VkQueueGlobalPriority"                       name="VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT" alias="VK_QUEUE_GLOBAL_PRIORITY_REALTIME"/>
                <type name="VkDeviceQueueGlobalPriorityCreateInfoEXT"/>
                <type name="VkQueueGlobalPriorityEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_subgroup_extended_types" number="176" type="device" depends="VK_VERSION_1_1" author="KHR" contact="Neil Henning @sheredom" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
            <require>
                <enum value="1"                                                 name="VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_subgroup_extended_types&quot;" name="VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES"/>
                <type name="VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR"/>
                <feature name="shaderSubgroupExtendedTypes" struct="VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_177" number="177" author="EXT" contact="Neil Henning @sheredom" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_177_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_177&quot;"              name="VK_EXT_EXTENSION_177_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_8bit_storage" number="178" type="device" depends="(VK_KHR_get_physical_device_properties2+VK_KHR_storage_buffer_storage_class),VK_VERSION_1_1" author="KHR" contact="Alexander Galazin @alegal-arm" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_8BIT_STORAGE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_8bit_storage&quot;"               name="VK_KHR_8BIT_STORAGE_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES"/>
                <type name="VkPhysicalDevice8BitStorageFeaturesKHR"/>
                <feature name="storageBuffer8BitAccess" struct="VkPhysicalDevice8BitStorageFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_external_memory_host" number="179" type="device" author="EXT" depends="VK_KHR_external_memory,VK_VERSION_1_1" contact="Daniel Rakos @drakos-amd" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_external_memory_host&quot;"       name="VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT"/>
                <enum bitpos="7" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT"/>
                <enum bitpos="8" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT"/>
                <type name="VkImportMemoryHostPointerInfoEXT"/>
                <type name="VkMemoryHostPointerPropertiesEXT"/>
                <type name="VkPhysicalDeviceExternalMemoryHostPropertiesEXT"/>
                <command name="vkGetMemoryHostPointerPropertiesEXT"/>
            </require>
        </extension>
        <extension name="VK_AMD_buffer_marker" number="180" type="device" author="AMD" contact="Daniel Rakos @drakos-amd" specialuse="devtools" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                          name="VK_AMD_BUFFER_MARKER_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_buffer_marker&quot;"           name="VK_AMD_BUFFER_MARKER_EXTENSION_NAME"/>
                <command name="vkCmdWriteBufferMarkerAMD"/>
            </require>
            <require depends="VK_VERSION_1_3,VK_KHR_synchronization2">
                <command name="vkCmdWriteBufferMarker2AMD"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_atomic_int64" number="181" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Aaron Hagan @ahagan" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_atomic_int64&quot;"        name="VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES"/>
                <type name="VkPhysicalDeviceShaderAtomicInt64FeaturesKHR"/>
                <feature name="shaderBufferInt64Atomics" struct="VkPhysicalDeviceShaderAtomicInt64FeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_clock" number="182" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Aaron Hagan @ahagan" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
            <require>
                <enum value="1"                                          name="VK_KHR_SHADER_CLOCK_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_clock&quot;"            name="VK_KHR_SHADER_CLOCK_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR"/>
                <type name="VkPhysicalDeviceShaderClockFeaturesKHR"/>
                <feature name="shaderSubgroupClock" struct="VkPhysicalDeviceShaderClockFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_183" number="183" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_183_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_183&quot;"              name="VK_AMD_EXTENSION_183_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_pipeline_compiler_control" number="184" type="device" author="AMD" contact="Matthaeus G. Chajdas @anteru" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_pipeline_compiler_control&quot;"  name="VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD"/>
                <type name="VkPipelineCompilerControlFlagBitsAMD"/>
                <type name="VkPipelineCompilerControlFlagsAMD"/>
                <type name="VkPipelineCompilerControlCreateInfoAMD"/>
            </require>
        </extension>
        <extension name="VK_EXT_calibrated_timestamps" number="185" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Daniel Rakos @drakos-amd" promotedto="VK_KHR_calibrated_timestamps" supported="vulkan" nofeatures="true">
            <require>
                <enum value="2"                                             name="VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_calibrated_timestamps&quot;"      name="VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT" alias="VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR"/>
                <enum extends="VkTimeDomainKHR"                             name="VK_TIME_DOMAIN_DEVICE_EXT"                       alias="VK_TIME_DOMAIN_DEVICE_KHR"/>
                <enum extends="VkTimeDomainKHR"                             name="VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT"              alias="VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR"/>
                <enum extends="VkTimeDomainKHR"                             name="VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT"          alias="VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR"/>
                <enum extends="VkTimeDomainKHR"                             name="VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT"    alias="VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR"/>
                <type name="VkTimeDomainEXT"/>
                <type name="VkCalibratedTimestampInfoEXT"/>
                <command name="vkGetPhysicalDeviceCalibrateableTimeDomainsEXT"/>
                <command name="vkGetCalibratedTimestampsEXT"/>
            </require>
        </extension>
        <extension name="VK_AMD_shader_core_properties" number="186" type="device" author="AMD" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Martin Dinkov @mdinkov" supported="vulkan" nofeatures="true">
            <require>
                <enum value="2"                                          name="VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_shader_core_properties&quot;"  name="VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD"/>
                <type name="VkPhysicalDeviceShaderCorePropertiesAMD"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_187" number="187" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_187_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_187&quot;"              name="VK_AMD_EXTENSION_187_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_video_decode_h265" number="188" type="device" depends="VK_KHR_video_decode_queue" author="KHR" contact="peter.fang@amd.com" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="8"                                             name="VK_KHR_VIDEO_DECODE_H265_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_video_decode_h265&quot;"          name="VK_KHR_VIDEO_DECODE_H265_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR"/>
                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR"/>
                <enum bitpos="1" extends="VkVideoCodecOperationFlagBitsKHR" name="VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR"/>
                <type name="VkVideoDecodeH265ProfileInfoKHR"/>
                <type name="VkVideoDecodeH265CapabilitiesKHR"/>
                <type name="VkVideoDecodeH265SessionParametersCreateInfoKHR"/>
                <type name="VkVideoDecodeH265SessionParametersAddInfoKHR"/>
                <type name="VkVideoDecodeH265PictureInfoKHR"/>
                <type name="VkVideoDecodeH265DpbSlotInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_global_priority" number="189" type="device" author="KHR" contact="Tobias Hector @tobski" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_4" ratified="vulkan,vulkansc">
            <require>
                <enum value="1"                                             name="VK_KHR_GLOBAL_PRIORITY_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_global_priority&quot;"            name="VK_KHR_GLOBAL_PRIORITY_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES"/>
                <enum extends="VkResult"                                    name="VK_ERROR_NOT_PERMITTED_KHR" alias="VK_ERROR_NOT_PERMITTED"/>
                <enum                                                       name="VK_MAX_GLOBAL_PRIORITY_SIZE_KHR" alias="VK_MAX_GLOBAL_PRIORITY_SIZE"/>
                <enum extends="VkQueueGlobalPriority"                       name="VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR" alias="VK_QUEUE_GLOBAL_PRIORITY_LOW"/>
                <enum extends="VkQueueGlobalPriority"                       name="VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR" alias="VK_QUEUE_GLOBAL_PRIORITY_MEDIUM"/>
                <enum extends="VkQueueGlobalPriority"                       name="VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR" alias="VK_QUEUE_GLOBAL_PRIORITY_HIGH"/>
                <enum extends="VkQueueGlobalPriority"                       name="VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR" alias="VK_QUEUE_GLOBAL_PRIORITY_REALTIME"/>
                <type name="VkDeviceQueueGlobalPriorityCreateInfoKHR"/>
                <type name="VkQueueGlobalPriorityKHR"/>
                <type name="VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR"/>
                <type name="VkQueueFamilyGlobalPriorityPropertiesKHR"/>
                <feature name="globalPriorityQuery" struct="VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_AMD_memory_overallocation_behavior" number="190" type="device" author="AMD" contact="Martin Dinkov @mdinkov" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_memory_overallocation_behavior&quot;"    name="VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD"/>
                <type name="VkMemoryOverallocationBehaviorAMD"/>
                <type name="VkDeviceMemoryOverallocationCreateInfoAMD"/>
            </require>
        </extension>
        <extension name="VK_EXT_vertex_attribute_divisor" number="191" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Vikram Kushwaha @vkushwaha" supported="vulkan" promotedto="VK_KHR_vertex_attribute_divisor">
            <require>
                <enum value="3"                                           name="VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_vertex_attribute_divisor&quot;" name="VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT"/>
                <enum            extends="VkStructureType"                name="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO"/>
                <enum            extends="VkStructureType"                name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES"/>
                <type name="VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT"/>
                <type name="VkVertexInputBindingDivisorDescriptionEXT"/>
                <type name="VkPipelineVertexInputDivisorStateCreateInfoEXT"/>
                <type name="VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT"/>
                <feature name="vertexAttributeInstanceRateDivisor" struct="VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_GGP_frame_token" number="192" type="device" depends="VK_KHR_swapchain+VK_GGP_stream_descriptor_surface" platform="ggp" author="GGP" contact="Jean-Francois Roy @jfroy" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_GGP_FRAME_TOKEN_SPEC_VERSION"/>
                <enum value="&quot;VK_GGP_frame_token&quot;"                    name="VK_GGP_FRAME_TOKEN_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP"/>
                <type name="VkPresentFrameTokenGGP"/>
            </require>
        </extension>
        <extension name="VK_EXT_pipeline_creation_feedback" number="193" type="device" author="GOOGLE" contact="Jean-Francois Roy @jfroy" specialuse="devtools" supported="vulkan" promotedto="VK_VERSION_1_3" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_pipeline_creation_feedback&quot;" name="VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO"/>
                <enum extends="VkPipelineCreationFeedbackFlagBits"          name="VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT" alias="VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT"/>
                <enum extends="VkPipelineCreationFeedbackFlagBits"          name="VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT" alias="VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT"/>
                <enum extends="VkPipelineCreationFeedbackFlagBits"          name="VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT" alias="VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT"/>
                <type name="VkPipelineCreationFeedbackFlagBitsEXT"/>
                <type name="VkPipelineCreationFeedbackFlagsEXT"/>
                <type name="VkPipelineCreationFeedbackCreateInfoEXT"/>
                <type name="VkPipelineCreationFeedbackEXT"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_extension_194" number="194" author="GOOGLE" contact="Jean-Francois Roy @jfroy" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_GOOGLE_EXTENSION_194_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_extension_194&quot;"       name="VK_GOOGLE_EXTENSION_194_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_extension_195" number="195" author="GOOGLE" contact="Jean-Francois Roy @jfroy" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_GOOGLE_EXTENSION_195_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_extension_195&quot;"       name="VK_GOOGLE_EXTENSION_195_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_extension_196" number="196" author="GOOGLE" contact="Jean-Francois Roy @jfroy" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_GOOGLE_EXTENSION_196_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_extension_196&quot;"       name="VK_GOOGLE_EXTENSION_196_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_driver_properties" number="197" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="KHR" contact="Daniel Rakos @drakos-amd" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_driver_properties&quot;"          name="VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES"/>
                <enum                                                       name="VK_MAX_DRIVER_NAME_SIZE_KHR" alias="VK_MAX_DRIVER_NAME_SIZE"/>
                <enum                                                       name="VK_MAX_DRIVER_INFO_SIZE_KHR" alias="VK_MAX_DRIVER_INFO_SIZE"/>
                <type name="VkDriverIdKHR"/>
                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_AMD_PROPRIETARY_KHR" alias="VK_DRIVER_ID_AMD_PROPRIETARY"/>
                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR" alias="VK_DRIVER_ID_AMD_OPEN_SOURCE"/>
                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_MESA_RADV_KHR" alias="VK_DRIVER_ID_MESA_RADV"/>
                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR" alias="VK_DRIVER_ID_NVIDIA_PROPRIETARY"/>
                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR" alias="VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS"/>
                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR" alias="VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA"/>
                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR" alias="VK_DRIVER_ID_IMAGINATION_PROPRIETARY"/>
                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR" alias="VK_DRIVER_ID_QUALCOMM_PROPRIETARY"/>
                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_ARM_PROPRIETARY_KHR" alias="VK_DRIVER_ID_ARM_PROPRIETARY"/>
                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR" alias="VK_DRIVER_ID_GOOGLE_SWIFTSHADER"/>
                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_GGP_PROPRIETARY_KHR" alias="VK_DRIVER_ID_GGP_PROPRIETARY"/>
                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR" alias="VK_DRIVER_ID_BROADCOM_PROPRIETARY"/>
                <type name="VkConformanceVersionKHR"/>
                <type name="VkPhysicalDeviceDriverPropertiesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_float_controls" number="198" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="KHR" contact="Alexander Galazin @alegal-arm" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="4"                                             name="VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_float_controls&quot;"      name="VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES"/>
                <type name="VkPhysicalDeviceFloatControlsPropertiesKHR"/>
                <type name="VkShaderFloatControlsIndependenceKHR"/>
                <enum extends="VkShaderFloatControlsIndependence"           name="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR" alias="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY"/>
                <enum extends="VkShaderFloatControlsIndependence"           name="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR"         alias="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL"/>
                <enum extends="VkShaderFloatControlsIndependence"           name="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR"        alias="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE"/>
            </require>
        </extension>
        <extension name="VK_NV_shader_subgroup_partitioned" number="199" type="device" depends="VK_VERSION_1_1" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_shader_subgroup_partitioned&quot;" name="VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME"/>
                <enum bitpos="8" extends="VkSubgroupFeatureFlagBits"        name="VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV"/>
            </require>
        </extension>
        <extension name="VK_KHR_depth_stencil_resolve" number="200" type="device" depends="VK_KHR_create_renderpass2,VK_VERSION_1_2" author="KHR" contact="Jan-Harald Fredriksen @janharald" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_depth_stencil_resolve&quot;"      name="VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR" alias="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE"/>
                <type name="VkSubpassDescriptionDepthStencilResolveKHR"/>
                <type name="VkPhysicalDeviceDepthStencilResolvePropertiesKHR"/>
                <type name="VkResolveModeFlagBitsKHR"/>
                <type name="VkResolveModeFlagsKHR"/>
                <enum extends="VkResolveModeFlagBits"                       name="VK_RESOLVE_MODE_NONE_KHR" alias="VK_RESOLVE_MODE_NONE"/>
                <enum extends="VkResolveModeFlagBits"                       name="VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR" alias="VK_RESOLVE_MODE_SAMPLE_ZERO_BIT"/>
                <enum extends="VkResolveModeFlagBits"                       name="VK_RESOLVE_MODE_AVERAGE_BIT_KHR" alias="VK_RESOLVE_MODE_AVERAGE_BIT"/>
                <enum extends="VkResolveModeFlagBits"                       name="VK_RESOLVE_MODE_MIN_BIT_KHR" alias="VK_RESOLVE_MODE_MIN_BIT"/>
                <enum extends="VkResolveModeFlagBits"                       name="VK_RESOLVE_MODE_MAX_BIT_KHR" alias="VK_RESOLVE_MODE_MAX_BIT"/>
            </require>
        </extension>
        <extension name="VK_KHR_swapchain_mutable_format" number="201" type="device" author="KHR" depends="VK_KHR_swapchain+(VK_KHR_maintenance2,VK_VERSION_1_1)+(VK_KHR_image_format_list,VK_VERSION_1_2)" contact="Daniel Rakos @drakos-amd" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                         name="VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_swapchain_mutable_format&quot;" name="VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME"/>
                <enum bitpos="2" extends="VkSwapchainCreateFlagBitsKHR" name="VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR"/>
            </require>
        </extension>
        <extension name="VK_NV_compute_shader_derivatives" number="202" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan" promotedto="VK_KHR_compute_shader_derivatives">
            <require>
                <enum value="1"                                         name="VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_compute_shader_derivatives&quot;" name="VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME"/>
                <enum extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR"/>
                <type name="VkPhysicalDeviceComputeShaderDerivativesFeaturesNV"/>
                <feature name="computeDerivativeGroupQuads,computeDerivativeGroupLinear" struct="VkPhysicalDeviceComputeShaderDerivativesFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_mesh_shader" number="203" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Christoph Kubisch @pixeljetstream" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_NV_MESH_SHADER_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_mesh_shader&quot;"             name="VK_NV_MESH_SHADER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV"/>
                <enum extends="VkShaderStageFlagBits"                   name="VK_SHADER_STAGE_TASK_BIT_NV" alias="VK_SHADER_STAGE_TASK_BIT_EXT"/>
                <enum extends="VkShaderStageFlagBits"                   name="VK_SHADER_STAGE_MESH_BIT_NV" alias="VK_SHADER_STAGE_MESH_BIT_EXT"/>
                <enum extends="VkPipelineStageFlagBits"                 name="VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV" alias="VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT"/>
                <enum extends="VkPipelineStageFlagBits"                 name="VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV" alias="VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT"/>
                <command name="vkCmdDrawMeshTasksNV"/>
                <command name="vkCmdDrawMeshTasksIndirectNV"/>
                <type name="VkPhysicalDeviceMeshShaderFeaturesNV"/>
                <type name="VkPhysicalDeviceMeshShaderPropertiesNV"/>
                <type name="VkDrawMeshTasksIndirectCommandNV"/>
                <feature name="meshShader" struct="VkPhysicalDeviceMeshShaderFeaturesNV"/>
            </require>
            <require depends="VK_VERSION_1_2,VK_KHR_draw_indirect_count,VK_AMD_draw_indirect_count">
                <command name="vkCmdDrawMeshTasksIndirectCountNV"/>
            </require>
            <require depends="VK_EXT_device_generated_commands">
                <enum offset="2" extends="VkIndirectCommandsTokenTypeEXT" name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT"/>
                <enum offset="3" extends="VkIndirectCommandsTokenTypeEXT" name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT"/>
            </require>
        </extension>
        <extension name="VK_NV_fragment_shader_barycentric" number="204" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan" promotedto="VK_KHR_fragment_shader_barycentric" nofeatures="true">
            <require>
                <enum value="1"                                         name="VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_fragment_shader_barycentric&quot;" name="VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME"/>
                <enum extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR"/>
                <type name="VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_shader_image_footprint" number="205" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
            <require>
                <enum value="2"                                         name="VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_shader_image_footprint&quot;"  name="VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV"/>
                <type name="VkPhysicalDeviceShaderImageFootprintFeaturesNV"/>
                <feature name="imageFootprint" struct="VkPhysicalDeviceShaderImageFootprintFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_scissor_exclusive" number="206" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
            <require>
                <enum value="2"                                         name="VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_scissor_exclusive&quot;"       name="VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV"/>
                <enum offset="2" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV"/>
                <enum offset="0" extends="VkDynamicState" name="VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV"/>
                <enum offset="1" extends="VkDynamicState" name="VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV"/>
                <type name="VkPipelineViewportExclusiveScissorStateCreateInfoNV"/>
                <type name="VkPhysicalDeviceExclusiveScissorFeaturesNV"/>
                <command name="vkCmdSetExclusiveScissorEnableNV"/>
                <command name="vkCmdSetExclusiveScissorNV"/>
                <feature name="exclusiveScissor" struct="VkPhysicalDeviceExclusiveScissorFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_device_diagnostic_checkpoints" type="device" number="207" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NVIDIA" contact="Nuno Subtil @nsubtil" supported="vulkan" nofeatures="true">
            <require>
                <enum value="2"                                         name="VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_device_diagnostic_checkpoints&quot;" name="VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV"/>
                <type name="VkQueueFamilyCheckpointPropertiesNV"/>
                <type name="VkCheckpointDataNV"/>
                <command name="vkCmdSetCheckpointNV"/>
                <command name="vkGetQueueCheckpointDataNV"/>
            </require>
            <require depends="VK_VERSION_1_3,VK_KHR_synchronization2">
                <type name="VkQueueFamilyCheckpointProperties2NV"/>
                <type name="VkCheckpointData2NV"/>
                <command name="vkGetQueueCheckpointData2NV"/>
                <enum offset="8" extends="VkStructureType" extnumber="315"  name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV"/>
                <enum offset="9" extends="VkStructureType" extnumber="315"  name="VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV"/>
            </require>
        </extension>
        <extension name="VK_KHR_timeline_semaphore" number="208" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Faith Ekstrand @gfxstrand" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
            <require>
                <enum value="2"                                         name="VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_timeline_semaphore&quot;"     name="VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR" alias="VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR" alias="VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR" alias="VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO"/>
                <enum extends="VkSemaphoreType"                             name="VK_SEMAPHORE_TYPE_BINARY_KHR" alias="VK_SEMAPHORE_TYPE_BINARY"/>
                <enum extends="VkSemaphoreType"                             name="VK_SEMAPHORE_TYPE_TIMELINE_KHR" alias="VK_SEMAPHORE_TYPE_TIMELINE"/>
                <enum extends="VkSemaphoreWaitFlagBits"                     name="VK_SEMAPHORE_WAIT_ANY_BIT_KHR" alias="VK_SEMAPHORE_WAIT_ANY_BIT"/>
                <type name="VkSemaphoreTypeKHR"/>
                <type name="VkPhysicalDeviceTimelineSemaphoreFeaturesKHR"/>
                <type name="VkPhysicalDeviceTimelineSemaphorePropertiesKHR"/>
                <type name="VkSemaphoreTypeCreateInfoKHR"/>
                <type name="VkTimelineSemaphoreSubmitInfoKHR"/>
                <type name="VkSemaphoreWaitFlagBitsKHR"/>
                <type name="VkSemaphoreWaitFlagsKHR"/>
                <type name="VkSemaphoreWaitInfoKHR"/>
                <type name="VkSemaphoreSignalInfoKHR"/>
                <command name="vkGetSemaphoreCounterValueKHR"/>
                <command name="vkWaitSemaphoresKHR"/>
                <command name="vkSignalSemaphoreKHR"/>
                <feature name="timelineSemaphore" struct="VkPhysicalDeviceTimelineSemaphoreFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_present_timing" number="209" type="device" depends="VK_KHR_swapchain+VK_KHR_present_id2+VK_KHR_get_surface_capabilities2+VK_KHR_calibrated_timestamps" author="EXT" contact="Lionel Duc @nvlduc" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="3"                                         name="VK_EXT_PRESENT_TIMING_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_present_timing&quot;"         name="VK_EXT_PRESENT_TIMING_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_TIMING_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SWAPCHAIN_TIMING_PROPERTIES_EXT"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SWAPCHAIN_TIME_DOMAIN_PROPERTIES_EXT"/>
                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PRESENT_TIMINGS_INFO_EXT"/>
                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PRESENT_TIMING_INFO_EXT"/>
                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_INFO_EXT"/>
                <enum offset="6" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_PROPERTIES_EXT"/>
                <enum offset="7" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_EXT"/>
                <enum offset="8" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PRESENT_TIMING_SURFACE_CAPABILITIES_EXT"/>
                <enum offset="9" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SWAPCHAIN_CALIBRATED_TIMESTAMP_INFO_EXT"/>
                <enum offset="0" extends="VkTimeDomainKHR"              name="VK_TIME_DOMAIN_PRESENT_STAGE_LOCAL_EXT"/>
                <enum offset="1" extends="VkTimeDomainKHR"              name="VK_TIME_DOMAIN_SWAPCHAIN_LOCAL_EXT"/>
                <enum offset="0" extends="VkResult" dir="-"             name="VK_ERROR_PRESENT_TIMING_QUEUE_FULL_EXT"/>
                <enum bitpos="9" extends="VkSwapchainCreateFlagBitsKHR" name="VK_SWAPCHAIN_CREATE_PRESENT_TIMING_BIT_EXT"/>
                <type name="VkPhysicalDevicePresentTimingFeaturesEXT"/>
                <type name="VkPresentTimingSurfaceCapabilitiesEXT"/>
                <type name="VkSwapchainCalibratedTimestampInfoEXT"/>
                <type name="VkSwapchainTimingPropertiesEXT"/>
                <type name="VkSwapchainTimeDomainPropertiesEXT"/>
                <type name="VkPastPresentationTimingInfoEXT"/>
                <type name="VkPastPresentationTimingPropertiesEXT"/>
                <type name="VkPastPresentationTimingEXT"/>
                <type name="VkPresentTimingsInfoEXT"/>
                <type name="VkPresentTimingInfoEXT"/>
                <type name="VkPresentStageTimeEXT"/>
                <type name="VkPresentStageFlagBitsEXT"/>
                <type name="VkPresentStageFlagsEXT"/>
                <type name="VkPresentTimingInfoFlagBitsEXT"/>
                <type name="VkPresentTimingInfoFlagsEXT"/>
                <type name="VkPastPresentationTimingFlagBitsEXT"/>
                <type name="VkPastPresentationTimingFlagsEXT"/>
                <command name="vkSetSwapchainPresentTimingQueueSizeEXT"/>
                <command name="vkGetSwapchainTimingPropertiesEXT"/>
                <command name="vkGetSwapchainTimeDomainPropertiesEXT"/>
                <command name="vkGetPastPresentationTimingEXT"/>
                <feature name="presentTiming" struct="VkPhysicalDevicePresentTimingFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_INTEL_shader_integer_functions2" number="210" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="INTEL" contact="Ian Romanick @ianromanick" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION"/>
                <enum value="&quot;VK_INTEL_shader_integer_functions2&quot;" name="VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL"/>
                <type name="VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL"/>
                <feature name="shaderIntegerFunctions2" struct="VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL"/>
            </require>
        </extension>
        <extension name="VK_INTEL_performance_query" number="211" type="device" author="INTEL" contact="Lionel Landwerlin @llandwerlin" specialuse="devtools" supported="vulkan" nofeatures="true">
            <require>
                <enum value="2"                                         name="VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION"/>
                <enum value="&quot;VK_INTEL_performance_query&quot;"    name="VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL"/>
                <enum extends="VkStructureType" name="VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL" alias="VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL" deprecated="aliased"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL"/>
                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL"/>
                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL"/>
                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL"/>
                <enum offset="0" extends="VkQueryType"                  name="VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL"/>
                <enum offset="0" extends="VkObjectType"                 name="VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL"/>
                <type name="VkPerformanceConfigurationTypeINTEL"/>
                <type name="VkQueryPoolSamplingModeINTEL"/>
                <type name="VkPerformanceOverrideTypeINTEL"/>
                <type name="VkPerformanceParameterTypeINTEL"/>
                <type name="VkPerformanceValueTypeINTEL"/>
                <type name="VkPerformanceValueDataINTEL"/>
                <type name="VkPerformanceValueINTEL"/>
                <type name="VkInitializePerformanceApiInfoINTEL"/>
                <type name="VkQueryPoolCreateInfoINTEL"/>
                <type name="VkQueryPoolPerformanceQueryCreateInfoINTEL"/>
                <type name="VkPerformanceMarkerInfoINTEL"/>
                <type name="VkPerformanceStreamMarkerInfoINTEL"/>
                <type name="VkPerformanceOverrideInfoINTEL"/>
                <type name="VkPerformanceConfigurationAcquireInfoINTEL"/>
                <type name="VkPerformanceConfigurationINTEL"/>
                <command name="vkInitializePerformanceApiINTEL"/>
                <command name="vkUninitializePerformanceApiINTEL"/>
                <command name="vkCmdSetPerformanceMarkerINTEL"/>
                <command name="vkCmdSetPerformanceStreamMarkerINTEL"/>
                <command name="vkCmdSetPerformanceOverrideINTEL"/>
                <command name="vkAcquirePerformanceConfigurationINTEL"/>
                <command name="vkReleasePerformanceConfigurationINTEL"/>
                <command name="vkQueueSetPerformanceConfigurationINTEL"/>
                <command name="vkGetPerformanceParameterINTEL"/>
            </require>
        </extension>
        <extension name="VK_KHR_vulkan_memory_model" number="212" type="device" author="KHR" contact="Jeff Bolz @jeffbolznv" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
            <require>
                <enum value="3"                                         name="VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_vulkan_memory_model&quot;"    name="VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES"/>
                <type name="VkPhysicalDeviceVulkanMemoryModelFeaturesKHR"/>
                <feature name="vulkanMemoryModel" struct="VkPhysicalDeviceVulkanMemoryModelFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_pci_bus_info" number="213" type="device" author="EXT" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Matthaeus G. Chajdas @anteru" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="2"                                         name="VK_EXT_PCI_BUS_INFO_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_pci_bus_info&quot;"           name="VK_EXT_PCI_BUS_INFO_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT"/>
                <type name="VkPhysicalDevicePCIBusInfoPropertiesEXT"/>
            </require>
        </extension>
        <extension name="VK_AMD_display_native_hdr" number="214" type="device" author="AMD" depends="(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_get_surface_capabilities2+VK_KHR_swapchain" contact="Matthaeus G. Chajdas @anteru" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                         name="VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_display_native_hdr&quot;"     name="VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD"/>
                <enum offset="0" extends="VkColorSpaceKHR"              name="VK_COLOR_SPACE_DISPLAY_NATIVE_AMD"/>
                <type name="VkDisplayNativeHdrSurfaceCapabilitiesAMD"/>
                <type name="VkSwapchainDisplayNativeHdrCreateInfoAMD"/>
                <command name="vkSetLocalDimmingAMD"/>
            </require>
        </extension>
        <extension name="VK_FUCHSIA_imagepipe_surface" number="215" type="instance" author="FUCHSIA" depends="VK_KHR_surface" platform="fuchsia" contact="Craig Stout @cdotstout" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                         name="VK_FUCHSIA_IMAGEPIPE_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_FUCHSIA_imagepipe_surface&quot;"  name="VK_FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA"/>
                <type name="VkImagePipeSurfaceCreateFlagsFUCHSIA"/>
                <type name="VkImagePipeSurfaceCreateInfoFUCHSIA"/>
                <command name="vkCreateImagePipeSurfaceFUCHSIA"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_terminate_invocation" number="216" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Jesse Hall @critsec" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3" ratified="vulkan,vulkansc">
            <require>
                <enum value="1"                                                 name="VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_terminate_invocation&quot;"    name="VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES"/>
                <type name="VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR"/>
                <feature name="shaderTerminateInvocation" struct="VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_extension_217" number="217" author="GOOGLE" contact="Jesse Hall @critsec" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_GOOGLE_EXTENSION_217_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_extension_217&quot;"           name="VK_GOOGLE_EXTENSION_217_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_metal_surface" number="218" type="instance" depends="VK_KHR_surface" platform="metal" supported="vulkan" ratified="vulkan" author="EXT" contact="Dzmitry Malyshau @kvark" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_METAL_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_metal_surface&quot;"              name="VK_EXT_METAL_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT"/>
                <type name="VkMetalSurfaceCreateFlagsEXT"/>
                <type name="VkMetalSurfaceCreateInfoEXT"/>
                <command name="vkCreateMetalSurfaceEXT"/>
                <type name="CAMetalLayer"/>
            </require>
        </extension>
        <extension name="VK_EXT_fragment_density_map" number="219" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Matthew Netsch @mnetsch" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="2"                                             name="VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_fragment_density_map&quot;"       name="VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT"/>
                <enum offset="1"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT"/>
                <enum offset="2"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT"/>
                <enum bitpos="14" extends="VkImageCreateFlagBits"           name="VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT"/>
                <enum offset="0"  extends="VkImageLayout"                   name="VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT"/>
                <enum bitpos="24" extends="VkAccessFlagBits"                name="VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT"/>
                <enum bitpos="24" extends="VkFormatFeatureFlagBits"         name="VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT"/>
                <enum bitpos="9"  extends="VkImageUsageFlagBits"            name="VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT"/>
                <enum bitpos="0"  extends="VkImageViewCreateFlagBits"       name="VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT"/>
                <enum bitpos="23" extends="VkPipelineStageFlagBits"         name="VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT"/>
                <enum bitpos="0"  extends="VkSamplerCreateFlagBits"         name="VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT"/>
                <enum bitpos="1"  extends="VkSamplerCreateFlagBits"         name="VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT"/>
                <type name="VkPhysicalDeviceFragmentDensityMapFeaturesEXT"/>
                <type name="VkPhysicalDeviceFragmentDensityMapPropertiesEXT"/>
                <type name="VkRenderPassFragmentDensityMapCreateInfoEXT"/>
                <feature name="fragmentDensityMap" struct="VkPhysicalDeviceFragmentDensityMapFeaturesEXT"/>
            </require>
            <require depends="VK_KHR_format_feature_flags2,VK_VERSION_1_3">
                <enum bitpos="24" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT"/>
            </require>
            <require depends="VK_VERSION_1_3,VK_KHR_dynamic_rendering">
                <enum bitpos="22" extends="VkPipelineCreateFlagBits"                name="VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT"/>
                <enum alias="VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT" extends="VkPipelineCreateFlagBits" name="VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT" deprecated="aliased"/>
                <enum offset="7" extends="VkStructureType" extnumber="45"           name="VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT"/>
                <type name="VkRenderingFragmentDensityMapAttachmentInfoEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_220" number="220" author="EXT" contact="Dzmitry Malyshau @kvark" supported="disabled">
            <require>
                <enum value="0"                                              name="VK_EXT_EXTENSION_220_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_220&quot;"               name="VK_EXT_EXTENSION_220_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_221" number="221" author="KHR" contact="Tobias Hector @tobski" supported="disabled">
            <require>
                <enum value="0"                                              name="VK_KHR_EXTENSION_221_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_221&quot;"               name="VK_KHR_EXTENSION_221_EXTENSION_NAME"/>
                <enum bitpos="0" extends="VkRenderPassCreateFlagBits"        name="VK_RENDER_PASS_CREATE_RESERVED_0_BIT_KHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_scalar_block_layout" number="222" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" type="device" author="EXT" contact="Tobias Hector @tobski" supported="vulkan" promotedto="VK_VERSION_1_2">
            <require>
                <enum value="1"                                             name="VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_scalar_block_layout&quot;"        name="VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME"/>
                <type name="VkPhysicalDeviceScalarBlockLayoutFeaturesEXT"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES"/>
                <feature name="scalarBlockLayout" struct="VkPhysicalDeviceScalarBlockLayoutFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_223" number="223" author="EXT" contact="Tobias Hector @tobski" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_223_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_223&quot;"              name="VK_EXT_EXTENSION_223_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_hlsl_functionality1" number="224" type="device" author="GOOGLE" contact="Hai Nguyen @chaoticbob" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_hlsl_functionality1&quot;"     name="VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME"/>
                <enum alias="VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION"   name="VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION" deprecated="aliased"/>
                <enum alias="VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME" name="VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME" deprecated="aliased"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_decorate_string" number="225" type="device" author="GOOGLE" contact="Hai Nguyen @chaoticbob" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_GOOGLE_DECORATE_STRING_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_decorate_string&quot;"         name="VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_subgroup_size_control" number="226" type="device" depends="VK_VERSION_1_1" author="EXT" contact="Neil Henning @sheredom" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3" ratified="vulkansc">
            <require>
                <enum value="2"                                             name="VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_subgroup_size_control&quot;"      name="VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME"/>
                <type                                                       name="VkPhysicalDeviceSubgroupSizeControlFeaturesEXT"/>
                <type                                                       name="VkPhysicalDeviceSubgroupSizeControlPropertiesEXT"/>
                <type                                                       name="VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES"/>
                <enum extends="VkPipelineShaderStageCreateFlagBits"         name="VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT" alias="VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT"/>
                <enum extends="VkPipelineShaderStageCreateFlagBits"         name="VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT" alias="VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT"/>
                <feature name="subgroupSizeControl" struct="VkPhysicalDeviceSubgroupSizeControlFeatures"/>
                <feature name="computeFullSubgroups" struct="VkPhysicalDeviceSubgroupSizeControlFeatures"/>
            </require>
        </extension>
        <extension name="VK_KHR_fragment_shading_rate" number="227" type="device" depends="((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_create_renderpass2),VK_VERSION_1_2" author="KHR" contact="Tobias Hector @tobski" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
            <require>
                <enum value="2"                                                 name="VK_KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_fragment_shading_rate&quot;"          name="VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME"/>
                <type name="VkFragmentShadingRateCombinerOpKHR"/>
                <type name="VkFragmentShadingRateAttachmentInfoKHR"/>
                <type name="VkPipelineFragmentShadingRateStateCreateInfoKHR"/>
                <type name="VkPhysicalDeviceFragmentShadingRateFeaturesKHR"/>
                <type name="VkPhysicalDeviceFragmentShadingRatePropertiesKHR"/>
                <type name="VkPhysicalDeviceFragmentShadingRateKHR"/>
                <command name="vkGetPhysicalDeviceFragmentShadingRatesKHR"/>
                <command name="vkCmdSetFragmentShadingRateKHR"/>
                <enum offset="3" extends="VkImageLayout" extnumber="165"        name="VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR"/>
                <enum offset="0" extends="VkDynamicState"                       name="VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR"/>
                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR"/>
                <enum offset="3" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR"/>
                <enum offset="4" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR"/>
                <enum bitpos="23" extends="VkAccessFlagBits"                    name="VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR"/>
                <enum bitpos="8" extends="VkImageUsageFlagBits"                 name="VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
                <enum bitpos="22" extends="VkPipelineStageFlagBits"             name="VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
                <enum bitpos="30" extends="VkFormatFeatureFlagBits"             name="VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
                <feature name="pipelineFragmentShadingRate" struct="VkPhysicalDeviceFragmentShadingRateFeaturesKHR"/>
            </require>
            <require depends="VK_KHR_format_feature_flags2,VK_VERSION_1_3">
                <enum bitpos="30" extends="VkFormatFeatureFlagBits2"            name="VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
            </require>
            <require depends="VK_VERSION_1_3,VK_KHR_dynamic_rendering">
                <enum offset="6" extends="VkStructureType" extnumber="45"       name="VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"/>
            </require>
            <require depends="VK_VERSION_1_3,VK_KHR_dynamic_rendering" api="vulkan" comment="Remove 'api' attribute once gitlab #4074 is fixed">
                <enum bitpos="21" extends="VkPipelineCreateFlagBits"            name="VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
                <enum alias="VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR" extends="VkPipelineCreateFlagBits" name="VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR" deprecated="aliased"/>
                <type name="VkRenderingFragmentShadingRateAttachmentInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_AMD_shader_core_properties2" number="228" type="device" author="AMD" contact="Matthaeus G. Chajdas @anteru" supported="vulkan" depends="VK_AMD_shader_core_properties" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_shader_core_properties2&quot;"    name="VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD"/>
                <type                                                       name="VkPhysicalDeviceShaderCoreProperties2AMD"/>
                <type                                                       name="VkShaderCorePropertiesFlagBitsAMD"/>
                <type                                                       name="VkShaderCorePropertiesFlagsAMD"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_229" number="229" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_229_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_229&quot;"              name="VK_AMD_EXTENSION_229_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_device_coherent_memory" number="230" type="device" author="AMD" contact="Tobias Hector @tobski" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_device_coherent_memory&quot;"     name="VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME"/>
                <enum bitpos="6" extends="VkMemoryPropertyFlagBits"         name="VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD"/>
                <enum bitpos="7" extends="VkMemoryPropertyFlagBits"         name="VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD"/>
                <type                                                       name="VkPhysicalDeviceCoherentMemoryFeaturesAMD"/>
                <feature name="deviceCoherentMemory"                        struct="VkPhysicalDeviceCoherentMemoryFeaturesAMD"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_231" number="231" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_231_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_231&quot;"              name="VK_AMD_EXTENSION_231_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_232" number="232" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_232_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_232&quot;"              name="VK_AMD_EXTENSION_232_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_dynamic_rendering_local_read" number="233" type="device" depends="VK_KHR_dynamic_rendering,VK_VERSION_1_3" author="AMD" contact="Tobias Hector @tobski" supported="vulkan" promotedto="VK_VERSION_1_4" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_dynamic_rendering_local_read&quot;" name="VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_EXTENSION_NAME"/>
                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR" alias="VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ"/>
                <command name="vkCmdSetRenderingAttachmentLocationsKHR"/>
                <command name="vkCmdSetRenderingInputAttachmentIndicesKHR"/>
                <type name="VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR"/>
                <type name="VkRenderingAttachmentLocationInfoKHR"/>
                <type name="VkRenderingInputAttachmentIndexInfoKHR"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR" alias="VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR" alias="VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO"/>
                <feature name="dynamicRenderingLocalRead" struct="VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR"/>
            </require>
            <deprecate explanationlink="legacy-dynamicrendering">
                <type name="VkRenderPass"/>
                <type name="VkRenderPassFragmentDensityMapCreateInfoEXT"/>
                <command name="vkCreateRenderPass2"/>
                <type name="VkRenderPassCreateInfo2"/>
                <type name="VkRenderPassCreationControlEXT"/>
                <type name="VkRenderPassCreationFeedbackCreateInfoEXT"/>
                <type name="VkRenderPassCreationFeedbackInfoEXT"/>
                <type name="VkAttachmentDescription2"/>
                <type name="VkAttachmentDescriptionStencilLayout"/>
                <type name="VkSubpassDescription2"/>
                <type name="VkFragmentShadingRateAttachmentInfoKHR"/>
                <type name="VkRenderPassSubpassFeedbackCreateInfoEXT"/>
                <type name="VkRenderPassSubpassFeedbackInfoEXT"/>
                <type name="VkSubpassDescriptionDepthStencilResolve"/>
                <type name="VkAttachmentReference2"/>
                <type name="VkSubpassDependency2"/>
                <command name="vkDestroyRenderPass"/>
                <type name="VkFramebuffer"/>
                <command name="vkCreateFramebuffer"/>
                <type name="VkFramebufferCreateInfo"/>
                <type name="VkFramebufferCreateFlagBits"/>
                <type name="VkFramebufferCreateFlags"/>
                <type name="VkFramebufferAttachmentsCreateInfo"/>
                <type name="VkFramebufferAttachmentImageInfo"/>
                <command name="vkDestroyFramebuffer"/>
                <command name="vkGetRenderAreaGranularity"/>
                <type name="VkRenderPassBeginInfo"/>
                <type name="VkRenderPassAttachmentBeginInfo"/>
                <type name="VkRenderPassSampleLocationsBeginInfoEXT"/>
                <type name="VkAttachmentSampleLocationsEXT"/>
                <type name="VkSubpassSampleLocationsEXT"/>
                <type name="VkSubpassContents"/>
                <command name="vkCmdBeginRenderPass2"/>
                <command name="vkCmdNextSubpass2"/>
                <type name="VkSubpassBeginInfo"/>
                <type name="VkSubpassEndInfo"/>
                <command name="vkCmdEndRenderPass2"/>
            </deprecate>
        </extension>
        <extension name="VK_AMD_extension_234" number="234" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_234_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_234&quot;"              name="VK_AMD_EXTENSION_234_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_image_atomic_int64" number="235" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Tobias Hector @tobski" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
            <require>
                <enum value="1"                                             name="VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_image_atomic_int64&quot;"  name="VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT"/>
                <feature name="shaderInt64" struct="VkPhysicalDeviceFeatures"/>
                <feature name="shaderImageInt64Atomics" struct="VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_quad_control" number="236" type="device" depends="((VK_VERSION_1_1+VK_KHR_vulkan_memory_model),VK_VERSION_1_2)+VK_KHR_shader_maximal_reconvergence" author="KHR" contact="Tobias Hector @tobski" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_SHADER_QUAD_CONTROL_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_quad_control&quot;"          name="VK_KHR_SHADER_QUAD_CONTROL_EXTENSION_NAME"/>
                <type                                                       name="VkPhysicalDeviceShaderQuadControlFeaturesKHR"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR"/>
                <feature name="shaderQuadControl" struct="VkPhysicalDeviceShaderQuadControlFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_spirv_1_4" number="237" type="device" depends="VK_VERSION_1_1+VK_KHR_shader_float_controls" author="KHR" contact="Jesse Hall @critsec" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_SPIRV_1_4_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_spirv_1_4&quot;"                  name="VK_KHR_SPIRV_1_4_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_memory_budget" number="238" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Jeff Bolz @jeffbolznv" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_MEMORY_BUDGET_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_memory_budget&quot;"              name="VK_EXT_MEMORY_BUDGET_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT"/>
                <type name="VkPhysicalDeviceMemoryBudgetPropertiesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_memory_priority" number="239" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1"  author="EXT" contact="Jeff Bolz @jeffbolznv" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_MEMORY_PRIORITY_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_memory_priority&quot;"            name="VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT"/>
                <type name="VkPhysicalDeviceMemoryPriorityFeaturesEXT"/>
                <type name="VkMemoryPriorityAllocateInfoEXT"/>
                <feature name="memoryPriority" struct="VkPhysicalDeviceMemoryPriorityFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_surface_protected_capabilities" number="240" type="instance" depends="VK_VERSION_1_1+VK_KHR_get_surface_capabilities2" author="KHR" contact="Sandeep Shinde @sashinde" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_surface_protected_capabilities&quot;"   name="VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR"/>
                <type name="VkSurfaceProtectedCapabilitiesKHR"/>
            </require>
        </extension>
        <extension name="VK_NV_dedicated_allocation_image_aliasing" number="241" type="device" depends="(VK_KHR_dedicated_allocation+VK_KHR_get_physical_device_properties2),VK_VERSION_1_1" author="NVIDIA" contact="Nuno Subtil @nsubtil" supported="vulkan">
            <require>
                <enum value="1"                                                         name="VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_dedicated_allocation_image_aliasing&quot;"     name="VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV"/>
                <type name="VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV"/>
                <feature name="dedicatedAllocationImageAliasing" struct="VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_KHR_separate_depth_stencil_layouts" number="242" type="device" depends="((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_create_renderpass2),VK_VERSION_1_2" author="KHR" contact="Piers Daniell @pdaniell-nv" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
            <require>
                <enum value="1"                                                   name="VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_separate_depth_stencil_layouts&quot;"   name="VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR" alias="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR" alias="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT"/>
                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL"/>
                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL"/>
                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL"/>
                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL"/>
                <type name="VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR"/>
                <type name="VkAttachmentReferenceStencilLayoutKHR"/>
                <type name="VkAttachmentDescriptionStencilLayoutKHR"/>
                <feature name="separateDepthStencilLayouts" struct="VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_INTEL_extension_243" number="243" author="INTEL" contact="Slawek Grajewski @sgrajewski" supported="disabled">
            <require>
                <enum value="0"                                              name="VK_INTEL_EXTENSION_243_SPEC_VERSION"/>
                <enum value="&quot;VK_INTEL_extension_243&quot;"             name="VK_INTEL_EXTENSION_243_EXTENSION_NAME"/>
                <enum bitpos="46" extends="VkAccessFlagBits2"                name="VK_ACCESS_2_RESERVED_46_BIT_INTEL"/>
            </require>
        </extension>
        <extension name="VK_MESA_extension_244" number="244" author="MESA" contact="Andres Rodriguez @lostgoat" supported="disabled">
            <require>
                <enum value="0"                                              name="VK_MESA_EXTENSION_244_SPEC_VERSION"/>
                <enum value="&quot;VK_MESA_extension_244&quot;"              name="VK_MESA_EXTENSION_244_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_buffer_device_address" number="245" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Jeff Bolz @jeffbolznv"  deprecatedby="VK_KHR_buffer_device_address" supported="vulkan">
            <require>
                <enum value="2"                                             name="VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_buffer_device_address&quot;"      name="VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT" alias="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT"/>
                <enum extends="VkBufferUsageFlagBits"                       name="VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT" alias="VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT"/>
                <enum extends="VkBufferCreateFlagBits"                      name="VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT" alias="VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"/>
                <enum extends="VkResult"                                    name="VK_ERROR_INVALID_DEVICE_ADDRESS_EXT" alias="VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS"/>
                <type name="VkPhysicalDeviceBufferAddressFeaturesEXT"/>
                <type name="VkPhysicalDeviceBufferDeviceAddressFeaturesEXT"/>
                <type name="VkBufferDeviceAddressInfoEXT"/>
                <type name="VkBufferDeviceAddressCreateInfoEXT"/>
                <command name="vkGetBufferDeviceAddressEXT"/>
                <feature name="bufferDeviceAddress" struct="VkPhysicalDeviceBufferDeviceAddressFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_tooling_info" number="246" type="device" author="EXT" contact="Tobias Hector @tobski" supported="vulkan" promotedto="VK_VERSION_1_3" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_TOOLING_INFO_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_tooling_info&quot;"               name="VK_EXT_TOOLING_INFO_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES"/>
                <enum extends="VkToolPurposeFlagBits"                       name="VK_TOOL_PURPOSE_VALIDATION_BIT_EXT" alias="VK_TOOL_PURPOSE_VALIDATION_BIT"/>
                <enum extends="VkToolPurposeFlagBits"                       name="VK_TOOL_PURPOSE_PROFILING_BIT_EXT" alias="VK_TOOL_PURPOSE_PROFILING_BIT"/>
                <enum extends="VkToolPurposeFlagBits"                       name="VK_TOOL_PURPOSE_TRACING_BIT_EXT" alias="VK_TOOL_PURPOSE_TRACING_BIT"/>
                <enum extends="VkToolPurposeFlagBits"                       name="VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT" alias="VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT"/>
                <enum extends="VkToolPurposeFlagBits"                       name="VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT"  alias="VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT"/>
                <type                                                       name="VkToolPurposeFlagBitsEXT"/>
                <type                                                       name="VkToolPurposeFlagsEXT"/>
                <type                                                       name="VkPhysicalDeviceToolPropertiesEXT"/>
                <command                                                    name="vkGetPhysicalDeviceToolPropertiesEXT"/>
            </require>
            <require depends="VK_EXT_debug_report">
                <enum bitpos="5" extends="VkToolPurposeFlagBits"            name="VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT"/>
            </require>
            <require depends="VK_EXT_debug_marker">
                <enum bitpos="6" extends="VkToolPurposeFlagBits"            name="VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT"/>
            </require>
            <require depends="VK_EXT_debug_utils">
                <enum bitpos="5" extends="VkToolPurposeFlagBits"            name="VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT"/>
                <enum bitpos="6" extends="VkToolPurposeFlagBits"            name="VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_separate_stencil_usage" number="247" type="device" author="EXT" contact="Daniel Rakos @drakos-amd" supported="vulkan" promotedto="VK_VERSION_1_2" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_separate_stencil_usage&quot;"     name="VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO"/>
                <type name="VkImageStencilUsageCreateInfoEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_validation_features" number="248" type="instance" author="LUNARG" contact="Karl Schultz @karl-lunarg" specialuse="debugging" supported="vulkan,vulkansc" ratified="vulkan" deprecatedby="VK_EXT_layer_settings" nofeatures="true">
            <require>
                <enum value="6"                                             name="VK_EXT_VALIDATION_FEATURES_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_validation_features&quot;"        name="VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT"/>
                <type name="VkValidationFeaturesEXT"/>
                <type name="VkValidationFeatureEnableEXT"/>
                <type name="VkValidationFeatureDisableEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_present_wait" number="249" type="device" depends="VK_KHR_swapchain+VK_KHR_present_id" author="KHR" contact="Keith Packard @keithp" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_PRESENT_WAIT_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_present_wait&quot;"           name="VK_KHR_PRESENT_WAIT_EXTENSION_NAME"/>
                <command name="vkWaitForPresentKHR"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR"/>
                <type name="VkPhysicalDevicePresentWaitFeaturesKHR"/>
                <feature name="presentWait" struct="VkPhysicalDevicePresentWaitFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_NV_cooperative_matrix" number="250" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
            <require>
                <enum value="1"                                              name="VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_cooperative_matrix&quot;"           name="VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV"/>
                <enum offset="2" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV"/>
                <type name="VkCooperativeMatrixPropertiesNV"/>
                <type name="VkScopeNV"/>
                <enum extends="VkScopeKHR" name="VK_SCOPE_DEVICE_NV"         alias="VK_SCOPE_DEVICE_KHR"/>
                <enum extends="VkScopeKHR" name="VK_SCOPE_WORKGROUP_NV"      alias="VK_SCOPE_WORKGROUP_KHR"/>
                <enum extends="VkScopeKHR" name="VK_SCOPE_SUBGROUP_NV"       alias="VK_SCOPE_SUBGROUP_KHR"/>
                <enum extends="VkScopeKHR" name="VK_SCOPE_QUEUE_FAMILY_NV"   alias="VK_SCOPE_QUEUE_FAMILY_KHR"/>
                <type name="VkComponentTypeNV"/>
                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_FLOAT16_NV"  alias="VK_COMPONENT_TYPE_FLOAT16_KHR"/>
                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_FLOAT32_NV"  alias="VK_COMPONENT_TYPE_FLOAT32_KHR"/>
                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_FLOAT64_NV"  alias="VK_COMPONENT_TYPE_FLOAT64_KHR"/>
                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_SINT8_NV"    alias="VK_COMPONENT_TYPE_SINT8_KHR"/>
                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_SINT16_NV"   alias="VK_COMPONENT_TYPE_SINT16_KHR"/>
                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_SINT32_NV"   alias="VK_COMPONENT_TYPE_SINT32_KHR"/>
                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_SINT64_NV"   alias="VK_COMPONENT_TYPE_SINT64_KHR"/>
                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_UINT8_NV"    alias="VK_COMPONENT_TYPE_UINT8_KHR"/>
                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_UINT16_NV"   alias="VK_COMPONENT_TYPE_UINT16_KHR"/>
                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_UINT32_NV"   alias="VK_COMPONENT_TYPE_UINT32_KHR"/>
                <enum extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_UINT64_NV"   alias="VK_COMPONENT_TYPE_UINT64_KHR"/>
                <type name="VkPhysicalDeviceCooperativeMatrixFeaturesNV"/>
                <type name="VkPhysicalDeviceCooperativeMatrixPropertiesNV"/>
                <command name="vkGetPhysicalDeviceCooperativeMatrixPropertiesNV"/>
                <feature name="cooperativeMatrix" struct="VkPhysicalDeviceCooperativeMatrixFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_coverage_reduction_mode" number="251" depends="VK_NV_framebuffer_mixed_samples+(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)" type="device" author="NV" contact="Kedarnath Thangudu @kthangudu" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_coverage_reduction_mode&quot;"     name="VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV"/>
                <type name="VkPhysicalDeviceCoverageReductionModeFeaturesNV"/>
                <type name="VkPipelineCoverageReductionStateCreateInfoNV"/>
                <type name="VkPipelineCoverageReductionStateCreateFlagsNV"/>
                <type name="VkCoverageReductionModeNV"/>
                <type name="VkFramebufferMixedSamplesCombinationNV"/>
                <command name="vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV"/>
                <feature name="coverageReductionMode" struct="VkPhysicalDeviceCoverageReductionModeFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_EXT_fragment_shader_interlock" number="252" author="EXT" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Piers Daniell @pdaniell-nv" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
            <require>
                <enum value="1"                                                 name="VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_fragment_shader_interlock&quot;"      name="VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT"/>
                <feature name="fragmentShaderSampleInterlock,fragmentShaderPixelInterlock,fragmentShaderShadingRateInterlock" struct="VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_ycbcr_image_arrays" number="253" type="device" depends="VK_KHR_sampler_ycbcr_conversion,VK_VERSION_1_1" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
            <require>
                <enum value="1"                                             name="VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_ycbcr_image_arrays&quot;"         name="VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceYcbcrImageArraysFeaturesEXT"/>
                <feature name="ycbcrImageArrays" struct="VkPhysicalDeviceYcbcrImageArraysFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_uniform_buffer_standard_layout" number="254" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" type="device" author="KHR" contact="Graeme Leese @gnl21" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
            <require>
                <enum value="1"                                                 name="VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_uniform_buffer_standard_layout&quot;" name="VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME"/>
                <type                                                           name="VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES"/>
                <feature name="uniformBufferStandardLayout" struct="VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_provoking_vertex" number="255" type="device" author="EXT" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Jesse Hall @jessehall" specialuse="glemulation" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_PROVOKING_VERTEX_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_provoking_vertex&quot;"           name="VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT"/>
                <type name="VkPhysicalDeviceProvokingVertexFeaturesEXT"/>
                <type name="VkPhysicalDeviceProvokingVertexPropertiesEXT"/>
                <type name="VkPipelineRasterizationProvokingVertexStateCreateInfoEXT"/>
                <type name="VkProvokingVertexModeEXT"/>
                <feature name="provokingVertexLast" struct="VkPhysicalDeviceProvokingVertexFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_full_screen_exclusive" number="256" type="device" author="EXT" depends="(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_surface+VK_KHR_get_surface_capabilities2+VK_KHR_swapchain" platform="win32" contact="James Jones @cubanismo" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="4"                                             name="VK_EXT_FULL_SCREEN_EXCLUSIVE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_full_screen_exclusive&quot;"      name="VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT"/>
                <enum offset="0" extends="VkResult" dir="-"                 name="VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT"/>
                <type name="VkFullScreenExclusiveEXT"/>
                <type name="VkSurfaceFullScreenExclusiveInfoEXT"/>
                <type name="VkSurfaceCapabilitiesFullScreenExclusiveEXT"/>
                <command name="vkGetPhysicalDeviceSurfacePresentModes2EXT"/>
                <command name="vkAcquireFullScreenExclusiveModeEXT"/>
                <command name="vkReleaseFullScreenExclusiveModeEXT"/>
            </require>
            <require depends="VK_KHR_win32_surface">
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT"/>
                <type name="VkSurfaceFullScreenExclusiveWin32InfoEXT"/>
            </require>
            <require depends="VK_KHR_device_group,VK_VERSION_1_1">
                <command name="vkGetDeviceGroupSurfacePresentModes2EXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_headless_surface" number="257" type="instance" depends="VK_KHR_surface" author="EXT" contact="Lisa Wu @chengtianww" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_EXT_HEADLESS_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_headless_surface&quot;"               name="VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT"/>
                <type name="VkHeadlessSurfaceCreateFlagsEXT"/>
                <type name="VkHeadlessSurfaceCreateInfoEXT"/>
                <command name="vkCreateHeadlessSurfaceEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_buffer_device_address" number="258" type="device" depends="(VK_KHR_get_physical_device_properties2+VK_KHR_device_group),VK_VERSION_1_1" author="KHR" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_2" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_buffer_device_address&quot;"      name="VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR" alias="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO"/>
                <enum extends="VkBufferUsageFlagBits"                       name="VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR" alias="VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT"/>
                <enum extends="VkBufferCreateFlagBits"                      name="VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR" alias="VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"/>
                <enum extends="VkMemoryAllocateFlagBits"                    name="VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR" alias="VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT"/>
                <enum extends="VkMemoryAllocateFlagBits"                    name="VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR" alias="VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"/>
                <enum extends="VkResult"                                    name="VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR" alias="VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS"/>
                <type name="VkPhysicalDeviceBufferDeviceAddressFeaturesKHR"/>
                <type name="VkBufferDeviceAddressInfoKHR"/>
                <type name="VkBufferOpaqueCaptureAddressCreateInfoKHR"/>
                <type name="VkMemoryOpaqueCaptureAddressAllocateInfoKHR"/>
                <type name="VkDeviceMemoryOpaqueCaptureAddressInfoKHR"/>
                <command name="vkGetBufferDeviceAddressKHR"/>
                <command name="vkGetBufferOpaqueCaptureAddressKHR"/>
                <command name="vkGetDeviceMemoryOpaqueCaptureAddressKHR"/>
                <feature name="bufferDeviceAddress" struct="VkPhysicalDeviceBufferDeviceAddressFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_259" number="259" author="EXT" contact="Matthew Netsch @mnetsch" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_259_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_259&quot;"              name="VK_EXT_EXTENSION_259_EXTENSION_NAME"/>
            </require>
            <require depends="(VK_KHR_dynamic_rendering,VK_VERSION_1_3)+(VK_KHR_maintenance5,VK_VERSION_1_4)">
                <enum bitpos="44" extends="VkPipelineCreateFlagBits2"       name="VK_PIPELINE_CREATE_RESERVED_44_BIT_KHR"/>
            </require>
            <require depends="VK_EXT_shader_object">
                <enum bitpos="16"  extends="VkShaderCreateFlagBitsEXT"      name="VK_SHADER_CREATE_RESERVED_16_BIT_KHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_line_rasterization" number="260" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Jeff Bolz @jeffbolznv" specialuse="cadsupport" supported="vulkan,vulkansc" promotedto="VK_KHR_line_rasterization">
            <require>
                <enum value="1"                                             name="VK_EXT_LINE_RASTERIZATION_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_line_rasterization&quot;"         name="VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES"/>
                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_LINE_STIPPLE_EXT" alias="VK_DYNAMIC_STATE_LINE_STIPPLE"/>
                <enum extends="VkLineRasterizationMode"                     name="VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT" alias="VK_LINE_RASTERIZATION_MODE_DEFAULT"/>
                <enum extends="VkLineRasterizationMode"                     name="VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT" alias="VK_LINE_RASTERIZATION_MODE_RECTANGULAR"/>
                <enum extends="VkLineRasterizationMode"                     name="VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT" alias="VK_LINE_RASTERIZATION_MODE_BRESENHAM"/>
                <enum extends="VkLineRasterizationMode"                     name="VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT" alias="VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH"/>
                <type name="VkPhysicalDeviceLineRasterizationFeaturesEXT"/>
                <type name="VkPhysicalDeviceLineRasterizationPropertiesEXT"/>
                <type name="VkPipelineRasterizationLineStateCreateInfoEXT"/>
                <type name="VkLineRasterizationModeEXT"/>
                <command name="vkCmdSetLineStippleEXT"/>
                <feature name="rectangularLines,bresenhamLines,smoothLines,stippledRectangularLines,stippledBresenhamLines,stippledSmoothLines" struct="VkPhysicalDeviceLineRasterizationFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_atomic_float" number="261" type="device" author="NV" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Vikram Kushwaha @vkushwaha-nv" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
            <require>
                <enum value="1"                                             name="VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_atomic_float&quot;"        name="VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT"/>
                <feature name="shaderBufferFloat32Atomics,shaderBufferFloat32AtomicAdd,shaderBufferFloat64Atomics,shaderBufferFloat64AtomicAdd,shaderSharedFloat32Atomics,shaderSharedFloat32AtomicAdd,shaderSharedFloat64Atomics,shaderSharedFloat64AtomicAdd,shaderImageFloat32Atomics,shaderImageFloat32AtomicAdd" struct="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT"/>
            </require>
            <require depends="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT::sparseImageFloat32Atomics">
                <feature name="shaderImageFloat32Atomics" struct="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT"/>
            </require>
            <require depends="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT::sparseImageFloat32AtomicAdd">
                <feature name="shaderImageFloat32AtomicAdd" struct="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_host_query_reset" number="262" author="EXT" contact="Bas Nieuwenhuizen @BNieuwenhuizen" supported="vulkan" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" promotedto="VK_VERSION_1_2">
            <require>
                <enum value="1"                                             name="VK_EXT_HOST_QUERY_RESET_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_host_query_reset&quot;"           name="VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES"/>
                <type name="VkPhysicalDeviceHostQueryResetFeaturesEXT"/>
                <command name="vkResetQueryPoolEXT"/>
                <feature name="hostQueryReset" struct="VkPhysicalDeviceHostQueryResetFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_GGP_extension_263" number="263" author="GGP" contact="Jean-Francois Roy @jfroy" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_GGP_EXTENSION_263_SPEC_VERSION"/>
                <enum value="&quot;VK_GGP_extension_263&quot;"              name="VK_GGP_EXTENSION_263_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_BRCM_extension_264" number="264" author="BRCM" contact="Graeme Leese @gnl21" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_BRCM_EXTENSION_264_SPEC_VERSION"/>
                <enum value="&quot;VK_BRCM_extension_264&quot;"             name="VK_BRCM_EXTENSION_264_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_BRCM_extension_265" number="265" author="BRCM" contact="Graeme Leese @gnl21" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_BRCM_EXTENSION_265_SPEC_VERSION"/>
                <enum value="&quot;VK_BRCM_extension_265&quot;"             name="VK_BRCM_EXTENSION_265_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_index_type_uint8" number="266" type="device" author="EXT" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Piers Daniell @pdaniell-nv" supported="vulkan,vulkansc" promotedto="VK_KHR_index_type_uint8">
            <require>
                <enum value="1"                                             name="VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_index_type_uint8&quot;"           name="VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES"/>
                <enum extends="VkIndexType"                                 name="VK_INDEX_TYPE_UINT8_EXT" alias="VK_INDEX_TYPE_UINT8"/>
                <type name="VkPhysicalDeviceIndexTypeUint8FeaturesEXT"/>
                <feature name="indexTypeUint8" struct="VkPhysicalDeviceIndexTypeUint8FeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_267" number="267" type="device" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_267_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_267&quot;"              name="VK_EXT_EXTENSION_267_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extended_dynamic_state" number="268" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3" ratified="vulkan,vulkansc">
            <require>
                <enum value="1"                                             name="VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extended_dynamic_state&quot;"     name="VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT" comment="Not promoted to 1.3"/>
                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_CULL_MODE_EXT" alias="VK_DYNAMIC_STATE_CULL_MODE"/>
                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_FRONT_FACE_EXT" alias="VK_DYNAMIC_STATE_FRONT_FACE"/>
                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT" alias="VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY"/>
                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT" alias="VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT"/>
                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT" alias="VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT"/>
                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT" alias="VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE"/>
                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT" alias="VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE"/>
                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT" alias="VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE"/>
                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT" alias="VK_DYNAMIC_STATE_DEPTH_COMPARE_OP"/>
                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT" alias="VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE"/>
                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT" alias="VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE"/>
                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_STENCIL_OP_EXT" alias="VK_DYNAMIC_STATE_STENCIL_OP"/>
                <type name="VkPhysicalDeviceExtendedDynamicStateFeaturesEXT" comment="Not promoted to 1.3"/>
                <command name="vkCmdSetCullModeEXT"/>
                <command name="vkCmdSetFrontFaceEXT"/>
                <command name="vkCmdSetPrimitiveTopologyEXT"/>
                <command name="vkCmdSetViewportWithCountEXT"/>
                <command name="vkCmdSetScissorWithCountEXT"/>
                <command name="vkCmdBindVertexBuffers2EXT"/>
                <command name="vkCmdSetDepthTestEnableEXT"/>
                <command name="vkCmdSetDepthWriteEnableEXT"/>
                <command name="vkCmdSetDepthCompareOpEXT"/>
                <command name="vkCmdSetDepthBoundsTestEnableEXT"/>
                <command name="vkCmdSetStencilTestEnableEXT"/>
                <command name="vkCmdSetStencilOpEXT"/>
                <feature name="extendedDynamicState" struct="VkPhysicalDeviceExtendedDynamicStateFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_deferred_host_operations" number="269" type="device" author="KHR" contact="Josh Barczak @jbarczak" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="4"                                             name="VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_deferred_host_operations&quot;"   name="VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkObjectType"                     name="VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR"/>
                <type name="VkDeferredOperationKHR"/>
                <command name="vkCreateDeferredOperationKHR"/>
                <command name="vkDestroyDeferredOperationKHR"/>
                <command name="vkGetDeferredOperationMaxConcurrencyKHR"/>
                <command name="vkGetDeferredOperationResultKHR"/>
                <command name="vkDeferredOperationJoinKHR"/>
                <enum extends="VkResult"       offset="0"       name="VK_THREAD_IDLE_KHR"/>
                <enum extends="VkResult"       offset="1"       name="VK_THREAD_DONE_KHR"/>
                <enum extends="VkResult"       offset="2"       name="VK_OPERATION_DEFERRED_KHR"/>
                <enum extends="VkResult"       offset="3"       name="VK_OPERATION_NOT_DEFERRED_KHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_pipeline_executable_properties" number="270" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="KHR" contact="Faith Ekstrand @gfxstrand" specialuse="devtools" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_pipeline_executable_properties&quot;"   name="VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR"/>
                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR"/>
                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR"/>
                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR"/>
                <enum bitpos="6" extends="VkPipelineCreateFlagBits"     name="VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR"/>
                <enum bitpos="7" extends="VkPipelineCreateFlagBits"     name="VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR"/>
                <type name="VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR"/>
                <type name="VkPipelineInfoKHR"/>
                <type name="VkPipelineExecutablePropertiesKHR"/>
                <type name="VkPipelineExecutableInfoKHR"/>
                <type name="VkPipelineExecutableStatisticFormatKHR"/>
                <type name="VkPipelineExecutableStatisticValueKHR"/>
                <type name="VkPipelineExecutableStatisticKHR"/>
                <type name="VkPipelineExecutableInternalRepresentationKHR"/>
                <command name="vkGetPipelineExecutablePropertiesKHR"/>
                <command name="vkGetPipelineExecutableStatisticsKHR"/>
                <command name="vkGetPipelineExecutableInternalRepresentationsKHR"/>
                <feature name="pipelineExecutableInfo" struct="VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_host_image_copy" number="271" type="device" depends="((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_copy_commands2+VK_KHR_format_feature_flags2),VK_VERSION_1_3" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="vulkan" promotedto="VK_VERSION_1_4" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_EXT_HOST_IMAGE_COPY_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_host_image_copy&quot;"        name="VK_EXT_HOST_IMAGE_COPY_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT" alias="VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT" alias="VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT" alias="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT" alias="VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT" alias="VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT" alias="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT" alias="VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT" alias="VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY"/>
                <enum extends="VkImageUsageFlagBits"                    name="VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT" alias="VK_IMAGE_USAGE_HOST_TRANSFER_BIT" comment="Can be used with host image copies"/>
                <enum extends="VkFormatFeatureFlagBits2"                name="VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT" alias="VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT" comment="Host image copies are supported"/>
                <enum extends="VkHostImageCopyFlagBits"                 name="VK_HOST_IMAGE_COPY_MEMCPY_BIT_EXT" alias="VK_HOST_IMAGE_COPY_MEMCPY_BIT"/>
                <enum extends="VkHostImageCopyFlagBits"                 name="VK_HOST_IMAGE_COPY_MEMCPY_EXT" alias="VK_HOST_IMAGE_COPY_MEMCPY_BIT" deprecated="aliased"/>
                <type name="VkPhysicalDeviceHostImageCopyFeaturesEXT"/>
                <type name="VkPhysicalDeviceHostImageCopyPropertiesEXT"/>
                <type name="VkHostImageCopyFlagBitsEXT"/>
                <type name="VkHostImageCopyFlagsEXT"/>
                <type name="VkMemoryToImageCopyEXT"/>
                <type name="VkImageToMemoryCopyEXT"/>
                <type name="VkCopyMemoryToImageInfoEXT"/>
                <type name="VkCopyImageToMemoryInfoEXT"/>
                <type name="VkCopyImageToImageInfoEXT"/>
                <type name="VkHostImageLayoutTransitionInfoEXT"/>
                <type name="VkSubresourceHostMemcpySizeEXT"/>
                <type name="VkHostImageCopyDevicePerformanceQueryEXT"/>
                <command name="vkCopyMemoryToImageEXT"/>
                <command name="vkCopyImageToMemoryEXT"/>
                <command name="vkCopyImageToImageEXT"/>
                <command name="vkTransitionImageLayoutEXT"/>
                <type name="VkSubresourceLayout2EXT"/>
                <type name="VkImageSubresource2EXT"/>
                <command name="vkGetImageSubresourceLayout2EXT" comment="Taken from VK_EXT_image_compression_control. VkStructureType enums defined in that extension"/>
                <feature name="hostImageCopy" struct="VkPhysicalDeviceHostImageCopyFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_map_memory2" number="272" type="device" author="KHR" contact="Faith Ekstrand @gfxstrand" supported="vulkan" promotedto="VK_VERSION_1_4" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                               name="VK_KHR_MAP_MEMORY_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_map_memory2&quot;"  name="VK_KHR_MAP_MEMORY_2_EXTENSION_NAME"/>
                <enum extends="VkStructureType"               name="VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_MAP_INFO"/>
                <enum extends="VkStructureType"               name="VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO"/>
                <type name="VkMemoryMapInfoKHR"/>
                <type name="VkMemoryUnmapInfoKHR"/>
                <type name="VkMemoryUnmapFlagBitsKHR"/>
                <type name="VkMemoryUnmapFlagsKHR"/>
                <command name="vkMapMemory2KHR"/>
                <command name="vkUnmapMemory2KHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_map_memory_placed" number="273" type="device" depends="VK_KHR_map_memory2,VK_VERSION_1_4" author="EXT" contact="Faith Ekstrand @gfxstrand" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_EXT_MAP_MEMORY_PLACED_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_map_memory_placed&quot;"      name="VK_EXT_MAP_MEMORY_PLACED_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT"/>
                <enum bitpos="0" extends="VkMemoryMapFlagBits"          name="VK_MEMORY_MAP_PLACED_BIT_EXT"/>
                <enum bitpos="0" extends="VkMemoryUnmapFlagBits"        name="VK_MEMORY_UNMAP_RESERVE_BIT_EXT"/>
                <type name="VkPhysicalDeviceMapMemoryPlacedFeaturesEXT"/>
                <type name="VkPhysicalDeviceMapMemoryPlacedPropertiesEXT"/>
                <type name="VkMemoryMapPlacedInfoEXT"/>
                <feature name="memoryMapPlaced" struct="VkPhysicalDeviceMapMemoryPlacedFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_atomic_float2" number="274" type="device" depends="VK_EXT_shader_atomic_float" author="EXT" contact="Faith Ekstrand @gfxstrand" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_SHADER_ATOMIC_FLOAT_2_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_atomic_float2&quot;"       name="VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT"/>
                <feature name="shaderBufferFloat16Atomics,shaderBufferFloat16AtomicAdd,shaderBufferFloat16AtomicMinMax,shaderBufferFloat32AtomicMinMax,shaderBufferFloat64AtomicMinMax,shaderSharedFloat16Atomics,shaderSharedFloat16AtomicAdd,shaderSharedFloat16AtomicMinMax,shaderSharedFloat32AtomicMinMax,shaderSharedFloat64AtomicMinMax,shaderImageFloat32AtomicMinMax" struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT"/>
            </require>
            <require depends="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT::sparseImageFloat32AtomicMinMax">
                <feature name="shaderImageFloat32AtomicMinMax" struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_surface_maintenance1" number="275" type="instance" depends="VK_KHR_surface+VK_KHR_get_surface_capabilities2" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="vulkan" promotedto="VK_KHR_surface_maintenance1" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_SURFACE_MAINTENANCE_1_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_surface_maintenance1&quot;"       name="VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT" alias="VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR"/>
                <enum extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT" alias="VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR"/>
                <enum extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT" alias="VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR"/>
                <type name="VkSurfacePresentModeEXT"/>
                <type name="VkPresentScalingFlagBitsEXT"/>
                <type name="VkPresentScalingFlagsEXT"/>
                <type name="VkPresentGravityFlagBitsEXT"/>
                <type name="VkPresentGravityFlagsEXT"/>
                <type name="VkSurfacePresentScalingCapabilitiesEXT"/>
                <type name="VkSurfacePresentModeCompatibilityEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_swapchain_maintenance1" number="276" type="device" depends="VK_KHR_swapchain+VK_EXT_surface_maintenance1+(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="vulkan" promotedto="VK_KHR_swapchain_maintenance1" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_SWAPCHAIN_MAINTENANCE_1_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_swapchain_maintenance1&quot;"     name="VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR"/>
                <enum extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT" alias="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR"/>
                <enum extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR"/>
                <enum extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT" alias="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR"/>
                <enum extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR"/>
                <enum extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT" alias="VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR"/>
                <enum extends="VkSwapchainCreateFlagBitsKHR"     name="VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT" alias="VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR"/>
                <type name="VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT"/>
                <type name="VkSwapchainPresentFenceInfoEXT"/>
                <type name="VkSwapchainPresentModesCreateInfoEXT"/>
                <type name="VkSwapchainPresentModeInfoEXT"/>
                <type name="VkSwapchainPresentScalingCreateInfoEXT"/>
                <type name="VkReleaseSwapchainImagesInfoEXT"/>
                <command name="vkReleaseSwapchainImagesEXT"/>
                <feature name="swapchainMaintenance1" struct="VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_demote_to_helper_invocation" number="277" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Jeff Bolz @jeffbolznv" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3" ratified="vulkansc">
            <require>
                <enum value="1"                                             name="VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_demote_to_helper_invocation&quot;" name="VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES"/>
                <type name="VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT"/>
                <feature name="shaderDemoteToHelperInvocation" struct="VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_NV_device_generated_commands" number="278" type="device" depends="(VK_VERSION_1_1+VK_KHR_buffer_device_address),VK_VERSION_1_2" author="NV" contact="Christoph Kubisch @pixeljetstream" supported="vulkan">
            <require>
                <comment>
                    This extension requires buffer_device_address functionality.
                    VK_EXT_buffer_device_address is also acceptable, but since it is deprecated the KHR version is preferred.
                </comment>
                <enum value="3"                                             name="VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_device_generated_commands&quot;"   name="VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV"/>
                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV"/>
                <enum offset="6" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV"/>
                <enum offset="7" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV"/>
                <enum bitpos="18" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV"/>
                <enum extends="VkPipelineStageFlagBits"                     name="VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV" alias="VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT"/>
                <enum extends="VkAccessFlagBits"                            name="VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV" alias="VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT"/>
                <enum extends="VkAccessFlagBits"                            name="VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV" alias="VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT"/>
                <enum offset="0" extends="VkObjectType"                     name="VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV"/>
                <type name="VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV"/>
                <type name="VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV"/>
                <type name="VkGraphicsShaderGroupCreateInfoNV"/>
                <type name="VkGraphicsPipelineShaderGroupsCreateInfoNV"/>
                <type name="VkBindShaderGroupIndirectCommandNV"/>
                <type name="VkBindIndexBufferIndirectCommandNV"/>
                <type name="VkBindVertexBufferIndirectCommandNV"/>
                <type name="VkSetStateFlagsIndirectCommandNV"/>
                <type name="VkIndirectStateFlagBitsNV"/>
                <type name="VkIndirectStateFlagsNV"/>
                <type name="VkIndirectCommandsLayoutNV"/>
                <type name="VkIndirectCommandsTokenTypeNV"/>
                <type name="VkIndirectCommandsLayoutUsageFlagBitsNV"/>
                <type name="VkIndirectCommandsLayoutUsageFlagsNV"/>
                <type name="VkIndirectCommandsStreamNV"/>
                <type name="VkIndirectCommandsLayoutTokenNV"/>
                <type name="VkIndirectCommandsLayoutCreateInfoNV"/>
                <type name="VkGeneratedCommandsInfoNV"/>
                <type name="VkGeneratedCommandsMemoryRequirementsInfoNV"/>
                <command name="vkGetGeneratedCommandsMemoryRequirementsNV"/>
                <command name="vkCmdPreprocessGeneratedCommandsNV"/>
                <command name="vkCmdExecuteGeneratedCommandsNV"/>
                <command name="vkCmdBindPipelineShaderGroupNV"/>
                <command name="vkCreateIndirectCommandsLayoutNV"/>
                <command name="vkDestroyIndirectCommandsLayoutNV"/>
                <feature name="deviceGeneratedCommands" struct="VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_inherited_viewport_scissor" number="279" type="device" author="NV" contact="David Zhao Akeley @akeley98" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_INHERITED_VIEWPORT_SCISSOR_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_inherited_viewport_scissor&quot;"  name="VK_NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV"/>
                <type name="VkPhysicalDeviceInheritedViewportScissorFeaturesNV"/>
                <type name="VkCommandBufferInheritanceViewportScissorInfoNV"/>
                <feature name="inheritedViewportScissor2D" struct="VkPhysicalDeviceInheritedViewportScissorFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_280" number="280" type="device" author="KHR" contact="Kevin Petit @kpet" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_280_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_280&quot;"              name="VK_KHR_EXTENSION_280_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_integer_dot_product" number="281" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Kevin Petit @kpet" supported="vulkan" promotedto="VK_VERSION_1_3" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_SHADER_INTEGER_DOT_PRODUCT_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_integer_dot_product&quot;" name="VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES"/>
                <type name="VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR"/>
                <type name="VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR"/>
                <feature name="shaderIntegerDotProduct" struct="VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_texel_buffer_alignment" number="282" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Jeff Bolz @jeffbolznv" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3" ratified="vulkansc">
            <require>
                <enum value="1"                                             name="VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_texel_buffer_alignment&quot;"     name="VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT" comment="Not promoted to 1.3"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES"/>
                <type name="VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT" comment="Not promoted to 1.3"/>
                <type name="VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT"/>
                <feature name="texelBufferAlignment" struct="VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_QCOM_render_pass_transform" number="283" type="device" author="QCOM" contact="Matthew Netsch @mnetsch" supported="vulkan" nofeatures="true">
            <require>
                <enum value="5"                                             name="VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_render_pass_transform&quot;"     name="VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM"/>
                <enum bitpos="1" extends="VkRenderPassCreateFlagBits"       name="VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM"/>
                <type name="VkRenderPassTransformBeginInfoQCOM"/>
                <type name="VkCommandBufferInheritanceRenderPassTransformInfoQCOM"/>
            </require>
        </extension>
        <extension name="VK_EXT_depth_bias_control" number="284" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Joshua Ashton @Joshua-Ashton" specialuse="d3demulation" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_DEPTH_BIAS_CONTROL_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_depth_bias_control&quot;"         name="VK_EXT_DEPTH_BIAS_CONTROL_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT"/>
                <type name="VkPhysicalDeviceDepthBiasControlFeaturesEXT"/>
                <type name="VkDepthBiasInfoEXT"/>
                <type name="VkDepthBiasRepresentationEXT"/>
                <type name="VkDepthBiasRepresentationInfoEXT"/>
                <command name="vkCmdSetDepthBias2EXT"/>
                <feature name="depthBiasControl" struct="VkPhysicalDeviceDepthBiasControlFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_device_memory_report" number="285" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Yiwei Zhang @zzyiwei" specialuse="devtools" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="2"                                             name="VK_EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_device_memory_report&quot;"       name="VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT"/>
                <type name="VkPhysicalDeviceDeviceMemoryReportFeaturesEXT"/>
                <type name="VkDeviceDeviceMemoryReportCreateInfoEXT"/>
                <type name="VkDeviceMemoryReportCallbackDataEXT"/>
                <type name="VkDeviceMemoryReportFlagsEXT"/>
                <type name="VkDeviceMemoryReportEventTypeEXT"/>
                <type name="PFN_vkDeviceMemoryReportCallbackEXT"/>
                <feature name="deviceMemoryReport" struct="VkPhysicalDeviceDeviceMemoryReportFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_acquire_drm_display" number="286" type="instance" depends="VK_EXT_direct_mode_display" author="EXT" contact="Drew DeVault sir@cmpwn.com" supported="vulkan" ratified="vulkan" comment="codespell:ignore devault" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_ACQUIRE_DRM_DISPLAY_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_acquire_drm_display&quot;"        name="VK_EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME"/>
                <command name="vkAcquireDrmDisplayEXT"/>
                <command name="vkGetDrmDisplayEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_robustness2" number="287"  type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Liam Middlebrook @liam-middlebrook" supported="vulkan,vulkansc" promotedto="VK_KHR_robustness2" ratified="vulkan,vulkansc">
            <require>
                <enum value="1"                                                 name="VK_EXT_ROBUSTNESS_2_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_robustness2&quot;"                    name="VK_EXT_ROBUSTNESS_2_EXTENSION_NAME"/>
                <enum extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR"/>
                <enum extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR"/>
                <type name="VkPhysicalDeviceRobustness2FeaturesEXT"/>
                <type name="VkPhysicalDeviceRobustness2PropertiesEXT"/>
                <feature name="robustBufferAccess2,robustImageAccess2,nullDescriptor" struct="VkPhysicalDeviceRobustness2FeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_custom_border_color" number="288" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Liam Middlebrook @liam-middlebrook" specialuse="glemulation,d3demulation" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
            <require>
                <enum value="12"                                            name="VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_custom_border_color&quot;"        name="VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT"/>
                <enum offset="3" extends="VkBorderColor"                    name="VK_BORDER_COLOR_FLOAT_CUSTOM_EXT"/>
                <enum offset="4" extends="VkBorderColor"                    name="VK_BORDER_COLOR_INT_CUSTOM_EXT"/>
                <type name="VkSamplerCustomBorderColorCreateInfoEXT"/>
                <type name="VkPhysicalDeviceCustomBorderColorPropertiesEXT"/>
                <type name="VkPhysicalDeviceCustomBorderColorFeaturesEXT"/>
                <feature name="customBorderColors" struct="VkPhysicalDeviceCustomBorderColorFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_289" number="289" author="EXT" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="disabled">
            <require>
                <comment>
                    These enums are present only to inform downstream
                    consumers like KTX2. There is no actual Vulkan extension
                    corresponding to the enums.
                </comment>
                <enum value="0"                                             name="VK_EXT_EXTENSION_289_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_289&quot;"              name="VK_EXT_EXTENSION_289_EXTENSION_NAME"/>
                <enum extends="VkFormat" extnumber="289" offset="0" name="VK_FORMAT_ASTC_3x3x3_UNORM_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="1" name="VK_FORMAT_ASTC_3x3x3_SRGB_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="2" name="VK_FORMAT_ASTC_3x3x3_SFLOAT_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="3" name="VK_FORMAT_ASTC_4x3x3_UNORM_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="4" name="VK_FORMAT_ASTC_4x3x3_SRGB_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="5" name="VK_FORMAT_ASTC_4x3x3_SFLOAT_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="6" name="VK_FORMAT_ASTC_4x4x3_UNORM_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="7" name="VK_FORMAT_ASTC_4x4x3_SRGB_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="8" name="VK_FORMAT_ASTC_4x4x3_SFLOAT_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="9" name="VK_FORMAT_ASTC_4x4x4_UNORM_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="10" name="VK_FORMAT_ASTC_4x4x4_SRGB_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="11" name="VK_FORMAT_ASTC_4x4x4_SFLOAT_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="12" name="VK_FORMAT_ASTC_5x4x4_UNORM_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="13" name="VK_FORMAT_ASTC_5x4x4_SRGB_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="14" name="VK_FORMAT_ASTC_5x4x4_SFLOAT_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="15" name="VK_FORMAT_ASTC_5x5x4_UNORM_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="16" name="VK_FORMAT_ASTC_5x5x4_SRGB_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="17" name="VK_FORMAT_ASTC_5x5x4_SFLOAT_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="18" name="VK_FORMAT_ASTC_5x5x5_UNORM_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="19" name="VK_FORMAT_ASTC_5x5x5_SRGB_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="20" name="VK_FORMAT_ASTC_5x5x5_SFLOAT_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="21" name="VK_FORMAT_ASTC_6x5x5_UNORM_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="22" name="VK_FORMAT_ASTC_6x5x5_SRGB_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="23" name="VK_FORMAT_ASTC_6x5x5_SFLOAT_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="24" name="VK_FORMAT_ASTC_6x6x5_UNORM_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="25" name="VK_FORMAT_ASTC_6x6x5_SRGB_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="26" name="VK_FORMAT_ASTC_6x6x5_SFLOAT_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="27" name="VK_FORMAT_ASTC_6x6x6_UNORM_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="28" name="VK_FORMAT_ASTC_6x6x6_SRGB_BLOCK_EXT"/>
                <enum extends="VkFormat" extnumber="289" offset="29" name="VK_FORMAT_ASTC_6x6x6_SFLOAT_BLOCK_EXT"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_user_type" number="290" type="device" author="GOOGLE" contact="Kaye Mason @chaleur" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_GOOGLE_USER_TYPE_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_user_type&quot;"               name="VK_GOOGLE_USER_TYPE_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_pipeline_library" number="291" type="device" author="KHR" contact="Christoph Kubisch @pixeljetstream" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_pipeline_library&quot;"           name="VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME"/>
                <enum bitpos="11" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_LIBRARY_BIT_KHR"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR"/>
                <type name="VkPipelineLibraryCreateInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_292" number="292" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_292_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_292&quot;"               name="VK_NV_EXTENSION_292_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_present_barrier" number="293" type="device" author="NV" depends="(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_surface+VK_KHR_get_surface_capabilities2+VK_KHR_swapchain" contact="Liya Li @liyli" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_PRESENT_BARRIER_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_present_barrier&quot;"             name="VK_NV_PRESENT_BARRIER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV"/>
                <type name="VkPhysicalDevicePresentBarrierFeaturesNV"/>
                <type name="VkSurfaceCapabilitiesPresentBarrierNV"/>
                <type name="VkSwapchainPresentBarrierCreateInfoNV"/>
                <feature name="presentBarrier" struct="VkPhysicalDevicePresentBarrierFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_non_semantic_info" number="294" type="device" author="KHR" contact="Baldur Karlsson @baldurk" supported="vulkan" promotedto="VK_VERSION_1_3" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_non_semantic_info&quot;"   name="VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_present_id" number="295" type="device" depends="VK_KHR_swapchain+VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="KHR" contact="Keith Packard @keithp" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_PRESENT_ID_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_present_id&quot;"             name="VK_KHR_PRESENT_ID_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PRESENT_ID_KHR"/>
                <type name="VkPresentIdKHR"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR"/>
                <type name="VkPhysicalDevicePresentIdFeaturesKHR"/>
                <feature name="presentId" struct="VkPhysicalDevicePresentIdFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_private_data" number="296" type="device" author="NV" contact="Matthew Rusch @mattruschnv" supported="vulkan" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" promotedto="VK_VERSION_1_3">
            <require>
                <enum value="1"                                             name="VK_EXT_PRIVATE_DATA_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_private_data&quot;"               name="VK_EXT_PRIVATE_DATA_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO"/>
                <enum extends="VkObjectType"                                name="VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT" alias="VK_OBJECT_TYPE_PRIVATE_DATA_SLOT"/>
                <type name="VkPhysicalDevicePrivateDataFeaturesEXT"/>
                <type name="VkDevicePrivateDataCreateInfoEXT"/>
                <type name="VkPrivateDataSlotCreateInfoEXT"/>
                <type name="VkPrivateDataSlotEXT"/>
                <type name="VkPrivateDataSlotCreateFlagsEXT" comment="Will add VkPrivateDataSlotCreateFlagBits when bits are defined in the future"/>
                <command name="vkCreatePrivateDataSlotEXT"/>
                <command name="vkDestroyPrivateDataSlotEXT"/>
                <command name="vkSetPrivateDataEXT"/>
                <command name="vkGetPrivateDataEXT"/>
                <feature name="privateData" struct="VkPhysicalDevicePrivateDataFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_297" number="297" author="KHR" contact="Corentin Wallez @Kangz" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_297_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_297&quot;"              name="VK_KHR_EXTENSION_297_EXTENSION_NAME"/>
                <enum bitpos="3" extends="VkPipelineShaderStageCreateFlagBits"  name="VK_PIPELINE_SHADER_STAGE_CREATE_RESERVED_3_BIT_KHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_pipeline_creation_cache_control" number="298" type="device" author="AMD" contact="Gregory Grebe @grgrebe_amd" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" supported="vulkan" promotedto="VK_VERSION_1_3">
            <require>
                <enum value="3"                                             name="VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_pipeline_creation_cache_control&quot;"    name="VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES"/>
                <enum extends="VkPipelineCreateFlagBits"                    name="VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT" alias="VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT"/>
                <enum extends="VkPipelineCreateFlagBits"                    name="VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT" alias="VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT"/>
                <enum extends="VkResult"                                    name="VK_PIPELINE_COMPILE_REQUIRED_EXT" alias="VK_PIPELINE_COMPILE_REQUIRED"/>
                <enum extends="VkResult"                                    name="VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT" alias="VK_PIPELINE_COMPILE_REQUIRED"/>
                <enum extends="VkPipelineCacheCreateFlagBits"               name="VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT" alias="VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT"/>
                <type name="VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT"/>
                <type name="VkPipelineCacheCreateFlagBits"/>
                <feature name="pipelineCreationCacheControl" struct="VkPhysicalDevicePipelineCreationCacheControlFeatures"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_299" number="299" type="device" author="KHR" contact="Mark Bellamy @mark.bellamy_arm" supported="disabled">
            <require comment="used for Vulkan SC 1.0 namespace">
                <enum value="0"                                         name="VK_KHR_EXTENSION_299_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_299&quot;"          name="VK_KHR_EXTENSION_299_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_video_encode_queue" number="300"  type="device" depends="VK_KHR_video_queue+(VK_KHR_synchronization2,VK_VERSION_1_3)" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="12"                                        name="VK_KHR_VIDEO_ENCODE_QUEUE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_video_encode_queue&quot;"     name="VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME"/>
                <!-- VkPipelineStageFlagBits bitpos="27" is reserved by this extension, but not used -->
                <enum bitpos="27" extends="VkPipelineStageFlagBits2"    name="VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR"/>
                <enum bitpos="37" extends="VkAccessFlagBits2"           name="VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR"/>
                <enum bitpos="38" extends="VkAccessFlagBits2"           name="VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR"/>
                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR"/>
                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR"/>
                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR"/>
                <enum offset="6" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR"/>
                <enum offset="7" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR"/>
                <enum offset="8" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR"/>
                <enum offset="9" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR"/>
                <enum offset="10" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR"/>
                <enum bitpos="6" extends="VkQueueFlagBits"              name="VK_QUEUE_VIDEO_ENCODE_BIT_KHR"/>
                <enum bitpos="1" extends="VkVideoCodingControlFlagBitsKHR" name="VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR"/>
                <enum bitpos="2" extends="VkVideoCodingControlFlagBitsKHR" name="VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR"/>
                <enum bitpos="15" extends="VkBufferUsageFlagBits"       name="VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR"/>
                <enum bitpos="16" extends="VkBufferUsageFlagBits"       name="VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR"/>
                <enum bitpos="13" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR"/>
                <enum bitpos="14" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR"/>
                <enum bitpos="15" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR"/>
                <enum bitpos="27" extends="VkFormatFeatureFlagBits"     name="VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR"/>
                <enum bitpos="28" extends="VkFormatFeatureFlagBits"     name="VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR"/>
                <enum bitpos="1" extends="VkVideoSessionCreateFlagBitsKHR" name="VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR"/>
                <enum offset="0" extends="VkImageLayout"                name="VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR"/>
                <enum offset="1" extends="VkImageLayout"                name="VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR"/>
                <enum offset="2" extends="VkImageLayout"                name="VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR"/>
                <enum offset="0" extends="VkQueryType"                  name="VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR"/>
                <enum offset="0" extends="VkQueryResultStatusKHR" dir="-" name="VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR"/>
                <enum offset="0" extends="VkResult" dir="-"             name="VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR"/>
                <type name="VkVideoEncodeFlagsKHR"/>
                <type name="VkVideoEncodeInfoKHR"/>
                <type name="VkVideoEncodeCapabilityFlagBitsKHR"/>
                <type name="VkVideoEncodeCapabilityFlagsKHR"/>
                <type name="VkVideoEncodeCapabilitiesKHR"/>
                <type name="VkQueryPoolVideoEncodeFeedbackCreateInfoKHR"/>
                <type name="VkVideoEncodeFeedbackFlagBitsKHR"/>
                <type name="VkVideoEncodeFeedbackFlagsKHR"/>
                <type name="VkVideoEncodeUsageFlagBitsKHR"/>
                <type name="VkVideoEncodeUsageFlagsKHR"/>
                <type name="VkVideoEncodeContentFlagBitsKHR"/>
                <type name="VkVideoEncodeContentFlagsKHR"/>
                <type name="VkVideoEncodeTuningModeKHR"/>
                <type name="VkVideoEncodeUsageInfoKHR"/>
                <type name="VkVideoEncodeRateControlFlagsKHR"/>
                <type name="VkVideoEncodeRateControlModeFlagBitsKHR"/>
                <type name="VkVideoEncodeRateControlModeFlagsKHR"/>
                <type name="VkVideoEncodeRateControlInfoKHR"/>
                <type name="VkVideoEncodeRateControlLayerInfoKHR"/>
                <type name="VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR"/>
                <type name="VkVideoEncodeQualityLevelPropertiesKHR"/>
                <type name="VkVideoEncodeQualityLevelInfoKHR"/>
                <type name="VkVideoEncodeSessionParametersGetInfoKHR"/>
                <type name="VkVideoEncodeSessionParametersFeedbackInfoKHR"/>
                <command name="vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR"/>
                <command name="vkGetEncodedVideoSessionParametersKHR"/>
                <command name="vkCmdEncodeVideoKHR"/>
            </require>
            <require depends="VK_KHR_format_feature_flags2,VK_VERSION_1_3">
                <enum bitpos="27" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR"/>
                <enum bitpos="28" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR"/>
            </require>
        </extension>
        <extension name="VK_NV_device_diagnostics_config" number="301" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Kedarnath Thangudu @kthangudu" supported="vulkan">
            <require>
                <enum value="2"                                             name="VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_device_diagnostics_config&quot;"   name="VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType" name="VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV"/>
                <type name="VkPhysicalDeviceDiagnosticsConfigFeaturesNV"/>
                <type name="VkDeviceDiagnosticsConfigCreateInfoNV"/>
                <type name="VkDeviceDiagnosticsConfigFlagsNV"/>
                <type name="VkDeviceDiagnosticsConfigFlagBitsNV"/>
                <feature name="diagnosticsConfig" struct="VkPhysicalDeviceDiagnosticsConfigFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_QCOM_render_pass_store_ops" number="302" type="device" author="QCOM" contact="Matthew Netsch @mnetsch" supported="vulkan" nofeatures="true">
            <require>
                <enum value="2"                                             name="VK_QCOM_RENDER_PASS_STORE_OPS_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_render_pass_store_ops&quot;"     name="VK_QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME"/>
                <enum extends="VkAttachmentStoreOp"                         name="VK_ATTACHMENT_STORE_OP_NONE_QCOM" alias="VK_ATTACHMENT_STORE_OP_NONE"/>
            </require>
        </extension>
        <extension name="VK_QCOM_extension_303" number="303" author="QCOM" contact="Matthew Netsch @mnetsch" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_QCOM_EXTENSION_303_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_extension_303&quot;"             name="VK_QCOM_EXTENSION_303_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_QCOM_extension_304" number="304" author="QCOM" contact="Matthew Netsch @mnetsch" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_QCOM_EXTENSION_304_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_extension_304&quot;"             name="VK_QCOM_EXTENSION_304_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_QCOM_extension_305" number="305" author="QCOM" contact="Matthew Netsch @mnetsch" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_QCOM_EXTENSION_305_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_extension_305&quot;"             name="VK_QCOM_EXTENSION_305_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_QCOM_extension_306" number="306" author="QCOM" contact="Matthew Netsch @mnetsch" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_QCOM_EXTENSION_306_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_extension_306&quot;"             name="VK_QCOM_EXTENSION_306_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_QCOM_extension_307" number="307" author="QCOM" contact="Matthew Netsch @mnetsch" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_QCOM_EXTENSION_307_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_extension_307&quot;"             name="VK_QCOM_EXTENSION_307_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_cuda_kernel_launch" number="308" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" type="device" author="NV" contact="Tristan Lorach @tlorach" supported="vulkan" provisional="true" platform="provisional">
            <require>
                <enum value="2"                                             name="VK_NV_CUDA_KERNEL_LAUNCH_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_cuda_kernel_launch&quot;"          name="VK_NV_CUDA_KERNEL_LAUNCH_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum offset="0" extends="VkObjectType"                     name="VK_OBJECT_TYPE_CUDA_MODULE_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum offset="1" extends="VkObjectType"                     name="VK_OBJECT_TYPE_CUDA_FUNCTION_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <type name="VkCudaModuleNV"/>
                <type name="VkCudaFunctionNV"/>
                <type name="VkCudaModuleCreateInfoNV"/>
                <type name="VkCudaFunctionCreateInfoNV"/>
                <type name="VkCudaLaunchInfoNV"/>
                <type name="VkPhysicalDeviceCudaKernelLaunchFeaturesNV"/>
                <type name="VkPhysicalDeviceCudaKernelLaunchPropertiesNV"/>
                <command name="vkCreateCudaModuleNV"/>
                <command name="vkGetCudaModuleCacheNV"/>
                <command name="vkCreateCudaFunctionNV"/>
                <command name="vkDestroyCudaModuleNV"/>
                <command name="vkDestroyCudaFunctionNV"/>
                <command name="vkCmdCudaLaunchKernelNV"/>
                <feature name="cudaKernelLaunchFeatures" struct="VkPhysicalDeviceCudaKernelLaunchFeaturesNV"/>
            </require>
            <require depends="VK_EXT_debug_report">
                <enum offset="0" extends="VkDebugReportObjectTypeEXT"       name="VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV_EXT"/>
                <enum offset="1" extends="VkDebugReportObjectTypeEXT"       name="VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV_EXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_object_refresh" number="309" type="device" author="KHR" contact="Aidan Fabius @afabius" supported="vulkansc" ratified="vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_OBJECT_REFRESH_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_object_refresh&quot;"             name="VK_KHR_OBJECT_REFRESH_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR"/>
                <type name="VkRefreshObjectListKHR"/>
                <type name="VkRefreshObjectKHR"/>
                <type name="VkRefreshObjectFlagBitsKHR"/>
                <type name="VkRefreshObjectFlagsKHR"/>
                <command name="vkCmdRefreshObjectsKHR"/>
                <command name="vkGetPhysicalDeviceRefreshableObjectTypesKHR"/>
            </require>
        </extension>
        <extension name="VK_QCOM_tile_shading" number="310" type="device" depends="VK_QCOM_tile_properties,VK_KHR_get_physical_device_properties2" author="QCOM" contact="Matthew Netsch @mnetsch" supported="vulkan">
            <require>
                <enum value="2"                                            name="VK_QCOM_TILE_SHADING_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_tile_shading&quot;"             name="VK_QCOM_TILE_SHADING_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"                name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM"/>
                <enum offset="1"  extends="VkStructureType"                name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM"/>
                <enum offset="2"  extends="VkStructureType"                name="VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM"/>
                <enum offset="3"  extends="VkStructureType"                name="VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM"/>
                <enum offset="4"  extends="VkStructureType"                name="VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM"/>
                <enum offset="5"  extends="VkStructureType"                name="VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM"/>
                <enum bitpos="51" extends="VkAccessFlagBits2"              name="VK_ACCESS_2_SHADER_TILE_ATTACHMENT_READ_BIT_QCOM"/>
                <enum bitpos="52" extends="VkAccessFlagBits2"              name="VK_ACCESS_2_SHADER_TILE_ATTACHMENT_WRITE_BIT_QCOM"/>
                <enum bitpos="8"  extends="VkSubpassDescriptionFlagBits"   name="VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM"/>
                <type name="VkPhysicalDeviceTileShadingFeaturesQCOM"/>
                <type name="VkPhysicalDeviceTileShadingPropertiesQCOM"/>
                <type name="VkRenderPassTileShadingCreateInfoQCOM"/>
                <type name="VkPerTileBeginInfoQCOM"/>
                <type name="VkPerTileEndInfoQCOM"/>
                <type name="VkDispatchTileInfoQCOM"/>
                <type name="VkTileShadingRenderPassFlagsQCOM"/>
                <type name="VkTileShadingRenderPassFlagBitsQCOM"/>
                <command name="vkCmdDispatchTileQCOM"/>
                <command name="vkCmdBeginPerTileExecutionQCOM"/>
                <command name="vkCmdEndPerTileExecutionQCOM"/>
                <feature name="tileShading"                   struct="VkPhysicalDeviceTileShadingFeaturesQCOM"/>
                <feature name="tileShadingFragmentStage"      struct="VkPhysicalDeviceTileShadingFeaturesQCOM"/>
                <feature name="tileShadingPerTileDispatch"    struct="VkPhysicalDeviceTileShadingFeaturesQCOM"/>
                <feature name="tileShadingAtomicOps"          struct="VkPhysicalDeviceTileShadingFeaturesQCOM"/>
                <feature name="tileShadingColorAttachments"   struct="VkPhysicalDeviceTileShadingFeaturesQCOM"/>
                <feature name="tileShadingPerTileDraw"        struct="VkPhysicalDeviceTileShadingFeaturesQCOM"/>
                <feature name="tileShadingDepthAttachments"   struct="VkPhysicalDeviceTileShadingFeaturesQCOM"/>
                <feature name="tileShadingStencilAttachments" struct="VkPhysicalDeviceTileShadingFeaturesQCOM"/>
                <feature name="tileShadingInputAttachments"   struct="VkPhysicalDeviceTileShadingFeaturesQCOM"/>
                <feature name="tileShadingSampledAttachments" struct="VkPhysicalDeviceTileShadingFeaturesQCOM"/>
            </require>
        </extension>
        <extension name="VK_NV_low_latency" number="311" author="NV" type="device" supported="vulkan" contact="Charles Hansen @cshansen" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_NV_LOW_LATENCY_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_low_latency&quot;"                 name="VK_NV_LOW_LATENCY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV"/>
                <type name="VkQueryLowLatencySupportNV"/>
            </require>
        </extension>
        <extension name="VK_EXT_metal_objects" number="312" type="device" platform="metal" supported="vulkan" ratified="vulkan" author="EXT" contact="Bill Hollings @billhollings" nofeatures="true">
            <require>
                <enum value="2"                                             name="VK_EXT_METAL_OBJECTS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_metal_objects&quot;"              name="VK_EXT_METAL_OBJECTS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT"/>
                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT"/>
                <enum offset="6" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT"/>
                <enum offset="7" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT"/>
                <enum offset="8" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT"/>
                <enum offset="9" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT"/>
                <enum offset="10" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT"/>
                <enum offset="11" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT"/>
                <type name="VkExportMetalObjectTypeFlagBitsEXT"/>
                <type name="VkExportMetalObjectTypeFlagsEXT"/>
                <type name="VkExportMetalObjectCreateInfoEXT"/>
                <type name="VkExportMetalObjectsInfoEXT"/>
                <type name="VkExportMetalDeviceInfoEXT"/>
                <type name="VkExportMetalCommandQueueInfoEXT"/>
                <type name="VkExportMetalBufferInfoEXT"/>
                <type name="VkImportMetalBufferInfoEXT"/>
                <type name="VkExportMetalTextureInfoEXT"/>
                <type name="VkImportMetalTextureInfoEXT"/>
                <type name="VkExportMetalIOSurfaceInfoEXT"/>
                <type name="VkImportMetalIOSurfaceInfoEXT"/>
                <type name="VkExportMetalSharedEventInfoEXT"/>
                <type name="VkImportMetalSharedEventInfoEXT"/>
                <type name="MTLDevice_id"/>
                <type name="MTLCommandQueue_id"/>
                <type name="MTLBuffer_id"/>
                <type name="MTLTexture_id"/>
                <type name="MTLSharedEvent_id"/>
                <type name="IOSurfaceRef"/>
                <command name="vkExportMetalObjectsEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_313" number="313" author="MVK" contact="Bill Hollings @billhollings" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_313_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_313&quot;"              name="VK_EXT_EXTENSION_313_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_314" number="314" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_314_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_314&quot;"              name="VK_AMD_EXTENSION_314_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_synchronization2" number="315" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Tobias Hector @tobski" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3" ratified="vulkan,vulkansc">
            <require>
                <enum value="1"                                             name="VK_KHR_SYNCHRONIZATION_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_synchronization2&quot;"           name="VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_BARRIER_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR" alias="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEPENDENCY_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_SUBMIT_INFO_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR" alias="VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR" alias="VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES"/>
                <enum extends="VkEventCreateFlagBits"                       name="VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR" alias="VK_EVENT_CREATE_DEVICE_ONLY_BIT"/>
                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL"/>
                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL"/>
                <enum extends="VkPipelineStageFlagBits"                     name="VK_PIPELINE_STAGE_NONE_KHR" alias="VK_PIPELINE_STAGE_NONE"/>
                <enum extends="VkAccessFlagBits"                            name="VK_ACCESS_NONE_KHR" alias="VK_ACCESS_NONE"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_NONE_KHR" alias="VK_ACCESS_2_NONE"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR" alias="VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_INDEX_READ_BIT_KHR" alias="VK_ACCESS_2_INDEX_READ_BIT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR" alias="VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_UNIFORM_READ_BIT_KHR" alias="VK_ACCESS_2_UNIFORM_READ_BIT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR" alias="VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_SHADER_READ_BIT_KHR" alias="VK_ACCESS_2_SHADER_READ_BIT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_SHADER_WRITE_BIT_KHR" alias="VK_ACCESS_2_SHADER_WRITE_BIT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR" alias="VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR" alias="VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR" alias="VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR" alias="VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_TRANSFER_READ_BIT_KHR" alias="VK_ACCESS_2_TRANSFER_READ_BIT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR" alias="VK_ACCESS_2_TRANSFER_WRITE_BIT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_HOST_READ_BIT_KHR" alias="VK_ACCESS_2_HOST_READ_BIT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_HOST_WRITE_BIT_KHR" alias="VK_ACCESS_2_HOST_WRITE_BIT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_MEMORY_READ_BIT_KHR" alias="VK_ACCESS_2_MEMORY_READ_BIT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_MEMORY_WRITE_BIT_KHR" alias="VK_ACCESS_2_MEMORY_WRITE_BIT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR" alias="VK_ACCESS_2_SHADER_SAMPLED_READ_BIT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR" alias="VK_ACCESS_2_SHADER_STORAGE_READ_BIT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR" alias="VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_NONE_KHR" alias="VK_PIPELINE_STAGE_2_NONE"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR" alias="VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR" alias="VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR" alias="VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR" alias="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR" alias="VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR" alias="VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR" alias="VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR" alias="VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR" alias="VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR" alias="VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR" alias="VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR" alias="VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR" alias="VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR" alias="VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR" alias="VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_HOST_BIT_KHR" alias="VK_PIPELINE_STAGE_2_HOST_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR" alias="VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR" alias="VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_COPY_BIT_KHR" alias="VK_PIPELINE_STAGE_2_COPY_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR" alias="VK_PIPELINE_STAGE_2_RESOLVE_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_BLIT_BIT_KHR" alias="VK_PIPELINE_STAGE_2_BLIT_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR" alias="VK_PIPELINE_STAGE_2_CLEAR_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR" alias="VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR" alias="VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR" alias="VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT"/>
                <enum extends="VkSubmitFlagBits"                            name="VK_SUBMIT_PROTECTED_BIT_KHR" alias="VK_SUBMIT_PROTECTED_BIT"/>
                <type name="VkFlags64"/>
                <type name="VkPipelineStageFlags2KHR"/>
                <type name="VkPipelineStageFlagBits2KHR"/>
                <type name="VkAccessFlags2KHR"/>
                <type name="VkAccessFlagBits2KHR"/>
                <type name="VkMemoryBarrier2KHR"/>
                <type name="VkBufferMemoryBarrier2KHR"/>
                <type name="VkImageMemoryBarrier2KHR"/>
                <type name="VkDependencyInfoKHR"/>
                <type name="VkSubmitInfo2KHR"/>
                <type name="VkSemaphoreSubmitInfoKHR"/>
                <type name="VkCommandBufferSubmitInfoKHR"/>
                <type name="VkSubmitFlagBitsKHR"/>
                <type name="VkSubmitFlagsKHR"/>
                <type name="VkPhysicalDeviceSynchronization2FeaturesKHR"/>
                <command name="vkCmdSetEvent2KHR"/>
                <command name="vkCmdResetEvent2KHR"/>
                <command name="vkCmdWaitEvents2KHR"/>
                <command name="vkCmdPipelineBarrier2KHR"/>
                <command name="vkCmdWriteTimestamp2KHR"/>
                <command name="vkQueueSubmit2KHR"/>
                <feature name="synchronization2" struct="VkPhysicalDeviceSynchronization2FeaturesKHR"/>
            </require>
            <require depends="VK_EXT_transform_feedback">
                <enum bitpos="24" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT"/>
                <enum bitpos="25" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT"/>
                <enum bitpos="26" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT"/>
                <enum bitpos="27" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT"/>
            </require>
            <require depends="VK_EXT_conditional_rendering">
                <enum bitpos="18" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT" comment="A pipeline stage for conditional rendering predicate fetch"/>
                <enum bitpos="20" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT" comment="read access flag for reading conditional rendering predicate"/>
            </require>
            <require depends="VK_NV_device_generated_commands">
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV" alias="VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV" alias="VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV" alias="VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT"/>
            </require>
            <require depends="VK_EXT_device_generated_commands">
                <enum bitpos="17" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT"/>
                <enum bitpos="17" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT"/>
                <enum bitpos="18" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT"/>
            </require>
            <require depends="VK_KHR_fragment_shading_rate">
                <enum bitpos="22" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
                <enum bitpos="23" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR"/>
            </require>
            <require depends="VK_NV_shading_rate_image">
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV" alias="VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV"    alias="VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR"/>
            </require>
            <require depends="VK_KHR_acceleration_structure">
                <enum bitpos="25" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"/>
                <enum bitpos="21" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR"/>
                <enum bitpos="22" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR"/>
            </require>
            <require depends="VK_KHR_ray_tracing_pipeline">
                <enum bitpos="21" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR"/>
            </require>
            <require depends="VK_NV_ray_tracing">
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV" alias="VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV" alias="VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV" alias="VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR"/>
                <enum extends="VkAccessFlagBits2"                           name="VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV" alias="VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR"/>
            </require>
            <require depends="VK_EXT_fragment_density_map">
                <enum bitpos="23" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT"/>
                <enum bitpos="24" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT"/>
            </require>
            <require depends="VK_EXT_blend_operation_advanced">
                <enum bitpos="19" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT"/>
            </require>
            <require depends="VK_NV_mesh_shader">
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV" alias="VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT"/>
                <enum extends="VkPipelineStageFlagBits2"                    name="VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV" alias="VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT"/>
            </require>
            <require depends="VK_EXT_mesh_shader">
                <enum bitpos="19" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT"/>
                <enum bitpos="20" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_316" number="316" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_316_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_316&quot;"              name="VK_AMD_EXTENSION_316_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_descriptor_buffer" number="317" type="device" author="EXT" depends="((((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_buffer_device_address+VK_EXT_descriptor_indexing),VK_VERSION_1_2)+VK_KHR_synchronization2),VK_VERSION_1_3" contact="Tobias Hector @tobski" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                                 name="VK_EXT_DESCRIPTOR_BUFFER_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_descriptor_buffer&quot;"              name="VK_EXT_DESCRIPTOR_BUFFER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT"/>
                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT"/>
                <enum offset="3" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT"/>
                <enum offset="4" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT"/>
                <enum offset="5" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"/>
                <enum offset="6" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"/>
                <enum offset="7" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"/>
                <enum offset="8" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"/>
                <enum offset="10" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT"/>
                <enum offset="11" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT"/>
                <enum offset="12" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT"/>
                <enum bitpos="4" extends="VkDescriptorSetLayoutCreateFlagBits"  name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT"/>
                <enum bitpos="5" extends="VkDescriptorSetLayoutCreateFlagBits"  name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT"/>
                <enum bitpos="21" extends="VkBufferUsageFlagBits"               name="VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT"/>
                <enum bitpos="22" extends="VkBufferUsageFlagBits"               name="VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT"/>
                <enum bitpos="26" extends="VkBufferUsageFlagBits"               name="VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT"/>
                <enum bitpos="5" extends="VkBufferCreateFlagBits"               name="VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"/>
                <enum bitpos="16" extends="VkImageCreateFlagBits"               name="VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"/>
                <enum bitpos="2" extends="VkImageViewCreateFlagBits"            name="VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"/>
                <enum bitpos="3" extends="VkSamplerCreateFlagBits"              name="VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"/>
                <enum bitpos="3" extends="VkAccelerationStructureCreateFlagBitsKHR" name="VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT"/>
                <enum bitpos="41" extends="VkAccessFlagBits2"                   name="VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT"/>
                <enum bitpos="29"  extends="VkPipelineCreateFlagBits"           name="VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT"/>
                <type name="VkPhysicalDeviceDescriptorBufferPropertiesEXT"/>
                <type name="VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT"/>
                <type name="VkPhysicalDeviceDescriptorBufferFeaturesEXT"/>
                <type name="VkDescriptorAddressInfoEXT"/>
                <type name="VkDescriptorBufferBindingInfoEXT"/>
                <type name="VkDescriptorBufferBindingPushDescriptorBufferHandleEXT"/>
                <type name="VkDescriptorDataEXT"/>
                <type name="VkDescriptorGetInfoEXT"/>
                <type name="VkBufferCaptureDescriptorDataInfoEXT"/>
                <type name="VkImageCaptureDescriptorDataInfoEXT"/>
                <type name="VkImageViewCaptureDescriptorDataInfoEXT"/>
                <type name="VkSamplerCaptureDescriptorDataInfoEXT"/>
                <type name="VkOpaqueCaptureDescriptorDataCreateInfoEXT"/>
                <command name="vkGetDescriptorSetLayoutSizeEXT"/>
                <command name="vkGetDescriptorSetLayoutBindingOffsetEXT"/>
                <command name="vkGetDescriptorEXT"/>
                <command name="vkCmdBindDescriptorBuffersEXT"/>
                <command name="vkCmdSetDescriptorBufferOffsetsEXT"/>
                <command name="vkCmdBindDescriptorBufferEmbeddedSamplersEXT"/>
                <command name="vkGetBufferOpaqueCaptureDescriptorDataEXT"/>
                <command name="vkGetImageOpaqueCaptureDescriptorDataEXT"/>
                <command name="vkGetImageViewOpaqueCaptureDescriptorDataEXT"/>
                <command name="vkGetSamplerOpaqueCaptureDescriptorDataEXT"/>
                <feature name="descriptorBuffer" struct="VkPhysicalDeviceDescriptorBufferFeaturesEXT"/>
            </require>
            <require depends="VK_KHR_acceleration_structure,VK_NV_ray_tracing">
                <enum offset="9" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT"/>
                <type name="VkAccelerationStructureCaptureDescriptorDataInfoEXT"/>
                <command name="vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_318" number="318" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_318_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_318&quot;"              name="VK_AMD_EXTENSION_318_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_319" number="319" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_319_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_319&quot;"              name="VK_AMD_EXTENSION_319_EXTENSION_NAME"/>
                <enum bitpos="3" extends="VkDescriptorSetLayoutCreateFlagBits" name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_RESERVED_3_BIT_AMD"/>
                <enum bitpos="0" extends="VkPipelineLayoutCreateFlagBits" name="VK_PIPELINE_LAYOUT_CREATE_RESERVED_0_BIT_AMD"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_320" number="320" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_320_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_320&quot;"              name="VK_AMD_EXTENSION_320_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_graphics_pipeline_library" number="321" type="device" depends="(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_pipeline_library" author="AMD" contact="Tobias Hector @tobski" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_GRAPHICS_PIPELINE_LIBRARY_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_graphics_pipeline_library&quot;"  name="VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME"/>
                <type name="VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT"/>
                <type name="VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT"/>
                <type name="VkGraphicsPipelineLibraryCreateInfoEXT"/>
                <type name="VkGraphicsPipelineLibraryFlagBitsEXT"/>
                <type name="VkGraphicsPipelineLibraryFlagsEXT"/>
                <type name="VkPipelineLayoutCreateFlagBits"/>
                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT"/>
                <enum offset="2" extends="VkStructureType" name="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT"/>
                <enum bitpos="23" extends="VkPipelineCreateFlagBits" name="VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT"/>
                <enum bitpos="10" extends="VkPipelineCreateFlagBits" name="VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT"/>
                <enum bitpos="1" extends="VkPipelineLayoutCreateFlagBits" name="VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT"/>
                <feature name="graphicsPipelineLibrary" struct="VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_AMD_shader_early_and_late_fragment_tests" number="322" author="EXT" contact="Tobias Hector @tobski" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_shader_early_and_late_fragment_tests&quot;" name="VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME"/>
                <type name="VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD"/>
                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD"/>
                <feature name="shaderEarlyAndLateFragmentTests" struct="VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD"/>
            </require>
        </extension>
        <extension name="VK_KHR_fragment_shader_barycentric" number="323" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="KHR" contact="Stu Smith" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                              name="VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_fragment_shader_barycentric&quot;" name="VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" extnumber="204"   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR"/>
                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR"/>
                <type name="VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR"/>
                <type name="VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR"/>
                <feature name="fragmentShaderBarycentric" struct="VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_subgroup_uniform_control_flow" number="324" type="device" depends="VK_VERSION_1_1" author="KHR" contact="Alan Baker @alan-baker" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1" name="VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_subgroup_uniform_control_flow&quot;" name="VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR"/>
                <type name="VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR"/>
                <feature name="shaderSubgroupUniformControlFlow" struct="VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_325" number="325" author="KHR" contact="Ralph Potter gitlab:@r_potter" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_325_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_325&quot;"              name="VK_KHR_EXTENSION_325_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_zero_initialize_workgroup_memory" number="326" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="KHR" contact="Alan Baker @alan-baker" supported="vulkan" promotedto="VK_VERSION_1_3" ratified="vulkan">
            <require>
                <enum value="1"                                                   name="VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_zero_initialize_workgroup_memory&quot;" name="VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES"/>
                <type name="VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR"/>
                <feature name="shaderZeroInitializeWorkgroupMemory" struct="VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_NV_fragment_shading_rate_enums" number="327" type="device" depends="VK_KHR_fragment_shading_rate" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_fragment_shading_rate_enums&quot;" name="VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV"/>
                <enum offset="1" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV"/>
                <enum offset="2" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV"/>
                <type name="VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV"/>
                <type name="VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV"/>
                <type name="VkPipelineFragmentShadingRateEnumStateCreateInfoNV"/>
                <type name="VkFragmentShadingRateNV"/>
                <type name="VkFragmentShadingRateTypeNV"/>
                <command name="vkCmdSetFragmentShadingRateEnumNV"/>
                <feature name="fragmentShadingRateEnums" struct="VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_ray_tracing_motion_blur" number="328" type="device" depends="VK_KHR_ray_tracing_pipeline" author="NV" contact="Eric Werness" supported="vulkan">
            <require>
                <enum value="1"                                                    name="VK_NV_RAY_TRACING_MOTION_BLUR_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_ray_tracing_motion_blur&quot;"            name="VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV"/>
                <enum offset="1" extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV"/>
                <enum offset="2" extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV"/>
                <enum bitpos="5" extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV"/>
                <enum bitpos="2" extends="VkAccelerationStructureCreateFlagBitsKHR" name="VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV"/>
                <enum bitpos="20" extends="VkPipelineCreateFlagBits"               name="VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV"/>
                <type name="VkAccelerationStructureGeometryMotionTrianglesDataNV"/>
                <type name="VkAccelerationStructureMotionInfoNV"/>
                <type name="VkAccelerationStructureMotionInstanceNV"/>
                <type name="VkAccelerationStructureMotionInstanceDataNV"/>
                <type name="VkAccelerationStructureMatrixMotionInstanceNV"/>
                <type name="VkAccelerationStructureSRTMotionInstanceNV"/>
                <type name="VkSRTDataNV"/>
                <type name="VkAccelerationStructureMotionInstanceTypeNV"/>
                <type name="VkPhysicalDeviceRayTracingMotionBlurFeaturesNV"/>
                <type name="VkAccelerationStructureMotionInfoFlagsNV"/>
                <type name="VkAccelerationStructureMotionInstanceFlagsNV"/>
                <feature name="rayTracingMotionBlur" struct="VkPhysicalDeviceRayTracingMotionBlurFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_EXT_mesh_shader" number="329" type="device" depends="VK_KHR_spirv_1_4,VK_VERSION_1_2" author="EXT" sortorder="1" contact="Christoph Kubisch @pixeljetstream" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_EXT_MESH_SHADER_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_mesh_shader&quot;"            name="VK_EXT_MESH_SHADER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT"/>
                <enum bitpos="6" extends="VkShaderStageFlagBits"        name="VK_SHADER_STAGE_TASK_BIT_EXT"/>
                <enum bitpos="7" extends="VkShaderStageFlagBits"        name="VK_SHADER_STAGE_MESH_BIT_EXT"/>
                <enum bitpos="19" extends="VkPipelineStageFlagBits"     name="VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT"/>
                <enum bitpos="20" extends="VkPipelineStageFlagBits"     name="VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT"/>
                <enum offset="0" extends="VkQueryType"                  name="VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT"/>
                <enum bitpos="11" extends="VkQueryPipelineStatisticFlagBits" name="VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT"/>
                <enum bitpos="12" extends="VkQueryPipelineStatisticFlagBits" name="VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT"/>
                <command name="vkCmdDrawMeshTasksEXT"/>
                <command name="vkCmdDrawMeshTasksIndirectEXT"/>
                <type name="VkPhysicalDeviceMeshShaderFeaturesEXT"/>
                <type name="VkPhysicalDeviceMeshShaderPropertiesEXT"/>
                <type name="VkDrawMeshTasksIndirectCommandEXT"/>
                <feature name="taskShader" struct="VkPhysicalDeviceMeshShaderFeaturesEXT"/>
                <feature name="meshShader" struct="VkPhysicalDeviceMeshShaderFeaturesEXT"/>
            </require>
            <require depends="VK_VERSION_1_2,VK_KHR_draw_indirect_count,VK_AMD_draw_indirect_count">
                <command name="vkCmdDrawMeshTasksIndirectCountEXT"/>
            </require>
            <require depends="VK_NV_device_generated_commands">
                <enum offset="0" extends="VkIndirectCommandsTokenTypeNV" name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV"/>
            </require>
            <require depends="VK_EXT_device_generated_commands">
                <enum offset="0" extends="VkIndirectCommandsTokenTypeEXT" name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT"/>
                <enum offset="1" extends="VkIndirectCommandsTokenTypeEXT" name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT"/>
            </require>
            <require depends="VK_KHR_fragment_shading_rate+VkPhysicalDeviceMeshShaderFeaturesEXT::primitiveFragmentShadingRateMeshShader">
                <feature name="primitiveFragmentShadingRate" struct="VkPhysicalDeviceFragmentShadingRateFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_330" number="330" author="NV" contact="Liam Middlebrook @liam-middlebrook" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_330_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_330&quot;"               name="VK_NV_EXTENSION_330_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_ycbcr_2plane_444_formats" number="331" type="device" depends="VK_KHR_sampler_ycbcr_conversion,VK_VERSION_1_1" author="EXT" contact="Tony Zlatinski @tzlatinski" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3" ratified="vulkansc">
            <require>
                <comment>
                    VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT and
                    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT
                    were not promoted to Vulkan 1.3.
                </comment>
                <enum value="1"                                           name="VK_EXT_YCBCR_2PLANE_444_FORMATS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_ycbcr_2plane_444_formats&quot;" name="VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT"/>
                <enum extends="VkFormat"                                  name="VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT" alias="VK_FORMAT_G8_B8R8_2PLANE_444_UNORM"/>
                <enum extends="VkFormat"                                  name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT" alias="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                  name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT" alias="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16"/>
                <enum extends="VkFormat"                                  name="VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT" alias="VK_FORMAT_G16_B16R16_2PLANE_444_UNORM"/>
                <type name="VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT"/>
                <feature name="ycbcr2plane444Formats" struct="VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_332" number="332" author="NV" contact="Tony Zlatinski @tzlatinski" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_332_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_332&quot;"               name="VK_NV_EXTENSION_332_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_fragment_density_map2" number="333" type="device" depends="VK_EXT_fragment_density_map" author="EXT" contact="Matthew Netsch @mnetsch" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_fragment_density_map2&quot;"      name="VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT"/>
                <enum offset="1"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT"/>
                <enum bitpos="1"  extends="VkImageViewCreateFlagBits"       name="VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT"/>
                <type name="VkPhysicalDeviceFragmentDensityMap2FeaturesEXT"/>
                <type name="VkPhysicalDeviceFragmentDensityMap2PropertiesEXT"/>
                <feature name="fragmentDensityMapDeferred" struct="VkPhysicalDeviceFragmentDensityMap2FeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_QCOM_rotated_copy_commands" number="334" type="device" depends="VK_KHR_copy_commands2,VK_VERSION_1_3" author="QCOM" contact="Matthew Netsch @mnetsch" supported="vulkan" nofeatures="true">
            <require>
                <enum value="2"                                             name="VK_QCOM_ROTATED_COPY_COMMANDS_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_rotated_copy_commands&quot;"     name="VK_QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM"/>
                <type name="VkCopyCommandTransformInfoQCOM"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_335" number="335" type="device" author="KHR" contact="Mark Bellamy @mark.bellamy_arm" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_335_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_335&quot;"              name="VK_KHR_EXTENSION_335_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_image_robustness" number="336" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Graeme Leese @gnl21" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3" ratified="vulkansc">
            <require>
                <enum value="1"                                             name="VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_image_robustness&quot;"           name="VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES"/>
                <type name="VkPhysicalDeviceImageRobustnessFeaturesEXT"/>
                <feature name="robustImageAccess" struct="VkPhysicalDeviceImageRobustnessFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_workgroup_memory_explicit_layout" number="337" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="KHR" contact="Caio Marcelo de Oliveira Filho @cmarcelo" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                                      name="VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_workgroup_memory_explicit_layout&quot;"    name="VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                           name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR"/>
                <type name="VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR"/>
                <feature name="workgroupMemoryExplicitLayout" struct="VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_copy_commands2" number="338" author="KHR" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Matthew Netsch @mnetsch" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_COPY_COMMANDS_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_copy_commands2&quot;"             name="VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR" alias="VK_STRUCTURE_TYPE_BUFFER_COPY_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_COPY_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_BLIT_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR" alias="VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2"/>
                <type name="VkCopyBufferInfo2KHR"/>
                <type name="VkCopyImageInfo2KHR"/>
                <type name="VkCopyBufferToImageInfo2KHR"/>
                <type name="VkCopyImageToBufferInfo2KHR"/>
                <type name="VkBlitImageInfo2KHR"/>
                <type name="VkResolveImageInfo2KHR"/>
                <type name="VkBufferCopy2KHR"/>
                <type name="VkImageCopy2KHR"/>
                <type name="VkImageBlit2KHR"/>
                <type name="VkBufferImageCopy2KHR"/>
                <type name="VkImageResolve2KHR"/>
                <command name="vkCmdCopyBuffer2KHR"/>
                <command name="vkCmdCopyImage2KHR"/>
                <command name="vkCmdCopyBufferToImage2KHR"/>
                <command name="vkCmdCopyImageToBuffer2KHR"/>
                <command name="vkCmdBlitImage2KHR"/>
                <command name="vkCmdResolveImage2KHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_image_compression_control" number="339" type="device" author="EXT" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_IMAGE_COMPRESSION_CONTROL_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_image_compression_control&quot;"  name="VK_EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceImageCompressionControlFeaturesEXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT"/>
                <type name="VkImageCompressionControlEXT"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT" alias="VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2"/>
                <type name="VkSubresourceLayout2EXT"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT" alias="VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2"/>
                <type name="VkImageSubresource2EXT"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT"/>
                <type name="VkImageCompressionPropertiesEXT"/>
                <type                                                       name="VkImageCompressionFlagBitsEXT"/>
                <type                                                       name="VkImageCompressionFlagsEXT"/>
                <type                                                       name="VkImageCompressionFixedRateFlagBitsEXT"/>
                <type                                                       name="VkImageCompressionFixedRateFlagsEXT"/>
                <enum offset="0" dir="-" extends="VkResult" name="VK_ERROR_COMPRESSION_EXHAUSTED_EXT"/>
                <command name="vkGetImageSubresourceLayout2EXT"/>
                <feature name="imageCompressionControl" struct="VkPhysicalDeviceImageCompressionControlFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_attachment_feedback_loop_layout" number="340" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Joshua Ashton @Joshua-Ashton" supported="vulkan" ratified="vulkan" specialuse="glemulation,d3demulation">
            <require>
                <enum value="2"                                                    name="VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_attachment_feedback_loop_layout&quot;"   name="VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT"/>
                <enum offset="0" extends="VkImageLayout"                           name="VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT"/>
                <enum bitpos="19" extends="VkImageUsageFlagBits"                   name="VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"/>
                <enum bitpos="25" extends="VkPipelineCreateFlagBits"               name="VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"/>
                <enum bitpos="26" extends="VkPipelineCreateFlagBits"               name="VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"/>
                <enum bitpos="3"  extends="VkDependencyFlagBits"                   name="VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT" comment="Dependency may be a feedback loop"/>
                <type name="VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT"/>
                <feature name="attachmentFeedbackLoopLayout" struct="VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_4444_formats" number="341" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Joshua Ashton @Joshua-Ashton" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3" ratified="vulkansc">
            <require>
                <comment>
                    VkPhysicalDevice4444FormatsFeaturesEXT and
                    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT
                    were not promoted to Vulkan 1.3.
                </comment>
                <enum value="1"                                             name="VK_EXT_4444_FORMATS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_4444_formats&quot;"               name="VK_EXT_4444_FORMATS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT" alias="VK_FORMAT_A4R4G4B4_UNORM_PACK16"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT" alias="VK_FORMAT_A4B4G4R4_UNORM_PACK16"/>
                <type name="VkPhysicalDevice4444FormatsFeaturesEXT"/>
                <feature name="formatA4R4G4B4" struct="VkPhysicalDevice4444FormatsFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_device_fault" number="342" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Ralph Potter gitlab:@r_potter" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="2"                                             name="VK_EXT_DEVICE_FAULT_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_device_fault&quot;"               name="VK_EXT_DEVICE_FAULT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT"/>
                <type name="VkPhysicalDeviceFaultFeaturesEXT"/>
                <type name="VkDeviceFaultCountsEXT"/>
                <type name="VkDeviceFaultInfoEXT"/>
                <type name="VkDeviceFaultAddressInfoEXT"/>
                <type name="VkDeviceFaultAddressTypeEXT"/>
                <type name="VkDeviceFaultVendorInfoEXT"/>
                <type name="VkDeviceFaultVendorBinaryHeaderVersionEXT"/>
                <type name="VkDeviceFaultVendorBinaryHeaderVersionOneEXT"/>
                <command name="vkGetDeviceFaultInfoEXT"/>
                <feature name="deviceFault" struct="VkPhysicalDeviceFaultFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_ARM_rasterization_order_attachment_access" number="343" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan" promotedto="VK_EXT_rasterization_order_attachment_access" nofeatures="true">
            <require>
                <enum value="1"                                                        name="VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_rasterization_order_attachment_access&quot;" name="VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM"/>
                <enum extends="VkPipelineColorBlendStateCreateFlagBits"     name="VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM" alias="VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT"/>
                <enum extends="VkPipelineDepthStencilStateCreateFlagBits"   name="VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM" alias="VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT"/>
                <enum extends="VkPipelineDepthStencilStateCreateFlagBits"   name="VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM" alias="VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT"/>
                <enum extends="VkSubpassDescriptionFlagBits"                name="VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM" alias="VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT"/>
                <enum extends="VkSubpassDescriptionFlagBits"                name="VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM" alias="VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT"/>
                <enum extends="VkSubpassDescriptionFlagBits"                name="VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM" alias="VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT"/>
            </require>
        </extension>
        <extension name="VK_ARM_extension_344" number="344" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_ARM_EXTENSION_344_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_extension_344&quot;"              name="VK_ARM_EXTENSION_344_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_rgba10x6_formats" number="345" type="device" depends="VK_KHR_sampler_ycbcr_conversion,VK_VERSION_1_1" author="EXT" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan" ratified="vulkan">
             <require>
                    <enum value="1"                                                name="VK_EXT_RGBA10X6_FORMATS_SPEC_VERSION"/>
                    <enum value="&quot;VK_EXT_rgba10x6_formats&quot;"              name="VK_EXT_RGBA10X6_FORMATS_EXTENSION_NAME"/>
                    <enum offset="0" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT"/>
                    <type name="VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT"/>
                    <feature name="formatRgba10x6WithoutYCbCrSampler" struct="VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_NV_acquire_winrt_display" number="346" type="device" depends="VK_EXT_direct_mode_display" author="NV" contact="Jeff Juliano @jjuliano" platform="win32" supported="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_NV_ACQUIRE_WINRT_DISPLAY_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_acquire_winrt_display&quot;"       name="VK_NV_ACQUIRE_WINRT_DISPLAY_EXTENSION_NAME"/>
                <command name="vkAcquireWinrtDisplayNV"/>
                <command name="vkGetWinrtDisplayNV"/>
            </require>
        </extension>
        <extension name="VK_EXT_directfb_surface" number="347" type="instance" depends="VK_KHR_surface" platform="directfb" supported="vulkan" ratified="vulkan" author="EXT" contact="Nicolas Caramelli @caramelli" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_DIRECTFB_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_directfb_surface&quot;"           name="VK_EXT_DIRECTFB_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT"/>
                <type name="VkDirectFBSurfaceCreateFlagsEXT"/>
                <type name="VkDirectFBSurfaceCreateInfoEXT"/>
                <command name="vkCreateDirectFBSurfaceEXT"/>
                <command name="vkGetPhysicalDeviceDirectFBPresentationSupportEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_350" number="350" type="device" author="KHR" contact="Mark Bellamy @mark.bellamy_arm" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_350_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_350&quot;"              name="VK_KHR_EXTENSION_350_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_351" number="351" author="NV" contact="Liam Middlebrook @liam-middlebrook" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_351_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_351&quot;"               name="VK_NV_EXTENSION_351_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_VALVE_mutable_descriptor_type" number="352" type="device" supported="vulkan" author="VALVE" contact="Joshua Ashton @Joshua-Ashton,Hans-Kristian Arntzen @HansKristian-Work" specialuse="d3demulation" depends="VK_KHR_maintenance3" promotedto="VK_EXT_mutable_descriptor_type">
            <require>
                <enum value="1"                                                name="VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION"/>
                <enum value="&quot;VK_VALVE_mutable_descriptor_type&quot;"     name="VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                                name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT"/>
                <enum extends="VkStructureType"                                name="VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE" alias="VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT"/>
                <enum extends="VkDescriptorType"                               name="VK_DESCRIPTOR_TYPE_MUTABLE_VALVE" alias="VK_DESCRIPTOR_TYPE_MUTABLE_EXT"/>
                <enum extends="VkDescriptorPoolCreateFlagBits"                 name="VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE" alias="VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT"/>
                <enum extends="VkDescriptorSetLayoutCreateFlagBits"            name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE" alias="VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT"/>
                <type name="VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE"/>
                <type name="VkMutableDescriptorTypeListVALVE"/>
                <type name="VkMutableDescriptorTypeCreateInfoVALVE"/>
                <feature name="mutableDescriptorType" struct="VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE"/>
            </require>
        </extension>
        <extension name="VK_EXT_vertex_input_dynamic_state" number="353" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
            <require>
                <enum value="2"                                             name="VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_vertex_input_dynamic_state&quot;" name="VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT"/>
                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VERTEX_INPUT_EXT"/>
                <type name="VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT"/>
                <type name="VkVertexInputBindingDescription2EXT"/>
                <type name="VkVertexInputAttributeDescription2EXT"/>
                <command name="vkCmdSetVertexInputEXT"/>
                <feature name="vertexInputDynamicState" struct="VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_physical_device_drm" number="354" author="EXT" type="device" contact="Simon Ser @emersion" supported="vulkan" ratified="vulkan" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_EXT_PHYSICAL_DEVICE_DRM_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_physical_device_drm&quot;"        name="VK_EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT"/>
                <type name="VkPhysicalDeviceDrmPropertiesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_device_address_binding_report" number="355" type="device" depends="(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_EXT_debug_utils" author="EXT" contact="Ralph Potter gitlab:@r_potter" specialuse="debugging,devtools" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                                 name="VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_device_address_binding_report&quot;"  name="VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT"/>
                <enum bitpos="3" extends="VkDebugUtilsMessageTypeFlagBitsEXT"   name="VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT"/>
                <type name="VkPhysicalDeviceAddressBindingReportFeaturesEXT"/>
                <type name="VkDeviceAddressBindingCallbackDataEXT"/>
                <type name="VkDeviceAddressBindingFlagsEXT"/>
                <type name="VkDeviceAddressBindingFlagBitsEXT"/>
                <type name="VkDeviceAddressBindingTypeEXT"/>
                <feature name="reportAddressBinding" struct="VkPhysicalDeviceAddressBindingReportFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_depth_clip_control" number="356" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="vulkan" ratified="vulkan" specialuse="glemulation">
            <require>
                <enum value="1"                                             name="VK_EXT_DEPTH_CLIP_CONTROL_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_depth_clip_control&quot;"         name="VK_EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT"/>
                <type name="VkPhysicalDeviceDepthClipControlFeaturesEXT"/>
                <type name="VkPipelineViewportDepthClipControlCreateInfoEXT"/>
                <feature name="depthClipControl" struct="VkPhysicalDeviceDepthClipControlFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_primitive_topology_list_restart" number="357" type="device" author="EXT" contact="Shahbaz Youssefi @syoussefi" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" supported="vulkan" ratified="vulkan" specialuse="glemulation">
            <require>
                <enum value="1"                                             name="VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_primitive_topology_list_restart&quot;"           name="VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT"/>
                <type name="VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT"/>
                <feature name="primitiveTopologyListRestart" struct="VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_358" number="358" author="KHR" contact="Jeff Bolz @jeffbolznv" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_358_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_358&quot;"              name="VK_KHR_EXTENSION_358_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_359" number="359" author="EXT" contact="Bill Hollings @billhollings" supported="disabled" specialuse="glemulation">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_359_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_359&quot;"              name="VK_EXT_EXTENSION_359_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_360" number="360" author="EXT" contact="Bill Hollings @billhollings" supported="disabled" specialuse="glemulation">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_360_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_360&quot;"              name="VK_EXT_EXTENSION_360_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_format_feature_flags2" number="361" author="KHR" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Lionel Landwerlin @llandwerlin" supported="vulkan" promotedto="VK_VERSION_1_3" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="2"                                             name="VK_KHR_FORMAT_FEATURE_FLAGS_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_format_feature_flags2&quot;"      name="VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR" alias="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR" alias="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR" alias="VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR" alias="VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR" alias="VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR" alias="VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR" alias="VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR" alias="VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR" alias="VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR" alias="VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR" alias="VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR" alias="VK_FORMAT_FEATURE_2_BLIT_SRC_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR" alias="VK_FORMAT_FEATURE_2_BLIT_DST_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR" alias="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR" alias="VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR" alias="VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR" alias="VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR" alias="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR" alias="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR" alias="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR" alias="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR" alias="VK_FORMAT_FEATURE_2_DISJOINT_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR" alias="VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR" alias="VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR" alias="VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT"/>
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR" alias="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT"/>
                <type                                                       name="VkFormatFeatureFlags2KHR"/>
                <type                                                       name="VkFormatFeatureFlagBits2KHR"/>
                <type                                                       name="VkFormatProperties3KHR"/>
            </require>
            <require depends="VK_VERSION_1_2,VK_EXT_sampler_filter_minmax">
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR" alias="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT"/>
            </require>
            <require depends="VK_EXT_filter_cubic,VK_IMG_filter_cubic">
                <enum extends="VkFormatFeatureFlagBits2"                    name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT" alias="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT"/>
            </require>
        </extension>
        <extension name="VK_EXT_present_mode_fifo_latest_ready" number="362" author="EXT" type="device" depends="VK_KHR_swapchain" contact="Lionel Duc @nvlduc" promotedto="VK_KHR_present_mode_fifo_latest_ready" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                                 name="VK_EXT_PRESENT_MODE_FIFO_LATEST_READY_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_present_mode_fifo_latest_ready&quot;" name="VK_EXT_PRESENT_MODE_FIFO_LATEST_READY_EXTENSION_NAME"/>
                <enum extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR"/>
                <enum extends="VkPresentModeKHR" name="VK_PRESENT_MODE_FIFO_LATEST_READY_EXT" alias="VK_PRESENT_MODE_FIFO_LATEST_READY_KHR"/>
                <type name="VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT"/>
                <feature name="presentModeFifoLatestReady" struct="VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_363" number="363" author="EXT" contact="Kaye Mason @chaleur" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_363_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_363&quot;"              name="VK_EXT_EXTENSION_363_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_FUCHSIA_extension_364" number="364" author="FUCHSIA" contact="Craig Stout @cdotstout" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_FUCHSIA_EXTENSION_364_SPEC_VERSION"/>
                <enum value="&quot;VK_FUCHSIA_extension_364&quot;"          name="VK_FUCHSIA_EXTENSION_364_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_FUCHSIA_external_memory" number="365" type="device" depends="(VK_KHR_external_memory_capabilities+VK_KHR_external_memory),VK_VERSION_1_1" author="FUCHSIA" contact="John Rosasco @rosasco" platform="fuchsia" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                name="VK_FUCHSIA_EXTERNAL_MEMORY_SPEC_VERSION"/>
                <enum value="&quot;VK_FUCHSIA_external_memory&quot;"           name="VK_FUCHSIA_EXTERNAL_MEMORY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA"/>
                <enum offset="1" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA"/>
                <enum offset="2" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA"/>
                <enum bitpos="11" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA"/>
                <type name="VkImportMemoryZirconHandleInfoFUCHSIA"/>
                <type name="VkMemoryZirconHandlePropertiesFUCHSIA"/>
                <type name="VkMemoryGetZirconHandleInfoFUCHSIA"/>
                <command name="vkGetMemoryZirconHandleFUCHSIA"/>
                <command name="vkGetMemoryZirconHandlePropertiesFUCHSIA"/>
            </require>
        </extension>
        <extension name="VK_FUCHSIA_external_semaphore" number="366" type="device" depends="VK_KHR_external_semaphore_capabilities+VK_KHR_external_semaphore" author="FUCHSIA" contact="John Rosasco @rosasco" platform="fuchsia" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                name="VK_FUCHSIA_EXTERNAL_SEMAPHORE_SPEC_VERSION"/>
                <enum value="&quot;VK_FUCHSIA_external_semaphore&quot;"        name="VK_FUCHSIA_EXTERNAL_SEMAPHORE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA"/>
                <enum offset="1" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA"/>
                <enum bitpos="7" extends="VkExternalSemaphoreHandleTypeFlagBits" name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA"/>
                <type name="VkImportSemaphoreZirconHandleInfoFUCHSIA"/>
                <type name="VkSemaphoreGetZirconHandleInfoFUCHSIA"/>
                <command name="vkImportSemaphoreZirconHandleFUCHSIA"/>
                <command name="vkGetSemaphoreZirconHandleFUCHSIA"/>
            </require>
        </extension>
        <extension name="VK_FUCHSIA_buffer_collection" number="367" type="device" depends="VK_FUCHSIA_external_memory+(VK_KHR_sampler_ycbcr_conversion,VK_VERSION_1_1)" author="FUCHSIA" contact="John Rosasco @rosasco" supported="vulkan" platform="fuchsia" nofeatures="true">
            <require>
                <enum value="2"                                         name="VK_FUCHSIA_BUFFER_COLLECTION_SPEC_VERSION"/>
                <enum value="&quot;VK_FUCHSIA_buffer_collection&quot;"  name="VK_FUCHSIA_BUFFER_COLLECTION_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA"/>
                <enum offset="0" extends="VkObjectType"                 name="VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA" comment="VkBufferCollectionFUCHSIA"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA"/>
                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA"/>
                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA"/>
                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA"/>
                <enum offset="6" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA"/>
                <enum offset="7" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA"/>
                <enum offset="8" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA"/>
                <enum offset="9" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA"/>
                <type name="VkBufferCollectionFUCHSIA"/>
                <type name="VkBufferCollectionCreateInfoFUCHSIA"/>
                <type name="VkImportMemoryBufferCollectionFUCHSIA"/>
                <type name="VkBufferCollectionImageCreateInfoFUCHSIA"/>
                <type name="VkBufferConstraintsInfoFUCHSIA"/>
                <type name="VkBufferCollectionBufferCreateInfoFUCHSIA"/>
                <type name="VkBufferCollectionPropertiesFUCHSIA"/>
                <type name="VkImageFormatConstraintsFlagsFUCHSIA" comment="Will add VkImageFormatConstraintsFlagBitsFUCHSIA when bits are defined in the future"/>
                <type name="VkSysmemColorSpaceFUCHSIA"/>
                <type name="VkImageConstraintsInfoFlagBitsFUCHSIA"/>
                <type name="VkImageConstraintsInfoFlagsFUCHSIA"/>
                <type name="VkImageConstraintsInfoFUCHSIA"/>
                <type name="VkImageFormatConstraintsInfoFUCHSIA"/>
                <type name="VkBufferCollectionConstraintsInfoFUCHSIA"/>
                <command name="vkCreateBufferCollectionFUCHSIA"/>
                <command name="vkSetBufferCollectionImageConstraintsFUCHSIA"/>
                <command name="vkSetBufferCollectionBufferConstraintsFUCHSIA"/>
                <command name="vkDestroyBufferCollectionFUCHSIA"/>
                <command name="vkGetBufferCollectionPropertiesFUCHSIA"/>
            </require>
            <require depends="VK_EXT_debug_report">
                <enum offset="0" extends="VkDebugReportObjectTypeEXT"   name="VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT"/>
            </require>
        </extension>
        <extension name="VK_FUCHSIA_extension_368" number="368" author="FUCHSIA" contact="Craig Stout @cdotstout" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_FUCHSIA_EXTENSION_368_SPEC_VERSION"/>
                <enum value="&quot;VK_FUCHSIA_extension_368&quot;"          name="VK_FUCHSIA_EXTENSION_368_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_QCOM_extension_369" number="369" author="QCOM" contact="Matthew Netsch @mnetsch" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_QCOM_EXTENSION_369_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_extension_369&quot;"         name="VK_QCOM_EXTENSION_369_EXTENSION_NAME"/>
                <enum bitpos="4" extends="VkDescriptorBindingFlagBits"  name="VK_DESCRIPTOR_BINDING_RESERVED_4_BIT_QCOM"/>
            </require>
        </extension>
        <extension name="VK_HUAWEI_subpass_shading" number="370" type="device" author="HUAWEI" contact="Pan Gao @PanGao-h" depends="((VK_KHR_create_renderpass2,VK_VERSION_1_2)+VK_KHR_synchronization2),VK_VERSION_1_3" supported="vulkan">
            <require>
                <enum value="3"                                         name="VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION"/>
                <enum value="&quot;VK_HUAWEI_subpass_shading&quot;"         name="VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI"/>
                <enum offset="3" extends="VkPipelineBindPoint" extnumber="370" name="VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI"/>
                <enum bitpos="39" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI"/>
                <enum             extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI" alias="VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI" deprecated="aliased"/>
                <enum bitpos="14" extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI"/>
                <type name="VkSubpassShadingPipelineCreateInfoHUAWEI"/>
                <type name="VkPhysicalDeviceSubpassShadingFeaturesHUAWEI"/>
                <type name="VkPhysicalDeviceSubpassShadingPropertiesHUAWEI"/>
                <command name="vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI"/>
                <command name="vkCmdSubpassShadingHUAWEI"/>
                <feature name="subpassShading" struct="VkPhysicalDeviceSubpassShadingFeaturesHUAWEI"/>
            </require>
        </extension>
        <extension name="VK_HUAWEI_invocation_mask" number="371" type="device" depends="VK_KHR_ray_tracing_pipeline+(VK_KHR_synchronization2,VK_VERSION_1_3)" author="Huawei" contact="Pan Gao @PanGao-h" supported="vulkan">
            <require>
                <enum value="1"                                              name="VK_HUAWEI_INVOCATION_MASK_SPEC_VERSION"/>
                <enum value="&quot;VK_HUAWEI_invocation_mask&quot;"        name="VK_HUAWEI_INVOCATION_MASK_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI"/>
                <enum bitpos="39" extends="VkAccessFlagBits2"                name="VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI"/>
                <enum bitpos="18" extends="VkImageUsageFlagBits"             name="VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI"/>
                <enum bitpos="40" extends="VkPipelineStageFlagBits2"         name="VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI"/>
                <type name="VkPhysicalDeviceInvocationMaskFeaturesHUAWEI"/>
                <command name="vkCmdBindInvocationMaskHUAWEI"/>
                <feature name="invocationMask" struct="VkPhysicalDeviceInvocationMaskFeaturesHUAWEI"/>
            </require>
        </extension>
        <extension name="VK_NV_external_memory_rdma" number="372" type="device" depends="VK_KHR_external_memory,VK_VERSION_1_1" author="NV" contact="Carsten Rohde @crohde" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_NV_EXTERNAL_MEMORY_RDMA_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_external_memory_rdma&quot;"            name="VK_NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV"/>
                <enum bitpos="8" extends="VkMemoryPropertyFlagBits"             name="VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV"/>
                <enum bitpos="12" extends="VkExternalMemoryHandleTypeFlagBits"  name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV"/>
                <type name="VkRemoteAddressNV"/>
                <type name="VkMemoryGetRemoteAddressInfoNV"/>
                <type name="VkPhysicalDeviceExternalMemoryRDMAFeaturesNV"/>
                <command name="vkGetMemoryRemoteAddressNV"/>
                <feature name="externalMemoryRDMA" struct="VkPhysicalDeviceExternalMemoryRDMAFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_EXT_pipeline_properties" number="373" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Mukund Keshava @mkeshavanv" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_PIPELINE_PROPERTIES_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_pipeline_properties&quot;"        name="VK_EXT_PIPELINE_PROPERTIES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT"/>
                <enum extends="VkStructureType" name="VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT" alias="VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR"/>
                <type name="VkPipelineInfoEXT"/>
                <type name="VkPipelinePropertiesIdentifierEXT"/>
                <type name="VkPhysicalDevicePipelinePropertiesFeaturesEXT"/>
                <command name="vkGetPipelinePropertiesEXT"/>
                <feature name="pipelinePropertiesIdentifier" struct="VkPhysicalDevicePipelinePropertiesFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_NV_external_sci_sync" number="374" depends="VK_VERSION_1_1" platform="sci" type="device" author="NV" contact="Kai Zhang @kazhang" supported="vulkansc" deprecatedby="VK_NV_external_sci_sync2">
            <require>
                <enum value="2"                                         name="VK_NV_EXTERNAL_SCI_SYNC_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_external_sci_sync&quot;"       name="VK_NV_EXTERNAL_SCI_SYNC_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV"/>
                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV"/>
                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV"/>
                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV"/>
                <enum offset="6" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV"/>
                <enum offset="7" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV"/>
                <enum bitpos="4" extends="VkExternalFenceHandleTypeFlagBits" name="VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV"/>
                <enum bitpos="5" extends="VkExternalFenceHandleTypeFlagBits" name="VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV"/>
                <enum bitpos="5" extends="VkExternalSemaphoreHandleTypeFlagBits" name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV"/>
                <type name="VkSciSyncClientTypeNV"/>
                <type name="VkSciSyncPrimitiveTypeNV"/>
                <type name="VkExportFenceSciSyncInfoNV"/>
                <type name="VkImportFenceSciSyncInfoNV"/>
                <type name="VkFenceGetSciSyncInfoNV"/>
                <type name="VkSciSyncAttributesInfoNV"/>
                <type name="VkExportSemaphoreSciSyncInfoNV"/>
                <type name="VkImportSemaphoreSciSyncInfoNV"/>
                <type name="VkSemaphoreGetSciSyncInfoNV"/>
                <type name="VkPhysicalDeviceExternalSciSyncFeaturesNV"/>
                <command name="vkGetFenceSciSyncFenceNV"/>
                <command name="vkGetFenceSciSyncObjNV"/>
                <command name="vkImportFenceSciSyncFenceNV"/>
                <command name="vkImportFenceSciSyncObjNV"/>
                <command name="vkGetPhysicalDeviceSciSyncAttributesNV"/>
                <command name="vkGetSemaphoreSciSyncObjNV"/>
                <command name="vkImportSemaphoreSciSyncObjNV"/>
                <feature name="sciSyncFence,sciSyncSemaphore" struct="VkPhysicalDeviceExternalSciSyncFeaturesNV"/>
                <feature name="sciSyncImport,sciSyncExport" struct="VkPhysicalDeviceExternalSciSyncFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_external_memory_sci_buf" number="375" depends="VK_VERSION_1_1" platform="sci" type="device" author="NV" contact="Kai Zhang @kazhang" supported="vulkansc">
            <require>
                <enum value="2"                                         name="VK_NV_EXTERNAL_MEMORY_SCI_BUF_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_external_memory_sci_buf&quot;" name="VK_NV_EXTERNAL_MEMORY_SCI_BUF_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV"/>
                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV"/>
                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_BUF_FEATURES_NV" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV"/>
                <enum bitpos="13" extends="VkExternalMemoryHandleTypeFlagBits"  name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCI_BUF_BIT_NV"/>
                <type name="VkExportMemorySciBufInfoNV"/>
                <type name="VkImportMemorySciBufInfoNV"/>
                <type name="VkMemoryGetSciBufInfoNV"/>
                <type name="VkMemorySciBufPropertiesNV"/>
                <type name="VkPhysicalDeviceExternalMemorySciBufFeaturesNV"/>
                <type name="VkPhysicalDeviceExternalSciBufFeaturesNV"/>
                <command name="vkGetMemorySciBufNV"/>
                <command name="vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV"/>
                <command name="vkGetPhysicalDeviceSciBufAttributesNV"/>
                <feature name="sciBufImport,sciBufExport" struct="VkPhysicalDeviceExternalSciBufFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_EXT_frame_boundary" number="376" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" type="device" author="EXT" contact="James Fitzpatrick @jamesfitzpatrick" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_EXT_FRAME_BOUNDARY_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_frame_boundary&quot;"         name="VK_EXT_FRAME_BOUNDARY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT"/>
                <type name="VkPhysicalDeviceFrameBoundaryFeaturesEXT"/>
                <type name="VkFrameBoundaryEXT"/>
                <type name="VkFrameBoundaryFlagBitsEXT"/>
                <type name="VkFrameBoundaryFlagsEXT"/>
                <feature name="frameBoundary" struct="VkPhysicalDeviceFrameBoundaryFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_multisampled_render_to_single_sampled" number="377" type="device" depends="(VK_KHR_create_renderpass2+VK_KHR_depth_stencil_resolve),VK_VERSION_1_2" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                                 name="VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_multisampled_render_to_single_sampled&quot;"   name="VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT"/>
                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT"/>
                <enum bitpos="18" extends="VkImageCreateFlagBits"               name="VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT"/>
                <type name="VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT"/>
                <type name="VkSubpassResolvePerformanceQueryEXT"/>
                <type name="VkMultisampledRenderToSingleSampledInfoEXT"/>
                <feature name="multisampledRenderToSingleSampled" struct="VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extended_dynamic_state2" number="378" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Vikram Kushwaha @vkushwaha-nv" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_3" ratified="vulkan,vulkansc">
            <require>
                <enum value="1"                                             name="VK_EXT_EXTENDED_DYNAMIC_STATE_2_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extended_dynamic_state2&quot;"    name="VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT" comment="Not promoted to 1.3"/>
                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT" comment="Not promoted to 1.3"/>
                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT" alias="VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE"/>
                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT" alias="VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE"/>
                <enum offset="3" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_LOGIC_OP_EXT" comment="Not promoted to 1.3"/>
                <enum extends="VkDynamicState"                              name="VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT" alias="VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE"/>
                <type name="VkPhysicalDeviceExtendedDynamicState2FeaturesEXT" comment="Not promoted to 1.3"/>
                <command name="vkCmdSetPatchControlPointsEXT" comment="Not promoted to 1.3"/>
                <command name="vkCmdSetRasterizerDiscardEnableEXT"/>
                <command name="vkCmdSetDepthBiasEnableEXT"/>
                <command name="vkCmdSetLogicOpEXT" comment="Not promoted to 1.3"/>
                <command name="vkCmdSetPrimitiveRestartEnableEXT"/>
                <feature name="extendedDynamicState2" struct="VkPhysicalDeviceExtendedDynamicState2FeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_QNX_screen_surface" number="379" type="instance" depends="VK_KHR_surface" platform="screen" author="QNX" contact="Mike Gorchak @mgorchak-blackberry" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                         name="VK_QNX_SCREEN_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_QNX_screen_surface&quot;"         name="VK_QNX_SCREEN_SURFACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX"/>
                <type name="VkScreenSurfaceCreateFlagsQNX"/>
                <type name="VkScreenSurfaceCreateInfoQNX"/>
                <command name="vkCreateScreenSurfaceQNX"/>
                <command name="vkGetPhysicalDeviceScreenPresentationSupportQNX"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_380" number="380" author="KHR" contact="James Jones @cubanismo" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_380_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_380&quot;"          name="VK_KHR_EXTENSION_380_EXTENSION_NAME"/>
                <enum bitpos="5" extends="VkSwapchainCreateFlagBitsKHR" name="VK_SWAPCHAIN_CREATE_RESERVED_5_BIT_EXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_381" number="381" author="KHR" contact="James Jones @cubanismo" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_381_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_381&quot;"          name="VK_KHR_EXTENSION_381_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_color_write_enable" number="382" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Sharif Elcott @selcott" supported="vulkan,vulkansc" ratified="vulkan,vulkansc">
            <require>
                <enum value="1"                                         name="VK_EXT_COLOR_WRITE_ENABLE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_color_write_enable&quot;"     name="VK_EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT"/>
                <enum offset="0" extends="VkDynamicState"               name="VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT"/>
                <type name="VkPhysicalDeviceColorWriteEnableFeaturesEXT"/>
                <type name="VkPipelineColorWriteCreateInfoEXT"/>
                <command name="vkCmdSetColorWriteEnableEXT"/>
                <feature name="colorWriteEnable" struct="VkPhysicalDeviceColorWriteEnableFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_primitives_generated_query" number="383" type="device" depends="VK_EXT_transform_feedback" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="vulkan" specialuse="glemulation" ratified="vulkan">
            <require>
                <enum value="1"                                                 name="VK_EXT_PRIMITIVES_GENERATED_QUERY_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_primitives_generated_query&quot;"     name="VK_EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT"/>
                <enum offset="0" extends="VkQueryType"                          name="VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT"/>
                <type name="VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT"/>
                <feature name="primitivesGeneratedQuery" struct="VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_384" number="384" type="instance" author="EXT" contact="Chia-I Wu @olvaffe1" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_EXT_EXTENSION_384_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_384&quot;"          name="VK_EXT_EXTENSION_384_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_MESA_extension_385" number="385" type="instance" author="MESA" contact="Chia-I Wu @olvaffe1" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_MESA_EXTENSION_385_SPEC_VERSION"/>
                <enum value="&quot;VK_MESA_extension_385&quot;"         name="VK_MESA_EXTENSION_385_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_extension_386" number="386" author="GOOGLE" contact="Chia-I Wu @olvaffe1" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_GOOGLE_EXTENSION_386_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_extension_386&quot;"       name="VK_GOOGLE_EXTENSION_386_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_ray_tracing_maintenance1" number="387" type="device" depends="VK_KHR_acceleration_structure" author="KHR" contact="Daniel Koch @dgkoch" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_RAY_TRACING_MAINTENANCE_1_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_ray_tracing_maintenance1&quot;"   name="VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR"/>
                <enum offset="0" extends="VkQueryType"                      name="VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR"/>
                <enum offset="1" extends="VkQueryType"                      name="VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR"/>
                <type name="VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR"/>
                <feature name="rayTracingMaintenance1" struct="VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR"/>
            </require>
            <require depends="VK_KHR_synchronization2,VK_VERSION_1_3">
                <!-- VkPipelineStageFlagBits bitpos="28" is reserved by this extension, but not used -->
                <enum bitpos="28" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR"/>
            </require>
            <require depends="(VK_KHR_synchronization2,VK_VERSION_1_3)+VK_KHR_ray_tracing_pipeline">
                <enum bitpos="40" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR"/>
            </require>
            <require depends="VK_KHR_ray_tracing_pipeline">
                <type name="VkTraceRaysIndirectCommand2KHR"/>
                <command name="vkCmdTraceRaysIndirect2KHR"/>
            </require>
            <require depends="VK_EXT_device_generated_commands">
                <enum offset="4" extends="VkIndirectCommandsTokenTypeEXT" name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_untyped_pointers" number="388" type="device" depends="VK_KHR_get_physical_device_properties2" author="KHR" contact="Alan Baker @alan-baker" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_SHADER_UNTYPED_POINTERS_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_untyped_pointers&quot;"    name="VK_KHR_SHADER_UNTYPED_POINTERS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR"/>
                <type name="VkPhysicalDeviceShaderUntypedPointersFeaturesKHR"/>
                <feature name="shaderUntypedPointers" struct="VkPhysicalDeviceShaderUntypedPointersFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_global_priority_query" number="389" type="device" depends="VK_EXT_global_priority+(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)" author="EXT" contact="Yiwei Zhang @zzyiwei" supported="vulkan" promotedto="VK_KHR_global_priority">
            <require>
                <enum value="1"                                         name="VK_EXT_GLOBAL_PRIORITY_QUERY_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_global_priority_query&quot;"  name="VK_EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME"/>
                <enum extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES"/>
                <enum extends="VkStructureType" name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES"/>
                <enum                                                   name="VK_MAX_GLOBAL_PRIORITY_SIZE_EXT" alias="VK_MAX_GLOBAL_PRIORITY_SIZE"/>
                <type                                                   name="VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT"/>
                <type                                                   name="VkQueueFamilyGlobalPriorityPropertiesEXT"/>
                <feature name="globalPriorityQuery" struct="VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_390" number="390" author="EXT" contact="Joshua Ashton @Joshua-Ashton" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_390_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_390&quot;"              name="VK_EXT_EXTENSION_390_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_VALVE_video_encode_rgb_conversion" number="391" type="device" depends="VK_KHR_video_encode_queue+(VK_KHR_sampler_ycbcr_conversion,VK_VERSION_1_1)" author="VALVE" contact="Autumn Ashton @misyltoad" supported="vulkan">
            <require>
                <enum value="1"                                                name="VK_VALVE_VIDEO_ENCODE_RGB_CONVERSION_SPEC_VERSION"/>
                <enum value="&quot;VK_VALVE_video_encode_rgb_conversion&quot;" name="VK_VALVE_VIDEO_ENCODE_RGB_CONVERSION_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_RGB_CONVERSION_FEATURES_VALVE"/>
                <enum offset="1"  extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_RGB_CONVERSION_CAPABILITIES_VALVE"/>
                <enum offset="2"  extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_PROFILE_RGB_CONVERSION_INFO_VALVE"/>
                <enum offset="3"  extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_RGB_CONVERSION_CREATE_INFO_VALVE"/>
                <type name="VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE"/>
                <type name="VkVideoEncodeRgbConversionCapabilitiesVALVE"/>
                <type name="VkVideoEncodeProfileRgbConversionInfoVALVE"/>
                <type name="VkVideoEncodeSessionRgbConversionCreateInfoVALVE"/>
                <type name="VkVideoEncodeRgbModelConversionFlagBitsVALVE"/>
                <type name="VkVideoEncodeRgbModelConversionFlagsVALVE"/>
                <type name="VkVideoEncodeRgbRangeCompressionFlagBitsVALVE"/>
                <type name="VkVideoEncodeRgbRangeCompressionFlagsVALVE"/>
                <type name="VkVideoEncodeRgbChromaOffsetFlagBitsVALVE"/>
                <type name="VkVideoEncodeRgbChromaOffsetFlagsVALVE"/>
                <feature name="videoEncodeRgbConversion" struct="VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE"/>
            </require>
        </extension>
        <extension name="VK_EXT_image_view_min_lod" number="392" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Joshua Ashton @Joshua-Ashton" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_IMAGE_VIEW_MIN_LOD_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_image_view_min_lod&quot;"         name="VK_EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT"/>
                <type                                                       name="VkPhysicalDeviceImageViewMinLodFeaturesEXT"/>
                <type                                                       name="VkImageViewMinLodCreateInfoEXT"/>
                <feature name="minLod" struct="VkPhysicalDeviceImageViewMinLodFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_multi_draw" number="393" author="EXT" contact="Mike Blumenkrantz @zmike" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_EXT_MULTI_DRAW_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_multi_draw&quot;"             name="VK_EXT_MULTI_DRAW_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT"/>
                <type name="VkPhysicalDeviceMultiDrawFeaturesEXT"/>
                <type name="VkPhysicalDeviceMultiDrawPropertiesEXT"/>
                <command name="vkCmdDrawMultiEXT"/>
                <command name="vkCmdDrawMultiIndexedEXT"/>
                <type name="VkMultiDrawInfoEXT"/>
                <type name="VkMultiDrawIndexedInfoEXT"/>
                <feature name="multiDraw" struct="VkPhysicalDeviceMultiDrawFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_image_2d_view_of_3d" number="394" depends="(VK_KHR_maintenance1+VK_KHR_get_physical_device_properties2),VK_VERSION_1_1" author="EXT" contact="Mike Blumenkrantz @zmike" specialuse="glemulation" type="device" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_IMAGE_2D_VIEW_OF_3D_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_image_2d_view_of_3d&quot;"        name="VK_EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceImage2DViewOf3DFeaturesEXT"/>
                <enum extends="VkImageCreateFlagBits" bitpos="17"           name="VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT" comment="Image is created with a layout where individual slices are capable of being used as 2D images"/>
                <feature name="image2DViewOf3D" struct="VkPhysicalDeviceImage2DViewOf3DFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_portability_enumeration" number="395" author="KHR" contact="Charles Giessen @charles-lunarg" type="instance" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_PORTABILITY_ENUMERATION_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_portability_enumeration&quot;"    name="VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME"/>
                <enum bitpos="0" extends="VkInstanceCreateFlagBits"         name="VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_tile_image" number="396" type="device" author="EXT" depends="VK_VERSION_1_3" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_SHADER_TILE_IMAGE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_tile_image&quot;"          name="VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT"/>
                <type name="VkPhysicalDeviceShaderTileImageFeaturesEXT"/>
                <type name="VkPhysicalDeviceShaderTileImagePropertiesEXT"/>
                <feature name="shaderTileImageColorReadAccess" struct="VkPhysicalDeviceShaderTileImageFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_opacity_micromap" number="397" type="device"  depends="VK_KHR_acceleration_structure+(VK_KHR_synchronization2,VK_VERSION_1_3)" author="EXT" contact="Christoph Kubisch @pixeljetstream, Eric Werness" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="2"                                             name="VK_EXT_OPACITY_MICROMAP_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_opacity_micromap&quot;"           name="VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT"/>
                <enum offset="1"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT"/>
                <enum offset="2"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT"/>
                <enum offset="3"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT"/>
                <enum offset="4"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT"/>
                <enum offset="5"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT"/>
                <enum offset="6"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT"/>
                <enum offset="7"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT"/>
                <enum offset="8"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT"/>
                <enum offset="9"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT"/>
                <enum bitpos="30" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT"/>
                <enum bitpos="44" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_MICROMAP_READ_BIT_EXT"/>
                <enum bitpos="45" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT"/>
                <enum offset="0"  extends="VkQueryType"                     name="VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT"/>
                <enum offset="1"  extends="VkQueryType"                     name="VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT"/>
                <enum offset="0"  extends="VkObjectType"                    name="VK_OBJECT_TYPE_MICROMAP_EXT"/>
                <enum bitpos="23" extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT"/>
                <enum bitpos="24" extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT"/>
                <enum bitpos="24" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT"/>
                <enum bitpos="4"  extends="VkGeometryInstanceFlagBitsKHR"   name="VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT"/>
                <enum             extends="VkGeometryInstanceFlagBitsKHR"   name="VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT" alias="VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT" deprecated="aliased"/>
                <enum bitpos="5"  extends="VkGeometryInstanceFlagBitsKHR"   name="VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT"/>
                <enum             extends="VkGeometryInstanceFlagBitsKHR"   name="VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT" alias="VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT" deprecated="aliased"/>
                <enum bitpos="6"  extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT"/>
                <enum             extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT" alias="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT" deprecated="aliased"/>
                <enum bitpos="7"  extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT"/>
                <enum             extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT" alias="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT" deprecated="aliased"/>
                <enum bitpos="8"  extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT"/>
                <enum             extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT" alias="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT" deprecated="aliased"/>
                <type name="VkMicromapTypeEXT"/>
                <type name="VkMicromapBuildInfoEXT"/>
                <type name="VkMicromapUsageEXT"/>
                <type name="VkMicromapCreateInfoEXT"/>
                <type name="VkMicromapEXT"/>
                <type name="VkBuildMicromapFlagBitsEXT"/>
                <type name="VkBuildMicromapFlagsEXT"/>
                <type name="VkCopyMicromapModeEXT"/>
                <type name="VkPhysicalDeviceOpacityMicromapFeaturesEXT"/>
                <type name="VkPhysicalDeviceOpacityMicromapPropertiesEXT"/>
                <type name="VkMicromapVersionInfoEXT"/>
                <type name="VkCopyMicromapToMemoryInfoEXT"/>
                <type name="VkCopyMemoryToMicromapInfoEXT"/>
                <type name="VkCopyMicromapInfoEXT"/>
                <type name="VkMicromapCreateFlagBitsEXT"/>
                <type name="VkMicromapCreateFlagsEXT"/>
                <type name="VkBuildMicromapModeEXT"/>
                <type name="VkMicromapBuildSizesInfoEXT"/>
                <type name="VkOpacityMicromapFormatEXT"/>
                <type name="VkAccelerationStructureTrianglesOpacityMicromapEXT"/>
                <type name="VkMicromapTriangleEXT"/>
                <type name="VkOpacityMicromapSpecialIndexEXT"/>
                <command name="vkCreateMicromapEXT"/>
                <command name="vkDestroyMicromapEXT"/>
                <command name="vkCmdBuildMicromapsEXT"/>
                <command name="vkBuildMicromapsEXT"/>
                <command name="vkCopyMicromapEXT"/>
                <command name="vkCopyMicromapToMemoryEXT"/>
                <command name="vkCopyMemoryToMicromapEXT"/>
                <command name="vkWriteMicromapsPropertiesEXT"/>
                <command name="vkCmdCopyMicromapEXT"/>
                <command name="vkCmdCopyMicromapToMemoryEXT"/>
                <command name="vkCmdCopyMemoryToMicromapEXT"/>
                <command name="vkCmdWriteMicromapsPropertiesEXT"/>
                <command name="vkGetDeviceMicromapCompatibilityEXT"/>
                <command name="vkGetMicromapBuildSizesEXT"/>
                <feature name="micromap" struct="VkPhysicalDeviceOpacityMicromapFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_NV_displacement_micromap" number="398" type="device" depends="VK_EXT_opacity_micromap" author="NV" contact="Christoph Kubisch @pixeljetstream, Eric Werness @ewerness-nv" supported="vulkan" provisional="true" platform="provisional" deprecatedby="VK_NV_cluster_acceleration_structure">
            <require>
                <enum value="2"                                        name="VK_NV_DISPLACEMENT_MICROMAP_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_displacement_micromap&quot;"  name="VK_NV_DISPLACEMENT_MICROMAP_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"            name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum offset="1"  extends="VkStructureType"            name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum offset="2"  extends="VkStructureType"            name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum bitpos="28" extends="VkPipelineCreateFlagBits"   name="VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum bitpos="9"  extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_BIT_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum             extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_NV" alias="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_BIT_NV" deprecated="aliased" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum offset="0"  extends="VkMicromapTypeEXT"          name="VK_MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <type name="VkPhysicalDeviceDisplacementMicromapFeaturesNV"/>
                <type name="VkPhysicalDeviceDisplacementMicromapPropertiesNV"/>
                <type name="VkAccelerationStructureTrianglesDisplacementMicromapNV"/>
                <type name="VkDisplacementMicromapFormatNV"/>
                <feature name="displacementMicromap" struct="VkPhysicalDeviceDisplacementMicromapFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_JUICE_extension_399" number="399" author="JUICE" contact="Dean Beeler @canadacow" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_JUICE_EXTENSION_399_SPEC_VERSION"/>
                <enum value="&quot;VK_JUICE_extension_399&quot;"        name="VK_JUICE_EXTENSION_399_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_JUICE_extension_400" number="400" author="JUICE" contact="David McCloskey @damcclos" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_JUICE_EXTENSION_400_SPEC_VERSION"/>
                <enum value="&quot;VK_JUICE_extension_400&quot;"        name="VK_JUICE_EXTENSION_400_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_load_store_op_none" number="401" author="EXT" type="device" contact="Shahbaz Youssefi @syoussefi" supported="vulkan" promotedto="VK_KHR_load_store_op_none" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                         name="VK_EXT_LOAD_STORE_OP_NONE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_load_store_op_none&quot;"     name="VK_EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME"/>
                <enum extends="VkAttachmentLoadOp" name="VK_ATTACHMENT_LOAD_OP_NONE_EXT" alias="VK_ATTACHMENT_LOAD_OP_NONE"/>
                <enum extends="VkAttachmentStoreOp" name="VK_ATTACHMENT_STORE_OP_NONE_EXT" alias="VK_ATTACHMENT_STORE_OP_NONE"/>
            </require>
        </extension>
        <extension name="VK_FB_extension_402" number="402" author="FB" contact="Artem Bolgar @artyom17" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_FB_EXTENSION_402_SPEC_VERSION"/>
                <enum value="&quot;VK_FB_extension_402&quot;"           name="VK_FB_EXTENSION_402_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_FB_extension_403" number="403" author="FB" contact="Artem Bolgar @artyom17" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_FB_EXTENSION_403_SPEC_VERSION"/>
                <enum value="&quot;VK_FB_extension_403&quot;"           name="VK_FB_EXTENSION_403_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_FB_extension_404" number="404" author="FB" contact="Artem Bolgar @artyom17" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_FB_EXTENSION_404_SPEC_VERSION"/>
                <enum value="&quot;VK_FB_extension_404&quot;"           name="VK_FB_EXTENSION_404_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_HUAWEI_cluster_culling_shader" number="405" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="HUAWEI" contact="Yuchang Wang @richard_Wang2" supported="vulkan">
            <require>
                <enum value="3"                                              name="VK_HUAWEI_CLUSTER_CULLING_SHADER_SPEC_VERSION"/>
                <enum value="&quot;VK_HUAWEI_cluster_culling_shader&quot;"   name="VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI"/>
                <enum offset="1" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI"/>
                <enum offset="2" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI"/>
                <enum bitpos="41" extends="VkPipelineStageFlagBits2"         name="VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
                <enum bitpos="19" extends="VkShaderStageFlagBits"            name="VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI"/>
                <enum bitpos="13" extends="VkQueryPipelineStatisticFlagBits" name="VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI"/>
                <command name="vkCmdDrawClusterHUAWEI"/>
                <command name="vkCmdDrawClusterIndirectHUAWEI"/>
                <type name="VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI"/>
                <type name="VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI"/>
                <type name="VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI"/>
                <feature name="clustercullingShader" struct="VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI"/>
            </require>
        </extension>
        <extension name="VK_HUAWEI_extension_406" number="406" author="HUAWEI" contact="Hueilong Wang @wyvernathuawei" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_HUAWEI_EXTENSION_406_SPEC_VERSION"/>
                <enum value="&quot;VK_HUAWEI_extension_406&quot;"           name="VK_HUAWEI_EXTENSION_406_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GGP_extension_407" number="407" author="GGP" contact="J.D. Rouan @jdrouan" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_GGP_EXTENSION_407_SPEC_VERSION"/>
                <enum value="&quot;VK_GGP_extension_407&quot;"          name="VK_GGP_EXTENSION_407_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GGP_extension_408" number="408" author="GGP" contact="J.D. Rouan @jdrouan" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_GGP_EXTENSION_408_SPEC_VERSION"/>
                <enum value="&quot;VK_GGP_extension_408&quot;"          name="VK_GGP_EXTENSION_408_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GGP_extension_409" number="409" author="GGP" contact="J.D. Rouan @jdrouan" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_GGP_EXTENSION_409_SPEC_VERSION"/>
                <enum value="&quot;VK_GGP_extension_409&quot;"          name="VK_GGP_EXTENSION_409_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GGP_extension_410" number="410" author="GGP" contact="J.D. Rouan @jdrouan" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_GGP_EXTENSION_410_SPEC_VERSION"/>
                <enum value="&quot;VK_GGP_extension_410&quot;"          name="VK_GGP_EXTENSION_410_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GGP_extension_411" number="411" author="GGP" contact="J.D. Rouan @jdrouan" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_GGP_EXTENSION_411_SPEC_VERSION"/>
                <enum value="&quot;VK_GGP_extension_411&quot;"          name="VK_GGP_EXTENSION_411_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_border_color_swizzle" number="412" type="device" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="vulkan" depends="VK_EXT_custom_border_color" specialuse="glemulation,d3demulation" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_EXT_BORDER_COLOR_SWIZZLE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_border_color_swizzle&quot;"   name="VK_EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT"/>
                <type name="VkPhysicalDeviceBorderColorSwizzleFeaturesEXT"/>
                <type name="VkSamplerBorderColorComponentMappingCreateInfoEXT"/>
                <feature name="borderColorSwizzle" struct="VkPhysicalDeviceBorderColorSwizzleFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_pageable_device_local_memory" number="413" author="EXT" contact="Piers Daniell @pdaniell-nv" type="device" depends="VK_EXT_memory_priority" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                                  name="VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_pageable_device_local_memory&quot;"    name="VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                       name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT"/>
                <type                                                            name="VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT"/>
                <command                                                         name="vkSetDeviceMemoryPriorityEXT"/>
                <feature name="pageableDeviceLocalMemory" struct="VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_maintenance4" number="414" type="device" depends="VK_VERSION_1_1" author="KHR" contact="Piers Daniell @pdaniell-nv" supported="vulkan" promotedto="VK_VERSION_1_3" ratified="vulkan">
            <require>
                <enum value="2"                                             name="VK_KHR_MAINTENANCE_4_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_maintenance4&quot;"               name="VK_KHR_MAINTENANCE_4_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS"/>
                <enum extends="VkImageAspectFlagBits"                       name="VK_IMAGE_ASPECT_NONE_KHR" alias="VK_IMAGE_ASPECT_NONE"/>
                <type name="VkPhysicalDeviceMaintenance4FeaturesKHR"/>
                <type name="VkPhysicalDeviceMaintenance4PropertiesKHR"/>
                <type name="VkDeviceBufferMemoryRequirementsKHR"/>
                <type name="VkDeviceImageMemoryRequirementsKHR"/>
                <command name="vkGetDeviceBufferMemoryRequirementsKHR"/>
                <command name="vkGetDeviceImageMemoryRequirementsKHR"/>
                <command name="vkGetDeviceImageSparseMemoryRequirementsKHR"/>
                <feature name="maintenance4" struct="VkPhysicalDeviceMaintenance4FeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_HUAWEI_extension_415" number="415" author="HUAWEI" contact="Hueilong Wang @wyvernathuawei" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_HUAWEI_EXTENSION_415_SPEC_VERSION"/>
                <enum value="&quot;VK_HUAWEI_extension_415&quot;"         name="VK_HUAWEI_EXTENSION_415_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_ARM_shader_core_properties" number="416" type="device" depends="VK_VERSION_1_1" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                         name="VK_ARM_SHADER_CORE_PROPERTIES_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_shader_core_properties&quot;" name="VK_ARM_SHADER_CORE_PROPERTIES_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM"/>
                <type name="VkPhysicalDeviceShaderCorePropertiesARM"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_subgroup_rotate" number="417" author="KHR" contact="Kevin Petit @kpet" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" type="device" supported="vulkan" promotedto="VK_VERSION_1_4" ratified="vulkan">
            <require>
                <enum value="2"                                         name="VK_KHR_SHADER_SUBGROUP_ROTATE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_subgroup_rotate&quot;" name="VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES"/>
                <enum extends="VkSubgroupFeatureFlagBits"               name="VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR" alias="VK_SUBGROUP_FEATURE_ROTATE_BIT"/>
                <enum extends="VkSubgroupFeatureFlagBits"               name="VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR" alias="VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT"/>
                <type name="VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR"/>
                <feature name="shaderSubgroupRotate" struct="VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_ARM_scheduling_controls" number="418" author="ARM" contact="Kevin Petit @kpet" type="device" depends="VK_ARM_shader_core_builtins" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_ARM_SCHEDULING_CONTROLS_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_scheduling_controls&quot;"    name="VK_ARM_SCHEDULING_CONTROLS_EXTENSION_NAME"/>
                <enum extends="VkStructureType" offset="0"              name="VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM"/>
                <enum extends="VkStructureType" offset="1"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM"/>
                <enum extends="VkStructureType" offset="2"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM"/>
                <type name="VkDeviceQueueShaderCoreControlCreateInfoARM"/>
                <type name="VkPhysicalDeviceSchedulingControlsFeaturesARM"/>
                <type name="VkPhysicalDeviceSchedulingControlsPropertiesARM"/>
                <type name="VkPhysicalDeviceSchedulingControlsFlagsARM"/>
                <type name="VkPhysicalDeviceSchedulingControlsFlagBitsARM"/>
                <feature name="schedulingControls" struct="VkPhysicalDeviceSchedulingControlsFeaturesARM"/>
            </require>
        </extension>
        <extension name="VK_EXT_image_sliced_view_of_3d" number="419" depends="(VK_KHR_maintenance1+VK_KHR_get_physical_device_properties2),VK_VERSION_1_1" author="EXT" contact="Mike Blumenkrantz @zmike" specialuse="d3demulation" type="device" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_IMAGE_SLICED_VIEW_OF_3D_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_image_sliced_view_of_3d&quot;"    name="VK_EXT_IMAGE_SLICED_VIEW_OF_3D_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT"/>
                <enum name="VK_REMAINING_3D_SLICES_EXT"/>
                <type name="VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT"/>
                <type name="VkImageViewSlicedCreateInfoEXT"/>
                <feature name="imageSlicedViewOf3D" struct="VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_420" number="420" author="EXT" contact="Mike Blumenkrantz @zmike" type="device" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_420_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_420&quot;"              name="VK_EXT_EXTENSION_420_EXTENSION_NAME"/>
                <enum bitpos="4" extends="VkSwapchainCreateFlagBitsKHR" name="VK_SWAPCHAIN_CREATE_RESERVED_4_BIT_EXT"/>
            </require>
        </extension>
        <extension name="VK_VALVE_descriptor_set_host_mapping" number="421" type="device" author="VALVE" contact="Hans-Kristian Arntzen @HansKristian-Work" specialuse="d3demulation" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_SPEC_VERSION"/>
                <enum value="&quot;VK_VALVE_descriptor_set_host_mapping&quot;"  name="VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE"/>
                <enum offset="1"  extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE"/>
                <enum offset="2"  extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE"/>
                <type name="VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE"/>
                <type name="VkDescriptorSetBindingReferenceVALVE"/>
                <type name="VkDescriptorSetLayoutHostMappingInfoVALVE"/>
                <command name="vkGetDescriptorSetLayoutHostMappingInfoVALVE"/>
                <command name="vkGetDescriptorSetHostMappingVALVE"/>
                <feature name="descriptorSetHostMapping" struct="VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE"/>
            </require>
        </extension>
        <extension name="VK_EXT_depth_clamp_zero_one" number="422" author="EXT" type="device" contact="Graeme Leese @gnl21" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" promotedto="VK_KHR_depth_clamp_zero_one" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_depth_clamp_zero_one&quot;"       name="VK_EXT_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR"/>
                <type name="VkPhysicalDeviceDepthClampZeroOneFeaturesEXT" />
                <feature name="depthClampZeroOne" struct="VkPhysicalDeviceDepthClampZeroOneFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_non_seamless_cube_map" number="423" author="EXT" type="device" contact="Georg Lehmann @DadSchoorse" specialuse="d3demulation,glemulation" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_NON_SEAMLESS_CUBE_MAP_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_non_seamless_cube_map&quot;"      name="VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME"/>
                <enum bitpos="2" extends="VkSamplerCreateFlagBits"          name="VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT"/>
                <feature name="nonSeamlessCubeMap" struct="VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_ARM_extension_424" number="424" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_ARM_EXTENSION_424_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_extension_424&quot;"          name="VK_ARM_EXTENSION_424_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_ARM_render_pass_striped" number="425" type="device" depends="((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_synchronization2),VK_VERSION_1_3" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_ARM_RENDER_PASS_STRIPED_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_render_pass_striped&quot;"    name="VK_ARM_RENDER_PASS_STRIPED_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM"/>
                <enum offset="1"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM"/>
                <enum offset="2"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM"/>
                <enum offset="3"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM"/>
                <enum offset="4"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM"/>
                <type name="VkPhysicalDeviceRenderPassStripedFeaturesARM"/>
                <type name="VkPhysicalDeviceRenderPassStripedPropertiesARM"/>
                <type name="VkRenderPassStripeBeginInfoARM"/>
                <type name="VkRenderPassStripeInfoARM"/>
                <type name="VkRenderPassStripeSubmitInfoARM"/>
                <feature name="renderPassStriped" struct="VkPhysicalDeviceRenderPassStripedFeaturesARM"/>
            </require>
        </extension>
        <extension name="VK_QCOM_fragment_density_map_offset" number="426" type="device" depends="(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_EXT_fragment_density_map" author="QCOM" contact="Matthew Netsch @mnetsch" supported="vulkan" promotedto="VK_EXT_fragment_density_map_offset">
            <require>
                <enum value="3"                                               name="VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_fragment_density_map_offset&quot;" name="VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                               name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT"/>
                <enum extends="VkStructureType"                               name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT"/>
                <enum extends="VkStructureType"                               name="VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM" alias="VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT"/>
                <enum extends="VkImageCreateFlagBits"                         name="VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM" alias="VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT"/>
                <type name="VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM"/>
                <type name="VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM"/>
                <type name="VkSubpassFragmentDensityMapOffsetEndInfoQCOM"/>
                <feature name="fragmentDensityMapOffset" struct="VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM"/>
            </require>
        </extension>
        <extension name="VK_NV_copy_memory_indirect" number="427" type="device" depends="((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_buffer_device_address),VK_VERSION_1_2" author="NV" contact="Vikram Kushwaha @vkushwaha-nv" promotedto="VK_KHR_copy_memory_indirect" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_NV_COPY_MEMORY_INDIRECT_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_copy_memory_indirect&quot;"    name="VK_NV_COPY_MEMORY_INDIRECT_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV"/>
                <enum extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_KHR"/>
                <type name="VkCopyMemoryIndirectCommandNV"/>
                <type name="VkCopyMemoryToImageIndirectCommandNV"/>
                <type name="VkPhysicalDeviceCopyMemoryIndirectFeaturesNV"/>
                <type name="VkPhysicalDeviceCopyMemoryIndirectPropertiesNV"/>
                <command name="vkCmdCopyMemoryIndirectNV"/>
                <command name="vkCmdCopyMemoryToImageIndirectNV"/>
                <feature name="indirectCopy" struct="VkPhysicalDeviceCopyMemoryIndirectFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_memory_decompression" number="428" type="device" depends="((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_buffer_device_address),VK_VERSION_1_2" author="NV" contact="Vikram Kushwaha @vkushwaha-nv" promotedto="VK_EXT_memory_decompression" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_NV_MEMORY_DECOMPRESSION_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_memory_decompression&quot;"    name="VK_NV_MEMORY_DECOMPRESSION_EXTENSION_NAME"/>
                <enum extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_EXT"/>
                <enum extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_EXT"/>
                <type name="VkMemoryDecompressionMethodFlagBitsNV"/>
                <type name="VkMemoryDecompressionMethodFlagsNV"/>
                <type name="VkDecompressMemoryRegionNV"/>
                <type name="VkPhysicalDeviceMemoryDecompressionFeaturesNV"/>
                <type name="VkPhysicalDeviceMemoryDecompressionPropertiesNV"/>
                <command name="vkCmdDecompressMemoryNV"/>
                <command name="vkCmdDecompressMemoryIndirectCountNV"/>
                <feature name="memoryDecompression" struct="VkPhysicalDeviceMemoryDecompressionFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_device_generated_commands_compute" number="429" type="device" depends="VK_NV_device_generated_commands" author="NV" contact="Vikram Kushwaha @vkushwaha-nv" supported="vulkan">
            <require>
                <enum value="2"                                           name="VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_device_generated_commands_compute&quot;"  name="VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV"/>
                <enum offset="2" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV"/>
                <enum offset="3" extends="VkIndirectCommandsTokenTypeNV"  name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV"/>
                <enum offset="4" extends="VkIndirectCommandsTokenTypeNV"  name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV"/>
                <enum bitpos="7" extends="VkDescriptorSetLayoutCreateFlagBits"  name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV"/>
                <type name="VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV"/>
                <type name="VkComputePipelineIndirectBufferInfoNV"/>
                <type name="VkPipelineIndirectDeviceAddressInfoNV"/>
                <type name="VkBindPipelineIndirectCommandNV"/>
                <command name="vkGetPipelineIndirectMemoryRequirementsNV"/>
                <command name="vkCmdUpdatePipelineIndirectBufferNV"/>
                <command name="vkGetPipelineIndirectDeviceAddressNV"/>
                <feature name="deviceGeneratedCompute" struct="VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_ray_tracing_linear_swept_spheres" number="430" type="device" depends="VK_KHR_ray_tracing_pipeline" author="NV" contact="Vikram Kushwaha @vkushwaha" supported="vulkan">
            <require>
                <enum value="1"                                                   name="VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_ray_tracing_linear_swept_spheres&quot;"  name="VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_EXTENSION_NAME"/>
                <enum offset="4" extends="VkGeometryTypeKHR"                      name="VK_GEOMETRY_TYPE_SPHERES_NV"/>
                <enum offset="5" extends="VkGeometryTypeKHR"                      name="VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV"/>
                <enum offset="8" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV"/>
                <enum offset="9" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV"/>
                <enum offset="10" extends="VkStructureType"                       name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV"/>
                <enum bitpos="33" extends="VkPipelineCreateFlagBits2"             name="VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_SPHERES_AND_LINEAR_SWEPT_SPHERES_BIT_NV"/>
                <enum bitpos="51" extends="VkFormatFeatureFlagBits2"              name="VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_RADIUS_BUFFER_BIT_NV"/>
                <type name="VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV"/>
                <type name="VkAccelerationStructureGeometryLinearSweptSpheresDataNV"/>
                <type name="VkAccelerationStructureGeometrySpheresDataNV"/>
                <type name="VkRayTracingLssIndexingModeNV"/>
                <type name="VkRayTracingLssPrimitiveEndCapsModeNV"/>
                <feature name="spheres,linearSweptSpheres" struct="VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_linear_color_attachment" number="431" type="device" author="NVIDIA" contact="sourav parmar @souravpNV" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_NV_LINEAR_COLOR_ATTACHMENT_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_linear_color_attachment&quot;" name="VK_NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV"/>
                <type                                                   name="VkPhysicalDeviceLinearColorAttachmentFeaturesNV"/>
                <feature name="linearColorAttachment" struct="VkPhysicalDeviceLinearColorAttachmentFeaturesNV"/>
            </require>
            <require depends="VK_KHR_format_feature_flags2,VK_VERSION_1_3">
                <enum bitpos="38" extends="VkFormatFeatureFlagBits2"    name="VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV" comment="Format support linear image as render target, it cannot be mixed with non linear attachment"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_432" number="432" author="NV" contact="Sourav Parmar @souravpNV" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_NV_EXTENSION_432_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_432&quot;"           name="VK_NV_EXTENSION_432_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_433" number="433" author="NV" contact="Sourav Parmar @souravpNV" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_NV_EXTENSION_433_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_433&quot;"           name="VK_NV_EXTENSION_433_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_surfaceless_query" number="434" type="instance" depends="VK_KHR_surface" author="GOOGLE" contact="Shahbaz Youssefi @syoussefi" specialuse="glemulation" supported="vulkan" nofeatures="true">
            <require>
                <enum value="2"                                         name="VK_GOOGLE_SURFACELESS_QUERY_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_surfaceless_query&quot;"   name="VK_GOOGLE_SURFACELESS_QUERY_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_maximal_reconvergence" number="435" type="device" author="KHR" depends="VK_VERSION_1_1" contact="Alan Baker @alan-baker" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_maximal_reconvergence&quot;"          name="VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR"/>
                <type name="VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR"/>
                <feature name="shaderMaximalReconvergence" struct="VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_application_parameters" number="436" type="instance" author="EXT" contact="Daniel Koch @dgkoch" supported="vulkansc" ratified="vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                         name="VK_EXT_APPLICATION_PARAMETERS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_application_parameters&quot;" name="VK_EXT_APPLICATION_PARAMETERS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT"/>
                <type name="VkApplicationParametersEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_437" number="437" author="EXT" contact="Jonathan Weinstein @Jonathan-Weinstein" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_EXT_EXTENSION_437_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_437&quot;"          name="VK_EXT_EXTENSION_437_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_image_compression_control_swapchain" number="438" type="device" depends="VK_EXT_image_compression_control" author="EXT" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_image_compression_control_swapchain&quot;"  name="VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT"/>
                <feature name="imageCompressionControlSwapchain" struct="VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_SEC_extension_439" number="439" author="SEC" contact="Ralph Potter gitlab:@r_potter" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_SEC_EXTENSION_439_SPEC_VERSION"/>
                <enum value="&quot;VK_SEC_extension_439&quot;"          name="VK_SEC_EXTENSION_439_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_QCOM_extension_440" number="440" author="QCOM" contact="Matthew Netsch @mnetsch" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_QCOM_EXTENSION_440_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_extension_440&quot;"         name="VK_QCOM_EXTENSION_440_EXTENSION_NAME"/>
                <enum bitpos="7" extends="VkQueueFlagBits"              name="VK_QUEUE_RESERVED_7_BIT_QCOM"/>
                <enum bitpos="1" extends="VkDeviceQueueCreateFlagBits"  name="VK_DEVICE_QUEUE_CREATE_RESERVED_1_BIT_QCOM"/>
            </require>
        </extension>
        <extension name="VK_QCOM_image_processing" number="441" type="device" depends="VK_KHR_format_feature_flags2,VK_VERSION_1_3" author="QCOM" contact="Matthew Netsch @mnetsch" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_QCOM_IMAGE_PROCESSING_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_image_processing&quot;"      name="VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM"/>
                <enum bitpos="4" extends="VkSamplerCreateFlagBits"      name="VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM"/>
                <enum bitpos="20" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM"/>
                <enum bitpos="21" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM"/>
                <enum offset="0" extends="VkDescriptorType"             name="VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM"/>
                <enum offset="1" extends="VkDescriptorType"             name="VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM"/>
                <type name="VkImageViewSampleWeightCreateInfoQCOM"/>
                <type name="VkPhysicalDeviceImageProcessingFeaturesQCOM"/>
                <type name="VkPhysicalDeviceImageProcessingPropertiesQCOM"/>
                <feature name="textureSampleWeighted" struct="VkPhysicalDeviceImageProcessingFeaturesQCOM"/>
                <feature name="textureBlockMatch" struct="VkPhysicalDeviceImageProcessingFeaturesQCOM"/>
                <feature name="textureBoxFilter" struct="VkPhysicalDeviceImageProcessingFeaturesQCOM"/>
            </require>
            <require depends="VK_KHR_format_feature_flags2,VK_VERSION_1_3">
                <enum bitpos="34" extends="VkFormatFeatureFlagBits2" name="VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM"/>
                <enum bitpos="35" extends="VkFormatFeatureFlagBits2" name="VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM"/>
                <enum bitpos="36" extends="VkFormatFeatureFlagBits2" name="VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM"/>
                <enum bitpos="37" extends="VkFormatFeatureFlagBits2" name="VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM"/>
            </require>
        </extension>
        <extension name="VK_COREAVI_extension_442" number="442" author="COREAVI" contact="Aidan Fabius @afabius" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_COREAVI_EXTENSION_442_SPEC_VERSION"/>
                <enum value="&quot;VK_COREAVI_extension_442&quot;"          name="VK_COREAVI_EXTENSION_442_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_COREAVI_extension_443" number="443" author="COREAVI" contact="Aidan Fabius @afabius" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_COREAVI_EXTENSION_443_SPEC_VERSION"/>
                <enum value="&quot;VK_COREAVI_extension_443&quot;"          name="VK_COREAVI_EXTENSION_443_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_COREAVI_extension_444" number="444" author="COREAVI" contact="Aidan Fabius @afabius" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_COREAVI_EXTENSION_444_SPEC_VERSION"/>
                <enum value="&quot;VK_COREAVI_extension_444&quot;"          name="VK_COREAVI_EXTENSION_444_EXTENSION_NAME"/>
                <enum extends="VkCommandPoolResetFlagBits" bitpos="1"       name="VK_COMMAND_POOL_RESET_RESERVED_1_BIT_COREAVI"/>
            </require>
        </extension>
        <extension name="VK_COREAVI_extension_445" number="445" author="COREAVI" contact="Aidan Fabius @afabius" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_COREAVI_EXTENSION_445_SPEC_VERSION"/>
                <enum value="&quot;VK_COREAVI_extension_445&quot;"          name="VK_COREAVI_EXTENSION_445_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_COREAVI_extension_446" number="446" author="COREAVI" contact="Aidan Fabius @afabius" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_COREAVI_EXTENSION_446_SPEC_VERSION"/>
                <enum value="&quot;VK_COREAVI_extension_446&quot;"          name="VK_COREAVI_EXTENSION_446_EXTENSION_NAME"/>
                <enum bitpos="24" extends="VkImageUsageFlagBits"            name="VK_IMAGE_USAGE_RESERVED_24_BIT_COREAVI"/>
            </require>
        </extension>
        <extension name="VK_COREAVI_extension_447" number="447" author="COREAVI" contact="Aidan Fabius @afabius" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_COREAVI_EXTENSION_447_SPEC_VERSION"/>
                <enum value="&quot;VK_COREAVI_extension_447&quot;"          name="VK_COREAVI_EXTENSION_447_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_SEC_extension_448" number="448" author="SEC" contact="Ralph Potter gitlab:@r_potter" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_SEC_EXTENSION_448_SPEC_VERSION"/>
                <enum value="&quot;VK_SEC_extension_448&quot;"          name="VK_SEC_EXTENSION_448_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_SEC_extension_449" number="449" author="SEC" contact="Ralph Potter gitlab:@r_potter" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_SEC_EXTENSION_449_SPEC_VERSION"/>
                <enum value="&quot;VK_SEC_extension_449&quot;"          name="VK_SEC_EXTENSION_449_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_SEC_extension_450" number="450" author="SEC" contact="Ralph Potter gitlab:@r_potter" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_SEC_EXTENSION_450_SPEC_VERSION"/>
                <enum value="&quot;VK_SEC_extension_450&quot;"          name="VK_SEC_EXTENSION_450_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_SEC_extension_451" number="451" author="SEC" contact="Ralph Potter gitlab:@r_potter" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_SEC_EXTENSION_451_SPEC_VERSION"/>
                <enum value="&quot;VK_SEC_extension_451&quot;"          name="VK_SEC_EXTENSION_451_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_nested_command_buffer" number="452" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_EXT_NESTED_COMMAND_BUFFER_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_nested_command_buffer&quot;"  name="VK_EXT_NESTED_COMMAND_BUFFER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT"/>
                <enum extends="VkSubpassContents"    name="VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT" alias="VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR"/>
                <enum extends="VkRenderingFlagBits"  name="VK_RENDERING_CONTENTS_INLINE_BIT_EXT" alias="VK_RENDERING_CONTENTS_INLINE_BIT_KHR"/>
                <type                                                   name="VkPhysicalDeviceNestedCommandBufferFeaturesEXT"/>
                <type                                                   name="VkPhysicalDeviceNestedCommandBufferPropertiesEXT"/>
                <feature name="nestedCommandBuffer" struct="VkPhysicalDeviceNestedCommandBufferFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_OHOS_external_memory" number="453" type="device" author="HUAWEI" depends="((VK_KHR_sampler_ycbcr_conversion+VK_KHR_external_memory+VK_KHR_dedicated_allocation),VK_VERSION_1_1)+VK_EXT_queue_family_foreign" platform="ohos" contact="Weilan Chen @wchen-h" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_OHOS_EXTERNAL_MEMORY_SPEC_VERSION"/>
                <enum value="&quot;VK_OHOS_external_memory&quot;"           name="VK_OHOS_EXTERNAL_MEMORY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_NATIVE_BUFFER_USAGE_OHOS"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_NATIVE_BUFFER_PROPERTIES_OHOS"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_NATIVE_BUFFER_FORMAT_PROPERTIES_OHOS"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_NATIVE_BUFFER_INFO_OHOS"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MEMORY_GET_NATIVE_BUFFER_INFO_OHOS"/>
                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_OHOS"/>
                <type name="VkNativeBufferUsageOHOS"/>
                <type name="VkNativeBufferPropertiesOHOS"/>
                <type name="VkNativeBufferFormatPropertiesOHOS"/>
                <type name="VkImportNativeBufferInfoOHOS"/>
                <type name="VkMemoryGetNativeBufferInfoOHOS"/>
                <type name="VkExternalFormatOHOS"/>
                <type name="OH_NativeBuffer"/>
                <enum bitpos="15" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OH_NATIVE_BUFFER_BIT_OHOS"/>
                <command name="vkGetNativeBufferPropertiesOHOS"/>
                <command name="vkGetMemoryNativeBufferOHOS"/>
            </require>
        </extension>
        <extension name="VK_EXT_external_memory_acquire_unmodified" number="454" type="device" depends="VK_KHR_external_memory,VK_VERSION_1_1" author="EXT" contact="James Jones @cubanismo" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require comment="Note that VK_OHOS_native_buffer uses VkStructureType enum values from this range, with permission">
                <enum value="1"                                                         name="VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_external_memory_acquire_unmodified&quot;"     name="VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                              name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT"/>
                <type name="VkExternalMemoryAcquireUnmodifiedEXT"/>
            </require>
        </extension>
        <extension name="VK_GOOGLE_extension_455" number="455" author="GOOGLE" contact="Shahbaz Youssefi @syoussefi" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_GOOGLE_EXTENSION_455_SPEC_VERSION"/>
                <enum value="&quot;VK_GOOGLE_extension_455&quot;"       name="VK_GOOGLE_EXTENSION_455_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extended_dynamic_state3" number="456" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="2"                                              name="VK_EXT_EXTENDED_DYNAMIC_STATE_3_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extended_dynamic_state3&quot;"     name="VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT"/>
                <enum offset="3" extends="VkDynamicState"                    name="VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT"/>
                <enum offset="4" extends="VkDynamicState"                    name="VK_DYNAMIC_STATE_POLYGON_MODE_EXT"/>
                <enum offset="5" extends="VkDynamicState"                    name="VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT"/>
                <enum offset="6" extends="VkDynamicState"                    name="VK_DYNAMIC_STATE_SAMPLE_MASK_EXT"/>
                <enum offset="7" extends="VkDynamicState"                    name="VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT"/>
                <enum offset="8" extends="VkDynamicState"                    name="VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT"/>
                <enum offset="9" extends="VkDynamicState"                    name="VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT"/>
                <enum offset="10" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT"/>
                <enum offset="11" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT"/>
                <enum offset="12" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT"/>
                <type name="VkPhysicalDeviceExtendedDynamicState3FeaturesEXT"/>
                <type name="VkPhysicalDeviceExtendedDynamicState3PropertiesEXT"/>
                <type name="VkColorBlendEquationEXT"/>
                <type name="VkColorBlendAdvancedEXT"/>
                <command name="vkCmdSetDepthClampEnableEXT"/>
                <command name="vkCmdSetPolygonModeEXT"/>
                <command name="vkCmdSetRasterizationSamplesEXT"/>
                <command name="vkCmdSetSampleMaskEXT"/>
                <command name="vkCmdSetAlphaToCoverageEnableEXT"/>
                <command name="vkCmdSetAlphaToOneEnableEXT"/>
                <command name="vkCmdSetLogicOpEnableEXT"/>
                <command name="vkCmdSetColorBlendEnableEXT"/>
                <command name="vkCmdSetColorBlendEquationEXT"/>
                <command name="vkCmdSetColorWriteMaskEXT"/>
            </require>
            <require depends="VK_KHR_maintenance2,VK_VERSION_1_1">
                <enum offset="2" extends="VkDynamicState"                    name="VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT"/>
                <command name="vkCmdSetTessellationDomainOriginEXT"/>
            </require>
            <require depends="VK_EXT_transform_feedback">
                <enum offset="13" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT"/>
                <command name="vkCmdSetRasterizationStreamEXT"/>
            </require>
            <require depends="VK_EXT_conservative_rasterization">
                <enum offset="14" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT"/>
                <enum offset="15" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT"/>
                <command name="vkCmdSetConservativeRasterizationModeEXT"/>
                <command name="vkCmdSetExtraPrimitiveOverestimationSizeEXT"/>
            </require>
            <require depends="VK_EXT_depth_clip_enable">
                <enum offset="16" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT"/>
                <command name="vkCmdSetDepthClipEnableEXT"/>
            </require>
            <require depends="VK_EXT_sample_locations">
                <enum offset="17" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT"/>
                <command name="vkCmdSetSampleLocationsEnableEXT"/>
            </require>
            <require depends="VK_EXT_blend_operation_advanced">
                <enum offset="18" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT"/>
                <command name="vkCmdSetColorBlendAdvancedEXT"/>
            </require>
            <require depends="VK_EXT_provoking_vertex">
                <enum offset="19" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT"/>
                <command name="vkCmdSetProvokingVertexModeEXT"/>
            </require>
            <require depends="VK_EXT_line_rasterization">
                <enum offset="20" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT"/>
                <enum offset="21" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT"/>
                <command name="vkCmdSetLineRasterizationModeEXT"/>
                <command name="vkCmdSetLineStippleEnableEXT"/>
            </require>
            <require depends="VK_EXT_depth_clip_control">
                <enum offset="22" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT"/>
                <command name="vkCmdSetDepthClipNegativeOneToOneEXT"/>
            </require>
            <require depends="VK_NV_clip_space_w_scaling">
                <enum offset="23" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV"/>
                <command name="vkCmdSetViewportWScalingEnableNV"/>
            </require>
            <require depends="VK_NV_viewport_swizzle">
                <enum offset="24" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV"/>
                <command name="vkCmdSetViewportSwizzleNV"/>
            </require>
            <require depends="VK_NV_fragment_coverage_to_color">
                <enum offset="25" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV"/>
                <enum offset="26" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV"/>
                <command name="vkCmdSetCoverageToColorEnableNV"/>
                <command name="vkCmdSetCoverageToColorLocationNV"/>
            </require>
            <require depends="VK_NV_framebuffer_mixed_samples">
                <enum offset="27" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV"/>
                <enum offset="28" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV"/>
                <enum offset="29" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV"/>
                <command name="vkCmdSetCoverageModulationModeNV"/>
                <command name="vkCmdSetCoverageModulationTableEnableNV"/>
                <command name="vkCmdSetCoverageModulationTableNV"/>
            </require>
            <require depends="VK_NV_shading_rate_image">
                <enum offset="30" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV"/>
                <command name="vkCmdSetShadingRateImageEnableNV"/>
            </require>
            <require depends="VK_NV_representative_fragment_test">
                <enum offset="31" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV"/>
                <command name="vkCmdSetRepresentativeFragmentTestEnableNV"/>
            </require>
            <require depends="VK_NV_coverage_reduction_mode">
                <enum offset="32" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV"/>
                <command name="vkCmdSetCoverageReductionModeNV"/>
            </require>
            <require depends="VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3TessellationDomainOrigin">
                <feature name="tessellationShader" struct="VkPhysicalDeviceFeatures"/>
            </require>
            <require depends="VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3DepthClampEnable">
                <feature name="depthClamp" struct="VkPhysicalDeviceFeatures"/>
            </require>
            <require depends="VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3PolygonMode">
                <feature name="fillModeNonSolid" struct="VkPhysicalDeviceFeatures"/>
            </require>
            <require depends="VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3AlphaToOneEnable">
                <feature name="alphaToOne" struct="VkPhysicalDeviceFeatures"/>
            </require>
            <require depends="VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3LogicOpEnable">
                <feature name="logicOp" struct="VkPhysicalDeviceFeatures"/>
            </require>
            <require depends="VK_EXT_transform_feedback+VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3RasterizationStream">
                <feature name="geometryStreams" struct="VkPhysicalDeviceTransformFeedbackFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_457" number="457" author="RASTERGRID" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_EXT_EXTENSION_457_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_457&quot;"          name="VK_EXT_EXTENSION_457_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_458" number="458" author="RASTERGRID" contact="Daniel Rakos @aqnuep" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_EXT_EXTENSION_458_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_458&quot;"          name="VK_EXT_EXTENSION_458_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_subpass_merge_feedback" number="459" type="device" author="EXT" contact="Ting Wei @catweiting" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="2"                                              name="VK_EXT_SUBPASS_MERGE_FEEDBACK_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_subpass_merge_feedback&quot;"      name="VK_EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT"/>
                <enum offset="2" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT"/>
                <enum offset="3" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT"/>
                <type name="VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT"/>
                <type name="VkRenderPassCreationControlEXT"/>
                <type name="VkRenderPassCreationFeedbackInfoEXT"/>
                <type name="VkRenderPassCreationFeedbackCreateInfoEXT"/>
                <type name="VkRenderPassSubpassFeedbackInfoEXT"/>
                <type name="VkRenderPassSubpassFeedbackCreateInfoEXT"/>
                <type name="VkSubpassMergeStatusEXT"/>
                <feature name="subpassMergeFeedback" struct="VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_LUNARG_direct_driver_loading" number="460" type="instance" author="LUNARG" contact="Charles Giessen @charles-lunarg" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                           name="VK_LUNARG_DIRECT_DRIVER_LOADING_SPEC_VERSION"/>
                <enum value="&quot;VK_LUNARG_direct_driver_loading&quot;" name="VK_LUNARG_DIRECT_DRIVER_LOADING_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG"/>
                <enum offset="1" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG"/>
                <type name="VkDirectDriverLoadingFlagsLUNARG" comment="Will add VkDirectDriverLoadingFlagBitsLUNARG when bits are defined in the future"/>
                <type name="VkDirectDriverLoadingModeLUNARG"/>
                <type name="VkDirectDriverLoadingInfoLUNARG"/>
                <type name="VkDirectDriverLoadingListLUNARG"/>
                <type name="PFN_vkGetInstanceProcAddrLUNARG"/>
            </require>
        </extension>
        <extension name="VK_ARM_tensors" number="461" author="ARM" contact="Kevin Petit @kpet" type="device" supported="vulkan" depends="VK_VERSION_1_3">
            <require>
                <enum value="1"                                    name="VK_ARM_TENSORS_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_tensors&quot;"           name="VK_ARM_TENSORS_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"        name="VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM"/>
                <enum offset="1"  extends="VkStructureType"        name="VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM"/>
                <enum offset="2"  extends="VkStructureType"        name="VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM"/>
                <enum offset="3"  extends="VkStructureType"        name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM"/>
                <enum offset="4"  extends="VkStructureType"        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM"/>
                <enum offset="5"  extends="VkStructureType"        name="VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM"/>
                <enum offset="6"  extends="VkStructureType"        name="VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM"/>
                <enum offset="7"  extends="VkStructureType"        name="VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM"/>
                <enum offset="8"  extends="VkStructureType"        name="VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM"/>
                <enum offset="9"  extends="VkStructureType"        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM"/>
                <enum offset="10" extends="VkStructureType"        name="VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM"/>
                <enum offset="11" extends="VkStructureType"        name="VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM"/>
                <enum offset="12" extends="VkStructureType"        name="VK_STRUCTURE_TYPE_TENSOR_COPY_ARM"/>
                <enum offset="13" extends="VkStructureType"        name="VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM"/>
                <enum offset="14" extends="VkStructureType"        name="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM"/>
                <enum offset="15" extends="VkStructureType"        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM"/>
                <enum offset="16" extends="VkStructureType"        name="VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM"/>
                <enum offset="17" extends="VkStructureType"        name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM"/>
                <enum offset="0"  extends="VkObjectType"           name="VK_OBJECT_TYPE_TENSOR_ARM"/>
                <enum offset="1"  extends="VkObjectType"           name="VK_OBJECT_TYPE_TENSOR_VIEW_ARM"/>
                <enum offset="0"  extends="VkDescriptorType"       name="VK_DESCRIPTOR_TYPE_TENSOR_ARM"/>
                <enum bitpos="39" extends="VkFormatFeatureFlagBits2"     name="VK_FORMAT_FEATURE_2_TENSOR_SHADER_BIT_ARM" />
                <enum bitpos="43" extends="VkFormatFeatureFlagBits2"     name="VK_FORMAT_FEATURE_2_TENSOR_IMAGE_ALIASING_BIT_ARM" />
                <enum bitpos="23" extends="VkImageUsageFlagBits"   name="VK_IMAGE_USAGE_TENSOR_ALIASING_BIT_ARM"/>
                <enum offset="0"  extends="VkImageLayout"          name="VK_IMAGE_LAYOUT_TENSOR_ALIASING_ARM"/>
                <enum offset="0"  extends="VkFormat"               name="VK_FORMAT_R8_BOOL_ARM"/>
                <type name="VkTensorARM"/>
                <type name="VkTensorViewARM"/>
                <type name="VkTensorCreateFlagsARM"/>
                <type name="VkTensorCreateFlagBitsARM"/>
                <type name="VkTensorViewCreateFlagsARM"/>
                <type name="VkTensorViewCreateFlagBitsARM"/>
                <type name="VkTensorUsageFlagsARM"/>
                <type name="VkTensorUsageFlagBitsARM"/>
                <type name="VkTensorDescriptionARM"/>
                <type name="VkTensorTilingARM"/>
                <type name="VkTensorCreateInfoARM"/>
                <type name="VkTensorViewCreateInfoARM"/>
                <type name="VkTensorMemoryRequirementsInfoARM"/>
                <type name="VkBindTensorMemoryInfoARM"/>
                <type name="VkWriteDescriptorSetTensorARM"/>
                <type name="VkTensorFormatPropertiesARM"/>
                <type name="VkPhysicalDeviceTensorPropertiesARM"/>
                <type name="VkTensorMemoryBarrierARM"/>
                <type name="VkTensorDependencyInfoARM"/>
                <type name="VkPhysicalDeviceTensorFeaturesARM"/>
                <type name="VkDeviceTensorMemoryRequirementsARM"/>
                <type name="VkCopyTensorInfoARM"/>
                <type name="VkTensorCopyARM"/>
                <type name="VkMemoryDedicatedAllocateInfoTensorARM"/>
                <type name="VkPhysicalDeviceExternalTensorInfoARM"/>
                <type name="VkExternalTensorPropertiesARM"/>
                <type name="VkExternalMemoryTensorCreateInfoARM"/>
                <command name="vkCreateTensorARM"/>
                <command name="vkDestroyTensorARM"/>
                <command name="vkCreateTensorViewARM"/>
                <command name="vkDestroyTensorViewARM"/>
                <command name="vkGetTensorMemoryRequirementsARM"/>
                <command name="vkBindTensorMemoryARM"/>
                <command name="vkGetDeviceTensorMemoryRequirementsARM"/>
                <command name="vkCmdCopyTensorARM"/>
                <command name="vkGetPhysicalDeviceExternalTensorPropertiesARM"/>
                <feature name="tensors" struct="VkPhysicalDeviceTensorFeaturesARM"/>
            </require>
            <require depends="VK_EXT_descriptor_buffer">
                <enum offset="18" extends="VkStructureType"        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM"/>
                <enum offset="19" extends="VkStructureType"        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM"/>
                <enum offset="20" extends="VkStructureType"        name="VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM"/>
                <enum offset="21" extends="VkStructureType"        name="VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM"/>
                <enum offset="22" extends="VkStructureType"        name="VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM"/>
                <enum bitpos="2"  extends="VkTensorCreateFlagBitsARM" name="VK_TENSOR_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_ARM" />
                <enum bitpos="0"  extends="VkTensorViewCreateFlagBitsARM" name="VK_TENSOR_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_ARM" />
                <type name="VkPhysicalDeviceDescriptorBufferTensorFeaturesARM"/>
                <type name="VkPhysicalDeviceDescriptorBufferTensorPropertiesARM"/>
                <type name="VkDescriptorGetTensorInfoARM"/>
                <type name="VkTensorCaptureDescriptorDataInfoARM"/>
                <type name="VkTensorViewCaptureDescriptorDataInfoARM"/>
                <command name="vkGetTensorOpaqueCaptureDescriptorDataARM"/>
                <command name="vkGetTensorViewOpaqueCaptureDescriptorDataARM"/>
            </require>
            <require depends="VK_EXT_frame_boundary">
                <enum offset="23" extends="VkStructureType"        name="VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM"/>
                <type name="VkFrameBoundaryTensorsARM"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_462" number="462" author="EXT" contact="Joshua Ashton @Joshua-Ashton,Liam Middlebrook @liam-middlebrook" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_EXT_EXTENSION_462_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_462&quot;"          name="VK_EXT_EXTENSION_462_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_module_identifier" number="463" type="device" depends="((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_EXT_pipeline_creation_cache_control),VK_VERSION_1_3" author="EXT" contact="Hans-Kristian Arntzen @HansKristian-Work" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_SHADER_MODULE_IDENTIFIER_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_module_identifier&quot;"   name="VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT"/>
                <enum name="VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT"/>
                <type name="VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT"/>
                <type name="VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT"/>
                <type name="VkPipelineShaderStageModuleIdentifierCreateInfoEXT"/>
                <type name="VkShaderModuleIdentifierEXT"/>
                <command name="vkGetShaderModuleIdentifierEXT"/>
                <command name="vkGetShaderModuleCreateInfoIdentifierEXT"/>
                <feature name="shaderModuleIdentifier" struct="VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_rasterization_order_attachment_access" number="464" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                        name="VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_rasterization_order_attachment_access&quot;" name="VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" extnumber="343" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT"/>
                <type name="VkPipelineColorBlendStateCreateFlagBits"/>
                <type name="VkPipelineDepthStencilStateCreateFlagBits"/>
                <enum bitpos="0" extends="VkPipelineColorBlendStateCreateFlagBits"   name="VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT"/>
                <enum bitpos="0" extends="VkPipelineDepthStencilStateCreateFlagBits" name="VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT"/>
                <enum bitpos="1" extends="VkPipelineDepthStencilStateCreateFlagBits" name="VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT"/>
                <enum bitpos="4" extends="VkSubpassDescriptionFlagBits"              name="VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT"/>
                <enum bitpos="5" extends="VkSubpassDescriptionFlagBits"              name="VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT"/>
                <enum bitpos="6" extends="VkSubpassDescriptionFlagBits"              name="VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT"/>
            </require>
        </extension>
        <extension name="VK_NV_optical_flow" number="465" depends="((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_format_feature_flags2+VK_KHR_synchronization2),VK_VERSION_1_3" type="device" author="NV" contact="Carsten Rohde @crohde" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_OPTICAL_FLOW_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_optical_flow&quot;"                name="VK_NV_OPTICAL_FLOW_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV"/>
                <enum offset="1"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV"/>
                <enum offset="2"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV"/>
                <enum offset="3"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV"/>
                <enum offset="4"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV"/>
                <enum offset="5"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV"/>
                <enum offset="10"  extends="VkStructureType"                name="VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV"/><comment>NV internal use only</comment>
                <enum offset="0"  extends="VkFormat"                        name="VK_FORMAT_R16G16_SFIXED5_NV"/>
                <enum extends="VkFormat"                                    name="VK_FORMAT_R16G16_S10_5_NV" alias="VK_FORMAT_R16G16_SFIXED5_NV" deprecated="aliased"/>
                <enum offset="0"  extends="VkObjectType"                    name="VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV"/>
                <enum bitpos="8"  extends="VkQueueFlagBits"                 name="VK_QUEUE_OPTICAL_FLOW_BIT_NV"/>
                <enum bitpos="29" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV"/>
                <enum bitpos="42" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV"/>
                <enum bitpos="43" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV"/>
                <enum bitpos="40" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV"/>
                <enum bitpos="41" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV"/>
                <enum bitpos="42" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV"/>
                <type name="VkPhysicalDeviceOpticalFlowFeaturesNV"/>
                <type name="VkPhysicalDeviceOpticalFlowPropertiesNV"/>
                <type name="VkOpticalFlowUsageFlagBitsNV"/>
                <type name="VkOpticalFlowUsageFlagsNV"/>
                <type name="VkOpticalFlowImageFormatInfoNV"/>
                <type name="VkOpticalFlowImageFormatPropertiesNV"/>
                <type name="VkOpticalFlowGridSizeFlagBitsNV"/>
                <type name="VkOpticalFlowGridSizeFlagsNV"/>
                <type name="VkOpticalFlowPerformanceLevelNV"/>
                <type name="VkOpticalFlowSessionBindingPointNV"/>
                <type name="VkOpticalFlowSessionCreateFlagBitsNV"/>
                <type name="VkOpticalFlowSessionCreateFlagsNV"/>
                <type name="VkOpticalFlowExecuteFlagBitsNV"/>
                <type name="VkOpticalFlowExecuteFlagsNV"/>
                <type name="VkOpticalFlowSessionNV"/>
                <type name="VkOpticalFlowSessionCreateInfoNV"/>
                <type name="VkOpticalFlowSessionCreatePrivateDataInfoNV"/><comment>NV internal use only</comment>
                <type name="VkOpticalFlowExecuteInfoNV"/>
                <command name="vkGetPhysicalDeviceOpticalFlowImageFormatsNV"/>
                <command name="vkCreateOpticalFlowSessionNV"/>
                <command name="vkDestroyOpticalFlowSessionNV"/>
                <command name="vkBindOpticalFlowSessionImageNV"/>
                <command name="vkCmdOpticalFlowExecuteNV"/>
                <feature name="opticalFlow" struct="VkPhysicalDeviceOpticalFlowFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_EXT_legacy_dithering" number="466" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="vulkan" ratified="vulkan" specialuse="glemulation">
            <require>
                <enum value="2"                                         name="VK_EXT_LEGACY_DITHERING_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_legacy_dithering&quot;"       name="VK_EXT_LEGACY_DITHERING_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT"/>
                <enum bitpos="7" extends="VkSubpassDescriptionFlagBits" name="VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT"/>
                <type name="VkPhysicalDeviceLegacyDitheringFeaturesEXT"/>
                <feature name="legacyDithering" struct="VkPhysicalDeviceLegacyDitheringFeaturesEXT"/>
            </require>
            <require depends="(VK_KHR_dynamic_rendering,VK_VERSION_1_3)+(VK_KHR_maintenance5,VK_VERSION_1_4)">
                <enum bitpos="3" extends="VkRenderingFlagBits"           name="VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT"/>
                <enum bitpos="34" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_pipeline_protected_access" number="467" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="vulkan" ratified="vulkan" promotedto="VK_VERSION_1_4">
            <require>
                <enum value="1"                                             name="VK_EXT_PIPELINE_PROTECTED_ACCESS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_pipeline_protected_access&quot;"  name="VK_EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES"/>
                <enum extends="VkPipelineCreateFlagBits"                    name="VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT" alias="VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT"/>
                <enum extends="VkPipelineCreateFlagBits"                    name="VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT" alias="VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT"/>
                <type name="VkPhysicalDevicePipelineProtectedAccessFeaturesEXT"/>
                <feature name="pipelineProtectedAccess" struct="VkPhysicalDevicePipelineProtectedAccessFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_468" number="468" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_EXT_EXTENSION_468_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_468&quot;"          name="VK_EXT_EXTENSION_468_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_ANDROID_external_format_resolve" number="469" type="device" depends="VK_ANDROID_external_memory_android_hardware_buffer" platform="android" author="ANDROID" contact="Chris Forbes @chrisforbes" specialuse="glemulation" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_SPEC_VERSION"/>
                <enum value="&quot;VK_ANDROID_external_format_resolve&quot;"  name="VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID"/>
                <type name="VkPhysicalDeviceExternalFormatResolveFeaturesANDROID"/>
                <type name="VkPhysicalDeviceExternalFormatResolvePropertiesANDROID"/>
                <type name="VkAndroidHardwareBufferFormatResolvePropertiesANDROID"/>
                <feature name="externalFormatResolve" struct="VkPhysicalDeviceExternalFormatResolveFeaturesANDROID"/>
            </require>
            <require depends="VK_KHR_dynamic_rendering,VK_VERSION_1_3">
                <enum bitpos="4" extends="VkResolveModeFlagBits"            name="VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID"/>
                <enum            extends="VkResolveModeFlagBits"            name="VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID" alias="VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID" deprecated="aliased"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_470" number="470" author="AMD" contact="Stu Smith" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_470_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_470&quot;"          name="VK_AMD_EXTENSION_470_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_maintenance5" number="471" type="device" depends="(VK_VERSION_1_1+VK_KHR_dynamic_rendering),VK_VERSION_1_3" author="KHR" contact="Stu Smith @stu-s" supported="vulkan" promotedto="VK_VERSION_1_4" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_MAINTENANCE_5_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_maintenance5&quot;"           name="VK_KHR_MAINTENANCE_5_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR" alias="VK_STRUCTURE_TYPE_RENDERING_AREA_INFO"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO"/>
                <type name="VkPhysicalDeviceMaintenance5FeaturesKHR"/>
                <type name="VkPhysicalDeviceMaintenance5PropertiesKHR"/>
                <enum extends="VkFormat"                                name="VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR" alias="VK_FORMAT_A1B5G5R5_UNORM_PACK16"/>
                <enum extends="VkFormat"                                name="VK_FORMAT_A8_UNORM_KHR" alias="VK_FORMAT_A8_UNORM"/>
                <command name="vkCmdBindIndexBuffer2KHR"/>
                <command name="vkGetRenderingAreaGranularityKHR"/>
                <type name="VkRenderingAreaInfoKHR"/>
                <command name="vkGetDeviceImageSubresourceLayoutKHR"/>
                <command name="vkGetImageSubresourceLayout2KHR"/>
                <type name="VkDeviceImageSubresourceInfoKHR"/>
                <type name="VkImageSubresource2KHR"/>
                <type name="VkSubresourceLayout2KHR"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR" alias="VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2"/>
                <feature name="maintenance5" struct="VkPhysicalDeviceMaintenance5FeaturesKHR"/>
            </require>
            <require comment="Split off new 64-bit flags separately, for the moment">
                <enum extends="VkPipelineCreateFlagBits2"               name="VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR" alias="VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT"/>
                <enum extends="VkPipelineCreateFlagBits2"               name="VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR" alias="VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT"/>
                <enum extends="VkPipelineCreateFlagBits2"               name="VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR" alias="VK_PIPELINE_CREATE_2_DERIVATIVE_BIT"/>
                <enum extends="VkPipelineCreateFlagBits2"               name="VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR" alias="VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT"/>
                <enum extends="VkPipelineCreateFlagBits2"               name="VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR" alias="VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT"/>
                <enum extends="VkBufferUsageFlagBits2"                  name="VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR" alias="VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT"/>
                <enum extends="VkBufferUsageFlagBits2"                  name="VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR" alias="VK_BUFFER_USAGE_2_TRANSFER_DST_BIT"/>
                <enum extends="VkBufferUsageFlagBits2"                  name="VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR" alias="VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT"/>
                <enum extends="VkBufferUsageFlagBits2"                  name="VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR" alias="VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT"/>
                <enum extends="VkBufferUsageFlagBits2"                  name="VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR" alias="VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT"/>
                <enum extends="VkBufferUsageFlagBits2"                  name="VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR" alias="VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT"/>
                <enum extends="VkBufferUsageFlagBits2"                  name="VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR" alias="VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT"/>
                <enum extends="VkBufferUsageFlagBits2"                  name="VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR" alias="VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT"/>
                <enum extends="VkBufferUsageFlagBits2"                  name="VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR" alias="VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT"/>
                <type name="VkPipelineCreateFlags2KHR"/>
                <type name="VkPipelineCreateFlagBits2KHR"/>
                <type name="VkPipelineCreateFlags2CreateInfoKHR"/>
                <type name="VkBufferUsageFlags2KHR"/>
                <type name="VkBufferUsageFlagBits2KHR"/>
                <type name="VkBufferUsageFlags2CreateInfoKHR"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO"/>
            </require>
            <require depends="VK_NV_ray_tracing">
                <enum bitpos="5"  extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV"/>
            </require>
            <require depends="VK_KHR_pipeline_executable_properties">
                <enum bitpos="6"  extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR"/>
                <enum bitpos="7"  extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR"/>
            </require>
            <require depends="VK_VERSION_1_3,VK_EXT_pipeline_creation_cache_control">
                <enum extends="VkPipelineCreateFlagBits2"                name="VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR" alias="VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT"/>
                <enum extends="VkPipelineCreateFlagBits2"                name="VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR" alias="VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT"/>
            </require>
            <require depends="VK_EXT_graphics_pipeline_library">
                <enum bitpos="10" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT"/>
                <enum bitpos="23" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT"/>
            </require>
            <require depends="VK_KHR_pipeline_library">
                <enum bitpos="11" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR"/>
            </require>
            <require depends="VK_KHR_ray_tracing_pipeline">
                <enum bitpos="12" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR"/>
                <enum bitpos="13" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR"/>
                <enum bitpos="14" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR"/>
                <enum bitpos="15" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR"/>
                <enum bitpos="16" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR"/>
                <enum bitpos="17" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR"/>
                <enum bitpos="19" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR"/>
            </require>
            <require depends="VK_NV_device_generated_commands">
                <enum bitpos="18" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV"/>
            </require>
            <require depends="VK_NV_ray_tracing_motion_blur">
                <enum bitpos="20" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV"/>
            </require>
            <require depends="(VK_KHR_dynamic_rendering,VK_VERSION_1_3)+VK_KHR_fragment_shading_rate">
                <enum bitpos="21" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
            </require>
            <require depends="(VK_KHR_dynamic_rendering,VK_VERSION_1_3)+VK_EXT_fragment_density_map">
                <enum bitpos="22" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT"/>
            </require>
            <require depends="VK_EXT_opacity_micromap">
                <enum bitpos="24" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT"/>
            </require>
            <require depends="VK_EXT_attachment_feedback_loop_layout">
                <enum bitpos="25" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"/>
                <enum bitpos="26" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT"/>
            </require>
            <require depends="VK_VERSION_1_4,VK_EXT_pipeline_protected_access">
                <enum extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT"   alias="VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT"/>
                <enum extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT" alias="VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT"/>
            </require>
            <require depends="VK_NV_displacement_micromap">
                <enum bitpos="28" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV"/>
            </require>
            <require depends="VK_EXT_descriptor_buffer">
                <enum bitpos="29" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT"/>
            </require>
            <require depends="VK_EXT_conditional_rendering">
                <enum bitpos="9"  extends="VkBufferUsageFlagBits2"       name="VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT"/>
            </require>
            <require depends="VK_KHR_ray_tracing_pipeline">
                <enum bitpos="10" extends="VkBufferUsageFlagBits2"       name="VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR"/>
            </require>
            <require depends="VK_NV_ray_tracing">
                <enum extends="VkBufferUsageFlagBits2"                   name="VK_BUFFER_USAGE_2_RAY_TRACING_BIT_NV" alias="VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR"/>
            </require>
            <require depends="VK_EXT_transform_feedback">
                <enum bitpos="11" extends="VkBufferUsageFlagBits2"       name="VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT"/>
                <enum bitpos="12" extends="VkBufferUsageFlagBits2"       name="VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT"/>
            </require>
            <require depends="VK_KHR_video_decode_queue">
                <enum bitpos="13" extends="VkBufferUsageFlagBits2"       name="VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR"/>
                <enum bitpos="14" extends="VkBufferUsageFlagBits2"       name="VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR"/>
            </require>
            <require depends="VK_KHR_video_encode_queue">
                <enum bitpos="15" extends="VkBufferUsageFlagBits2"       name="VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR"/>
                <enum bitpos="16" extends="VkBufferUsageFlagBits2"       name="VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR"/>
            </require>
            <require depends="VK_VERSION_1_2,VK_KHR_buffer_device_address,VK_EXT_buffer_device_address">
                <enum extends="VkBufferUsageFlagBits2"                   name="VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT_KHR" alias="VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT"/>
            </require>
            <require depends="VK_KHR_acceleration_structure">
                <enum bitpos="19" extends="VkBufferUsageFlagBits2"       name="VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR"/>
                <enum bitpos="20" extends="VkBufferUsageFlagBits2"       name="VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR"/>
            </require>
            <require depends="VK_EXT_descriptor_buffer">
                <enum bitpos="21" extends="VkBufferUsageFlagBits2"       name="VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT"/>
                <enum bitpos="22" extends="VkBufferUsageFlagBits2"       name="VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT"/>
                <enum bitpos="26" extends="VkBufferUsageFlagBits2"       name="VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT"/>
            </require>
            <require depends="VK_EXT_opacity_micromap">
                <enum bitpos="23" extends="VkBufferUsageFlagBits2"       name="VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT"/>
                <enum bitpos="24" extends="VkBufferUsageFlagBits2"       name="VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT"/>
            </require>
            <require depends="VK_ARM_pipeline_opacity_micromap">
                <enum bitpos="37"  extends="VkPipelineCreateFlagBits2" name="VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_472" number="472" author="AMD" contact="Stu Smith" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_472_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_472&quot;"          name="VK_AMD_EXTENSION_472_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_473" number="473" author="AMD" contact="Stu Smith" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_473_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_473&quot;"          name="VK_AMD_EXTENSION_473_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_474" number="474" author="AMD" contact="Stu Smith" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_474_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_474&quot;"          name="VK_AMD_EXTENSION_474_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_475" number="475" author="AMD" contact="Stu Smith" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_475_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_475&quot;"          name="VK_AMD_EXTENSION_475_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_476" number="476" author="AMD" contact="Stu Smith" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_476_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_476&quot;"          name="VK_AMD_EXTENSION_476_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_anti_lag" number="477" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" type="device" author="AMD" contact="Stu Smith" supported="vulkan">
            <require>
                <enum value="1"                                         name="VK_AMD_ANTI_LAG_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_anti_lag&quot;"               name="VK_AMD_ANTI_LAG_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD"/>
                <enum offset="1"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD"/>
                <enum offset="2"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD"/>
                <type name="VkPhysicalDeviceAntiLagFeaturesAMD"/>
                <type name="VkAntiLagDataAMD"/>
                <type name="VkAntiLagPresentationInfoAMD"/>
                <type name="VkAntiLagModeAMD"/>
                <type name="VkAntiLagStageAMD"/>
                <command name="vkAntiLagUpdateAMD"/>
                <feature name="antiLag"                                 struct="VkPhysicalDeviceAntiLagFeaturesAMD"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_478" number="478" author="AMD" contact="Stu Smith" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_AMD_EXTENSION_478_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_478&quot;"          name="VK_AMD_EXTENSION_478_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMDX_dense_geometry_format" number="479" type="device" depends="VK_KHR_acceleration_structure+(VK_KHR_maintenance5,VK_VERSION_1_4)" author="AMD" contact="Stu Smith @stu-s" supported="vulkan" provisional="true" platform="provisional">
            <require>
                <enum value="1"                                             name="VK_AMDX_DENSE_GEOMETRY_FORMAT_SPEC_VERSION"/>
                <enum value="&quot;VK_AMDX_dense_geometry_format&quot;"     name="VK_AMDX_DENSE_GEOMETRY_FORMAT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DENSE_GEOMETRY_FORMAT_FEATURES_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DENSE_GEOMETRY_FORMAT_TRIANGLES_DATA_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum offset="0" extends="VkGeometryTypeKHR"                name="VK_GEOMETRY_TYPE_DENSE_GEOMETRY_FORMAT_TRIANGLES_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum bitpos="33" extends="VkBufferUsageFlagBits2"          name="VK_BUFFER_USAGE_2_COMPRESSED_DATA_DGF1_BIT_AMDX" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <type name="VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX"/>
                <type name="VkAccelerationStructureDenseGeometryFormatTrianglesDataAMDX"/>
                <type name="VkCompressedTriangleFormatAMDX"/>
                <enum name="VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_ALIGNMENT_AMDX"/>
                <enum name="VK_COMPRESSED_TRIANGLE_FORMAT_DGF1_BYTE_STRIDE_AMDX"/>
                <feature name="denseGeometryFormat" struct="VkPhysicalDeviceDenseGeometryFormatFeaturesAMDX"/>
            </require>
        </extension>
        <extension name="VK_KHR_present_id2" number="480" author="KHR" contact="Daniel Stone" type="device" depends="VK_KHR_get_surface_capabilities2+VK_KHR_surface+VK_KHR_swapchain" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_PRESENT_ID_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_present_id2&quot;"            name="VK_KHR_PRESENT_ID_2_EXTENSION_NAME"/>
                <enum bitpos="6" extends="VkSwapchainCreateFlagBitsKHR" name="VK_SWAPCHAIN_CREATE_PRESENT_ID_2_BIT_KHR" comment="Allow use of VK_KHR_present_id2 with this swapchain"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR"/>
                <type name="VkSurfaceCapabilitiesPresentId2KHR"/>
                <type name="VkPresentId2KHR"/>
                <type name="VkPhysicalDevicePresentId2FeaturesKHR"/>
                <feature name="presentId2" struct="VkPhysicalDevicePresentId2FeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_present_wait2" number="481" author="KHR" contact="Daniel Stone" type="device" depends="VK_KHR_get_surface_capabilities2+VK_KHR_surface+VK_KHR_swapchain+VK_KHR_present_id2" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_PRESENT_WAIT_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_present_wait2&quot;"          name="VK_KHR_PRESENT_WAIT_2_EXTENSION_NAME"/>
                <enum bitpos="7" extends="VkSwapchainCreateFlagBitsKHR" name="VK_SWAPCHAIN_CREATE_PRESENT_WAIT_2_BIT_KHR" comment="Allow use of VK_KHR_present_wait2 with this swapchain"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR"/>
                <type name="VkSurfaceCapabilitiesPresentWait2KHR"/>
                <type name="VkPhysicalDevicePresentWait2FeaturesKHR"/>
                <type name="VkPresentWait2InfoKHR"/>
                <command name="vkWaitForPresent2KHR"/>
                <feature name="presentWait2" struct="VkPhysicalDevicePresentWait2FeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_ray_tracing_position_fetch" number="482" type="device" depends="VK_KHR_acceleration_structure" author="KHR" contact="Eric Werness" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                                     name="VK_KHR_RAY_TRACING_POSITION_FETCH_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_ray_tracing_position_fetch&quot;"         name="VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR"/>
                <enum bitpos="11" extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR"/>
                <enum             extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR" alias="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR" deprecated="aliased"/>
                <type name="VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR"/>
                <feature name="rayTracingPositionFetch" struct="VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_object" number="483" depends="((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_dynamic_rendering),VK_VERSION_1_3" type="device" author="EXT" contact="Daniel Story @daniel-story" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                            name="VK_EXT_SHADER_OBJECT_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_object&quot;"             name="VK_EXT_SHADER_OBJECT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT"/>
                <enum offset="2" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT"/>
                <enum extnumber="353" offset="1" extends="VkStructureType" name="VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT"/>
                <enum extnumber="353" offset="2" extends="VkStructureType" name="VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT"/>
                <enum extends="VkStructureType"                            name="VK_STRUCTURE_TYPE_SHADER_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO"/>
                <enum offset="0" extends="VkObjectType"                    name="VK_OBJECT_TYPE_SHADER_EXT"/>
                <enum offset="0" extends="VkResult"                        name="VK_INCOMPATIBLE_SHADER_BINARY_EXT"/>
                <enum            extends="VkResult"                        name="VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT" alias="VK_INCOMPATIBLE_SHADER_BINARY_EXT" deprecated="aliased"/>
                <type name="VkShaderEXT"/>
                <type name="VkShaderCreateFlagBitsEXT"/>
                <type name="VkShaderCreateFlagsEXT"/>
                <type name="VkShaderCodeTypeEXT"/>
                <type name="VkPhysicalDeviceShaderObjectFeaturesEXT"/>
                <type name="VkPhysicalDeviceShaderObjectPropertiesEXT"/>
                <type name="VkShaderCreateInfoEXT"/>
                <type name="VkShaderRequiredSubgroupSizeCreateInfoEXT"/>
                <type name="VkVertexInputBindingDescription2EXT"/>
                <type name="VkVertexInputAttributeDescription2EXT"/>
                <type name="VkColorBlendEquationEXT"/>
                <type name="VkColorBlendAdvancedEXT"/>
                <command name="vkCreateShadersEXT"/>
                <command name="vkDestroyShaderEXT"/>
                <command name="vkGetShaderBinaryDataEXT"/>
                <command name="vkCmdBindShadersEXT"/>
                <command name="vkCmdSetCullModeEXT"/>
                <command name="vkCmdSetFrontFaceEXT"/>
                <command name="vkCmdSetPrimitiveTopologyEXT"/>
                <command name="vkCmdSetViewportWithCountEXT"/>
                <command name="vkCmdSetScissorWithCountEXT"/>
                <command name="vkCmdBindVertexBuffers2EXT"/>
                <command name="vkCmdSetDepthTestEnableEXT"/>
                <command name="vkCmdSetDepthWriteEnableEXT"/>
                <command name="vkCmdSetDepthCompareOpEXT"/>
                <command name="vkCmdSetDepthBoundsTestEnableEXT"/>
                <command name="vkCmdSetStencilTestEnableEXT"/>
                <command name="vkCmdSetStencilOpEXT"/>
                <command name="vkCmdSetVertexInputEXT"/>
                <command name="vkCmdSetPatchControlPointsEXT"/>
                <command name="vkCmdSetRasterizerDiscardEnableEXT"/>
                <command name="vkCmdSetDepthBiasEnableEXT"/>
                <command name="vkCmdSetLogicOpEXT"/>
                <command name="vkCmdSetPrimitiveRestartEnableEXT"/>
                <command name="vkCmdSetTessellationDomainOriginEXT"/>
                <command name="vkCmdSetDepthClampEnableEXT"/>
                <command name="vkCmdSetPolygonModeEXT"/>
                <command name="vkCmdSetRasterizationSamplesEXT"/>
                <command name="vkCmdSetSampleMaskEXT"/>
                <command name="vkCmdSetAlphaToCoverageEnableEXT"/>
                <command name="vkCmdSetAlphaToOneEnableEXT"/>
                <command name="vkCmdSetLogicOpEnableEXT"/>
                <command name="vkCmdSetColorBlendEnableEXT"/>
                <command name="vkCmdSetColorBlendEquationEXT"/>
                <command name="vkCmdSetColorWriteMaskEXT"/>
                <feature name="shaderObject" struct="VkPhysicalDeviceShaderObjectFeaturesEXT"/>
            </require>
            <require depends="VK_EXT_transform_feedback">
                <command name="vkCmdSetRasterizationStreamEXT"/>
            </require>
            <require depends="VK_EXT_conservative_rasterization">
                <command name="vkCmdSetConservativeRasterizationModeEXT"/>
                <command name="vkCmdSetExtraPrimitiveOverestimationSizeEXT"/>
            </require>
            <require depends="VK_EXT_depth_clip_enable">
                <command name="vkCmdSetDepthClipEnableEXT"/>
            </require>
            <require depends="VK_EXT_sample_locations">
                <command name="vkCmdSetSampleLocationsEnableEXT"/>
            </require>
            <require depends="VK_EXT_blend_operation_advanced">
                <command name="vkCmdSetColorBlendAdvancedEXT"/>
            </require>
            <require depends="VK_EXT_provoking_vertex">
                <command name="vkCmdSetProvokingVertexModeEXT"/>
            </require>
            <require depends="VK_EXT_line_rasterization">
                <command name="vkCmdSetLineRasterizationModeEXT"/>
                <command name="vkCmdSetLineStippleEnableEXT"/>
            </require>
            <require depends="VK_EXT_depth_clip_control">
                <command name="vkCmdSetDepthClipNegativeOneToOneEXT"/>
            </require>
            <require depends="VK_EXT_subgroup_size_control,VK_VERSION_1_3">
                <enum bitpos="1" extends="VkShaderCreateFlagBitsEXT" name="VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT"/>
                <enum bitpos="2" extends="VkShaderCreateFlagBitsEXT" name="VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT"/>
            </require>
            <require depends="VK_EXT_mesh_shader,VK_NV_mesh_shader">
                <enum bitpos="3" extends="VkShaderCreateFlagBitsEXT" name="VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT"/>
            </require>
            <require depends="VK_KHR_device_group,VK_VERSION_1_1">
                <enum bitpos="4" extends="VkShaderCreateFlagBitsEXT" name="VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT"/>
            </require>
            <require depends="VK_KHR_fragment_shading_rate">
                <enum bitpos="5" extends="VkShaderCreateFlagBitsEXT" name="VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT"/>
            </require>
            <require depends="VK_EXT_fragment_density_map">
                <enum bitpos="6" extends="VkShaderCreateFlagBitsEXT" name="VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT"/>
            </require>
            <require depends="VK_NV_clip_space_w_scaling">
                <command name="vkCmdSetViewportWScalingEnableNV"/>
            </require>
            <require depends="VK_NV_viewport_swizzle">
                <command name="vkCmdSetViewportSwizzleNV"/>
            </require>
            <require depends="VK_NV_fragment_coverage_to_color">
                <command name="vkCmdSetCoverageToColorEnableNV"/>
                <command name="vkCmdSetCoverageToColorLocationNV"/>
            </require>
            <require depends="VK_NV_framebuffer_mixed_samples">
                <command name="vkCmdSetCoverageModulationModeNV"/>
                <command name="vkCmdSetCoverageModulationTableEnableNV"/>
                <command name="vkCmdSetCoverageModulationTableNV"/>
            </require>
            <require depends="VK_NV_shading_rate_image">
                <command name="vkCmdSetShadingRateImageEnableNV"/>
            </require>
            <require depends="VK_NV_representative_fragment_test">
                <command name="vkCmdSetRepresentativeFragmentTestEnableNV"/>
            </require>
            <require depends="VK_NV_coverage_reduction_mode">
                <command name="vkCmdSetCoverageReductionModeNV"/>
            </require>
            <require depends="VK_EXT_depth_clamp_control">
                <command name="vkCmdSetDepthClampRangeEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_pipeline_binary" number="484" author="KHR" contact="Stu Smith @stu-s" depends="VK_KHR_maintenance5,VK_VERSION_1_4" type="device" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_PIPELINE_BINARY_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_pipeline_binary&quot;"      name="VK_KHR_PIPELINE_BINARY_EXTENSION_NAME"/>
                <enum name="VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR"/>
                <type name="VkPhysicalDevicePipelineBinaryFeaturesKHR"/>
                <type name="VkPhysicalDevicePipelineBinaryPropertiesKHR"/>
                <type name="VkDevicePipelineBinaryInternalCacheControlKHR"/>
                <type name="VkPipelineBinaryKHR"/>
                <type name="VkPipelineBinaryKeyKHR"/>
                <type name="VkPipelineBinaryDataKHR"/>
                <type name="VkPipelineBinaryKeysAndDataKHR"/>
                <type name="VkPipelineBinaryCreateInfoKHR"/>
                <type name="VkPipelineBinaryInfoKHR"/>
                <type name="VkReleaseCapturedPipelineDataInfoKHR"/>
                <type name="VkPipelineBinaryDataInfoKHR"/>
                <type name="VkPipelineCreateInfoKHR"/>
                <type name="VkPipelineBinaryHandlesInfoKHR"/>
                <command name="vkCreatePipelineBinariesKHR"/>
                <command name="vkDestroyPipelineBinaryKHR"/>
                <command name="vkGetPipelineKeyKHR"/>
                <command name="vkGetPipelineBinaryDataKHR"/>
                <command name="vkReleaseCapturedPipelineDataKHR"/>
                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR"/>
                <enum offset="1" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR"/>
                <enum offset="2" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR"/>
                <enum offset="3" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR"/>
                <enum offset="4" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR"/>
                <enum offset="5" extends="VkStructureType" name="VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR"/>
                <enum offset="6" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR"/>
                <enum offset="7" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR"/>
                <enum offset="8" extends="VkStructureType" name="VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR"/>
                <enum offset="9" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR"/>
                <enum offset="0" extends="VkObjectType" name="VK_OBJECT_TYPE_PIPELINE_BINARY_KHR"/>
                <enum offset="0" extends="VkResult" name="VK_PIPELINE_BINARY_MISSING_KHR"/>
                <enum offset="0" extends="VkResult" dir="-" name="VK_ERROR_NOT_ENOUGH_SPACE_KHR"/>
                <enum bitpos="31" extends="VkPipelineCreateFlagBits2" name="VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR"/>
                <feature name="pipelineBinaries" struct="VkPhysicalDevicePipelineBinaryFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_QCOM_tile_properties" number="485" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="QCOM" contact="Matthew Netsch @mnetsch" supported="vulkan">
            <require>
                <enum value="1"                                               name="VK_QCOM_TILE_PROPERTIES_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_tile_properties&quot;"             name="VK_QCOM_TILE_PROPERTIES_EXTENSION_NAME"/>
                <command name="vkGetFramebufferTilePropertiesQCOM"/>
                <command name="vkGetDynamicRenderingTilePropertiesQCOM"/>
                <enum offset="0" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM"/>
                <enum offset="1" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM"/>
                <type name="VkPhysicalDeviceTilePropertiesFeaturesQCOM"/>
                <type name="VkTilePropertiesQCOM"/>
                <feature name="tileProperties" struct="VkPhysicalDeviceTilePropertiesFeaturesQCOM"/>
            </require>
            <require depends="VK_KHR_dynamic_rendering,VK_VERSION_1_3">
                <type name="VkRenderingInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_SEC_amigo_profiling" number="486" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="SEC" contact="Ralph Potter gitlab:@r_potter" supported="vulkan">
            <require>
                <enum value="1"                                               name="VK_SEC_AMIGO_PROFILING_SPEC_VERSION"/>
                <enum value="&quot;VK_SEC_amigo_profiling&quot;"              name="VK_SEC_AMIGO_PROFILING_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC"/>
                <enum offset="1" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC"/>
                <type name="VkPhysicalDeviceAmigoProfilingFeaturesSEC"/>
                <type name="VkAmigoProfilingSubmitInfoSEC"/>
                <feature name="amigoProfiling" struct="VkPhysicalDeviceAmigoProfilingFeaturesSEC"/>
            </require>
        </extension>
        <extension name="VK_KHR_surface_maintenance1" number="487" type="instance" depends="VK_KHR_surface,VK_KHR_get_surface_capabilities2" author="KHR" contact="Shahbaz Youssefi @syoussefi" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_SURFACE_MAINTENANCE_1_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_surface_maintenance1&quot;"       name="VK_KHR_SURFACE_MAINTENANCE_1_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" extnumber="275"  name="VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR"/>
                <enum offset="1" extends="VkStructureType" extnumber="275"  name="VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR"/>
                <enum offset="2" extends="VkStructureType" extnumber="275"  name="VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR"/>
                <type name="VkSurfacePresentModeKHR"/>
                <type name="VkPresentScalingFlagBitsKHR"/>
                <type name="VkPresentScalingFlagsKHR"/>
                <type name="VkPresentGravityFlagBitsKHR"/>
                <type name="VkPresentGravityFlagsKHR"/>
                <type name="VkSurfacePresentScalingCapabilitiesKHR"/>
                <type name="VkSurfacePresentModeCompatibilityKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_swapchain_maintenance1" number="488" type="device" depends="VK_KHR_swapchain,VK_KHR_surface_maintenance1,VK_KHR_get_physical_device_properties2" author="KHR" contact="Shahbaz Youssefi @syoussefi" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_SWAPCHAIN_MAINTENANCE_1_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_swapchain_maintenance1&quot;"     name="VK_KHR_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" extnumber="276"  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR"/>
                <enum offset="1" extends="VkStructureType" extnumber="276"  name="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR"/>
                <enum offset="2" extends="VkStructureType" extnumber="276"  name="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR"/>
                <enum offset="3" extends="VkStructureType" extnumber="276"  name="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR"/>
                <enum offset="4" extends="VkStructureType" extnumber="276"  name="VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR"/>
                <enum offset="5" extends="VkStructureType" extnumber="276"  name="VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR"/>
                <enum bitpos="3" extends="VkSwapchainCreateFlagBitsKHR"     name="VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR"/>
                <type name="VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR"/>
                <type name="VkSwapchainPresentFenceInfoKHR"/>
                <type name="VkSwapchainPresentModesCreateInfoKHR"/>
                <type name="VkSwapchainPresentModeInfoKHR"/>
                <type name="VkSwapchainPresentScalingCreateInfoKHR"/>
                <type name="VkReleaseSwapchainImagesInfoKHR"/>
                <command name="vkReleaseSwapchainImagesKHR"/>
                <feature name="swapchainMaintenance1" struct="VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_QCOM_multiview_per_view_viewports" number="489" type="device" author="QCOM" contact="Matthew Netsch @mnetsch" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" supported="vulkan">
            <require>
                <enum value="1"                                                name="VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_multiview_per_view_viewports&quot;" name="VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM"/>
                <type name="VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM"/>
                <feature name="multiviewPerViewViewports" struct="VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM"/>
            </require>
        </extension>
        <extension name="VK_NV_external_sci_sync2" number="490" author="NV" depends="VK_VERSION_1_1" platform="sci" type="device" contact="Kai Zhang @kazhang" supported="vulkansc">
            <require>
                <enum value="1"                                         name="VK_NV_EXTERNAL_SCI_SYNC_2_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_external_sci_sync2&quot;"      name="VK_NV_EXTERNAL_SCI_SYNC_2_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkObjectType"                name="VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV" comment="VkSemaphoreSciSyncPoolNV"/>
                <enum offset="0"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV"/>
                <enum offset="1"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV"/>
                <enum offset="2"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV"/>
                <type name="VkSemaphoreSciSyncPoolNV"/>
                <type name="VkPhysicalDeviceExternalSciSync2FeaturesNV"/>
                <type name="VkSemaphoreSciSyncPoolCreateInfoNV"/>
                <type name="VkSemaphoreSciSyncCreateInfoNV"/>
                <command name="vkCreateSemaphoreSciSyncPoolNV"/>
                <command name="vkDestroySemaphoreSciSyncPoolNV"/>
                <feature name="sciSyncFence,sciSyncSemaphore2" struct="VkPhysicalDeviceExternalSciSync2FeaturesNV"/>
                <feature name="sciSyncImport,sciSyncExport" struct="VkPhysicalDeviceExternalSciSync2FeaturesNV"/>
            </require>
            <require comment="functionality reused unmodified from VK_NV_external_sci_sync">
                <enum extnumber="374" offset="0" extends="VkStructureType"   name="VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV"/>
                <enum extnumber="374" offset="1" extends="VkStructureType"   name="VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV"/>
                <enum extnumber="374" offset="2" extends="VkStructureType"   name="VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV"/>
                <enum extnumber="374" offset="3" extends="VkStructureType"   name="VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV"/>
                <enum bitpos="4" extends="VkExternalFenceHandleTypeFlagBits" name="VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV"/>
                <enum bitpos="5" extends="VkExternalFenceHandleTypeFlagBits" name="VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV"/>
                <type name="VkSciSyncClientTypeNV"/>
                <type name="VkSciSyncPrimitiveTypeNV"/>
                <type name="VkExportFenceSciSyncInfoNV"/>
                <type name="VkImportFenceSciSyncInfoNV"/>
                <type name="VkFenceGetSciSyncInfoNV"/>
                <type name="VkSciSyncAttributesInfoNV"/>
                <command name="vkGetFenceSciSyncFenceNV"/>
                <command name="vkGetFenceSciSyncObjNV"/>
                <command name="vkImportFenceSciSyncFenceNV"/>
                <command name="vkImportFenceSciSyncObjNV"/>
                <command name="vkGetPhysicalDeviceSciSyncAttributesNV"/>
            </require>
            <require depends="VKSC_VERSION_1_0" api="vulkansc">
                <enum offset="3" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_DEVICE_SEMAPHORE_SCI_SYNC_POOL_RESERVATION_CREATE_INFO_NV"/>
                <type name="VkDeviceSemaphoreSciSyncPoolReservationCreateInfoNV"/>
            </require>
        </extension>
        <extension name="VK_NV_ray_tracing_invocation_reorder" number="491" type="device" depends="VK_KHR_ray_tracing_pipeline" author="NV" contact="Eric Werness @ewerness-nv" promotedto="VK_EXT_ray_tracing_invocation_reorder" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_NV_RAY_TRACING_INVOCATION_REORDER_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_ray_tracing_invocation_reorder&quot;"  name="VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV"/>
                <type name="VkRayTracingInvocationReorderModeNV"/>
                <enum extends="VkRayTracingInvocationReorderModeEXT" name="VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV" alias="VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_EXT"/>
                <enum extends="VkRayTracingInvocationReorderModeEXT" name="VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV" alias="VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_EXT"/>
                <type name="VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV"/>
                <type name="VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV"/>
                <feature name="rayTracingInvocationReorder" struct="VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_cooperative_vector" number="492" author="NV" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" type="device" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
            <require>
                <enum value="4"                                                 name="VK_NV_COOPERATIVE_VECTOR_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_cooperative_vector&quot;"              name="VK_NV_COOPERATIVE_VECTOR_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV"/>
                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV"/>
                <enum offset="4" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV"/>
                <enum offset="0" extends="VkComponentTypeKHR"                   name="VK_COMPONENT_TYPE_SINT8_PACKED_NV"/>
                <enum offset="1" extends="VkComponentTypeKHR"                   name="VK_COMPONENT_TYPE_UINT8_PACKED_NV"/>
                <enum extends="VkComponentTypeKHR"                              name="VK_COMPONENT_TYPE_FLOAT_E4M3_NV" alias="VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT"/>
                <enum extends="VkComponentTypeKHR"                              name="VK_COMPONENT_TYPE_FLOAT_E5M2_NV" alias="VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT"/>
                <enum bitpos="44" extends="VkPipelineStageFlagBits2"            name="VK_PIPELINE_STAGE_2_CONVERT_COOPERATIVE_VECTOR_MATRIX_BIT_NV"/>
                <type name="VkPhysicalDeviceCooperativeVectorPropertiesNV"/>
                <type name="VkPhysicalDeviceCooperativeVectorFeaturesNV"/>
                <type name="VkCooperativeVectorPropertiesNV"/>
                <type name="VkConvertCooperativeVectorMatrixInfoNV"/>
                <type name="VkCooperativeVectorMatrixLayoutNV"/>
                <type name="VkComponentTypeKHR"/>
                <type name="VkDeviceOrHostAddressKHR"/>
                <type name="VkDeviceOrHostAddressConstKHR"/>
                <command name="vkGetPhysicalDeviceCooperativeVectorPropertiesNV"/>
                <command name="vkConvertCooperativeVectorMatrixNV"/>
                <command name="vkCmdConvertCooperativeVectorMatrixNV"/>
                <feature name="cooperativeVector" struct="VkPhysicalDeviceCooperativeVectorFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_extended_sparse_address_space" number="493" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Russell Chou @russellcnv" supported="vulkan">
            <require>
                <enum value="1"                                               name="VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extended_sparse_address_space&quot;" name="VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV"/>
                <type name="VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV"/>
                <type name="VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV"/>
                <feature name="extendedSparseAddressSpace" struct="VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_494" number="494" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_NV_EXTENSION_494_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_494&quot;"           name="VK_NV_EXTENSION_494_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_mutable_descriptor_type" number="495" type="device" supported="vulkan" ratified="vulkan" author="EXT" contact="Joshua Ashton @Joshua-Ashton,Hans-Kristian Arntzen @HansKristian-Work" specialuse="d3demulation" depends="VK_KHR_maintenance3,VK_VERSION_1_1">
            <require>
                <enum value="1"                                                name="VK_EXT_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_mutable_descriptor_type&quot;"       name="VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" extnumber="352"     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT"/>
                <enum offset="2" extends="VkStructureType" extnumber="352"     name="VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT"/>
                <enum offset="0" extends="VkDescriptorType" extnumber="352"    name="VK_DESCRIPTOR_TYPE_MUTABLE_EXT"/>
                <enum bitpos="2" extends="VkDescriptorPoolCreateFlagBits"      name="VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT"/>
                <enum bitpos="2" extends="VkDescriptorSetLayoutCreateFlagBits" name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT"/>
                <type name="VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT"/>
                <type name="VkMutableDescriptorTypeListEXT"/>
                <type name="VkMutableDescriptorTypeCreateInfoEXT"/>
                <feature name="mutableDescriptorType" struct="VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_legacy_vertex_attributes" number="496" author="EXT" contact="Mike Blumenkrantz @zmike" type="device" supported="vulkan" ratified="vulkan" depends="VK_EXT_vertex_input_dynamic_state" specialuse="glemulation">
            <require>
                <enum value="1"                                                   name="VK_EXT_LEGACY_VERTEX_ATTRIBUTES_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_legacy_vertex_attributes&quot;"   name="VK_EXT_LEGACY_VERTEX_ATTRIBUTES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT"/>
                <type name="VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT"/>
                <type name="VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT"/>
                <feature name="legacyVertexAttributes" struct="VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_layer_settings" number="497" author="EXT" contact="Christophe Riccio @christophe" type="instance" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="2"                                             name="VK_EXT_LAYER_SETTINGS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_layer_settings&quot;"              name="VK_EXT_LAYER_SETTINGS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT"/>
                <type name="VkLayerSettingsCreateInfoEXT"/>
                <type name="VkLayerSettingEXT"/>
                <type name="VkLayerSettingTypeEXT"/>
            </require>
        </extension>
        <extension name="VK_ARM_shader_core_builtins" number="498" author="ARM" contact="Kevin Petit @kpet" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" supported="vulkan">
            <require>
                <enum value="2"                                         name="VK_ARM_SHADER_CORE_BUILTINS_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_shader_core_builtins&quot;"   name="VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM"/>
                <enum offset="1"  extends="VkStructureType"             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM"/>
                <type name="VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM"/>
                <type name="VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM"/>
                <feature name="shaderCoreBuiltins" struct="VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM"/>
            </require>
        </extension>
        <extension name="VK_EXT_pipeline_library_group_handles" number="499" type="device" depends="VK_KHR_ray_tracing_pipeline+VK_KHR_pipeline_library" author="EXT" contact="Hans-Kristian Arntzen @HansKristian-Work" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                                  name="VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_pipeline_library_group_handles&quot;"  name="VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                       name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT"/>
                <type name="VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT"/>
                <feature name="pipelineLibraryGroupHandles" struct="VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_dynamic_rendering_unused_attachments" number="500" author="EXT" contact="Piers Daniell @pdaniell-nv" type="device" depends="((VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_dynamic_rendering),VK_VERSION_1_3" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                                        name="VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_dynamic_rendering_unused_attachments&quot;"  name="VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"                            name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT"/>
                <feature name="dynamicRenderingUnusedAttachments" struct="VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_501" number="501" author="SEC" contact="Chris Hambacher @chambacher" type="device" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_501_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_501&quot;"              name="VK_EXT_EXTENSION_501_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_502" number="502" author="HUAWEI" contact="Pan Gao @PanGao-h" type="device" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_502_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_502&quot;"              name="VK_EXT_EXTENSION_502_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_503" number="503" author="HUAWEI" contact="Pan Gao @PanGao-h" type="device" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_503_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_503&quot;"              name="VK_EXT_EXTENSION_503_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_504" number="504" author="NV" contact="Piers Daniell @pdaniell-nv" type="instance" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_504_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_504&quot;"               name="VK_NV_EXTENSION_504_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_505" number="505" author="EXT" contact="Shahbaz Youssefi @syoussefi" type="device" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_505_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_505&quot;"              name="VK_EXT_EXTENSION_505_EXTENSION_NAME"/>
                <enum bitpos="2"  extends="VkDeviceQueueCreateFlagBits"     name="VK_DEVICE_QUEUE_CREATE_RESERVED_2_BIT_EXT"/>
            </require>
        </extension>
        <extension name="VK_NV_low_latency2" number="506" author="NV" depends="(VK_VERSION_1_2,VK_KHR_timeline_semaphore)+(VK_KHR_present_id,VK_KHR_present_id2)" contact="Charles Hansen @cshansen" type="device" supported="vulkan" nofeatures="true">
            <require>
                <enum value="2"                                             name="VK_NV_LOW_LATENCY_2_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_low_latency2&quot;"                name="VK_NV_LOW_LATENCY_2_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV"/>
                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV"/>
                <enum offset="6" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV"/>
                <enum offset="7" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV"/>
                <enum offset="8" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV"/>
                <type name="VkLatencySleepModeInfoNV"/>
                <type name="VkLatencySleepInfoNV"/>
                <type name="VkSetLatencyMarkerInfoNV"/>
                <type name="VkGetLatencyMarkerInfoNV"/>
                <type name="VkLatencyTimingsFrameReportNV"/>
                <type name="VkLatencyMarkerNV"/>
                <type name="VkLatencySubmissionPresentIdNV"/>
                <type name="VkSwapchainLatencyCreateInfoNV"/>
                <type name="VkOutOfBandQueueTypeInfoNV"/>
                <type name="VkOutOfBandQueueTypeNV"/>
                <type name="VkLatencySurfaceCapabilitiesNV"/>
                <command name="vkSetLatencySleepModeNV"/>
                <command name="vkLatencySleepNV"/>
                <command name="vkSetLatencyMarkerNV"/>
                <command name="vkGetLatencyTimingsNV"/>
                <command name="vkQueueNotifyOutOfBandNV"/>
            </require>
        </extension>
        <extension name="VK_KHR_cooperative_matrix" number="507" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="KHR" contact="Kevin Petit @kpet" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="2"                                              name="VK_KHR_COOPERATIVE_MATRIX_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_cooperative_matrix&quot;"          name="VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR"/>
                <enum offset="1" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR"/>
                <enum offset="2" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR"/>
                <type name="VkCooperativeMatrixPropertiesKHR"/>
                <type name="VkScopeKHR"/>
                <type name="VkComponentTypeKHR"/>
                <type name="VkPhysicalDeviceCooperativeMatrixFeaturesKHR"/>
                <type name="VkPhysicalDeviceCooperativeMatrixPropertiesKHR"/>
                <command name="vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR"/>
                <feature name="cooperativeMatrix" struct="VkPhysicalDeviceCooperativeMatrixFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_ARM_data_graph" number="508" author="ARM" contact="Kevin Petit @kpet" type="device" depends="VK_VERSION_1_3+VK_KHR_maintenance5+VK_KHR_deferred_host_operations" supported="vulkan">
            <require>
                <enum value="1"                                 name="VK_ARM_DATA_GRAPH_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_data_graph&quot;"     name="VK_ARM_DATA_GRAPH_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"      name="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM"/>
                <enum offset="1" extends="VkStructureType"      name="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM"/>
                <enum offset="2" extends="VkStructureType"      name="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM"/>
                <enum offset="3" extends="VkStructureType"      name="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM"/>
                <enum offset="4" extends="VkStructureType"      name="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM"/>
                <enum offset="5" extends="VkStructureType"      name="VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM"/>
                <enum offset="6" extends="VkStructureType"      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM"/>
                <enum offset="7" extends="VkStructureType"      name="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM"/>
                <enum offset="8" extends="VkStructureType"      name="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM"/>
                <enum offset="9" extends="VkStructureType"      name="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM"/>
                <enum offset="10" extends="VkStructureType"     name="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM"/>
                <enum offset="11" extends="VkStructureType"     name="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM"/>
                <enum offset="12" extends="VkStructureType"     name="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM"/>
                <enum offset="13" extends="VkStructureType"     name="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM"/>
                <enum offset="14" extends="VkStructureType"     name="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM"/>
                <enum offset="16" extends="VkStructureType"     name="VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM"/>
                <enum offset="17" extends="VkStructureType"     name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM"/>
                <enum offset="18" extends="VkStructureType"     name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM"/>
                <enum offset="19" extends="VkStructureType"     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM"/>
                <enum offset="0"  extends="VkObjectType"        name="VK_OBJECT_TYPE_DATA_GRAPH_PIPELINE_SESSION_ARM"/>
                <enum offset="0"  extends="VkPipelineBindPoint" name="VK_PIPELINE_BIND_POINT_DATA_GRAPH_ARM"/>
                <enum bitpos="10" extends="VkQueueFlagBits"     name="VK_QUEUE_DATA_GRAPH_BIT_ARM" />
                <enum bitpos="42" extends="VkPipelineStageFlagBits2"  name="VK_PIPELINE_STAGE_2_DATA_GRAPH_BIT_ARM" />
                <enum bitpos="47" extends="VkAccessFlagBits2"   name="VK_ACCESS_2_DATA_GRAPH_READ_BIT_ARM" />
                <enum bitpos="48" extends="VkAccessFlagBits2"   name="VK_ACCESS_2_DATA_GRAPH_WRITE_BIT_ARM" />
                <enum bitpos="5"  extends="VkTensorUsageFlagBitsARM" name="VK_TENSOR_USAGE_DATA_GRAPH_BIT_ARM" />
                <enum bitpos="48" extends="VkFormatFeatureFlagBits2" name="VK_FORMAT_FEATURE_2_TENSOR_DATA_GRAPH_BIT_ARM" />
                <enum bitpos="29"  extends="VkBufferUsageFlagBits2" name="VK_BUFFER_USAGE_2_DATA_GRAPH_FOREIGN_DESCRIPTOR_BIT_ARM" />
                <enum name="VK_MAX_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_SET_NAME_SIZE_ARM"/>
                <type name="VkPhysicalDeviceDataGraphFeaturesARM"/>
                <type name="VkDataGraphPipelineSessionARM"/>
                <type name="VkDataGraphPipelineSessionBindPointARM"/>
                <type name="VkDataGraphPipelineSessionBindPointTypeARM"/>
                <type name="VkDataGraphPipelineConstantARM"/>
                <type name="VkDataGraphPipelineResourceInfoARM"/>
                <type name="VkDataGraphPipelineCompilerControlCreateInfoARM"/>
                <type name="VkDataGraphPipelineCreateInfoARM"/>
                <type name="VkDataGraphPipelineShaderModuleCreateInfoARM"/>
                <type name="VkDataGraphPipelineSessionCreateInfoARM"/>
                <type name="VkDataGraphPipelineSessionCreateFlagsARM"/>
                <type name="VkDataGraphPipelineSessionCreateFlagBitsARM"/>
                <type name="VkDataGraphPipelineSessionBindPointRequirementsInfoARM"/>
                <type name="VkDataGraphPipelineSessionBindPointRequirementARM"/>
                <type name="VkDataGraphPipelineSessionMemoryRequirementsInfoARM"/>
                <type name="VkBindDataGraphPipelineSessionMemoryInfoARM"/>
                <type name="VkDataGraphPipelineInfoARM"/>
                <type name="VkDataGraphPipelinePropertyQueryResultARM"/>
                <type name="VkDataGraphPipelinePropertyARM"/>
                <type name="VkDataGraphPipelineIdentifierCreateInfoARM"/>
                <type name="VkDataGraphPipelineDispatchFlagsARM"/>
                <type name="VkDataGraphPipelineDispatchFlagBitsARM"/>
                <type name="VkDataGraphPipelineDispatchInfoARM"/>
                <type name="VkPhysicalDeviceDataGraphProcessingEngineTypeARM"/>
                <type name="VkPhysicalDeviceDataGraphOperationTypeARM"/>
                <type name="VkPhysicalDeviceDataGraphProcessingEngineARM"/>
                <type name="VkQueueFamilyDataGraphPropertiesARM"/>
                <type name="VkDataGraphProcessingEngineCreateInfoARM"/>
                <type name="VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM"/>
                <type name="VkQueueFamilyDataGraphProcessingEnginePropertiesARM"/>
                <type name="VkPhysicalDeviceDataGraphOperationSupportARM"/>
                <command name="vkCreateDataGraphPipelinesARM"/>
                <command name="vkCreateDataGraphPipelineSessionARM"/>
                <command name="vkGetDataGraphPipelineSessionBindPointRequirementsARM"/>
                <command name="vkGetDataGraphPipelineSessionMemoryRequirementsARM"/>
                <command name="vkBindDataGraphPipelineSessionMemoryARM"/>
                <command name="vkDestroyDataGraphPipelineSessionARM"/>
                <command name="vkCmdDispatchDataGraphARM"/>
                <command name="vkGetDataGraphPipelineAvailablePropertiesARM"/>
                <command name="vkGetDataGraphPipelinePropertiesARM"/>
                <command name="vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM"/>
                <command name="vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM"/>
                <feature name="dataGraph" struct="VkPhysicalDeviceDataGraphFeaturesARM"/>
            </require>
            <require depends="VK_ARM_tensors">
                <type name="VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM"/>
                <enum offset="15" extends="VkStructureType"     name="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_509" number="509" author="EXT" contact="Kevin Petit @kpet" type="device" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_509_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_509&quot;"              name="VK_EXT_EXTENSION_509_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_MESA_extension_510" number="510" author="MESA" contact="Dave Airlie @airlied" type="device" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_MESA_EXTENSION_510_SPEC_VERSION"/>
                <enum value="&quot;VK_MESA_extension_510&quot;"             name="VK_MESA_EXTENSION_510_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_QCOM_multiview_per_view_render_areas" number="511" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="QCOM" contact="Matthew Netsch @mnetsch" supported="vulkan">
            <require>
                <enum value="1"                                                   name="VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_multiview_per_view_render_areas&quot;" name="VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM"/>
                <enum offset="1" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM"/>
                <type name="VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM"/>
                <type name="VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM"/>
                <feature name="multiviewPerViewRenderAreas" struct="VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM"/>
            </require>
        </extension>
        <extension name="VK_KHR_compute_shader_derivatives" number="512" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="KHR" contact="Jean-Noe Morissette @MagicPoncho" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_compute_shader_derivatives&quot;" name="VK_KHR_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" extnumber="202"  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR"/>
                <type name="VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR"/>
                <type name="VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR"/>
                <feature name="computeDerivativeGroupLinear" struct="VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_video_decode_av1" number="513" author="KHR" depends="VK_KHR_video_decode_queue" contact="Daniel Rakos @aqnuep" type="device" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                             name="VK_KHR_VIDEO_DECODE_AV1_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_video_decode_av1&quot;"           name="VK_KHR_VIDEO_DECODE_AV1_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR"/>
                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR"/>
                <enum bitpos="2" extends="VkVideoCodecOperationFlagBitsKHR" name="VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR"/>
                <enum name="VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR"/>
                <type name="VkVideoDecodeAV1ProfileInfoKHR"/>
                <type name="VkVideoDecodeAV1CapabilitiesKHR"/>
                <type name="VkVideoDecodeAV1SessionParametersCreateInfoKHR"/>
                <type name="VkVideoDecodeAV1PictureInfoKHR"/>
                <type name="VkVideoDecodeAV1DpbSlotInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_video_encode_av1" number="514" author="KHR" depends="VK_KHR_video_encode_queue" contact="Daniel Rakos @aqnuep" type="device" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_VIDEO_ENCODE_AV1_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_video_encode_av1&quot;"           name="VK_KHR_VIDEO_ENCODE_AV1_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR"/>
                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR"/>
                <enum offset="6" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR"/>
                <enum offset="7" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR"/>
                <enum offset="8" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR"/>
                <enum offset="9" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR"/>
                <enum offset="10" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR"/>
                <enum bitpos="18" extends="VkVideoCodecOperationFlagBitsKHR" name="VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR"/>
                <enum name="VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR"/>
                <type name="VkPhysicalDeviceVideoEncodeAV1FeaturesKHR"/>
                <type name="VkVideoEncodeAV1PredictionModeKHR"/>
                <type name="VkVideoEncodeAV1RateControlGroupKHR"/>
                <type name="VkVideoEncodeAV1CapabilityFlagBitsKHR"/>
                <type name="VkVideoEncodeAV1CapabilityFlagsKHR"/>
                <type name="VkVideoEncodeAV1StdFlagBitsKHR"/>
                <type name="VkVideoEncodeAV1StdFlagsKHR"/>
                <type name="VkVideoEncodeAV1SuperblockSizeFlagBitsKHR"/>
                <type name="VkVideoEncodeAV1SuperblockSizeFlagsKHR"/>
                <type name="VkVideoEncodeAV1CapabilitiesKHR"/>
                <type name="VkVideoEncodeAV1QualityLevelPropertiesKHR"/>
                <type name="VkVideoEncodeAV1SessionCreateInfoKHR"/>
                <type name="VkVideoEncodeAV1SessionParametersCreateInfoKHR"/>
                <type name="VkVideoEncodeAV1PictureInfoKHR"/>
                <type name="VkVideoEncodeAV1DpbSlotInfoKHR"/>
                <type name="VkVideoEncodeAV1ProfileInfoKHR"/>
                <type name="VkVideoEncodeAV1QIndexKHR"/>
                <type name="VkVideoEncodeAV1FrameSizeKHR"/>
                <type name="VkVideoEncodeAV1GopRemainingFrameInfoKHR"/>
                <type name="VkVideoEncodeAV1RateControlInfoKHR"/>
                <type name="VkVideoEncodeAV1RateControlFlagBitsKHR"/>
                <type name="VkVideoEncodeAV1RateControlFlagsKHR"/>
                <type name="VkVideoEncodeAV1RateControlLayerInfoKHR"/>
                <feature name="videoEncodeAV1" struct="VkPhysicalDeviceVideoEncodeAV1FeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_video_decode_vp9" number="515" author="KHR" depends="VK_KHR_video_decode_queue" contact="Ahmed Abdelkhalek @aabdelkh" type="device" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_VIDEO_DECODE_VP9_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_video_decode_vp9&quot;"           name="VK_KHR_VIDEO_DECODE_VP9_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR"/>
                <enum bitpos="3" extends="VkVideoCodecOperationFlagBitsKHR" name="VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR"/>
                <enum name="VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR"/>
                <type name="VkPhysicalDeviceVideoDecodeVP9FeaturesKHR"/>
                <type name="VkVideoDecodeVP9ProfileInfoKHR"/>
                <type name="VkVideoDecodeVP9CapabilitiesKHR"/>
                <type name="VkVideoDecodeVP9PictureInfoKHR"/>
                <feature name="videoDecodeVP9" struct="VkPhysicalDeviceVideoDecodeVP9FeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_video_maintenance1" number="516" author="KHR" contact="Daniel Rakos @aqnuep" type="device" depends="VK_KHR_video_queue" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_VIDEO_MAINTENANCE_1_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_video_maintenance1&quot;"         name="VK_KHR_VIDEO_MAINTENANCE_1_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR"/>
                <enum bitpos="20" extends="VkImageCreateFlagBits"           name="VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR"/>
                <enum bitpos="6" extends="VkBufferCreateFlagBits"           name="VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR"/>
                <enum bitpos="2" extends="VkVideoSessionCreateFlagBitsKHR"  name="VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR"/>
                <type name="VkPhysicalDeviceVideoMaintenance1FeaturesKHR"/>
                <type name="VkVideoInlineQueryInfoKHR"/>
                <feature name="videoMaintenance1" struct="VkPhysicalDeviceVideoMaintenance1FeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_NV_per_stage_descriptor_set" number="517" depends="VK_KHR_maintenance6,VK_VERSION_1_4" type="device" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
            <require>
                <enum value="1"                                                name="VK_NV_PER_STAGE_DESCRIPTOR_SET_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_per_stage_descriptor_set&quot;"       name="VK_NV_PER_STAGE_DESCRIPTOR_SET_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV"/>
                <enum bitpos="6" extends="VkDescriptorSetLayoutCreateFlagBits" name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV"/>
                <type name="VkPhysicalDevicePerStageDescriptorSetFeaturesNV"/>
                <feature name="perStageDescriptorSet" struct="VkPhysicalDevicePerStageDescriptorSetFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_MESA_extension_518" number="518" author="MESA" contact="Dave Airlie @airlied" type="device" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_MESA_EXTENSION_518_SPEC_VERSION"/>
                <enum value="&quot;VK_MESA_extension_518&quot;"             name="VK_MESA_EXTENSION_518_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_QCOM_image_processing2" number="519" type="device" author="QCOM" contact="Matthew Netsch @mnetsch" supported="vulkan" depends="VK_QCOM_image_processing">
            <require>
                <enum value="1"                                                   name="VK_QCOM_IMAGE_PROCESSING_2_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_image_processing2&quot;"               name="VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM"/>
                <enum offset="1" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM"/>
                <enum offset="2" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM"/>
                <type name="VkPhysicalDeviceImageProcessing2FeaturesQCOM"/>
                <type name="VkPhysicalDeviceImageProcessing2PropertiesQCOM"/>
                <type name="VkSamplerBlockMatchWindowCreateInfoQCOM"/>
                <type name="VkBlockMatchWindowCompareModeQCOM"/>
                <feature name="textureBlockMatch2" struct="VkPhysicalDeviceImageProcessing2FeaturesQCOM"/>
            </require>
        </extension>
        <extension name="VK_QCOM_filter_cubic_weights" number="520" type="device" author="QCOM" contact="Matthew Netsch @mnetsch" supported="vulkan" depends="VK_EXT_filter_cubic">
            <require>
                <enum value="1"                                             name="VK_QCOM_FILTER_CUBIC_WEIGHTS_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_filter_cubic_weights&quot;"      name="VK_QCOM_FILTER_CUBIC_WEIGHTS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM"/>
                <type name="VkPhysicalDeviceCubicWeightsFeaturesQCOM"/>
                <type name="VkSamplerCubicWeightsCreateInfoQCOM"/>
                <type name="VkBlitImageCubicWeightsInfoQCOM"/>
                <type name="VkCubicFilterWeightsQCOM"/>
                <feature name="selectableCubicWeights" struct="VkPhysicalDeviceCubicWeightsFeaturesQCOM"/>
            </require>
        </extension>
        <extension name="VK_QCOM_ycbcr_degamma" number="521" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="QCOM" contact="Matthew Netsch @mnetsch" supported="vulkan">
            <require>
                <enum value="1"                                                   name="VK_QCOM_YCBCR_DEGAMMA_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_ycbcr_degamma&quot;"                   name="VK_QCOM_YCBCR_DEGAMMA_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM"/>
                <enum offset="1" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM"/>
                <type name="VkPhysicalDeviceYcbcrDegammaFeaturesQCOM"/>
                <type name="VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM"/>
                <feature name="ycbcrDegamma" struct="VkPhysicalDeviceYcbcrDegammaFeaturesQCOM"/>
            </require>
        </extension>
        <extension name="VK_QCOM_filter_cubic_clamp" number="522" type="device" author="QCOM" depends="(VK_EXT_filter_cubic)+(VK_VERSION_1_2,VK_EXT_sampler_filter_minmax)" contact="Matthew Netsch @mnetsch" supported="vulkan">
            <require>
                <enum value="1"                                                   name="VK_QCOM_FILTER_CUBIC_CLAMP_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_filter_cubic_clamp&quot;"              name="VK_QCOM_FILTER_CUBIC_CLAMP_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM"/>
                <enum offset="0" extends="VkSamplerReductionMode"                 name="VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM"/>
                <type name="VkPhysicalDeviceCubicClampFeaturesQCOM"/>
                <feature name="cubicRangeClamp" struct="VkPhysicalDeviceCubicClampFeaturesQCOM"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_523" number="523" author="EXT" contact="Kevin Petit @kpet" supported="disabled">
            <require>
                <enum value="0"                                                name="VK_EXT_EXTENSION_523_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_523&quot;"                 name="VK_EXT_EXTENSION_523_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_524" number="524" author="EXT" contact="Tony Zlatinski @tzlatinski" supported="disabled">
            <require>
                <enum value="0"                                                name="VK_EXT_EXTENSION_524_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_524&quot;"                 name="VK_EXT_EXTENSION_524_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_attachment_feedback_loop_dynamic_state" number="525" type="device" author="EXT" depends="(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_EXT_attachment_feedback_loop_layout" contact="Mike Blumenkrantz @zmike" supported="vulkan" ratified="vulkan" specialuse="glemulation,d3demulation">
            <require>
                <enum value="1"                                                                name="VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_attachment_feedback_loop_dynamic_state&quot;" name="VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                                     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT"/>
                <enum offset="0" extends="VkDynamicState"                                      name="VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT"/>
                <type name="VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT"/>
                <command name="vkCmdSetAttachmentFeedbackLoopEnableEXT"/>
                <feature name="attachmentFeedbackLoopDynamicState" struct="VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_vertex_attribute_divisor" number="526" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="KHR" contact="Shahbaz Youssefi @syoussefi" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_4" ratified="vulkan,vulkansc">
            <require>
                <enum value="1"                                            name="VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_vertex_attribute_divisor&quot;"  name="VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                            name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES"/>
                <enum extends="VkStructureType"                            name="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO"/>
                <enum extends="VkStructureType"                            name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES"/>
                <type name="VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR"/>
                <type name="VkVertexInputBindingDivisorDescriptionKHR"/>
                <type name="VkPipelineVertexInputDivisorStateCreateInfoKHR"/>
                <type name="VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR"/>
                <feature name="vertexAttributeInstanceRateDivisor" struct="VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_load_store_op_none" number="527" author="KHR" type="device" contact="Shahbaz Youssefi @syoussefi" supported="vulkan" promotedto="VK_VERSION_1_4" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                         name="VK_KHR_LOAD_STORE_OP_NONE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_load_store_op_none&quot;"     name="VK_KHR_LOAD_STORE_OP_NONE_EXTENSION_NAME"/>
                <enum extends="VkAttachmentLoadOp"                      name="VK_ATTACHMENT_LOAD_OP_NONE_KHR" alias="VK_ATTACHMENT_LOAD_OP_NONE"/>
                <enum extends="VkAttachmentStoreOp" name="VK_ATTACHMENT_STORE_OP_NONE_KHR" alias="VK_ATTACHMENT_STORE_OP_NONE"/>
            </require>
        </extension>
        <extension name="VK_KHR_unified_image_layouts" number="528" author="KHR" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" type="device" contact="Shahbaz Youssefi @syoussefi" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                                 name="VK_KHR_UNIFIED_IMAGE_LAYOUTS_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_unified_image_layouts&quot;"          name="VK_KHR_UNIFIED_IMAGE_LAYOUTS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR"/>
                <type name="VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR"/>
                <feature name="unifiedImageLayouts" struct="VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR"/>
            </require>
            <require depends="VK_EXT_attachment_feedback_loop_layout+(VK_VERSION_1_3,VK_KHR_dynamic_rendering)">
                <enum offset="1" extends="VkStructureType" name="VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT"/>
                <type name="VkAttachmentFeedbackLoopInfoEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_float_controls2" number="529" type="device" depends="VK_VERSION_1_1+VK_KHR_shader_float_controls" author="KHR" contact="Graeme Leese @gnl21" supported="vulkan" promotedto="VK_VERSION_1_4" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_SHADER_FLOAT_CONTROLS_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_float_controls2&quot;" name="VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES"/>
                <type name="VkPhysicalDeviceShaderFloatControls2FeaturesKHR"/>
                <feature name="shaderFloatControls2" struct="VkPhysicalDeviceShaderFloatControls2FeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_QNX_external_memory_screen_buffer" number="530" type="device" author="QNX" depends="((VK_KHR_sampler_ycbcr_conversion+VK_KHR_external_memory+VK_KHR_dedicated_allocation),VK_VERSION_1_1)+VK_EXT_queue_family_foreign" platform="screen" contact="Mike Gorchak @mgorchak-blackberry, Aaron Ruby @aruby-blackberry" supported="vulkan,vulkansc">
            <require>
                <enum value="1"                                         name="VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_SPEC_VERSION"/>
                <enum value="&quot;VK_QNX_external_memory_screen_buffer&quot;" name="VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_EXTENSION_NAME"/>
                <enum bitpos="14" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX"/>
                <enum offset="0" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX"/>
                <enum offset="1" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX"/>
                <enum offset="2" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX"/>
                <enum offset="3" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX"/>
                <enum offset="4" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX"/>
                <type name="VkScreenBufferPropertiesQNX"/>
                <type name="VkScreenBufferFormatPropertiesQNX"/>
                <type name="VkImportScreenBufferInfoQNX"/>
                <type name="VkExternalFormatQNX"/>
                <type name="VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX"/>
                <command name="vkGetScreenBufferPropertiesQNX"/>
                <feature name="screenBufferImport" struct="VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX"/>
            </require>
        </extension>
        <extension name="VK_MSFT_layered_driver" number="531" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="MSFT" contact="Jesse Natalie @jenatali" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                         name="VK_MSFT_LAYERED_DRIVER_SPEC_VERSION"/>
                <enum value="&quot;VK_MSFT_layered_driver&quot;"        name="VK_MSFT_LAYERED_DRIVER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT"/>
                <type name="VkLayeredDriverUnderlyingApiMSFT"/>
                <type name="VkPhysicalDeviceLayeredDriverPropertiesMSFT"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_532" number="532" author="KHR" contact="Tobias Hector @tobias" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_KHR_EXTENSION_532_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_532&quot;"          name="VK_KHR_EXTENSION_532_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_533" number="533" author="EXT" contact="Daniel Koch @dgkoch" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_EXT_EXTENSION_533_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_533&quot;"          name="VK_EXT_EXTENSION_533_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_index_type_uint8" number="534" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Piers Daniell @pdaniell-nv" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_4" ratified="vulkan,vulkansc">
            <require>
                <enum value="1"                                         name="VK_KHR_INDEX_TYPE_UINT8_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_index_type_uint8&quot;"       name="VK_KHR_INDEX_TYPE_UINT8_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES"/>
                <enum extends="VkIndexType"                             name="VK_INDEX_TYPE_UINT8_KHR" alias="VK_INDEX_TYPE_UINT8"/>
                <type name="VkPhysicalDeviceIndexTypeUint8FeaturesKHR"/>
                <feature name="indexTypeUint8" struct="VkPhysicalDeviceIndexTypeUint8FeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_line_rasterization" number="535" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Piers Daniell @pdaniell-nv" supported="vulkan,vulkansc" promotedto="VK_VERSION_1_4" ratified="vulkan,vulkansc">
            <require>
                <enum value="1"                                         name="VK_KHR_LINE_RASTERIZATION_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_line_rasterization&quot;"     name="VK_KHR_LINE_RASTERIZATION_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES"/>
                <enum extends="VkDynamicState"                          name="VK_DYNAMIC_STATE_LINE_STIPPLE_KHR" alias="VK_DYNAMIC_STATE_LINE_STIPPLE"/>
                <enum extends="VkLineRasterizationMode"                 name="VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR" alias="VK_LINE_RASTERIZATION_MODE_DEFAULT"/>
                <enum extends="VkLineRasterizationMode"                 name="VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR" alias="VK_LINE_RASTERIZATION_MODE_RECTANGULAR"/>
                <enum extends="VkLineRasterizationMode"                 name="VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR" alias="VK_LINE_RASTERIZATION_MODE_BRESENHAM"/>
                <enum extends="VkLineRasterizationMode"                 name="VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR" alias="VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH"/>
                <type name="VkPhysicalDeviceLineRasterizationFeaturesKHR"/>
                <type name="VkPhysicalDeviceLineRasterizationPropertiesKHR"/>
                <type name="VkPipelineRasterizationLineStateCreateInfoKHR"/>
                <type name="VkLineRasterizationModeKHR"/>
                <command name="vkCmdSetLineStippleKHR"/>
                <feature name="rectangularLines,bresenhamLines,smoothLines,stippledRectangularLines,stippledBresenhamLines,stippledSmoothLines" struct="VkPhysicalDeviceLineRasterizationFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_QCOM_extension_536" number="536" type="device" author="QCOM" contact="Matthew Netsch @mnetsch" supported="disabled">
            <require>
                <enum value="0"                                                   name="VK_QCOM_EXTENSION_536_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_extension_536&quot;"                   name="VK_QCOM_EXTENSION_536_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_537" number="537" author="EXT" contact="Daniel Koch @dgkoch" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_EXT_EXTENSION_537_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_537&quot;"          name="VK_EXT_EXTENSION_537_EXTENSION_NAME"/>
                <enum bitpos="12" extends="VkQueueFlagBits"             name="VK_QUEUE_RESERVED_12_BIT_EXT"/>
                <enum bitpos="34" extends="VkBufferUsageFlagBits2"      name="VK_BUFFER_USAGE_2_RESERVED_34_BIT_EXT"/>
                <enum bitpos="28" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_RESERVED_28_BIT_EXT"/>
                <enum bitpos="60" extends="VkFormatFeatureFlagBits2"    name="VK_FORMAT_FEATURE_2_RESERVED_60_BIT_EXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_538" number="538" author="EXT" contact="Daniel Koch @dgkoch" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_EXT_EXTENSION_538_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_538&quot;"          name="VK_EXT_EXTENSION_538_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_539" number="539" author="EXT" contact="Daniel Koch @dgkoch" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_EXT_EXTENSION_539_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_539&quot;"          name="VK_EXT_EXTENSION_539_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_540" number="540" author="EXT" contact="Daniel Koch @dgkoch" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_EXT_EXTENSION_540_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_540&quot;"          name="VK_EXT_EXTENSION_540_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_541" number="541" author="EXT" contact="Daniel Koch @dgkoch" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_EXT_EXTENSION_541_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_541&quot;"          name="VK_EXT_EXTENSION_541_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_542" number="542" author="EXT" contact="Daniel Koch @dgkoch" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_EXT_EXTENSION_542_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_542&quot;"          name="VK_EXT_EXTENSION_542_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_543" number="543" author="EXT" contact="Daniel Koch @dgkoch" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_EXT_EXTENSION_543_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_543&quot;"          name="VK_EXT_EXTENSION_543_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_calibrated_timestamps" number="544" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="KHR" contact="Daniel Rakos @aqnuep" supported="vulkan,vulkansc" ratified="vulkan,vulkansc" nofeatures="true">
            <require>
                <enum value="1"                                         name="VK_KHR_CALIBRATED_TIMESTAMPS_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_calibrated_timestamps&quot;"  name="VK_KHR_CALIBRATED_TIMESTAMPS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" extnumber="185" name="VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR"/>
                <type name="VkTimeDomainKHR"/>
                <type name="VkCalibratedTimestampInfoKHR"/>
                <command name="vkGetPhysicalDeviceCalibrateableTimeDomainsKHR"/>
                <command name="vkGetCalibratedTimestampsKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_expect_assume" number="545" type="device" author="KHR" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Kevin Petit @kpet" supported="vulkan" promotedto="VK_VERSION_1_4" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_SHADER_EXPECT_ASSUME_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_expect_assume&quot;"   name="VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES"/>
                <type name="VkPhysicalDeviceShaderExpectAssumeFeaturesKHR"/>
                <feature name="shaderExpectAssume" struct="VkPhysicalDeviceShaderExpectAssumeFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_maintenance6" number="546" type="device" depends="VK_VERSION_1_1" author="KHR" contact="Jon Leech @oddhack" supported="vulkan" promotedto="VK_VERSION_1_4" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_MAINTENANCE_6_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_maintenance6&quot;"           name="VK_KHR_MAINTENANCE_6_EXTENSION_NAME"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR" alias="VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR" alias="VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO"/>
                <type name="VkPhysicalDeviceMaintenance6FeaturesKHR"/>
                <type name="VkPhysicalDeviceMaintenance6PropertiesKHR"/>
                <type name="VkBindMemoryStatusKHR"/>
                <type name="VkBindDescriptorSetsInfoKHR"/>
                <type name="VkPushConstantsInfoKHR"/>
                <command name="vkCmdBindDescriptorSets2KHR"/>
                <command name="vkCmdPushConstants2KHR"/>
                <feature name="maintenance6" struct="VkPhysicalDeviceMaintenance6FeaturesKHR"/>
            </require>
            <require depends="VK_KHR_push_descriptor">
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR" alias="VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO"/>
                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO"/>
                <type name="VkPushDescriptorSetInfoKHR"/>
                <type name="VkPushDescriptorSetWithTemplateInfoKHR"/>
                <command name="vkCmdPushDescriptorSet2KHR"/>
                <command name="vkCmdPushDescriptorSetWithTemplate2KHR"/>
            </require>
            <require depends="VK_EXT_descriptor_buffer">
                <enum offset="7" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT"/>
                <enum offset="8" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT"/>
                <type name="VkSetDescriptorBufferOffsetsInfoEXT"/>
                <type name="VkBindDescriptorBufferEmbeddedSamplersInfoEXT"/>
                <command name="vkCmdSetDescriptorBufferOffsets2EXT"/>
                <command name="vkCmdBindDescriptorBufferEmbeddedSamplers2EXT"/>
            </require>
            <require comment="Individual APIs with dependencies on specific versions/extensions should get their own require blocks with depends= attribute set appropriately">
            </require>
        </extension>
        <extension name="VK_NV_descriptor_pool_overallocation" number="547" type="device" author="NV" depends="VK_VERSION_1_1" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
            <require>
                <enum value="1"                                                 name="VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_descriptor_pool_overallocation&quot;"  name="VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV"/>
                <enum bitpos="3" extends="VkDescriptorPoolCreateFlagBits"       name="VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV"/>
                <enum bitpos="4" extends="VkDescriptorPoolCreateFlagBits"       name="VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV"/>
                <type name="VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV"/>
                <feature name="descriptorPoolOverallocation" struct="VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_QCOM_tile_memory_heap" number="548" type="device" author="QCOM" depends="(VK_KHR_get_memory_requirements2+VK_KHR_get_physical_device_properties2),VK_VERSION_1_1" contact="Patrick Boyle @pboyleQCOM" supported="vulkan">
            <require>
                <enum value="1"                                    name="VK_QCOM_TILE_MEMORY_HEAP_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_tile_memory_heap&quot;" name="VK_QCOM_TILE_MEMORY_HEAP_EXTENSION_NAME"/>
                <enum bitpos="3"  extends="VkMemoryHeapFlagBits"   name="VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM"/>
                <enum bitpos="27" extends="VkBufferUsageFlagBits"  name="VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM"/>
                <enum bitpos="27" extends="VkBufferUsageFlagBits2" name="VK_BUFFER_USAGE_2_TILE_MEMORY_BIT_QCOM"/>
                <enum bitpos="27" extends="VkImageUsageFlagBits"   name="VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM"/>
                <enum offset="0"  extends="VkStructureType"        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM"/>
                <enum offset="1"  extends="VkStructureType"        name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM"/>
                <enum offset="2"  extends="VkStructureType"        name="VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM"/>
                <enum offset="3"  extends="VkStructureType"        name="VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM"/>
                <type name="VkPhysicalDeviceTileMemoryHeapFeaturesQCOM"/>
                <type name="VkPhysicalDeviceTileMemoryHeapPropertiesQCOM"/>
                <type name="VkTileMemoryRequirementsQCOM"/>
                <type name="VkTileMemoryBindInfoQCOM"/>
                <command name="vkCmdBindTileMemoryQCOM"/>
                <feature name="tileMemoryHeap" struct="VkPhysicalDeviceTileMemoryHeapFeaturesQCOM"/>
            </require>
            <require depends="VK_QCOM_tile_properties">
                <enum offset="4" extends="VkStructureType" name="VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM"/>
                <type name="VkTileMemorySizeInfoQCOM"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_549" number="549" author="NV" contact="Piers Daniell @pdaniell-nv" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_NV_EXTENSION_549_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_549&quot;"           name="VK_NV_EXTENSION_549_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_copy_memory_indirect" number="550" type="device" depends="(VK_KHR_get_physical_device_properties2+VK_KHR_buffer_device_address),VK_VERSION_1_2" author="KHR" contact="Vikram Kushwaha @vkushwaha-nv" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_COPY_MEMORY_INDIRECT_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_copy_memory_indirect&quot;"   name="VK_KHR_COPY_MEMORY_INDIRECT_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_KHR"/>
                <enum offset="1" extnumber="427" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_KHR"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_COPY_MEMORY_INDIRECT_INFO_KHR"/>
                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INDIRECT_INFO_KHR"/>
                <enum bitpos="46" extends="VkPipelineStageFlagBits2"    name="VK_PIPELINE_STAGE_2_COPY_INDIRECT_BIT_KHR"/>
                <enum bitpos="59" extends="VkFormatFeatureFlagBits2"    name="VK_FORMAT_FEATURE_2_COPY_IMAGE_INDIRECT_DST_BIT_KHR"/>
                <type name="VkStridedDeviceAddressRangeKHR"/>
                <type name="VkAddressCopyFlagBitsKHR"/>
                <type name="VkAddressCopyFlagsKHR"/>
                <type name="VkCopyMemoryIndirectCommandKHR"/>
                <type name="VkCopyMemoryIndirectInfoKHR"/>
                <type name="VkCopyMemoryToImageIndirectCommandKHR"/>
                <type name="VkCopyMemoryToImageIndirectInfoKHR"/>
                <type name="VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR"/>
                <type name="VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR"/>
                <command name="vkCmdCopyMemoryIndirectKHR"/>
                <command name="vkCmdCopyMemoryToImageIndirectKHR"/>
                <feature name="indirectMemoryCopy" struct="VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_memory_decompression" number="551" type="device" depends="VK_KHR_get_physical_device_properties2+VK_KHR_buffer_device_address" author="EXT" contact="Vikram Kushwaha @vkushwaha-nv" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_MEMORY_DECOMPRESSION_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_memory_decompression&quot;"       name="VK_EXT_MEMORY_DECOMPRESSION_EXTENSION_NAME"/>
                <enum offset="0" extnumber="428" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_EXT"/>
                <enum offset="1" extnumber="428" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_EXT"/>
                <enum offset="2" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_DECOMPRESS_MEMORY_INFO_EXT"/>
                <enum bitpos="45" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_MEMORY_DECOMPRESSION_BIT_EXT"/>
                <enum bitpos="55" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_MEMORY_DECOMPRESSION_READ_BIT_EXT"/>
                <enum bitpos="56" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_MEMORY_DECOMPRESSION_WRITE_BIT_EXT"/>
                <enum bitpos="32" extends="VkBufferUsageFlagBits2"          name="VK_BUFFER_USAGE_2_MEMORY_DECOMPRESSION_BIT_EXT"/>
                <type name="VkMemoryDecompressionMethodFlagBitsEXT"/>
                <type name="VkMemoryDecompressionMethodFlagsEXT"/>
                <type name="VkDecompressMemoryInfoEXT"/>
                <type name="VkDecompressMemoryRegionEXT"/>
                <type name="VkPhysicalDeviceMemoryDecompressionFeaturesEXT"/>
                <type name="VkPhysicalDeviceMemoryDecompressionPropertiesEXT"/>
                <command name="vkCmdDecompressMemoryEXT"/>
                <command name="vkCmdDecompressMemoryIndirectCountEXT"/>
                <feature name="memoryDecompression" struct="VkPhysicalDeviceMemoryDecompressionFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_NV_display_stereo" number="552" type="instance" depends="VK_KHR_display+VK_KHR_get_display_properties2" author="NV" contact="Russell Chou @russellcnv" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                name="VK_NV_DISPLAY_STEREO_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_display_stereo&quot;" name="VK_NV_DISPLAY_STEREO_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"     name="VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV"/>
                <enum offset="1" extends="VkStructureType"     name="VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV"/>
                <type name="VkDisplaySurfaceStereoCreateInfoNV"/>
                <type name="VkDisplaySurfaceStereoTypeNV"/>
                <type name="VkDisplayModeStereoPropertiesNV"/>
            </require>
        </extension>
        <extension name="VK_KHR_video_encode_intra_refresh" number="553" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" type="device" depends="VK_KHR_video_encode_queue" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_VIDEO_ENCODE_INTRA_REFRESH_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_video_encode_intra_refresh&quot;" name="VK_KHR_VIDEO_ENCODE_INTRA_REFRESH_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR"/>
                <enum offset="1"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR"/>
                <enum offset="2"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR"/>
                <enum offset="3"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR"/>
                <enum offset="4"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR"/>
                <enum bitpos="2"  extends="VkVideoEncodeFlagBitsKHR"        name="VK_VIDEO_ENCODE_INTRA_REFRESH_BIT_KHR"/>
                <type name="VkVideoEncodeIntraRefreshModeFlagsKHR"/>
                <type name="VkVideoEncodeIntraRefreshModeFlagBitsKHR"/>
                <type name="VkVideoEncodeIntraRefreshCapabilitiesKHR"/>
                <type name="VkVideoEncodeSessionIntraRefreshCreateInfoKHR"/>
                <type name="VkVideoEncodeIntraRefreshInfoKHR"/>
                <type name="VkVideoReferenceIntraRefreshInfoKHR"/>
                <type name="VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR"/>
                <feature name="videoEncodeIntraRefresh" struct="VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR"/>
            </require>
            <require depends="VK_KHR_video_encode_h264">
                <enum bitpos="10" extends="VkVideoEncodeH264CapabilityFlagBitsKHR" name="VK_VIDEO_ENCODE_H264_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR"/>
            </require>
            <require depends="VK_KHR_video_encode_h265">
                <enum bitpos="11" extends="VkVideoEncodeH265CapabilityFlagBitsKHR" name="VK_VIDEO_ENCODE_H265_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR"/>
            </require>
            <require depends="VK_KHR_video_encode_av1">
                <enum bitpos="5" extends="VkVideoEncodeAV1CapabilityFlagBitsKHR" name="VK_VIDEO_ENCODE_AV1_CAPABILITY_COMPOUND_PREDICTION_INTRA_REFRESH_BIT_KHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_video_encode_quantization_map" number="554" type="device" depends="VK_KHR_video_encode_queue+(VK_KHR_format_feature_flags2,VK_VERSION_1_3)" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="2"                                                 name="VK_KHR_VIDEO_ENCODE_QUANTIZATION_MAP_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_video_encode_quantization_map&quot;"  name="VK_KHR_VIDEO_ENCODE_QUANTIZATION_MAP_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR"/>
                <enum offset="1"  extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR"/>
                <enum offset="2"  extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR"/>
                <enum offset="5"  extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR"/>
                <enum offset="9"  extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR"/>
                <enum bitpos="2"  extends="VkVideoEncodeCapabilityFlagBitsKHR"  name="VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR"/>
                <enum bitpos="3"  extends="VkVideoEncodeCapabilityFlagBitsKHR"  name="VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR"/>
                <enum bitpos="3"  extends="VkVideoSessionCreateFlagBitsKHR"     name="VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR"/>
                <enum bitpos="4"  extends="VkVideoSessionCreateFlagBitsKHR"     name="VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR"/>
                <enum bitpos="0"  extends="VkVideoSessionParametersCreateFlagBitsKHR" name="VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR"/>
                <enum bitpos="0"  extends="VkVideoEncodeFlagBitsKHR"            name="VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR"/>
                <enum bitpos="1"  extends="VkVideoEncodeFlagBitsKHR"            name="VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR"/>
                <enum bitpos="25" extends="VkImageUsageFlagBits"                name="VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR"/>
                <enum bitpos="26" extends="VkImageUsageFlagBits"                name="VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR"/>
                <enum bitpos="49" extends="VkFormatFeatureFlagBits2"            name="VK_FORMAT_FEATURE_2_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR"/>
                <enum bitpos="50" extends="VkFormatFeatureFlagBits2"            name="VK_FORMAT_FEATURE_2_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR"/>
                <enum offset="0"  extends="VkImageLayout"                       name="VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR"/>
                <type name="VkVideoEncodeFlagBitsKHR"/>
                <type name="VkVideoSessionParametersCreateFlagBitsKHR"/>
                <type name="VkVideoEncodeQuantizationMapCapabilitiesKHR"/>
                <type name="VkVideoFormatQuantizationMapPropertiesKHR"/>
                <type name="VkVideoEncodeQuantizationMapInfoKHR"/>
                <type name="VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR"/>
                <type name="VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR"/>
                <feature name="videoEncodeQuantizationMap" struct="VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR"/>
            </require>
            <require depends="VK_KHR_video_encode_h264">
                <enum offset="3"  extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR"/>
                <enum bitpos="9"  extends="VkVideoEncodeH264CapabilityFlagBitsKHR" name="VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR"/>
                <type name="VkVideoEncodeH264QuantizationMapCapabilitiesKHR"/>
            </require>
            <require depends="VK_KHR_video_encode_h265">
                <enum offset="4"  extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR"/>
                <enum offset="6"  extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR"/>
                <enum bitpos="10" extends="VkVideoEncodeH265CapabilityFlagBitsKHR" name="VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR"/>
                <type name="VkVideoEncodeH265QuantizationMapCapabilitiesKHR"/>
                <type name="VkVideoFormatH265QuantizationMapPropertiesKHR"/>
            </require>
            <require depends="VK_KHR_video_encode_av1">
                <enum offset="7"  extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR"/>
                <enum offset="8"  extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR"/>
                <type name="VkVideoEncodeAV1QuantizationMapCapabilitiesKHR"/>
                <type name="VkVideoFormatAV1QuantizationMapPropertiesKHR"/>
            </require>
        </extension>
        <extension name="VK_IMG_extension_555" number="555" author="IMG" contact="Jarred Davies" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_IMG_EXTENSION_555_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_extension_555&quot;"              name="VK_IMG_EXTENSION_555_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_raw_access_chains" number="556" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Rodrigo Locatti @rlocatti" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_RAW_ACCESS_CHAINS_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_raw_access_chains&quot;"           name="VK_NV_RAW_ACCESS_CHAINS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV"/>
                <type name="VkPhysicalDeviceRawAccessChainsFeaturesNV"/>
                <feature name="shaderRawAccessChains" struct="VkPhysicalDeviceRawAccessChainsFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_external_compute_queue" number="557" type="device" author="NV" contact="Chris Lentini @clentini" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                         name="VK_NV_EXTERNAL_COMPUTE_QUEUE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_external_compute_queue&quot;"  name="VK_NV_EXTERNAL_COMPUTE_QUEUE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV"/>
                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV"/>
                <enum offset="0" extends="VkObjectType"                 name="VK_OBJECT_TYPE_EXTERNAL_COMPUTE_QUEUE_NV"/>
                <type name="VkExternalComputeQueueNV"/>
                <type name="VkExternalComputeQueueDeviceCreateInfoNV"/>
                <type name="VkExternalComputeQueueCreateInfoNV"/>
                <type name="VkExternalComputeQueueDataParamsNV"/>
                <type name="VkPhysicalDeviceExternalComputeQueuePropertiesNV"/>
                <command name="vkCreateExternalComputeQueueNV"/>
                <command name="vkDestroyExternalComputeQueueNV"/>
                <command name="vkGetExternalComputeQueueDataNV"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_558" number="558" type="device" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_558_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_558&quot;"              name="VK_KHR_EXTENSION_558_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_relaxed_extended_instruction" number="559" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" type="device" author="KHR" contact="Nathan GauÃ«r @Keenuts" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                                       name="VK_KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_relaxed_extended_instruction&quot;"  name="VK_KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                            name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR"/>
                <type name="VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR"/>
                <feature name="shaderRelaxedExtendedInstruction" struct="VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_NV_command_buffer_inheritance" number="560" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" type="device" author="NV" contact="Lujin Wang @lujinwangnv" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_COMMAND_BUFFER_INHERITANCE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_command_buffer_inheritance&quot;"  name="VK_NV_COMMAND_BUFFER_INHERITANCE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV"/>
                <type name="VkPhysicalDeviceCommandBufferInheritanceFeaturesNV"/>
                <feature name="commandBufferInheritance" struct="VkPhysicalDeviceCommandBufferInheritanceFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_561" number="561" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_561_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_561&quot;"              name="VK_EXT_EXTENSION_561_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_562" number="562" author="KHR" contact="Piers Daniell @pdaniell-nv" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_562_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_562&quot;"              name="VK_KHR_EXTENSION_562_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_maintenance7" number="563" type="device" depends="VK_VERSION_1_1" author="KHR" contact="Mike Blumenkrantz @zmike" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_MAINTENANCE_7_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_maintenance7&quot;"           name="VK_KHR_MAINTENANCE_7_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR"/>
                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR"/>
                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR"/>
                <enum offset="0" extends="VkSubpassContents" extnumber="452" name="VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR"/>
                <enum bitpos="4" extends="VkRenderingFlagBits"          name="VK_RENDERING_CONTENTS_INLINE_BIT_KHR" comment="Promoted from extension 452"/>
                <type name="VkPhysicalDeviceMaintenance7FeaturesKHR"/>
                <type name="VkPhysicalDeviceMaintenance7PropertiesKHR"/>
                <type name="VkPhysicalDeviceLayeredApiPropertiesListKHR"/>
                <type name="VkPhysicalDeviceLayeredApiPropertiesKHR"/>
                <type name="VkPhysicalDeviceLayeredApiKHR"/>
                <type name="VkPhysicalDeviceLayeredApiVulkanPropertiesKHR"/>
                <feature name="maintenance7" struct="VkPhysicalDeviceMaintenance7FeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_NV_shader_atomic_float16_vector" number="564" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" type="device" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_shader_atomic_float16_vector&quot;" name="VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV"/>
                <type name="VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV"/>
                <feature name="shaderFloat16VectorAtomics" struct="VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_replicated_composites" number="565" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" type="device" author="EXT" contact="Kevin Petit @kpet" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                               name="VK_EXT_SHADER_REPLICATED_COMPOSITES_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_replicated_composites&quot;" name="VK_EXT_SHADER_REPLICATED_COMPOSITES_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT"/>
                <feature name="shaderReplicatedComposites" struct="VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_ARM_extension_566" number="566" author="ARM" contact="Kevin Petit @kpet" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_ARM_EXTENSION_566_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_extension_566&quot;"              name="VK_ARM_EXTENSION_566_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_ARM_extension_567" number="567" author="ARM" contact="Kevin Petit @kpet" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_ARM_EXTENSION_567_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_extension_567&quot;"              name="VK_ARM_EXTENSION_567_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_float8" number="568" author="EXT" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Kevin Petit @kpet" type="device" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                          name="VK_EXT_SHADER_FLOAT8_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_float8&quot;"           name="VK_EXT_SHADER_FLOAT8_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceShaderFloat8FeaturesEXT"/>
                <feature name="shaderFloat8" struct="VkPhysicalDeviceShaderFloat8FeaturesEXT"/>
            </require>
            <require depends="VK_KHR_cooperative_matrix">
                <enum offset="2" extnumber="492" extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT"/>
                <enum offset="3" extnumber="492" extends="VkComponentTypeKHR" name="VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT"/>
            </require>
        </extension>
        <extension name="VK_NV_ray_tracing_validation" number="569" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Vikram Kushwaha @vkushwaha-nv" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_RAY_TRACING_VALIDATION_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_ray_tracing_validation&quot;"      name="VK_NV_RAY_TRACING_VALIDATION_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV"/>
                <type name="VkPhysicalDeviceRayTracingValidationFeaturesNV"/>
                <feature name="rayTracingValidation" struct="VkPhysicalDeviceRayTracingValidationFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_cluster_acceleration_structure" number="570" type="device" depends="VK_KHR_acceleration_structure" author="NV" contact="Vikram Kushwaha @vkushwaha" supported="vulkan">
            <require>
                <enum value="4"                                                 name="VK_NV_CLUSTER_ACCELERATION_STRUCTURE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_cluster_acceleration_structure&quot;"  name="VK_NV_CLUSTER_ACCELERATION_STRUCTURE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV"/>
                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV"/>
                <enum offset="3" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV"/>
                <enum offset="4" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV"/>
                <enum offset="5" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV"/>
                <enum offset="6" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV"/>
                <enum offset="7" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV"/>
                <enum bitpos="12" extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_CLUSTER_OPACITY_MICROMAPS_BIT_NV"/>
                <type name="VkPhysicalDeviceClusterAccelerationStructureFeaturesNV"/>
                <type name="VkPhysicalDeviceClusterAccelerationStructurePropertiesNV"/>
                <type name="VkClusterAccelerationStructureClustersBottomLevelInputNV"/>
                <type name="VkClusterAccelerationStructureTriangleClusterInputNV"/>
                <type name="VkClusterAccelerationStructureMoveObjectsInputNV"/>
                <type name="VkClusterAccelerationStructureOpInputNV"/>
                <type name="VkClusterAccelerationStructureInputInfoNV"/>
                <type name="VkClusterAccelerationStructureCommandsInfoNV"/>
                <type name="VkStridedDeviceAddressNV"/>
                <type name="VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV"/>
                <type name="VkClusterAccelerationStructureClusterFlagsNV"/>
                <type name="VkClusterAccelerationStructureClusterFlagBitsNV"/>
                <type name="VkClusterAccelerationStructureGeometryFlagsNV"/>
                <type name="VkClusterAccelerationStructureGeometryFlagBitsNV"/>
                <type name="VkClusterAccelerationStructureAddressResolutionFlagsNV"/>
                <type name="VkClusterAccelerationStructureAddressResolutionFlagBitsNV"/>
                <type name="VkClusterAccelerationStructureMoveObjectsInfoNV"/>
                <type name="VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV"/>
                <type name="VkClusterAccelerationStructureBuildTriangleClusterInfoNV"/>
                <type name="VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV"/>
                <type name="VkClusterAccelerationStructureInstantiateClusterInfoNV"/>
                <type name="VkClusterAccelerationStructureIndexFormatFlagBitsNV"/>
                <type name="VkClusterAccelerationStructureIndexFormatFlagsNV"/>
                <type name="VkClusterAccelerationStructureTypeNV"/>
                <type name="VkClusterAccelerationStructureOpTypeNV"/>
                <type name="VkClusterAccelerationStructureOpModeNV"/>
                <type name="VkClusterAccelerationStructureGetTemplateIndicesInfoNV"/>
                <command name="vkGetClusterAccelerationStructureBuildSizesNV"/>
                <command name="vkCmdBuildClusterAccelerationStructureIndirectNV"/>
                <feature name="clusterAccelerationStructure" struct="VkPhysicalDeviceClusterAccelerationStructureFeaturesNV"/>
            </require>
            <require depends="VK_EXT_opacity_micromap">
                <enum value="-5" extends="VkOpacityMicromapSpecialIndexEXT" name="VK_OPACITY_MICROMAP_SPECIAL_INDEX_CLUSTER_GEOMETRY_DISABLE_OPACITY_MICROMAP_NV"/>
            </require>
            <require depends="VK_KHR_ray_tracing_pipeline">
                <type name="VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV"/>
            </require>
        </extension>
        <extension name="VK_NV_partitioned_acceleration_structure" number="571" type="device" depends="VK_KHR_acceleration_structure" author="NV" contact="Vikram Kushwaha @vkushwaha" supported="vulkan">
            <require>
                <enum value="1"                                                     name="VK_NV_PARTITIONED_ACCELERATION_STRUCTURE_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_partitioned_acceleration_structure&quot;"  name="VK_NV_PARTITIONED_ACCELERATION_STRUCTURE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV"/>
                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV"/>
                <enum offset="3" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV"/>
                <enum offset="4" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV"/>
                <enum offset="5" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV"/>
                <enum offset="0" extends="VkDescriptorType"                     name="VK_DESCRIPTOR_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_NV"/>
                <enum name="VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV"/>
                <type name="VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV"/>
                <type name="VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV"/>
                <type name="VkPartitionedAccelerationStructureFlagsNV"/>
                <type name="VkPartitionedAccelerationStructureOpTypeNV"/>
                <type name="VkBuildPartitionedAccelerationStructureIndirectCommandNV"/>
                <type name="VkPartitionedAccelerationStructureInstanceFlagsNV"/>
                <type name="VkPartitionedAccelerationStructureInstanceFlagBitsNV"/>
                <type name="VkPartitionedAccelerationStructureWriteInstanceDataNV"/>
                <type name="VkPartitionedAccelerationStructureUpdateInstanceDataNV"/>
                <type name="VkPartitionedAccelerationStructureWritePartitionTranslationDataNV"/>
                <type name="VkWriteDescriptorSetPartitionedAccelerationStructureNV"/>
                <type name="VkPartitionedAccelerationStructureInstancesInputNV"/>
                <type name="VkBuildPartitionedAccelerationStructureInfoNV"/>
                <command name="vkGetPartitionedAccelerationStructuresBuildSizesNV"/>
                <command name="vkCmdBuildPartitionedAccelerationStructuresNV"/>
                <feature name="partitionedAccelerationStructure" struct="VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_572" number="572" author="NV" contact="Jeff Juliano @jjuliano" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_572_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_572&quot;"               name="VK_NV_EXTENSION_572_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_device_generated_commands" number="573" author="EXT" type="device" depends="((VK_KHR_buffer_device_address,VK_VERSION_1_2)+VK_KHR_maintenance5),VK_VERSION_1_3" contact="Mike Blumenkrantz @zmike" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                                     name="VK_EXT_DEVICE_GENERATED_COMMANDS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_device_generated_commands&quot;"          name="VK_EXT_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME"/>
                <enum bitpos="7" extends="VkShaderCreateFlagBitsEXT"        name="VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT"/>
                <enum bitpos="31" extends="VkBufferUsageFlagBits2"          name="VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT"/>
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT"/>
                <enum offset="6" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT"/>
                <enum offset="7" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT"/>
                <enum offset="8" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT"/>
                <enum offset="9" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT"/>
                <enum offset="10" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT"/>
                <enum offset="11" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT"/>
                <enum offset="12" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT"/>
                <enum offset="13" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT"/>
                <enum offset="14" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT"/>
                <enum offset="0" extends="VkObjectType"                     name="VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT"/>
                <enum offset="1" extends="VkObjectType"                     name="VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT"/>
                <enum bitpos="38" extends="VkPipelineCreateFlagBits2"       name="VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT"/>
                <enum bitpos="17" extends="VkPipelineStageFlagBits"         name="VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT"/>
                <enum bitpos="17" extends="VkAccessFlagBits"                name="VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT"/>
                <enum bitpos="18" extends="VkAccessFlagBits"                name="VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT"/>
                <type name="VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT"/>
                <type name="VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT"/>
                <type name="VkGeneratedCommandsMemoryRequirementsInfoEXT"/>
                <type name="VkIndirectExecutionSetCreateInfoEXT"/>
                <type name="VkIndirectExecutionSetInfoEXT"/>
                <type name="VkIndirectExecutionSetPipelineInfoEXT"/>
                <type name="VkIndirectExecutionSetShaderInfoEXT"/>
                <type name="VkGeneratedCommandsInfoEXT"/>
                <type name="VkWriteIndirectExecutionSetPipelineEXT"/>
                <type name="VkIndirectCommandsLayoutCreateInfoEXT"/>
                <type name="VkIndirectCommandsLayoutTokenEXT"/>
                <type name="VkDrawIndirectCountIndirectCommandEXT"/>
                <type name="VkIndirectCommandsVertexBufferTokenEXT"/>
                <type name="VkBindVertexBufferIndirectCommandEXT"/>
                <type name="VkIndirectCommandsIndexBufferTokenEXT"/>
                <type name="VkBindIndexBufferIndirectCommandEXT"/>
                <type name="VkIndirectCommandsPushConstantTokenEXT"/>
                <type name="VkIndirectCommandsExecutionSetTokenEXT"/>
                <type name="VkIndirectCommandsTokenDataEXT"/>
                <type name="VkIndirectCommandsLayoutEXT"/>
                <type name="VkIndirectExecutionSetEXT"/>
                <type name="VkIndirectCommandsTokenTypeEXT"/>
                <type name="VkIndirectExecutionSetInfoTypeEXT"/>
                <type name="VkIndirectCommandsLayoutUsageFlagsEXT"/>
                <type name="VkIndirectCommandsLayoutUsageFlagBitsEXT"/>
                <type name="VkIndirectCommandsInputModeFlagsEXT"/>
                <type name="VkIndirectCommandsInputModeFlagBitsEXT"/>
                <type name="VkIndirectExecutionSetShaderLayoutInfoEXT"/>
                <type name="VkGeneratedCommandsPipelineInfoEXT"/>
                <type name="VkGeneratedCommandsShaderInfoEXT"/>
                <command name="vkGetGeneratedCommandsMemoryRequirementsEXT"/>
                <command name="vkCmdPreprocessGeneratedCommandsEXT"/>
                <command name="vkCmdExecuteGeneratedCommandsEXT"/>
                <command name="vkCreateIndirectCommandsLayoutEXT"/>
                <command name="vkDestroyIndirectCommandsLayoutEXT"/>
                <command name="vkCreateIndirectExecutionSetEXT"/>
                <command name="vkDestroyIndirectExecutionSetEXT"/>
                <command name="vkUpdateIndirectExecutionSetPipelineEXT"/>
                <command name="vkUpdateIndirectExecutionSetShaderEXT"/>
                <feature name="deviceGeneratedCommands" struct="VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT"/>
            </require>
            <require depends="VK_EXT_shader_object">
                <type name="VkWriteIndirectExecutionSetShaderEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_574" number="574" author="KHR" contact="Ralph Potter gitlab:@r_potter" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_574_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_574&quot;"              name="VK_KHR_EXTENSION_574_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_maintenance8" number="575" type="device" depends="VK_VERSION_1_1" author="KHR" contact="Mike Blumenkrantz @zmike" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_MAINTENANCE_8_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_maintenance8&quot;"               name="VK_KHR_MAINTENANCE_8_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR"/>
                <enum bitpos="3" extends="VkPipelineCacheCreateFlagBits"    name="VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR"/>
                <enum bitpos="5" extends="VkDependencyFlagBits" name="VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR"/>
                <type name="VkMemoryBarrierAccessFlags3KHR"/>
                <type name="VkAccessFlagBits3KHR"/>
                <type name="VkAccessFlags3KHR"/>
                <type name="VkPipelineCacheCreateFlagBits"/>
                <type name="VkPhysicalDeviceMaintenance8FeaturesKHR"/>
                <feature name="maintenance8" struct="VkPhysicalDeviceMaintenance8FeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_MESA_image_alignment_control" number="576" type="device" author="MESA" contact="Hans-Kristian Arntzen @HansKristian-Work" specialuse="d3demulation" supported="vulkan" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1">
            <require>
                <enum value="1"                                             name="VK_MESA_IMAGE_ALIGNMENT_CONTROL_SPEC_VERSION"/>
                <enum value="&quot;VK_MESA_image_alignment_control&quot;"   name="VK_MESA_IMAGE_ALIGNMENT_CONTROL_EXTENSION_NAME"/>
                <type name="VkPhysicalDeviceImageAlignmentControlFeaturesMESA"/>
                <type name="VkPhysicalDeviceImageAlignmentControlPropertiesMESA"/>
                <type name="VkImageAlignmentControlCreateInfoMESA"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA"/>
                <feature name="imageAlignmentControl" struct="VkPhysicalDeviceImageAlignmentControlFeaturesMESA"/>
            </require>
        </extension>
        <extension name="VK_HUAWEI_extension_577" number="577" author="HUAWEI" contact="Ye Wang @wangye" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_HUAWEI_EXTENSION_577_SPEC_VERSION"/>
                <enum value="&quot;VK_HUAWEI_extension_577&quot;"              name="VK_HUAWEI_EXTENSION_577_EXTENSION_NAME"/>
                <enum bitpos="35" extends="VkPipelineCreateFlagBits2"    name="VK_PIPELINE_CREATE_2_RESERVED_35_BIT_KHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_578" number="578" author="EXT" contact="Daniel Story @daniel-story" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_578_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_578&quot;"              name="VK_EXT_EXTENSION_578_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_579" number="579" author="EXT" contact="Daniel Story @daniel-story" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_579_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_579&quot;"              name="VK_EXT_EXTENSION_579_EXTENSION_NAME"/>
                <enum bitpos="8" extends="VkShaderCreateFlagBitsEXT"        name="VK_SHADER_CREATE_RESERVED_8_BIT_EXT"/>
                <enum bitpos="9" extends="VkShaderCreateFlagBitsEXT"        name="VK_SHADER_CREATE_RESERVED_9_BIT_EXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_shader_fma" number="580" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" type="device" author="KHR" contact="Graeme Leese @gnl21" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                  name="VK_KHR_SHADER_FMA_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_shader_fma&quot;"      name="VK_KHR_SHADER_FMA_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"       name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FMA_FEATURES_KHR"/>
                <type name="VkPhysicalDeviceShaderFmaFeaturesKHR"/>
                <feature name="shaderFmaFloat32" struct="VkPhysicalDeviceShaderFmaFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_581" number="581" author="NV" contact="Piers Daniell @pdaniell-nv" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_581_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_581&quot;"               name="VK_NV_EXTENSION_581_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_ray_tracing_invocation_reorder" number="582" type="device" depends="VK_KHR_ray_tracing_pipeline" author="EXT" contact="Eric Werness @ewerness-nv" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                                  name="VK_EXT_RAY_TRACING_INVOCATION_REORDER_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_ray_tracing_invocation_reorder&quot;"  name="VK_EXT_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                       name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                       name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_EXT"/>
                <type name="VkRayTracingInvocationReorderModeEXT"/>
                <type name="VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT"/>
                <type name="VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT"/>
                <feature name="rayTracingInvocationReorder" struct="VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_depth_clamp_control" number="583" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" type="device" author="EXT" contact="Jules Blok @jules" comment="codespell:ignore blok" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_DEPTH_CLAMP_CONTROL_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_depth_clamp_control&quot;"        name="VK_EXT_DEPTH_CLAMP_CONTROL_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT"/>
                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT"/>
                <type name="VkPhysicalDeviceDepthClampControlFeaturesEXT"/>
                <type name="VkPipelineViewportDepthClampControlCreateInfoEXT"/>
                <type name="VkDepthClampModeEXT"/>
                <type name="VkDepthClampRangeEXT"/>
                <command name="vkCmdSetDepthClampRangeEXT"/>
                <feature name="depthClampControl" struct="VkPhysicalDeviceDepthClampControlFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_584" number="584" author="EXT" contact="James Jones @cubanismo" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_584_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_584&quot;"              name="VK_EXT_EXTENSION_584_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_maintenance9" number="585" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="KHR" contact="Mike Blumenkrantz @zmike" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                         name="VK_KHR_MAINTENANCE_9_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_maintenance9&quot;"           name="VK_KHR_MAINTENANCE_9_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR"/>
                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR"/>
                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR"/>
                <enum bitpos="6" extends="VkDependencyFlagBits"         name="VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR"/>
                <enum bitpos="0" extends="VkQueryPoolCreateFlagBits"    name="VK_QUERY_POOL_CREATE_RESET_BIT_KHR"/>
                <type name="VkPhysicalDeviceMaintenance9FeaturesKHR"/>
                <type name="VkPhysicalDeviceMaintenance9PropertiesKHR"/>
                <type name="VkQueueFamilyOwnershipTransferPropertiesKHR"/>
                <type name="VkDefaultVertexAttributeValueKHR"/>
                <feature name="maintenance9" struct="VkPhysicalDeviceMaintenance9FeaturesKHR"/>
            </require>
            <require comment="Individual APIs with dependencies on specific versions/extensions should get their own require blocks with depends= attribute set appropriately"/>
        </extension>
        <extension name="VK_IMG_extension_586" number="586" author="IMG" contact="James Fitzpatrick @jfitzpatrick-img" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_IMG_EXTENSION_586_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_extension_586&quot;"              name="VK_IMG_EXTENSION_586_EXTENSION_NAME"/>
                <enum bitpos="4" extends="VkDependencyFlagBits"             name="VK_DEPENDENCY_EXTENSION_586_BIT_IMG"/>
            </require>
        </extension>
        <extension name="VK_KHR_video_maintenance2" number="587" author="KHR" contact="Daniel Rakos @aqnuep" type="device" depends="VK_KHR_video_queue" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_VIDEO_MAINTENANCE_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_video_maintenance2&quot;"         name="VK_KHR_VIDEO_MAINTENANCE_2_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR"/>
                <type name="VkPhysicalDeviceVideoMaintenance2FeaturesKHR"/>
                <feature name="videoMaintenance2" struct="VkPhysicalDeviceVideoMaintenance2FeaturesKHR"/>
            </require>
            <require depends="VK_KHR_video_decode_queue">
                <enum bitpos="5" extends="VkVideoSessionCreateFlagBitsKHR"  name="VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR"/>
            </require>
            <require depends="VK_KHR_video_decode_h264">
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR"/>
                <type name="VkVideoDecodeH264InlineSessionParametersInfoKHR"/>
            </require>
            <require depends="VK_KHR_video_decode_h265">
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR"/>
                <type name="VkVideoDecodeH265InlineSessionParametersInfoKHR"/>
            </require>
            <require depends="VK_KHR_video_decode_av1">
                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR"/>
                <type name="VkVideoDecodeAV1InlineSessionParametersInfoKHR"/>
            </require>
        </extension>
        <extension name="VK_OHOS_surface" number="588" type="instance" depends="VK_KHR_surface" platform="ohos" author="HUAWEI" contact="Weilan Chen @wchen-h" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                 name="VK_OHOS_SURFACE_SPEC_VERSION"/>
                <enum value="&quot;VK_OHOS_surface&quot;"                       name="VK_OHOS_SURFACE_EXTENSION_NAME"/>
                <enum value="1000685000" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_SURFACE_CREATE_INFO_OHOS"/>
                <type name="VkSurfaceCreateFlagsOHOS"/>
                <type name="VkSurfaceCreateInfoOHOS"/>
                <type name="OHNativeWindow"/>
                <command name="vkCreateSurfaceOHOS"/>
            </require>
        </extension>
        <extension name="VK_HUAWEI_extension_686" number="686" author="HUAWEI" contact="Weilan Chen @wchen-h" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_HUAWEI_EXTENSION_686_SPEC_VERSION"/>
                <enum value="&quot;VK_HUAWEI_extension_686&quot;"           name="VK_HUAWEI_EXTENSION_686_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_OHOS_native_buffer" number="589" type="device" platform="ohos" author="HUAWEI" contact="Weilan Chen @wchen-h" supported="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                     name="VK_OHOS_NATIVE_BUFFER_SPEC_VERSION"/>
                <enum value="&quot;VK_OHOS_native_buffer&quot;"                     name="VK_OHOS_NATIVE_BUFFER_EXTENSION_NAME"/>
                <enum offset="1" extends="VkStructureType" extnumber="454"          name="VK_STRUCTURE_TYPE_NATIVE_BUFFER_OHOS"/>
                <enum offset="2" extends="VkStructureType" extnumber="454"          name="VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_OHOS"/>
                <enum offset="3" extends="VkStructureType" extnumber="454"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_OHOS"/>
                <type name="VkSwapchainImageUsageFlagBitsOHOS"/>
                <type name="VkNativeBufferOHOS"/>
                <type name="VkSwapchainImageCreateInfoOHOS"/>
                <type name="VkPhysicalDevicePresentationPropertiesOHOS"/>
                <type name="OHBufferHandle"/>
                <type name="VkSwapchainImageUsageFlagsOHOS"/>
                <command name="vkGetSwapchainGrallocUsageOHOS"/>
                <command name="vkAcquireImageOHOS"/>
                <command name="vkQueueSignalReleaseImageOHOS"/>
            </require>
        </extension>
        <extension name="VK_HUAWEI_extension_590" number="590" author="HUAWEI" contact="Weilan Chen @wchen-h" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_HUAWEI_EXTENSION_590_SPEC_VERSION"/>
                <enum value="&quot;VK_HUAWEI_extension_590&quot;"           name="VK_HUAWEI_EXTENSION_590_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_HUAWEI_hdr_vivid" number="591" author="HUAWEI" contact="Zehui Lin @bactlink" type="device" depends="(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_KHR_swapchain+VK_EXT_hdr_metadata" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_HUAWEI_HDR_VIVID_SPEC_VERSION"/>
                <enum value="&quot;VK_HUAWEI_hdr_vivid&quot;"               name="VK_HUAWEI_HDR_VIVID_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI"/>
                <type name="VkPhysicalDeviceHdrVividFeaturesHUAWEI"/>
                <type name="VkHdrVividDynamicMetadataHUAWEI"/>
                <feature name="hdrVivid" struct="VkPhysicalDeviceHdrVividFeaturesHUAWEI"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_592" number="592" author="NV" contact="Jeff Juliano @jjuliano" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_592_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_592&quot;"               name="VK_NV_EXTENSION_592_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_593" number="593" author="NV" contact="Jeff Juliano @jjuliano" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_593_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_593&quot;"               name="VK_NV_EXTENSION_593_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_cooperative_matrix2" number="594" type="device" author="NV" depends="VK_KHR_cooperative_matrix" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_NV_COOPERATIVE_MATRIX_2_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_cooperative_matrix2&quot;"         name="VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV"/>
                <enum offset="1" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV"/>
                <enum offset="2" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV"/>
                <type name="VkCooperativeMatrixFlexibleDimensionsPropertiesNV"/>
                <type name="VkPhysicalDeviceCooperativeMatrix2FeaturesNV"/>
                <type name="VkPhysicalDeviceCooperativeMatrix2PropertiesNV"/>
                <command name="vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV"/>
                <feature name="cooperativeMatrixWorkgroupScope,cooperativeMatrixFlexibleDimensions,cooperativeMatrixReductions,cooperativeMatrixConversions,cooperativeMatrixPerElementOperations,cooperativeMatrixTensorAddressing,cooperativeMatrixBlockLoads" struct="VkPhysicalDeviceCooperativeMatrix2FeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_595" number="595" author="NV" contact="Jeff Bolz @jeffbolznv" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_595_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_595&quot;"               name="VK_NV_EXTENSION_595_EXTENSION_NAME"/>
                <enum bitpos="15" extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_RESERVED_15_BIT_NV"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_596" number="596" author="KHR" contact="Simon Zeni @simonz" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_596_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_596&quot;"              name="VK_KHR_EXTENSION_596_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_ARM_pipeline_opacity_micromap" number="597" type="device" depends="VK_EXT_opacity_micromap" author="ARM" contact="Mathieu Robart @mathieurobart-arm" supported="vulkan">
            <require>
                <enum value="1"                                              name="VK_ARM_PIPELINE_OPACITY_MICROMAP_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_pipeline_opacity_micromap&quot;"   name="VK_ARM_PIPELINE_OPACITY_MICROMAP_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM"/>
                <type name="VkPhysicalDevicePipelineOpacityMicromapFeaturesARM"/>
                <feature name="pipelineOpacityMicromap" struct="VkPhysicalDevicePipelineOpacityMicromapFeaturesARM"/>
                <enum bitpos="37" extends="VkPipelineCreateFlagBits2"        name="VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_598" number="598" type="device" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_598_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_598&quot;"              name="VK_KHR_EXTENSION_598_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_599" number="599" type="device" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_599_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_599&quot;"              name="VK_KHR_EXTENSION_599_EXTENSION_NAME"/>
                <enum bitpos="3" extends="VkVideoEncodeFeedbackFlagBitsKHR" name="VK_VIDEO_ENCODE_FEEDBACK_RESERVED_3_BIT_KHR"/>
                <enum bitpos="4" extends="VkVideoEncodeFeedbackFlagBitsKHR" name="VK_VIDEO_ENCODE_FEEDBACK_RESERVED_4_BIT_KHR"/>
                <enum bitpos="5" extends="VkVideoEncodeFeedbackFlagBitsKHR" name="VK_VIDEO_ENCODE_FEEDBACK_RESERVED_5_BIT_KHR"/>
                <enum bitpos="6" extends="VkVideoEncodeFeedbackFlagBitsKHR" name="VK_VIDEO_ENCODE_FEEDBACK_RESERVED_6_BIT_KHR"/>
                <enum bitpos="7" extends="VkVideoEncodeFeedbackFlagBitsKHR" name="VK_VIDEO_ENCODE_FEEDBACK_RESERVED_7_BIT_KHR"/>
                <enum bitpos="8" extends="VkVideoEncodeFeedbackFlagBitsKHR" name="VK_VIDEO_ENCODE_FEEDBACK_RESERVED_8_BIT_KHR"/>
                <enum bitpos="9" extends="VkVideoEncodeFeedbackFlagBitsKHR" name="VK_VIDEO_ENCODE_FEEDBACK_RESERVED_9_BIT_KHR"/>
            </require>
        </extension>
        <extension name="VK_IMG_extension_600" number="600" author="IMG" contact="James Fitzpatrick @jfitzpatrick-img" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_IMG_EXTENSION_600_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_extension_600&quot;"              name="VK_IMG_EXTENSION_600_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_IMG_extension_601" number="601" author="IMG" contact="James Fitzpatrick @jfitzpatrick-img" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_IMG_EXTENSION_601_SPEC_VERSION"/>
                <enum value="&quot;VK_IMG_extension_601&quot;"              name="VK_IMG_EXTENSION_601_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_602" number="602" author="KHR" contact="Shahbaz Youssefi @syoussefi" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_EXT_EXTENSION_602_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_602&quot;"          name="VK_EXT_EXTENSION_602_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_external_memory_metal" number="603" type="device" depends="VK_KHR_external_memory,VK_VERSION_1_1" author="EXT" contact="Aitor Camacho Larrondo @aitor-lunarg" platform="metal" supported="vulkan" ratified="vulkan" nofeatures="true">
            <require>
                <enum value="1"                                                name="VK_EXT_EXTERNAL_MEMORY_METAL_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_external_memory_metal&quot;"         name="VK_EXT_EXTERNAL_MEMORY_METAL_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT"/>
                <enum offset="1" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT"/>
                <enum offset="2" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT"/>
                <enum bitpos="16" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT"/>
                <enum bitpos="17" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT"/>
                <enum bitpos="18" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT"/>
                <type name="VkImportMemoryMetalHandleInfoEXT"/>
                <type name="VkMemoryMetalHandlePropertiesEXT"/>
                <type name="VkMemoryGetMetalHandleInfoEXT"/>
                <command name="vkGetMemoryMetalHandleEXT"/>
                <command name="vkGetMemoryMetalHandlePropertiesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_604" number="604" author="EXT" contact="Colin Marc @colinmarc" supported="disabled">
            <require>
                <enum value="0"                                              name="VK_EXT_EXTENSION_604_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_604&quot;"               name="VK_EXT_EXTENSION_604_EXTENSION_NAME"/>
                <enum bitpos="0" extends="VkWaylandSurfaceCreateFlagBitsKHR" name="VK_WAYLAND_SURFACE_CREATE_DISABLE_COLOR_MANAGEMENT"/>
            </require>
        </extension>
        <extension name="VK_KHR_depth_clamp_zero_one" number="605" author="KHR" type="device" contact="Graeme Leese @gnl21" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_depth_clamp_zero_one&quot;"       name="VK_KHR_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" extnumber="422"  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR"/>
                <type name="VkPhysicalDeviceDepthClampZeroOneFeaturesKHR" />
                <feature name="depthClampZeroOne" struct="VkPhysicalDeviceDepthClampZeroOneFeaturesKHR"/>
            </require>
        </extension>
      <extension name="VK_ARM_performance_counters_by_region" number="606" author="ARM" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan" specialuse="devtools" type="device">
        <require>
          <enum value="1"                                                         name="VK_ARM_PERFORMANCE_COUNTERS_BY_REGION_SPEC_VERSION"/>
          <enum value="&quot;VK_ARM_performance_counters_by_region&quot;"         name="VK_ARM_PERFORMANCE_COUNTERS_BY_REGION_EXTENSION_NAME"/>
          <enum offset="0" extends="VkStructureType"                              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_FEATURES_ARM"/>
          <enum offset="1" extends="VkStructureType"                              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_COUNTERS_BY_REGION_PROPERTIES_ARM"/>
          <enum offset="2" extends="VkStructureType"                              name="VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_ARM"/>
          <enum offset="3" extends="VkStructureType"                              name="VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_ARM"/>
          <enum offset="4" extends="VkStructureType"                              name="VK_STRUCTURE_TYPE_RENDER_PASS_PERFORMANCE_COUNTERS_BY_REGION_BEGIN_INFO_ARM"/>
          <type name="VkPhysicalDevicePerformanceCountersByRegionFeaturesARM"/>
          <type name="VkPhysicalDevicePerformanceCountersByRegionPropertiesARM"/>
          <type name="VkPerformanceCounterARM"/>
          <type name="VkPerformanceCounterDescriptionARM"/>
          <type name="VkRenderPassPerformanceCountersByRegionBeginInfoARM"/>
          <type name="VkPerformanceCounterDescriptionFlagsARM" comment="Will add VkPerformanceCounterDescriptionFlagBitsARM when bits are defined in the future"/>
          <command name="vkEnumeratePhysicalDeviceQueueFamilyPerformanceCountersByRegionARM"/>
          <feature name="performanceCountersByRegion" struct="VkPhysicalDevicePerformanceCountersByRegionFeaturesARM"/>
        </require>
      </extension>
        <extension name="VK_KHR_extension_607" number="607" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_607_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_607&quot;"              name="VK_KHR_EXTENSION_607_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_608" number="608" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_608_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_608&quot;"              name="VK_KHR_EXTENSION_608_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_vertex_attribute_robustness" number="609" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="vulkan" promotedto="VK_KHR_maintenance9">
            <require>
                <enum value="1"                                              name="VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_vertex_attribute_robustness&quot;" name="VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT"/>
                <feature name="vertexAttributeRobustness" struct="VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_ARM_format_pack" number="610" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_ARM_FORMAT_PACK_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_format_pack&quot;"               name="VK_ARM_FORMAT_PACK_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM"/>
                <type name="VkPhysicalDeviceFormatPackFeaturesARM"/>
                <feature name="formatPack" struct="VkPhysicalDeviceFormatPackFeaturesARM"/>
                <enum offset="0" extends="VkFormat"                         name="VK_FORMAT_R10X6_UINT_PACK16_ARM"/>
                <enum offset="1" extends="VkFormat"                         name="VK_FORMAT_R10X6G10X6_UINT_2PACK16_ARM"/>
                <enum offset="2" extends="VkFormat"                         name="VK_FORMAT_R10X6G10X6B10X6A10X6_UINT_4PACK16_ARM"/>
                <enum offset="3" extends="VkFormat"                         name="VK_FORMAT_R12X4_UINT_PACK16_ARM"/>
                <enum offset="4" extends="VkFormat"                         name="VK_FORMAT_R12X4G12X4_UINT_2PACK16_ARM"/>
                <enum offset="5" extends="VkFormat"                         name="VK_FORMAT_R12X4G12X4B12X4A12X4_UINT_4PACK16_ARM"/>
                <enum offset="6" extends="VkFormat"                         name="VK_FORMAT_R14X2_UINT_PACK16_ARM"/>
                <enum offset="7" extends="VkFormat"                         name="VK_FORMAT_R14X2G14X2_UINT_2PACK16_ARM"/>
                <enum offset="8" extends="VkFormat"                         name="VK_FORMAT_R14X2G14X2B14X2A14X2_UINT_4PACK16_ARM"/>
                <enum offset="9" extends="VkFormat"                         name="VK_FORMAT_R14X2_UNORM_PACK16_ARM"/>
                <enum offset="10" extends="VkFormat"                        name="VK_FORMAT_R14X2G14X2_UNORM_2PACK16_ARM"/>
                <enum offset="11" extends="VkFormat"                        name="VK_FORMAT_R14X2G14X2B14X2A14X2_UNORM_4PACK16_ARM"/>
                <enum offset="12" extends="VkFormat"                        name="VK_FORMAT_G14X2_B14X2R14X2_2PLANE_420_UNORM_3PACK16_ARM"/>
                <enum offset="13" extends="VkFormat"                        name="VK_FORMAT_G14X2_B14X2R14X2_2PLANE_422_UNORM_3PACK16_ARM"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_611" number="611" author="NV" contact="David Kvasnica @DaKvasNV" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_611_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_611&quot;"               name="VK_NV_EXTENSION_611_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_VALVE_fragment_density_map_layered" number="612" type="device" depends="(VK_KHR_maintenance5,VK_VERSION_1_4)+VK_EXT_fragment_density_map" author="VALVE" contact="Connor Abbott @cwabbott0" supported="vulkan">
            <require>
                <enum value="1"                                               name="VK_VALVE_FRAGMENT_DENSITY_MAP_LAYERED_SPEC_VERSION"/>
                <enum value="&quot;VK_VALVE_fragment_density_map_layered&quot;" name="VK_VALVE_FRAGMENT_DENSITY_MAP_LAYERED_EXTENSION_NAME"/>
                <enum offset="0"  extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE"/>
                <enum offset="1"  extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE"/>
                <enum offset="2"  extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE"/>
                <enum bitpos="2" extends="VkRenderPassCreateFlagBits"         name="VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE"/>
                <enum bitpos="5" extends="VkRenderingFlagBits"                name="VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE"/>
                <enum bitpos="40" extends="VkPipelineCreateFlagBits2"         name="VK_PIPELINE_CREATE_2_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE"/>
                <type name="VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE"/>
                <type name="VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE"/>
                <type name="VkPipelineFragmentDensityMapLayeredCreateInfoVALVE"/>
                <feature name="fragmentDensityMapLayered" struct="VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE"/>
            </require>
        </extension>
        <extension name="VK_KHR_robustness2" number="613" author="KHR" type="device" contact="Piers Daniell @pdaniell-nv" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                                 name="VK_KHR_ROBUSTNESS_2_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_robustness2&quot;"                    name="VK_KHR_ROBUSTNESS_2_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" extnumber="287" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR"/>
                <enum offset="1" extends="VkStructureType" extnumber="287" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR"/>
                <type name="VkPhysicalDeviceRobustness2FeaturesKHR"/>
                <type name="VkPhysicalDeviceRobustness2PropertiesKHR"/>
                <feature name="robustBufferAccess2,robustImageAccess2,nullDescriptor" struct="VkPhysicalDeviceRobustness2FeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_NV_present_metering" number="614" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="NV" contact="Charles Hansen @chansen" supported="vulkan" provisional="true" platform="provisional">
            <require>
                <enum value="1"                                             name="VK_NV_PRESENT_METERING_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_present_metering&quot;"            name="VK_NV_PRESENT_METERING_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV" protect="VK_ENABLE_BETA_EXTENSIONS"/>
                <type name="VkSetPresentConfigNV"/>
                <type name="VkPhysicalDevicePresentMeteringFeaturesNV"/>
                <feature name="presentMetering" struct="VkPhysicalDevicePresentMeteringFeaturesNV"/>
            </require>
        </extension>
        <extension name="VK_QCOM_extension_615" number="615" author="QCOM" contact="Matthew Netsch @mnetsch" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_QCOM_EXTENSION_615_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_extension_615&quot;"             name="VK_QCOM_EXTENSION_615_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_616" number="616" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_616_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_616&quot;"              name="VK_EXT_EXTENSION_616_EXTENSION_NAME"/>
                <enum bitpos="1" extends="VkInstanceCreateFlagBits"         name="VK_INSTANCE_CREATE_RESERVED_616_BIT_EXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_617" number="617" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_617_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_617&quot;"              name="VK_EXT_EXTENSION_617_EXTENSION_NAME"/>
                <enum bitpos="8" extends="VkSwapchainCreateFlagBitsKHR" name="VK_SWAPCHAIN_CREATE_RESERVED_8_BIT_EXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_618" number="618" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_618_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_618&quot;"              name="VK_EXT_EXTENSION_618_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_fragment_density_map_offset" number="620" type="device" depends="(VK_KHR_get_physical_device_properties2,VK_VERSION_1_1)+VK_EXT_fragment_density_map+(VK_KHR_create_renderpass2,VK_VERSION_1_2)+(VK_VERSION_1_3,VK_KHR_dynamic_rendering)" author="EXT" contact="Connor Abbott @cwabbott0" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                               name="VK_EXT_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_fragment_density_map_offset&quot;"  name="VK_EXT_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME"/>
                <type name="VkRenderingEndInfoEXT"/>
                <enum offset="0"  extends="VkStructureType" extnumber="426"   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT"/>
                <enum offset="1"  extends="VkStructureType" extnumber="426"   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT"/>
                <enum offset="2"  extends="VkStructureType" extnumber="426"   name="VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT"/>
                <enum extends="VkStructureType"                               name="VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT"                                       alias="VK_STRUCTURE_TYPE_RENDERING_END_INFO_KHR"/>
                <enum bitpos="15" extends="VkImageCreateFlagBits"             name="VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT"/>
                <type name="VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT"/>
                <type name="VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT"/>
                <type name="VkRenderPassFragmentDensityMapOffsetEndInfoEXT"/>
                <command name="vkCmdEndRendering2EXT"/>
                <feature name="fragmentDensityMapOffset" struct="VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_zero_initialize_device_memory" number="621" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Mike Blumenkrantz @zmike" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                                          name="VK_EXT_ZERO_INITIALIZE_DEVICE_MEMORY_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_zero_initialize_device_memory&quot;"           name="VK_EXT_ZERO_INITIALIZE_DEVICE_MEMORY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                               name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT"/>
                <enum bitpos="3" extends="VkMemoryAllocateFlagBits"                      name="VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT"/>
                <enum offset="0" extends="VkImageLayout"                                 name="VK_IMAGE_LAYOUT_ZERO_INITIALIZED_EXT"/>
                <type name="VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT"/>
                <feature name="zeroInitializeDeviceMemory" struct="VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_present_mode_fifo_latest_ready" number="622" author="KHR" type="device" depends="VK_KHR_swapchain" contact="Lionel Duc @nvlduc" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                                 name="VK_KHR_PRESENT_MODE_FIFO_LATEST_READY_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_present_mode_fifo_latest_ready&quot;" name="VK_KHR_PRESENT_MODE_FIFO_LATEST_READY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" extnumber="362"      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR"/>
                <enum offset="0" extends="VkPresentModeKHR" extnumber="362"     name="VK_PRESENT_MODE_FIFO_LATEST_READY_KHR"/>
                <type name="VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR"/>
                <feature name="presentModeFifoLatestReady" struct="VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_623" number="623" author="EXT" contact="Mark Young @marky_lunarg" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_623_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_623&quot;"              name="VK_EXT_EXTENSION_623_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_624" number="624" author="KHR" contact="Matthew Netsch @mnetsch" supported="disabled">
            <require>
                <enum value="0"                                                     name="VK_KHR_EXTENSION_624_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_624&quot;"                      name="VK_KHR_EXTENSION_624_EXTENSION_NAME"/>
                <enum bitpos="10" extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_RESERVED_10_BIT_KHR"/>
            </require>
            <require depends="VK_KHR_maintenance5,VK_VERSION_1_4">
                <enum bitpos="41" extends="VkPipelineCreateFlagBits2"       name="VK_PIPELINE_CREATE_2_RESERVED_41_BIT_KHR"/>
            </require>
            <require depends="VK_EXT_shader_object">
                <enum bitpos="12" extends="VkShaderCreateFlagBitsEXT"       name="VK_SHADER_CREATE_RESERVED_12_BIT_EXT"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_625" number="625" author="KHR" contact="James Jones @cubanismo" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_625_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_625&quot;"              name="VK_KHR_EXTENSION_625_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_626" number="626" author="EXT" contact="Robert Mader @rmader" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_626_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_626&quot;"              name="VK_EXT_EXTENSION_626_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_627" number="627" author="NV" contact="Jeff Juliano @jjuliano" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_627_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_627&quot;"              name="VK_NV_EXTENSION_627_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_64bit_indexing" number="628" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Jeff Bolz @jeffbolznv" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_SHADER_64BIT_INDEXING_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_64bit_indexing&quot;"      name="VK_EXT_SHADER_64BIT_INDEXING_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_64_BIT_INDEXING_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceShader64BitIndexingFeaturesEXT"/>
                <enum bitpos="43" extends="VkPipelineCreateFlagBits2"       name="VK_PIPELINE_CREATE_2_64_BIT_INDEXING_BIT_EXT"/>
                <enum bitpos="15" extends="VkShaderCreateFlagBitsEXT"       name="VK_SHADER_CREATE_64_BIT_INDEXING_BIT_EXT"/>
                <feature name="shader64BitIndexing" struct="VkPhysicalDeviceShader64BitIndexingFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_custom_resolve" number="629" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Mike Blumenkrantz @zmike" supported="vulkan">
            <require>
                <enum value="1"                                             name="VK_EXT_CUSTOM_RESOLVE_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_custom_resolve&quot;"             name="VK_EXT_CUSTOM_RESOLVE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_RESOLVE_FEATURES_EXT"/>
                <enum bitpos="2" extends="VkSubpassDescriptionFlagBits"     name="VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_EXT"/>
                <enum bitpos="3" extends="VkSubpassDescriptionFlagBits"     name="VK_SUBPASS_DESCRIPTION_CUSTOM_RESOLVE_BIT_EXT"/>
                <type name="VkPhysicalDeviceCustomResolveFeaturesEXT"/>
                <feature name="customResolve" struct="VkPhysicalDeviceCustomResolveFeaturesEXT"/>
            </require>
            <require depends="VK_KHR_dynamic_rendering,VK_VERSION_1_3">
                <enum bitpos="6" extends="VkRenderingFlagBits"              name="VK_RENDERING_FRAGMENT_REGION_BIT_EXT"/>
                <enum bitpos="7" extends="VkRenderingFlagBits"              name="VK_RENDERING_CUSTOM_RESOLVE_BIT_EXT"/>
                <enum bitpos="5" extends="VkResolveModeFlagBits"            name="VK_RESOLVE_MODE_CUSTOM_BIT_EXT"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_BEGIN_CUSTOM_RESOLVE_INFO_EXT"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_CUSTOM_RESOLVE_CREATE_INFO_EXT"/>
                <type name="VkBeginCustomResolveInfoEXT"/>
                <type name="VkCustomResolveCreateInfoEXT"/>
                <command name="vkCmdBeginCustomResolveEXT"/>
            </require>
        </extension>
        <extension name="VK_QCOM_data_graph_model" number="630" author="QCOM" type="device" depends="VK_ARM_data_graph" contact="Matthew Netsch @mnetsch" supported="vulkan">
            <require>
                <enum value="1"                                                             name="VK_QCOM_DATA_GRAPH_MODEL_SPEC_VERSION"/>
                <enum value="&quot;VK_QCOM_data_graph_model&quot;"                          name="VK_QCOM_DATA_GRAPH_MODEL_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_MODEL_FEATURES_QCOM"/>
                <enum offset="1" extends="VkStructureType"                                  name="VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_BUILTIN_MODEL_CREATE_INFO_QCOM"/>
                <enum offset="0" extends="VkPhysicalDeviceDataGraphProcessingEngineTypeARM" name="VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_NEURAL_QCOM"/>
                <enum offset="1" extends="VkPhysicalDeviceDataGraphProcessingEngineTypeARM" name="VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_COMPUTE_QCOM"/>
                <enum offset="0" extends="VkPhysicalDeviceDataGraphOperationTypeARM"        name="VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_NEURAL_MODEL_QCOM"/>
                <enum offset="1" extends="VkPhysicalDeviceDataGraphOperationTypeARM"        name="VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_BUILTIN_MODEL_QCOM"/>
                <enum offset="0" extends="VkPipelineCacheHeaderVersion"                     name="VK_PIPELINE_CACHE_HEADER_VERSION_DATA_GRAPH_QCOM"/>
                <enum name="VK_DATA_GRAPH_MODEL_TOOLCHAIN_VERSION_LENGTH_QCOM"/>
                <type name="VkDataGraphModelCacheTypeQCOM"/>
                <type name="VkPipelineCacheHeaderVersionDataGraphQCOM"/>
                <type name="VkDataGraphPipelineBuiltinModelCreateInfoQCOM"/>
                <type name="VkPhysicalDeviceDataGraphModelFeaturesQCOM"/>
                <feature name="dataGraphModel" struct="VkPhysicalDeviceDataGraphModelFeaturesQCOM"/>
            </require>
        </extension>
        <extension name="VK_KHR_maintenance10" number="631" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="KHR" contact="Mike Blumenkrantz @zmike" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1"                                             name="VK_KHR_MAINTENANCE_10_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_maintenance10&quot;"              name="VK_KHR_MAINTENANCE_10_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_FEATURES_KHR"/>
                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_10_PROPERTIES_KHR"/>
                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_FLAGS_INFO_KHR"/>
                <enum offset="3" extends="VkStructureType" extnumber="620"  name="VK_STRUCTURE_TYPE_RENDERING_END_INFO_KHR"/>
                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_RESOLVE_IMAGE_MODE_INFO_KHR"/>
                <type name="VkPhysicalDeviceMaintenance10FeaturesKHR"/>
                <type name="VkPhysicalDeviceMaintenance10PropertiesKHR"/>
                <type name="VkRenderingEndInfoKHR"/>
                <command name="vkCmdEndRendering2KHR"/>
                <type name="VkRenderingAttachmentFlagsInfoKHR"/>
                <type name="VkRenderingAttachmentFlagsKHR"/>
                <type name="VkRenderingAttachmentFlagBitsKHR"/>
                <type name="VkResolveImageModeInfoKHR"/>
                <type name="VkResolveImageFlagsKHR"/>
                <type name="VkResolveImageFlagBitsKHR"/>
                <feature name="maintenance10" struct="VkPhysicalDeviceMaintenance10FeaturesKHR"/>
                <enum bitpos="1" extends="VkAttachmentDescriptionFlagBits"  name="VK_ATTACHMENT_DESCRIPTION_RESOLVE_SKIP_TRANSFER_FUNCTION_BIT_KHR"/>
                <enum bitpos="2" extends="VkAttachmentDescriptionFlagBits"  name="VK_ATTACHMENT_DESCRIPTION_RESOLVE_ENABLE_TRANSFER_FUNCTION_BIT_KHR"/>
            </require>
            <require depends="(VK_VERSION_1_4,VK_KHR_dynamic_rendering_local_read)+(VK_VERSION_1_3,VK_KHR_dynamic_rendering)">
                <enum bitpos="8" extends="VkRenderingFlagBits"              name="VK_RENDERING_LOCAL_READ_CONCURRENT_ACCESS_CONTROL_BIT_KHR"/>
                <enum bitpos="0" extends="VkRenderingAttachmentFlagBitsKHR" name="VK_RENDERING_ATTACHMENT_INPUT_ATTACHMENT_FEEDBACK_BIT_KHR"/>
            </require>
            <require depends="VK_KHR_format_feature_flags2,VK_VERSION_1_3">
                <enum bitpos="52" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_DEPTH_COPY_ON_COMPUTE_QUEUE_BIT_KHR"/>
                <enum bitpos="53" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_DEPTH_COPY_ON_TRANSFER_QUEUE_BIT_KHR"/>
                <enum bitpos="54" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_STENCIL_COPY_ON_COMPUTE_QUEUE_BIT_KHR"/>
                <enum bitpos="55" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_STENCIL_COPY_ON_TRANSFER_QUEUE_BIT_KHR"/>
            </require>
            <require depends="VK_VERSION_1_3,VK_KHR_dynamic_rendering">
                <enum bitpos="1" extends="VkRenderingAttachmentFlagBitsKHR" name="VK_RENDERING_ATTACHMENT_RESOLVE_SKIP_TRANSFER_FUNCTION_BIT_KHR"/>
                <enum bitpos="2" extends="VkRenderingAttachmentFlagBitsKHR" name="VK_RENDERING_ATTACHMENT_RESOLVE_ENABLE_TRANSFER_FUNCTION_BIT_KHR"/>
            </require>
            <require depends="VK_VERSION_1_3,VK_KHR_copy_commands2">
                <enum bitpos="0" extends="VkResolveImageFlagBitsKHR"  name="VK_RESOLVE_IMAGE_SKIP_TRANSFER_FUNCTION_BIT_KHR"/>
                <enum bitpos="1" extends="VkResolveImageFlagBitsKHR"  name="VK_RESOLVE_IMAGE_ENABLE_TRANSFER_FUNCTION_BIT_KHR"/>
            </require>
        </extension>
        <extension name="VK_ARM_extension_632" number="632" author="ARM" contact="Kevin Petit @kpet" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_ARM_EXTENSION_632_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_extension_632&quot;"              name="VK_ARM_EXTENSION_632_EXTENSION_NAME"/>
                <enum bitpos="56" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_RESERVED_56_BIT_ARM"/>
                <enum bitpos="57" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_RESERVED_57_BIT_ARM"/>
                <enum bitpos="58" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_RESERVED_58_BIT_ARM"/>
            </require>
        </extension>
        <extension name="VK_MTK_extension_633" number="633" author="MTK" contact="Samuel Huang @shengwenhuang" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_MTK_EXTENSION_633_SPEC_VERSION"/>
                <enum value="&quot;VK_MTK_extension_633&quot;"              name="VK_MTK_EXTENSION_633_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_634" number="634" author="NV" contact="Nate Morrical @nmorrical" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_634_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_634&quot;"               name="VK_NV_EXTENSION_634_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_MTK_extension_635" number="635" author="MTK" contact="Samuel Huang @shengwenhuang" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_MTK_EXTENSION_635_SPEC_VERSION"/>
                <enum value="&quot;VK_MTK_extension_635&quot;"              name="VK_MTK_EXTENSION_635_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_636" number="636" author="EXT" contact="Jeff Bolz @jeffbolznv" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_636_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_636&quot;"              name="VK_EXT_EXTENSION_636_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_637" number="637" author="EXT" contact="Peter Kohaut @peterkohaut-nv" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_637_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_637&quot;"              name="VK_EXT_EXTENSION_637_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_SEC_pipeline_cache_incremental_mode" number="638" author="SEC" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" contact="Chris Hambacher @chambacher" type="device" supported="vulkan">
            <require>
                <enum value="1"                                                     name="VK_SEC_PIPELINE_CACHE_INCREMENTAL_MODE_SPEC_VERSION"/>
                <enum value="&quot;VK_SEC_pipeline_cache_incremental_mode&quot;"    name="VK_SEC_PIPELINE_CACHE_INCREMENTAL_MODE_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType"                          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC"/>
                <type name="VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC"/>
                <feature name="pipelineCacheIncrementalMode" struct="VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_639" number="639" author="EXT" contact="Ralph Potter gitlab:@r_potter" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_639_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_639&quot;"              name="VK_EXT_EXTENSION_639_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_640" number="640" author="NV" contact="Nate Morrical @nmorrical" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_640_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_640&quot;"               name="VK_NV_EXTENSION_640_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_641" number="641" author="EXT" contact="Vikram Kushwaha @vkushwaha-nv" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_641_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_641&quot;"              name="VK_EXT_EXTENSION_641_EXTENSION_NAME"/>
                <enum bitpos="45" extends="VkPipelineCreateFlagBits2"       name="VK_PIPELINE_CREATE_2_RESERVED_45_BIT_EXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_642" number="642" author="EXT" contact="Vikram Kushwaha @vkushwaha-nv" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_642_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_642&quot;"              name="VK_EXT_EXTENSION_642_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_shader_uniform_buffer_unsized_array" number="643" type="device" depends="VK_KHR_get_physical_device_properties2,VK_VERSION_1_1" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="vulkan" ratified="vulkan">
            <require>
                <enum value="1" name="VK_EXT_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_shader_uniform_buffer_unsized_array&quot;" name="VK_EXT_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_EXTENSION_NAME"/>
                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNIFORM_BUFFER_UNSIZED_ARRAY_FEATURES_EXT"/>
                <type name="VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT"/>
                <feature name="shaderUniformBufferUnsizedArray" struct="VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_644" number="644" author="EXT" contact="Tony Zlatinski @tzlatinski" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_644_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_644&quot;"              name="VK_EXT_EXTENSION_644_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_645" number="645" author="EXT" contact="Tony Zlatinski @tzlatinski" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_645_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_645&quot;"              name="VK_EXT_EXTENSION_645_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_NV_extension_646" number="646" author="NV" contact="Chris Lentini @clentini" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_NV_EXTENSION_646_SPEC_VERSION"/>
                <enum value="&quot;VK_NV_extension_646&quot;"              name="VK_NV_EXTENSION_646_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_647" number="647" type="device" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_647_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_647&quot;"              name="VK_KHR_EXTENSION_647_EXTENSION_NAME"/>
                <enum bitpos="13" extends="VkQueueFlagBits"                 name="VK_QUEUE_RESERVED_13_BIT_EXT"/>
                <enum bitpos="47" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_RESERVED_47_BIT_KHR"/>
                <enum bitpos="60" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_RESERVED_60_BIT_KHR"/>
                <enum bitpos="61" extends="VkAccessFlagBits2"               name="VK_ACCESS_2_RESERVED_61_BIT_KHR"/>
                <enum bitpos="35" extends="VkBufferUsageFlagBits2"          name="VK_BUFFER_USAGE_2_RESERVED_35_BIT_KHR"/>
                <enum bitpos="36" extends="VkBufferUsageFlagBits2"          name="VK_BUFFER_USAGE_2_RESERVED_36_BIT_KHR"/>
                <enum bitpos="29" extends="VkImageUsageFlagBits"            name="VK_IMAGE_USAGE_RESERVED_29_BIT_KHR"/>
                <enum bitpos="30" extends="VkImageUsageFlagBits"            name="VK_IMAGE_USAGE_RESERVED_30_BIT_KHR"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_648" number="648" type="device" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_648_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_648&quot;"              name="VK_KHR_EXTENSION_648_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_649" number="649" type="device" author="AMD" contact="Stu Smith @stu-s" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_649_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_649&quot;"              name="VK_AMD_EXTENSION_649_EXTENSION_NAME"/>
                <enum bitpos="47" extends="VkPipelineCreateFlagBits2"       name="VK_PIPELINE_CREATE_2_RESERVED_47_BIT_AMD"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_650" number="650" type="device" author="AMD" contact="Stu Smith @stu-s" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_650_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_650&quot;"              name="VK_AMD_EXTENSION_650_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_651" number="651" type="device" author="AMD" contact="Stu Smith @stu-s" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_651_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_651&quot;"              name="VK_AMD_EXTENSION_651_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_652" number="652" type="device" author="AMD" contact="Stu Smith @stu-s" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_652_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_652&quot;"              name="VK_AMD_EXTENSION_652_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_AMD_extension_653" number="653" type="device" author="AMD" contact="Stu Smith @stu-s" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_AMD_EXTENSION_653_SPEC_VERSION"/>
                <enum value="&quot;VK_AMD_extension_653&quot;"              name="VK_AMD_EXTENSION_653_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_VALVE_extension_654" number="654" type="device" author="VALVE" contact="Mike Blumenkrantz @zmike" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_VALVE_EXTENSION_654_SPEC_VERSION"/>
                <enum value="&quot;VK_VALVE_extension_654&quot;"            name="VK_VALVE_EXTENSION_654_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_ARM_extension_655" number="655" type="device" author="Arm" contact="Kevin petit @kpet" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_ARM_EXTENSION_655_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_extension_655&quot;"              name="VK_ARM_EXTENSION_655_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_ARM_extension_656" number="656" type="device" author="Arm" contact="Kevin petit @kpet" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_ARM_EXTENSION_656_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_extension_656&quot;"              name="VK_ARM_EXTENSION_656_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_ARM_extension_657" number="657" type="device" author="Arm" contact="Kevin petit @kpet" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_ARM_EXTENSION_657_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_extension_657&quot;"              name="VK_ARM_EXTENSION_657_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_658" number="658" type="device" author="KHR" contact="Mike Blumenkrantz @zmike" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_658_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_658&quot;"              name="VK_KHR_EXTENSION_658_EXTENSION_NAME"/>
                <enum bitpos="22"  extends="VkImageCreateFlagBits"          name="VK_IMAGE_CREATE_RESERVED_22_BIT_KHR"/>
            </require>
            <require depends="VK_EXT_shader_object">
                <enum bitpos="18" extends="VkShaderCreateFlagBitsEXT"       name="VK_SHADER_CREATE_RESERVED_18_BIT_KHR" />
            </require>
        </extension>
        <extension name="VK_ARM_extension_659" number="659" author="Arm" contact="Kevin Petit @kpet" supported="disabled">
            <require>
                <enum value="0"                                         name="VK_ARM_EXTENSION_659_SPEC_VERSION"/>
                <enum value="&quot;VK_ARM_extension_659&quot;"          name="VK_ARM_EXTENSION_659_EXTENSION_NAME"/>
                <enum bitpos="11" extends="VkQueueFlagBits"             name="VK_QUEUE_RESERVED_11_BIT_ARM"/>
                <enum bitpos="43" extends="VkPipelineStageFlagBits2"    name="VK_PIPELINE_STAGE_2_RESERVED_43_BIT_ARM"/>
                <enum bitpos="49" extends="VkAccessFlagBits2"           name="VK_ACCESS_2_RESERVED_49_BIT_ARM"/>
                <enum bitpos="50" extends="VkAccessFlagBits2"           name="VK_ACCESS_2_RESERVED_50_BIT_ARM"/>
                <enum bitpos="47" extends="VkFormatFeatureFlagBits2"    name="VK_FORMAT_FEATURE_2_RESERVED_47_BIT_ARM"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_660" number="660" author="EXT" contact="Jeff Bolz @jeffbolznv" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_660_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_660&quot;"              name="VK_EXT_EXTENSION_660_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_KHR_extension_661" number="661" type="device" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_KHR_EXTENSION_661_SPEC_VERSION"/>
                <enum value="&quot;VK_KHR_extension_661&quot;"              name="VK_KHR_EXTENSION_661_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_VALVE_extension_662" number="662" type="device" author="VALVE" contact="Mike Blumenkrantz @zmike" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_VALVE_EXTENSION_662_SPEC_VERSION"/>
                <enum value="&quot;VK_VALVE_extension_662&quot;"            name="VK_VALVE_EXTENSION_662_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_663" number="663" author="EXT" contact="Jeff Bolz @jeffbolznv" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_663_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_663&quot;"              name="VK_EXT_EXTENSION_663_EXTENSION_NAME"/>
            </require>
        </extension>
        <extension name="VK_EXT_extension_664" number="664" author="HUAWEI" contact="Pan Gao @pangao-h" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_EXT_EXTENSION_664_SPEC_VERSION"/>
                <enum value="&quot;VK_EXT_extension_664&quot;"              name="VK_EXT_EXTENSION_664_EXTENSION_NAME"/>
                <enum bitpos="3"  extends="VkCommandBufferUsageFlagBits"    name="VK_COMMAND_BUFFER_USAGE_RESERVED_3_BIT_HUAWEI"/>
                <enum bitpos="16" extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_RESERVED_16_BIT_HUAWEI"/>
                <enum bitpos="16" extends="VkImageUsageFlagBits"            name="VK_IMAGE_USAGE_RESERVED_16_BIT_HUAWEI"/>
                <enum bitpos="17" extends="VkImageUsageFlagBits"            name="VK_IMAGE_USAGE_RESERVED_27_BIT_HUAWEI"/>
                <enum bitpos="48" extends="VkPipelineCreateFlagBits2"       name="VK_PIPELINE_CREATE_2_RESERVED_48_BIT_HUAWEI"/>
                <enum bitpos="37" extends="VkBufferUsageFlagBits2"          name="VK_BUFFER_USAGE_2_RESERVED_37_BIT_HUAWEI"/>
                <enum bitpos="48" extends="VkPipelineStageFlagBits2"        name="VK_PIPELINE_STAGE_2_RESERVED_48_BIT_HUAWEI"/>
                <enum bitpos="11" extends="VkImageAspectFlagBits"           name="VK_IMAGE_ASPECT_RESERVED_11_BIT_HUAWEI"/>
                <enum bitpos="61" extends="VkFormatFeatureFlagBits2"        name="VK_FORMAT_FEATURE_2_RESERVED_61_BIT_HUAWEI"/>
            </require>
        </extension>
        <extension name="VK_SEC_extension_665" number="665" author="SEC" contact="Ralph Potter gitlab:@r_potter" supported="disabled">
            <require>
                <enum value="0"                                             name="VK_SEC_EXTENSION_665_SPEC_VERSION"/>
                <enum value="&quot;VK_SEC_extension_665&quot;"              name="VK_SEC_EXTENSION_665_EXTENSION_NAME"/>
            </require>
        </extension>
    </extensions>
    <formats>
        <format name="VK_FORMAT_R4G4_UNORM_PACK8" class="8-bit" blockSize="1" texelsPerBlock="1" packed="8">
            <component name="R" bits="4" numericFormat="UNORM"/>
            <component name="G" bits="4" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_R4G4B4A4_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
            <component name="R" bits="4" numericFormat="UNORM"/>
            <component name="G" bits="4" numericFormat="UNORM"/>
            <component name="B" bits="4" numericFormat="UNORM"/>
            <component name="A" bits="4" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_B4G4R4A4_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
            <component name="B" bits="4" numericFormat="UNORM"/>
            <component name="G" bits="4" numericFormat="UNORM"/>
            <component name="R" bits="4" numericFormat="UNORM"/>
            <component name="A" bits="4" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_R5G6B5_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
            <component name="R" bits="5" numericFormat="UNORM"/>
            <component name="G" bits="6" numericFormat="UNORM"/>
            <component name="B" bits="5" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_B5G6R5_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
            <component name="B" bits="5" numericFormat="UNORM"/>
            <component name="G" bits="6" numericFormat="UNORM"/>
            <component name="R" bits="5" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_R5G5B5A1_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
            <component name="R" bits="5" numericFormat="UNORM"/>
            <component name="G" bits="5" numericFormat="UNORM"/>
            <component name="B" bits="5" numericFormat="UNORM"/>
            <component name="A" bits="1" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_B5G5R5A1_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
            <component name="B" bits="5" numericFormat="UNORM"/>
            <component name="G" bits="5" numericFormat="UNORM"/>
            <component name="R" bits="5" numericFormat="UNORM"/>
            <component name="A" bits="1" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_A1R5G5B5_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
            <component name="A" bits="1" numericFormat="UNORM"/>
            <component name="R" bits="5" numericFormat="UNORM"/>
            <component name="G" bits="5" numericFormat="UNORM"/>
            <component name="B" bits="5" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_A1B5G5R5_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
            <component name="A" bits="1" numericFormat="UNORM"/>
            <component name="B" bits="5" numericFormat="UNORM"/>
            <component name="G" bits="5" numericFormat="UNORM"/>
            <component name="R" bits="5" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_A8_UNORM" class="8-bit alpha" blockSize="1" texelsPerBlock="1">
            <component name="A" bits="8" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_R8_UNORM" class="8-bit" blockSize="1" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="UNORM"/>
            <spirvimageformat name="R8"/>
        </format>
        <format name="VK_FORMAT_R8_SNORM" class="8-bit" blockSize="1" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="SNORM"/>
            <spirvimageformat name="R8Snorm"/>
        </format>
        <format name="VK_FORMAT_R8_USCALED" class="8-bit" blockSize="1" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="USCALED"/>
        </format>
        <format name="VK_FORMAT_R8_SSCALED" class="8-bit" blockSize="1" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="SSCALED"/>
        </format>
        <format name="VK_FORMAT_R8_UINT" class="8-bit" blockSize="1" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="UINT"/>
            <spirvimageformat name="R8ui"/>
        </format>
        <format name="VK_FORMAT_R8_SINT" class="8-bit" blockSize="1" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="SINT"/>
            <spirvimageformat name="R8i"/>
        </format>
        <format name="VK_FORMAT_R8_SRGB" class="8-bit" blockSize="1" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="SRGB"/>
        </format>
        <format name="VK_FORMAT_R8G8_UNORM" class="16-bit" blockSize="2" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="UNORM"/>
            <component name="G" bits="8" numericFormat="UNORM"/>
            <spirvimageformat name="Rg8"/>
        </format>
        <format name="VK_FORMAT_R8G8_SNORM" class="16-bit" blockSize="2" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="SNORM"/>
            <component name="G" bits="8" numericFormat="SNORM"/>
            <spirvimageformat name="Rg8Snorm"/>
        </format>
        <format name="VK_FORMAT_R8G8_USCALED" class="16-bit" blockSize="2" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="USCALED"/>
            <component name="G" bits="8" numericFormat="USCALED"/>
        </format>
        <format name="VK_FORMAT_R8G8_SSCALED" class="16-bit" blockSize="2" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="SSCALED"/>
            <component name="G" bits="8" numericFormat="SSCALED"/>
        </format>
        <format name="VK_FORMAT_R8G8_UINT" class="16-bit" blockSize="2" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="UINT"/>
            <component name="G" bits="8" numericFormat="UINT"/>
            <spirvimageformat name="Rg8ui"/>
        </format>
        <format name="VK_FORMAT_R8G8_SINT" class="16-bit" blockSize="2" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="SINT"/>
            <component name="G" bits="8" numericFormat="SINT"/>
            <spirvimageformat name="Rg8i"/>
        </format>
        <format name="VK_FORMAT_R8G8_SRGB" class="16-bit" blockSize="2" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="SRGB"/>
            <component name="G" bits="8" numericFormat="SRGB"/>
        </format>
        <format name="VK_FORMAT_R8G8B8_UNORM" class="24-bit" blockSize="3" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="UNORM"/>
            <component name="G" bits="8" numericFormat="UNORM"/>
            <component name="B" bits="8" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_R8G8B8_SNORM" class="24-bit" blockSize="3" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="SNORM"/>
            <component name="G" bits="8" numericFormat="SNORM"/>
            <component name="B" bits="8" numericFormat="SNORM"/>
        </format>
        <format name="VK_FORMAT_R8G8B8_USCALED" class="24-bit" blockSize="3" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="USCALED"/>
            <component name="G" bits="8" numericFormat="USCALED"/>
            <component name="B" bits="8" numericFormat="USCALED"/>
        </format>
        <format name="VK_FORMAT_R8G8B8_SSCALED" class="24-bit" blockSize="3" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="SSCALED"/>
            <component name="G" bits="8" numericFormat="SSCALED"/>
            <component name="B" bits="8" numericFormat="SSCALED"/>
        </format>
        <format name="VK_FORMAT_R8G8B8_UINT" class="24-bit" blockSize="3" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="UINT"/>
            <component name="G" bits="8" numericFormat="UINT"/>
            <component name="B" bits="8" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_R8G8B8_SINT" class="24-bit" blockSize="3" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="SINT"/>
            <component name="G" bits="8" numericFormat="SINT"/>
            <component name="B" bits="8" numericFormat="SINT"/>
        </format>
        <format name="VK_FORMAT_R8G8B8_SRGB" class="24-bit" blockSize="3" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="SRGB"/>
            <component name="G" bits="8" numericFormat="SRGB"/>
            <component name="B" bits="8" numericFormat="SRGB"/>
        </format>
        <format name="VK_FORMAT_B8G8R8_UNORM" class="24-bit" blockSize="3" texelsPerBlock="1">
            <component name="B" bits="8" numericFormat="UNORM"/>
            <component name="G" bits="8" numericFormat="UNORM"/>
            <component name="R" bits="8" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_B8G8R8_SNORM" class="24-bit" blockSize="3" texelsPerBlock="1">
            <component name="B" bits="8" numericFormat="SNORM"/>
            <component name="G" bits="8" numericFormat="SNORM"/>
            <component name="R" bits="8" numericFormat="SNORM"/>
        </format>
        <format name="VK_FORMAT_B8G8R8_USCALED" class="24-bit" blockSize="3" texelsPerBlock="1">
            <component name="B" bits="8" numericFormat="USCALED"/>
            <component name="G" bits="8" numericFormat="USCALED"/>
            <component name="R" bits="8" numericFormat="USCALED"/>
        </format>
        <format name="VK_FORMAT_B8G8R8_SSCALED" class="24-bit" blockSize="3" texelsPerBlock="1">
            <component name="B" bits="8" numericFormat="SSCALED"/>
            <component name="G" bits="8" numericFormat="SSCALED"/>
            <component name="R" bits="8" numericFormat="SSCALED"/>
        </format>
        <format name="VK_FORMAT_B8G8R8_UINT" class="24-bit" blockSize="3" texelsPerBlock="1">
            <component name="B" bits="8" numericFormat="UINT"/>
            <component name="G" bits="8" numericFormat="UINT"/>
            <component name="R" bits="8" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_B8G8R8_SINT" class="24-bit" blockSize="3" texelsPerBlock="1">
            <component name="B" bits="8" numericFormat="SINT"/>
            <component name="G" bits="8" numericFormat="SINT"/>
            <component name="R" bits="8" numericFormat="SINT"/>
        </format>
        <format name="VK_FORMAT_B8G8R8_SRGB" class="24-bit" blockSize="3" texelsPerBlock="1">
            <component name="B" bits="8" numericFormat="SRGB"/>
            <component name="G" bits="8" numericFormat="SRGB"/>
            <component name="R" bits="8" numericFormat="SRGB"/>
        </format>
        <format name="VK_FORMAT_R8G8B8A8_UNORM" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="UNORM"/>
            <component name="G" bits="8" numericFormat="UNORM"/>
            <component name="B" bits="8" numericFormat="UNORM"/>
            <component name="A" bits="8" numericFormat="UNORM"/>
            <spirvimageformat name="Rgba8"/>
        </format>
        <format name="VK_FORMAT_R8G8B8A8_SNORM" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="SNORM"/>
            <component name="G" bits="8" numericFormat="SNORM"/>
            <component name="B" bits="8" numericFormat="SNORM"/>
            <component name="A" bits="8" numericFormat="SNORM"/>
            <spirvimageformat name="Rgba8Snorm"/>
        </format>
        <format name="VK_FORMAT_R8G8B8A8_USCALED" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="USCALED"/>
            <component name="G" bits="8" numericFormat="USCALED"/>
            <component name="B" bits="8" numericFormat="USCALED"/>
            <component name="A" bits="8" numericFormat="USCALED"/>
        </format>
        <format name="VK_FORMAT_R8G8B8A8_SSCALED" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="SSCALED"/>
            <component name="G" bits="8" numericFormat="SSCALED"/>
            <component name="B" bits="8" numericFormat="SSCALED"/>
            <component name="A" bits="8" numericFormat="SSCALED"/>
        </format>
        <format name="VK_FORMAT_R8G8B8A8_UINT" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="UINT"/>
            <component name="G" bits="8" numericFormat="UINT"/>
            <component name="B" bits="8" numericFormat="UINT"/>
            <component name="A" bits="8" numericFormat="UINT"/>
            <spirvimageformat name="Rgba8ui"/>
        </format>
        <format name="VK_FORMAT_R8G8B8A8_SINT" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="SINT"/>
            <component name="G" bits="8" numericFormat="SINT"/>
            <component name="B" bits="8" numericFormat="SINT"/>
            <component name="A" bits="8" numericFormat="SINT"/>
            <spirvimageformat name="Rgba8i"/>
        </format>
        <format name="VK_FORMAT_R8G8B8A8_SRGB" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="SRGB"/>
            <component name="G" bits="8" numericFormat="SRGB"/>
            <component name="B" bits="8" numericFormat="SRGB"/>
            <component name="A" bits="8" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_B8G8R8A8_UNORM" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="B" bits="8" numericFormat="UNORM"/>
            <component name="G" bits="8" numericFormat="UNORM"/>
            <component name="R" bits="8" numericFormat="UNORM"/>
            <component name="A" bits="8" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_B8G8R8A8_SNORM" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="B" bits="8" numericFormat="SNORM"/>
            <component name="G" bits="8" numericFormat="SNORM"/>
            <component name="R" bits="8" numericFormat="SNORM"/>
            <component name="A" bits="8" numericFormat="SNORM"/>
        </format>
        <format name="VK_FORMAT_B8G8R8A8_USCALED" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="B" bits="8" numericFormat="USCALED"/>
            <component name="G" bits="8" numericFormat="USCALED"/>
            <component name="R" bits="8" numericFormat="USCALED"/>
            <component name="A" bits="8" numericFormat="USCALED"/>
        </format>
        <format name="VK_FORMAT_B8G8R8A8_SSCALED" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="B" bits="8" numericFormat="SSCALED"/>
            <component name="G" bits="8" numericFormat="SSCALED"/>
            <component name="R" bits="8" numericFormat="SSCALED"/>
            <component name="A" bits="8" numericFormat="SSCALED"/>
        </format>
        <format name="VK_FORMAT_B8G8R8A8_UINT" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="B" bits="8" numericFormat="UINT"/>
            <component name="G" bits="8" numericFormat="UINT"/>
            <component name="R" bits="8" numericFormat="UINT"/>
            <component name="A" bits="8" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_B8G8R8A8_SINT" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="B" bits="8" numericFormat="SINT"/>
            <component name="G" bits="8" numericFormat="SINT"/>
            <component name="R" bits="8" numericFormat="SINT"/>
            <component name="A" bits="8" numericFormat="SINT"/>
        </format>
        <format name="VK_FORMAT_B8G8R8A8_SRGB" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="B" bits="8" numericFormat="SRGB"/>
            <component name="G" bits="8" numericFormat="SRGB"/>
            <component name="R" bits="8" numericFormat="SRGB"/>
            <component name="A" bits="8" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_A8B8G8R8_UNORM_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="A" bits="8" numericFormat="UNORM"/>
            <component name="B" bits="8" numericFormat="UNORM"/>
            <component name="G" bits="8" numericFormat="UNORM"/>
            <component name="R" bits="8" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_A8B8G8R8_SNORM_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="A" bits="8" numericFormat="SNORM"/>
            <component name="B" bits="8" numericFormat="SNORM"/>
            <component name="G" bits="8" numericFormat="SNORM"/>
            <component name="R" bits="8" numericFormat="SNORM"/>
        </format>
        <format name="VK_FORMAT_A8B8G8R8_USCALED_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="A" bits="8" numericFormat="USCALED"/>
            <component name="B" bits="8" numericFormat="USCALED"/>
            <component name="G" bits="8" numericFormat="USCALED"/>
            <component name="R" bits="8" numericFormat="USCALED"/>
        </format>
        <format name="VK_FORMAT_A8B8G8R8_SSCALED_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="A" bits="8" numericFormat="SSCALED"/>
            <component name="B" bits="8" numericFormat="SSCALED"/>
            <component name="G" bits="8" numericFormat="SSCALED"/>
            <component name="R" bits="8" numericFormat="SSCALED"/>
        </format>
        <format name="VK_FORMAT_A8B8G8R8_UINT_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="A" bits="8" numericFormat="UINT"/>
            <component name="B" bits="8" numericFormat="UINT"/>
            <component name="G" bits="8" numericFormat="UINT"/>
            <component name="R" bits="8" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_A8B8G8R8_SINT_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="A" bits="8" numericFormat="SINT"/>
            <component name="B" bits="8" numericFormat="SINT"/>
            <component name="G" bits="8" numericFormat="SINT"/>
            <component name="R" bits="8" numericFormat="SINT"/>
        </format>
        <format name="VK_FORMAT_A8B8G8R8_SRGB_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="A" bits="8" numericFormat="UNORM"/>
            <component name="B" bits="8" numericFormat="SRGB"/>
            <component name="G" bits="8" numericFormat="SRGB"/>
            <component name="R" bits="8" numericFormat="SRGB"/>
        </format>
        <format name="VK_FORMAT_A2R10G10B10_UNORM_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="A" bits="2" numericFormat="UNORM"/>
            <component name="R" bits="10" numericFormat="UNORM"/>
            <component name="G" bits="10" numericFormat="UNORM"/>
            <component name="B" bits="10" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_A2R10G10B10_SNORM_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="A" bits="2" numericFormat="SNORM"/>
            <component name="R" bits="10" numericFormat="SNORM"/>
            <component name="G" bits="10" numericFormat="SNORM"/>
            <component name="B" bits="10" numericFormat="SNORM"/>
        </format>
        <format name="VK_FORMAT_A2R10G10B10_USCALED_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="A" bits="2" numericFormat="USCALED"/>
            <component name="R" bits="10" numericFormat="USCALED"/>
            <component name="G" bits="10" numericFormat="USCALED"/>
            <component name="B" bits="10" numericFormat="USCALED"/>
        </format>
        <format name="VK_FORMAT_A2R10G10B10_SSCALED_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="A" bits="2" numericFormat="SSCALED"/>
            <component name="R" bits="10" numericFormat="SSCALED"/>
            <component name="G" bits="10" numericFormat="SSCALED"/>
            <component name="B" bits="10" numericFormat="SSCALED"/>
        </format>
        <format name="VK_FORMAT_A2R10G10B10_UINT_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="A" bits="2" numericFormat="UINT"/>
            <component name="R" bits="10" numericFormat="UINT"/>
            <component name="G" bits="10" numericFormat="UINT"/>
            <component name="B" bits="10" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_A2R10G10B10_SINT_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="A" bits="2" numericFormat="SINT"/>
            <component name="R" bits="10" numericFormat="SINT"/>
            <component name="G" bits="10" numericFormat="SINT"/>
            <component name="B" bits="10" numericFormat="SINT"/>
        </format>
        <format name="VK_FORMAT_A2B10G10R10_UNORM_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="A" bits="2" numericFormat="UNORM"/>
            <component name="B" bits="10" numericFormat="UNORM"/>
            <component name="G" bits="10" numericFormat="UNORM"/>
            <component name="R" bits="10" numericFormat="UNORM"/>
            <spirvimageformat name="Rgb10A2"/>
        </format>
        <format name="VK_FORMAT_A2B10G10R10_SNORM_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="A" bits="2" numericFormat="SNORM"/>
            <component name="B" bits="10" numericFormat="SNORM"/>
            <component name="G" bits="10" numericFormat="SNORM"/>
            <component name="R" bits="10" numericFormat="SNORM"/>
        </format>
        <format name="VK_FORMAT_A2B10G10R10_USCALED_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="A" bits="2" numericFormat="USCALED"/>
            <component name="B" bits="10" numericFormat="USCALED"/>
            <component name="G" bits="10" numericFormat="USCALED"/>
            <component name="R" bits="10" numericFormat="USCALED"/>
        </format>
        <format name="VK_FORMAT_A2B10G10R10_SSCALED_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="A" bits="2" numericFormat="SSCALED"/>
            <component name="B" bits="10" numericFormat="SSCALED"/>
            <component name="G" bits="10" numericFormat="SSCALED"/>
            <component name="R" bits="10" numericFormat="SSCALED"/>
        </format>
        <format name="VK_FORMAT_A2B10G10R10_UINT_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="A" bits="2" numericFormat="UINT"/>
            <component name="B" bits="10" numericFormat="UINT"/>
            <component name="G" bits="10" numericFormat="UINT"/>
            <component name="R" bits="10" numericFormat="UINT"/>
            <spirvimageformat name="Rgb10a2ui"/>
        </format>
        <format name="VK_FORMAT_A2B10G10R10_SINT_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="A" bits="2" numericFormat="SINT"/>
            <component name="B" bits="10" numericFormat="SINT"/>
            <component name="G" bits="10" numericFormat="SINT"/>
            <component name="R" bits="10" numericFormat="SINT"/>
        </format>
        <format name="VK_FORMAT_R16_UNORM" class="16-bit" blockSize="2" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="UNORM"/>
            <spirvimageformat name="R16"/>
        </format>
        <format name="VK_FORMAT_R16_SNORM" class="16-bit" blockSize="2" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="SNORM"/>
            <spirvimageformat name="R16Snorm"/>
        </format>
        <format name="VK_FORMAT_R16_USCALED" class="16-bit" blockSize="2" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="USCALED"/>
        </format>
        <format name="VK_FORMAT_R16_SSCALED" class="16-bit" blockSize="2" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="SSCALED"/>
        </format>
        <format name="VK_FORMAT_R16_UINT" class="16-bit" blockSize="2" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="UINT"/>
            <spirvimageformat name="R16ui"/>
        </format>
        <format name="VK_FORMAT_R16_SINT" class="16-bit" blockSize="2" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="SINT"/>
            <spirvimageformat name="R16i"/>
        </format>
        <format name="VK_FORMAT_R16_SFLOAT" class="16-bit" blockSize="2" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="SFLOAT"/>
            <spirvimageformat name="R16f"/>
        </format>
        <format name="VK_FORMAT_R16G16_UNORM" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="UNORM"/>
            <component name="G" bits="16" numericFormat="UNORM"/>
            <spirvimageformat name="Rg16"/>
        </format>
        <format name="VK_FORMAT_R16G16_SNORM" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="SNORM"/>
            <component name="G" bits="16" numericFormat="SNORM"/>
            <spirvimageformat name="Rg16Snorm"/>
        </format>
        <format name="VK_FORMAT_R16G16_USCALED" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="USCALED"/>
            <component name="G" bits="16" numericFormat="USCALED"/>
        </format>
        <format name="VK_FORMAT_R16G16_SSCALED" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="SSCALED"/>
            <component name="G" bits="16" numericFormat="SSCALED"/>
        </format>
        <format name="VK_FORMAT_R16G16_UINT" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="UINT"/>
            <component name="G" bits="16" numericFormat="UINT"/>
            <spirvimageformat name="Rg16ui"/>
        </format>
        <format name="VK_FORMAT_R16G16_SINT" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="SINT"/>
            <component name="G" bits="16" numericFormat="SINT"/>
            <spirvimageformat name="Rg16i"/>
        </format>
        <format name="VK_FORMAT_R16G16_SFLOAT" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="SFLOAT"/>
            <component name="G" bits="16" numericFormat="SFLOAT"/>
            <spirvimageformat name="Rg16f"/>
        </format>
        <format name="VK_FORMAT_R16G16B16_UNORM" class="48-bit" blockSize="6" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="UNORM"/>
            <component name="G" bits="16" numericFormat="UNORM"/>
            <component name="B" bits="16" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_R16G16B16_SNORM" class="48-bit" blockSize="6" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="SNORM"/>
            <component name="G" bits="16" numericFormat="SNORM"/>
            <component name="B" bits="16" numericFormat="SNORM"/>
        </format>
        <format name="VK_FORMAT_R16G16B16_USCALED" class="48-bit" blockSize="6" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="USCALED"/>
            <component name="G" bits="16" numericFormat="USCALED"/>
            <component name="B" bits="16" numericFormat="USCALED"/>
        </format>
        <format name="VK_FORMAT_R16G16B16_SSCALED" class="48-bit" blockSize="6" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="SSCALED"/>
            <component name="G" bits="16" numericFormat="SSCALED"/>
            <component name="B" bits="16" numericFormat="SSCALED"/>
        </format>
        <format name="VK_FORMAT_R16G16B16_UINT" class="48-bit" blockSize="6" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="UINT"/>
            <component name="G" bits="16" numericFormat="UINT"/>
            <component name="B" bits="16" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_R16G16B16_SINT" class="48-bit" blockSize="6" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="SINT"/>
            <component name="G" bits="16" numericFormat="SINT"/>
            <component name="B" bits="16" numericFormat="SINT"/>
        </format>
        <format name="VK_FORMAT_R16G16B16_SFLOAT" class="48-bit" blockSize="6" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="SFLOAT"/>
            <component name="G" bits="16" numericFormat="SFLOAT"/>
            <component name="B" bits="16" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_R16G16B16A16_UNORM" class="64-bit" blockSize="8" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="UNORM"/>
            <component name="G" bits="16" numericFormat="UNORM"/>
            <component name="B" bits="16" numericFormat="UNORM"/>
            <component name="A" bits="16" numericFormat="UNORM"/>
            <spirvimageformat name="Rgba16"/>
        </format>
        <format name="VK_FORMAT_R16G16B16A16_SNORM" class="64-bit" blockSize="8" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="SNORM"/>
            <component name="G" bits="16" numericFormat="SNORM"/>
            <component name="B" bits="16" numericFormat="SNORM"/>
            <component name="A" bits="16" numericFormat="SNORM"/>
            <spirvimageformat name="Rgba16Snorm"/>
        </format>
        <format name="VK_FORMAT_R16G16B16A16_USCALED" class="64-bit" blockSize="8" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="USCALED"/>
            <component name="G" bits="16" numericFormat="USCALED"/>
            <component name="B" bits="16" numericFormat="USCALED"/>
            <component name="A" bits="16" numericFormat="USCALED"/>
        </format>
        <format name="VK_FORMAT_R16G16B16A16_SSCALED" class="64-bit" blockSize="8" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="SSCALED"/>
            <component name="G" bits="16" numericFormat="SSCALED"/>
            <component name="B" bits="16" numericFormat="SSCALED"/>
            <component name="A" bits="16" numericFormat="SSCALED"/>
        </format>
        <format name="VK_FORMAT_R16G16B16A16_UINT" class="64-bit" blockSize="8" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="UINT"/>
            <component name="G" bits="16" numericFormat="UINT"/>
            <component name="B" bits="16" numericFormat="UINT"/>
            <component name="A" bits="16" numericFormat="UINT"/>
            <spirvimageformat name="Rgba16ui"/>
        </format>
        <format name="VK_FORMAT_R16G16B16A16_SINT" class="64-bit" blockSize="8" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="SINT"/>
            <component name="G" bits="16" numericFormat="SINT"/>
            <component name="B" bits="16" numericFormat="SINT"/>
            <component name="A" bits="16" numericFormat="SINT"/>
            <spirvimageformat name="Rgba16i"/>
        </format>
        <format name="VK_FORMAT_R16G16B16A16_SFLOAT" class="64-bit" blockSize="8" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="SFLOAT"/>
            <component name="G" bits="16" numericFormat="SFLOAT"/>
            <component name="B" bits="16" numericFormat="SFLOAT"/>
            <component name="A" bits="16" numericFormat="SFLOAT"/>
            <spirvimageformat name="Rgba16f"/>
        </format>
        <format name="VK_FORMAT_R32_UINT" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="R" bits="32" numericFormat="UINT"/>
            <spirvimageformat name="R32ui"/>
        </format>
        <format name="VK_FORMAT_R32_SINT" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="R" bits="32" numericFormat="SINT"/>
            <spirvimageformat name="R32i"/>
        </format>
        <format name="VK_FORMAT_R32_SFLOAT" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="R" bits="32" numericFormat="SFLOAT"/>
            <spirvimageformat name="R32f"/>
        </format>
        <format name="VK_FORMAT_R32G32_UINT" class="64-bit" blockSize="8" texelsPerBlock="1">
            <component name="R" bits="32" numericFormat="UINT"/>
            <component name="G" bits="32" numericFormat="UINT"/>
            <spirvimageformat name="Rg32ui"/>
        </format>
        <format name="VK_FORMAT_R32G32_SINT" class="64-bit" blockSize="8" texelsPerBlock="1">
            <component name="R" bits="32" numericFormat="SINT"/>
            <component name="G" bits="32" numericFormat="SINT"/>
            <spirvimageformat name="Rg32i"/>
        </format>
        <format name="VK_FORMAT_R32G32_SFLOAT" class="64-bit" blockSize="8" texelsPerBlock="1">
            <component name="R" bits="32" numericFormat="SFLOAT"/>
            <component name="G" bits="32" numericFormat="SFLOAT"/>
            <spirvimageformat name="Rg32f"/>
        </format>
        <format name="VK_FORMAT_R32G32B32_UINT" class="96-bit" blockSize="12" texelsPerBlock="1">
            <component name="R" bits="32" numericFormat="UINT"/>
            <component name="G" bits="32" numericFormat="UINT"/>
            <component name="B" bits="32" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_R32G32B32_SINT" class="96-bit" blockSize="12" texelsPerBlock="1">
            <component name="R" bits="32" numericFormat="SINT"/>
            <component name="G" bits="32" numericFormat="SINT"/>
            <component name="B" bits="32" numericFormat="SINT"/>
        </format>
        <format name="VK_FORMAT_R32G32B32_SFLOAT" class="96-bit" blockSize="12" texelsPerBlock="1">
            <component name="R" bits="32" numericFormat="SFLOAT"/>
            <component name="G" bits="32" numericFormat="SFLOAT"/>
            <component name="B" bits="32" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_R32G32B32A32_UINT" class="128-bit" blockSize="16" texelsPerBlock="1">
            <component name="R" bits="32" numericFormat="UINT"/>
            <component name="G" bits="32" numericFormat="UINT"/>
            <component name="B" bits="32" numericFormat="UINT"/>
            <component name="A" bits="32" numericFormat="UINT"/>
            <spirvimageformat name="Rgba32ui"/>
        </format>
        <format name="VK_FORMAT_R32G32B32A32_SINT" class="128-bit" blockSize="16" texelsPerBlock="1">
            <component name="R" bits="32" numericFormat="SINT"/>
            <component name="G" bits="32" numericFormat="SINT"/>
            <component name="B" bits="32" numericFormat="SINT"/>
            <component name="A" bits="32" numericFormat="SINT"/>
            <spirvimageformat name="Rgba32i"/>
        </format>
        <format name="VK_FORMAT_R32G32B32A32_SFLOAT" class="128-bit" blockSize="16" texelsPerBlock="1">
            <component name="R" bits="32" numericFormat="SFLOAT"/>
            <component name="G" bits="32" numericFormat="SFLOAT"/>
            <component name="B" bits="32" numericFormat="SFLOAT"/>
            <component name="A" bits="32" numericFormat="SFLOAT"/>
            <spirvimageformat name="Rgba32f"/>
        </format>
        <format name="VK_FORMAT_R64_UINT" class="64-bit" blockSize="8" texelsPerBlock="1">
            <component name="R" bits="64" numericFormat="UINT"/>
            <spirvimageformat name="R64ui"/>
        </format>
        <format name="VK_FORMAT_R64_SINT" class="64-bit" blockSize="8" texelsPerBlock="1">
            <component name="R" bits="64" numericFormat="SINT"/>
            <spirvimageformat name="R64i"/>
        </format>
        <format name="VK_FORMAT_R64_SFLOAT" class="64-bit" blockSize="8" texelsPerBlock="1">
            <component name="R" bits="64" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_R64G64_UINT" class="128-bit" blockSize="16" texelsPerBlock="1">
            <component name="R" bits="64" numericFormat="UINT"/>
            <component name="G" bits="64" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_R64G64_SINT" class="128-bit" blockSize="16" texelsPerBlock="1">
            <component name="R" bits="64" numericFormat="SINT"/>
            <component name="G" bits="64" numericFormat="SINT"/>
        </format>
        <format name="VK_FORMAT_R64G64_SFLOAT" class="128-bit" blockSize="16" texelsPerBlock="1">
            <component name="R" bits="64" numericFormat="SFLOAT"/>
            <component name="G" bits="64" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_R64G64B64_UINT" class="192-bit" blockSize="24" texelsPerBlock="1">
            <component name="R" bits="64" numericFormat="UINT"/>
            <component name="G" bits="64" numericFormat="UINT"/>
            <component name="B" bits="64" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_R64G64B64_SINT" class="192-bit" blockSize="24" texelsPerBlock="1">
            <component name="R" bits="64" numericFormat="SINT"/>
            <component name="G" bits="64" numericFormat="SINT"/>
            <component name="B" bits="64" numericFormat="SINT"/>
        </format>
        <format name="VK_FORMAT_R64G64B64_SFLOAT" class="192-bit" blockSize="24" texelsPerBlock="1">
            <component name="R" bits="64" numericFormat="SFLOAT"/>
            <component name="G" bits="64" numericFormat="SFLOAT"/>
            <component name="B" bits="64" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_R64G64B64A64_UINT" class="256-bit" blockSize="32" texelsPerBlock="1">
            <component name="R" bits="64" numericFormat="UINT"/>
            <component name="G" bits="64" numericFormat="UINT"/>
            <component name="B" bits="64" numericFormat="UINT"/>
            <component name="A" bits="64" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_R64G64B64A64_SINT" class="256-bit" blockSize="32" texelsPerBlock="1">
            <component name="R" bits="64" numericFormat="SINT"/>
            <component name="G" bits="64" numericFormat="SINT"/>
            <component name="B" bits="64" numericFormat="SINT"/>
            <component name="A" bits="64" numericFormat="SINT"/>
        </format>
        <format name="VK_FORMAT_R64G64B64A64_SFLOAT" class="256-bit" blockSize="32" texelsPerBlock="1">
            <component name="R" bits="64" numericFormat="SFLOAT"/>
            <component name="G" bits="64" numericFormat="SFLOAT"/>
            <component name="B" bits="64" numericFormat="SFLOAT"/>
            <component name="A" bits="64" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_B10G11R11_UFLOAT_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="B" bits="10" numericFormat="UFLOAT"/>
            <component name="G" bits="11" numericFormat="UFLOAT"/>
            <component name="R" bits="11" numericFormat="UFLOAT"/>
            <spirvimageformat name="R11fG11fB10f"/>
        </format>
        <format name="VK_FORMAT_E5B9G9R9_UFLOAT_PACK32" class="32-bit" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="B" bits="9" numericFormat="UFLOAT"/>
            <component name="G" bits="9" numericFormat="UFLOAT"/>
            <component name="R" bits="9" numericFormat="UFLOAT"/>
        </format>
        <format name="VK_FORMAT_D16_UNORM" class="D16" blockSize="2" texelsPerBlock="1">
            <component name="D" bits="16" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_X8_D24_UNORM_PACK32" class="D24" blockSize="4" texelsPerBlock="1" packed="32">
            <component name="D" bits="24" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_D32_SFLOAT" class="D32" blockSize="4" texelsPerBlock="1">
            <component name="D" bits="32" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_S8_UINT" class="S8" blockSize="1" texelsPerBlock="1">
            <component name="S" bits="8" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_D16_UNORM_S8_UINT" class="D16S8" blockSize="3" texelsPerBlock="1">
            <component name="D" bits="16" numericFormat="UNORM"/>
            <component name="S" bits="8" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_D24_UNORM_S8_UINT" class="D24S8" blockSize="4" texelsPerBlock="1">
            <component name="D" bits="24" numericFormat="UNORM"/>
            <component name="S" bits="8" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_D32_SFLOAT_S8_UINT" class="D32S8" blockSize="5" texelsPerBlock="1">
            <component name="D" bits="32" numericFormat="SFLOAT"/>
            <component name="S" bits="8" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_BC1_RGB_UNORM_BLOCK" class="BC1_RGB" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_BC1_RGB_SRGB_BLOCK" class="BC1_RGB" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
        </format>
        <format name="VK_FORMAT_BC1_RGBA_UNORM_BLOCK" class="BC1_RGBA" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_BC1_RGBA_SRGB_BLOCK" class="BC1_RGBA" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_BC2_UNORM_BLOCK" class="BC2" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_BC2_SRGB_BLOCK" class="BC2" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_BC3_UNORM_BLOCK" class="BC3" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_BC3_SRGB_BLOCK" class="BC3" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_BC4_UNORM_BLOCK" class="BC4" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_BC4_SNORM_BLOCK" class="BC4" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
            <component name="R" bits="compressed" numericFormat="SNORM"/>
        </format>
        <format name="VK_FORMAT_BC5_UNORM_BLOCK" class="BC5" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_BC5_SNORM_BLOCK" class="BC5" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
            <component name="R" bits="compressed" numericFormat="SNORM"/>
            <component name="G" bits="compressed" numericFormat="SNORM"/>
        </format>
        <format name="VK_FORMAT_BC6H_UFLOAT_BLOCK" class="BC6H" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
            <component name="R" bits="compressed" numericFormat="UFLOAT"/>
            <component name="G" bits="compressed" numericFormat="UFLOAT"/>
            <component name="B" bits="compressed" numericFormat="UFLOAT"/>
        </format>
        <format name="VK_FORMAT_BC6H_SFLOAT_BLOCK" class="BC6H" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_BC7_UNORM_BLOCK" class="BC7" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_BC7_SRGB_BLOCK" class="BC7" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="BC">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK" class="ETC2_RGB" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="ETC2">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK" class="ETC2_RGB" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="ETC2">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
        </format>
        <format name="VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK" class="ETC2_RGBA" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="ETC2">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK" class="ETC2_RGBA" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="ETC2">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK" class="ETC2_EAC_RGBA" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="ETC2">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK" class="ETC2_EAC_RGBA" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="ETC2">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_EAC_R11_UNORM_BLOCK" class="EAC_R" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="EAC">
            <component name="R" bits="11" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_EAC_R11_SNORM_BLOCK" class="EAC_R" blockSize="8" texelsPerBlock="16" blockExtent="4,4,1" compressed="EAC">
            <component name="R" bits="11" numericFormat="SNORM"/>
        </format>
        <format name="VK_FORMAT_EAC_R11G11_UNORM_BLOCK" class="EAC_RG" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="EAC">
            <component name="R" bits="11" numericFormat="UNORM"/>
            <component name="G" bits="11" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_EAC_R11G11_SNORM_BLOCK" class="EAC_RG" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="EAC">
            <component name="R" bits="11" numericFormat="SNORM"/>
            <component name="G" bits="11" numericFormat="SNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_4x4_UNORM_BLOCK" class="ASTC_4x4" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_4x4_SRGB_BLOCK" class="ASTC_4x4" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_5x4_UNORM_BLOCK" class="ASTC_5x4" blockSize="16" texelsPerBlock="20" blockExtent="5,4,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_5x4_SRGB_BLOCK" class="ASTC_5x4" blockSize="16" texelsPerBlock="20" blockExtent="5,4,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_5x5_UNORM_BLOCK" class="ASTC_5x5" blockSize="16" texelsPerBlock="25" blockExtent="5,5,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_5x5_SRGB_BLOCK" class="ASTC_5x5" blockSize="16" texelsPerBlock="25" blockExtent="5,5,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_6x5_UNORM_BLOCK" class="ASTC_6x5" blockSize="16" texelsPerBlock="30" blockExtent="6,5,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_6x5_SRGB_BLOCK" class="ASTC_6x5" blockSize="16" texelsPerBlock="30" blockExtent="6,5,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_6x6_UNORM_BLOCK" class="ASTC_6x6" blockSize="16" texelsPerBlock="36" blockExtent="6,6,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_6x6_SRGB_BLOCK" class="ASTC_6x6" blockSize="16" texelsPerBlock="36" blockExtent="6,6,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_8x5_UNORM_BLOCK" class="ASTC_8x5" blockSize="16" texelsPerBlock="40" blockExtent="8,5,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_8x5_SRGB_BLOCK" class="ASTC_8x5" blockSize="16" texelsPerBlock="40" blockExtent="8,5,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_8x6_UNORM_BLOCK" class="ASTC_8x6" blockSize="16" texelsPerBlock="48" blockExtent="8,6,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_8x6_SRGB_BLOCK" class="ASTC_8x6" blockSize="16" texelsPerBlock="48" blockExtent="8,6,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_8x8_UNORM_BLOCK" class="ASTC_8x8" blockSize="16" texelsPerBlock="64" blockExtent="8,8,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_8x8_SRGB_BLOCK" class="ASTC_8x8" blockSize="16" texelsPerBlock="64" blockExtent="8,8,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_10x5_UNORM_BLOCK" class="ASTC_10x5" blockSize="16" texelsPerBlock="50" blockExtent="10,5,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_10x5_SRGB_BLOCK" class="ASTC_10x5" blockSize="16" texelsPerBlock="50" blockExtent="10,5,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_10x6_UNORM_BLOCK" class="ASTC_10x6" blockSize="16" texelsPerBlock="60" blockExtent="10,6,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_10x6_SRGB_BLOCK" class="ASTC_10x6" blockSize="16" texelsPerBlock="60" blockExtent="10,6,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_10x8_UNORM_BLOCK" class="ASTC_10x8" blockSize="16" texelsPerBlock="80" blockExtent="10,8,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_10x8_SRGB_BLOCK" class="ASTC_10x8" blockSize="16" texelsPerBlock="80" blockExtent="10,8,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_10x10_UNORM_BLOCK" class="ASTC_10x10" blockSize="16" texelsPerBlock="100" blockExtent="10,10,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_10x10_SRGB_BLOCK" class="ASTC_10x10" blockSize="16" texelsPerBlock="100" blockExtent="10,10,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_12x10_UNORM_BLOCK" class="ASTC_12x10" blockSize="16" texelsPerBlock="120" blockExtent="12,10,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_12x10_SRGB_BLOCK" class="ASTC_12x10" blockSize="16" texelsPerBlock="120" blockExtent="12,10,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_12x12_UNORM_BLOCK" class="ASTC_12x12" blockSize="16" texelsPerBlock="144" blockExtent="12,12,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_12x12_SRGB_BLOCK" class="ASTC_12x12" blockSize="16" texelsPerBlock="144" blockExtent="12,12,1" compressed="ASTC LDR">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_G8B8G8R8_422_UNORM" class="32-bit G8B8G8R8" blockSize="4" texelsPerBlock="1" blockExtent="2,1,1" chroma="422">
            <component name="G" bits="8" numericFormat="UNORM"/>
            <component name="B" bits="8" numericFormat="UNORM"/>
            <component name="G" bits="8" numericFormat="UNORM"/>
            <component name="R" bits="8" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_B8G8R8G8_422_UNORM" class="32-bit B8G8R8G8" blockSize="4" texelsPerBlock="1" blockExtent="2,1,1" chroma="422">
            <component name="B" bits="8" numericFormat="UNORM"/>
            <component name="G" bits="8" numericFormat="UNORM"/>
            <component name="R" bits="8" numericFormat="UNORM"/>
            <component name="G" bits="8" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM" class="8-bit 3-plane 420" blockSize="3" texelsPerBlock="1" chroma="420">
            <component name="G" bits="8" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="8" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="8" numericFormat="UNORM" planeIndex="2"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
            <plane index="1" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R8_UNORM"/>
            <plane index="2" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R8_UNORM"/>
        </format>
        <format name="VK_FORMAT_G8_B8R8_2PLANE_420_UNORM" class="8-bit 2-plane 420" blockSize="3" texelsPerBlock="1" chroma="420">
            <component name="G" bits="8" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="8" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="8" numericFormat="UNORM" planeIndex="1"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
            <plane index="1" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R8G8_UNORM"/>
        </format>
        <format name="VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM" class="8-bit 3-plane 422" blockSize="3" texelsPerBlock="1" chroma="422">
            <component name="G" bits="8" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="8" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="8" numericFormat="UNORM" planeIndex="2"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
            <plane index="1" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
            <plane index="2" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
        </format>
        <format name="VK_FORMAT_G8_B8R8_2PLANE_422_UNORM" class="8-bit 2-plane 422" blockSize="3" texelsPerBlock="1" chroma="422">
            <component name="G" bits="8" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="8" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="8" numericFormat="UNORM" planeIndex="1"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
            <plane index="1" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R8G8_UNORM"/>
        </format>
        <format name="VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM" class="8-bit 3-plane 444" blockSize="3" texelsPerBlock="1" chroma="444">
            <component name="G" bits="8" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="8" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="8" numericFormat="UNORM" planeIndex="2"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
            <plane index="1" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
            <plane index="2" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
        </format>
        <format name="VK_FORMAT_R10X6_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
            <component name="R" bits="10" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_R10X6G10X6_UNORM_2PACK16" class="32-bit" blockSize="4" texelsPerBlock="1" packed="16">
            <component name="R" bits="10" numericFormat="UNORM"/>
            <component name="G" bits="10" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16" class="64-bit R10G10B10A10" blockSize="8" texelsPerBlock="1" packed="16" chroma="444">
            <component name="R" bits="10" numericFormat="UNORM"/>
            <component name="G" bits="10" numericFormat="UNORM"/>
            <component name="B" bits="10" numericFormat="UNORM"/>
            <component name="A" bits="10" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16" class="64-bit G10B10G10R10" blockSize="8" texelsPerBlock="1" blockExtent="2,1,1" packed="16" chroma="422">
            <component name="G" bits="10" numericFormat="UNORM"/>
            <component name="B" bits="10" numericFormat="UNORM"/>
            <component name="G" bits="10" numericFormat="UNORM"/>
            <component name="R" bits="10" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16" class="64-bit B10G10R10G10" blockSize="8" texelsPerBlock="1" blockExtent="2,1,1" packed="16" chroma="422">
            <component name="B" bits="10" numericFormat="UNORM"/>
            <component name="G" bits="10" numericFormat="UNORM"/>
            <component name="R" bits="10" numericFormat="UNORM"/>
            <component name="G" bits="10" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16" class="10-bit 3-plane 420" blockSize="6" texelsPerBlock="1" packed="16" chroma="420">
            <component name="G" bits="10" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="10" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="10" numericFormat="UNORM" planeIndex="2"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
            <plane index="1" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
            <plane index="2" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
        </format>
        <format name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16" class="10-bit 2-plane 420" blockSize="6" texelsPerBlock="1" packed="16" chroma="420">
            <component name="G" bits="10" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="10" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="10" numericFormat="UNORM" planeIndex="1"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
            <plane index="1" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R10X6G10X6_UNORM_2PACK16"/>
        </format>
        <format name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16" class="10-bit 3-plane 422" blockSize="6" texelsPerBlock="1" packed="16" chroma="422">
            <component name="G" bits="10" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="10" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="10" numericFormat="UNORM" planeIndex="2"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
            <plane index="1" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
            <plane index="2" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
        </format>
        <format name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16" class="10-bit 2-plane 422" blockSize="6" texelsPerBlock="1" packed="16" chroma="422">
            <component name="G" bits="10" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="10" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="10" numericFormat="UNORM" planeIndex="1"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
            <plane index="1" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R10X6G10X6_UNORM_2PACK16"/>
        </format>
        <format name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16" class="10-bit 3-plane 444" blockSize="6" texelsPerBlock="1" packed="16" chroma="444">
            <component name="G" bits="10" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="10" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="10" numericFormat="UNORM" planeIndex="2"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
            <plane index="1" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
            <plane index="2" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
        </format>
        <format name="VK_FORMAT_R12X4_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
            <component name="R" bits="12" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_R12X4G12X4_UNORM_2PACK16" class="32-bit" blockSize="4" texelsPerBlock="1" packed="16">
            <component name="R" bits="12" numericFormat="UNORM"/>
            <component name="G" bits="12" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16" class="64-bit R12G12B12A12" blockSize="8" texelsPerBlock="1" packed="16" chroma="444">
            <component name="R" bits="12" numericFormat="UNORM"/>
            <component name="G" bits="12" numericFormat="UNORM"/>
            <component name="B" bits="12" numericFormat="UNORM"/>
            <component name="A" bits="12" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16" class="64-bit G12B12G12R12" blockSize="8" texelsPerBlock="1" blockExtent="2,1,1" packed="16" chroma="422">
            <component name="G" bits="12" numericFormat="UNORM"/>
            <component name="B" bits="12" numericFormat="UNORM"/>
            <component name="G" bits="12" numericFormat="UNORM"/>
            <component name="R" bits="12" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16" class="64-bit B12G12R12G12" blockSize="8" texelsPerBlock="1" blockExtent="2,1,1" packed="16" chroma="422">
            <component name="B" bits="12" numericFormat="UNORM"/>
            <component name="G" bits="12" numericFormat="UNORM"/>
            <component name="R" bits="12" numericFormat="UNORM"/>
            <component name="G" bits="12" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16" class="12-bit 3-plane 420" blockSize="6" texelsPerBlock="1" packed="16" chroma="420">
            <component name="G" bits="12" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="12" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="12" numericFormat="UNORM" planeIndex="2"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
            <plane index="1" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
            <plane index="2" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
        </format>
        <format name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16" class="12-bit 2-plane 420" blockSize="6" texelsPerBlock="1" packed="16" chroma="420">
            <component name="G" bits="12" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="12" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="12" numericFormat="UNORM" planeIndex="1"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
            <plane index="1" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R12X4G12X4_UNORM_2PACK16"/>
        </format>
        <format name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16" class="12-bit 3-plane 422" blockSize="6" texelsPerBlock="1" packed="16" chroma="422">
            <component name="G" bits="12" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="12" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="12" numericFormat="UNORM" planeIndex="2"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
            <plane index="1" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
            <plane index="2" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
        </format>
        <format name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16" class="12-bit 2-plane 422" blockSize="6" texelsPerBlock="1" packed="16" chroma="422">
            <component name="G" bits="12" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="12" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="12" numericFormat="UNORM" planeIndex="1"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
            <plane index="1" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R12X4G12X4_UNORM_2PACK16"/>
        </format>
        <format name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16" class="12-bit 3-plane 444" blockSize="6" texelsPerBlock="1" packed="16" chroma="444">
            <component name="G" bits="12" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="12" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="12" numericFormat="UNORM" planeIndex="2"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
            <plane index="1" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
            <plane index="2" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
        </format>
        <format name="VK_FORMAT_G16B16G16R16_422_UNORM" class="64-bit G16B16G16R16" blockSize="8" texelsPerBlock="1" blockExtent="2,1,1" chroma="422">
            <component name="G" bits="16" numericFormat="UNORM"/>
            <component name="B" bits="16" numericFormat="UNORM"/>
            <component name="G" bits="16" numericFormat="UNORM"/>
            <component name="R" bits="16" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_B16G16R16G16_422_UNORM" class="64-bit B16G16R16G16" blockSize="8" texelsPerBlock="1" blockExtent="2,1,1" chroma="422">
            <component name="B" bits="16" numericFormat="UNORM"/>
            <component name="G" bits="16" numericFormat="UNORM"/>
            <component name="R" bits="16" numericFormat="UNORM"/>
            <component name="G" bits="16" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM" class="16-bit 3-plane 420" blockSize="6" texelsPerBlock="1" chroma="420">
            <component name="G" bits="16" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="16" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="16" numericFormat="UNORM" planeIndex="2"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
            <plane index="1" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R16_UNORM"/>
            <plane index="2" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R16_UNORM"/>
        </format>
        <format name="VK_FORMAT_G16_B16R16_2PLANE_420_UNORM" class="16-bit 2-plane 420" blockSize="6" texelsPerBlock="1" chroma="420">
            <component name="G" bits="16" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="16" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="16" numericFormat="UNORM" planeIndex="1"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
            <plane index="1" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R16G16_UNORM"/>
        </format>
        <format name="VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM" class="16-bit 3-plane 422" blockSize="6" texelsPerBlock="1" chroma="422">
            <component name="G" bits="16" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="16" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="16" numericFormat="UNORM" planeIndex="2"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
            <plane index="1" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
            <plane index="2" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
        </format>
        <format name="VK_FORMAT_G16_B16R16_2PLANE_422_UNORM" class="16-bit 2-plane 422" blockSize="6" texelsPerBlock="1" chroma="422">
            <component name="G" bits="16" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="16" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="16" numericFormat="UNORM" planeIndex="1"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
            <plane index="1" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R16G16_UNORM"/>
        </format>
        <format name="VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM" class="16-bit 3-plane 444" blockSize="6" texelsPerBlock="1" chroma="444">
            <component name="G" bits="16" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="16" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="16" numericFormat="UNORM" planeIndex="2"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
            <plane index="1" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
            <plane index="2" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
        </format>
        <format name="VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG" class="PVRTC1_2BPP" blockSize="8" texelsPerBlock="1" blockExtent="8,4,1" compressed="PVRTC">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG" class="PVRTC1_4BPP" blockSize="8" texelsPerBlock="1" blockExtent="4,4,1" compressed="PVRTC">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG" class="PVRTC2_2BPP" blockSize="8" texelsPerBlock="1" blockExtent="8,4,1" compressed="PVRTC">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG" class="PVRTC2_4BPP" blockSize="8" texelsPerBlock="1" blockExtent="4,4,1" compressed="PVRTC">
            <component name="R" bits="compressed" numericFormat="UNORM"/>
            <component name="G" bits="compressed" numericFormat="UNORM"/>
            <component name="B" bits="compressed" numericFormat="UNORM"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG" class="PVRTC1_2BPP" blockSize="8" texelsPerBlock="1" blockExtent="8,4,1" compressed="PVRTC">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG" class="PVRTC1_4BPP" blockSize="8" texelsPerBlock="1" blockExtent="4,4,1" compressed="PVRTC">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG" class="PVRTC2_2BPP" blockSize="8" texelsPerBlock="1" blockExtent="8,4,1" compressed="PVRTC">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG" class="PVRTC2_4BPP" blockSize="8" texelsPerBlock="1" blockExtent="4,4,1" compressed="PVRTC">
            <component name="R" bits="compressed" numericFormat="SRGB"/>
            <component name="G" bits="compressed" numericFormat="SRGB"/>
            <component name="B" bits="compressed" numericFormat="SRGB"/>
            <component name="A" bits="compressed" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK" class="ASTC_4x4" blockSize="16" texelsPerBlock="16" blockExtent="4,4,1" compressed="ASTC HDR">
            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK" class="ASTC_5x4" blockSize="16" texelsPerBlock="20" blockExtent="5,4,1" compressed="ASTC HDR">
            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK" class="ASTC_5x5" blockSize="16" texelsPerBlock="25" blockExtent="5,5,1" compressed="ASTC HDR">
            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK" class="ASTC_6x5" blockSize="16" texelsPerBlock="30" blockExtent="6,5,1" compressed="ASTC HDR">
            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK" class="ASTC_6x6" blockSize="16" texelsPerBlock="36" blockExtent="6,6,1" compressed="ASTC HDR">
            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK" class="ASTC_8x5" blockSize="16" texelsPerBlock="40" blockExtent="8,5,1" compressed="ASTC HDR">
            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK" class="ASTC_8x6" blockSize="16" texelsPerBlock="48" blockExtent="8,6,1" compressed="ASTC HDR">
            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK" class="ASTC_8x8" blockSize="16" texelsPerBlock="64" blockExtent="8,8,1" compressed="ASTC HDR">
            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK" class="ASTC_10x5" blockSize="16" texelsPerBlock="50" blockExtent="10,5,1" compressed="ASTC HDR">
            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK" class="ASTC_10x6" blockSize="16" texelsPerBlock="60" blockExtent="10,6,1" compressed="ASTC HDR">
            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK" class="ASTC_10x8" blockSize="16" texelsPerBlock="80" blockExtent="10,8,1" compressed="ASTC HDR">
            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK" class="ASTC_10x10" blockSize="16" texelsPerBlock="100" blockExtent="10,10,1" compressed="ASTC HDR">
            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK" class="ASTC_12x10" blockSize="16" texelsPerBlock="120" blockExtent="12,10,1" compressed="ASTC HDR">
            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK" class="ASTC_12x12" blockSize="16" texelsPerBlock="144" blockExtent="12,12,1" compressed="ASTC HDR">
            <component name="R" bits="compressed" numericFormat="SFLOAT"/>
            <component name="G" bits="compressed" numericFormat="SFLOAT"/>
            <component name="B" bits="compressed" numericFormat="SFLOAT"/>
            <component name="A" bits="compressed" numericFormat="SFLOAT"/>
        </format>
        <format name="VK_FORMAT_G8_B8R8_2PLANE_444_UNORM" class="8-bit 2-plane 444" blockSize="3" texelsPerBlock="1" chroma="444">
            <component name="G" bits="8" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="8" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="8" numericFormat="UNORM" planeIndex="1"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R8_UNORM"/>
            <plane index="1" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R8G8_UNORM"/>
        </format>
        <format name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16" class="10-bit 2-plane 444" blockSize="6" texelsPerBlock="1" packed="16" chroma="444">
            <component name="G" bits="10" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="10" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="10" numericFormat="UNORM" planeIndex="1"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R10X6_UNORM_PACK16"/>
            <plane index="1" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R10X6G10X6_UNORM_2PACK16"/>
        </format>
        <format name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16" class="12-bit 2-plane 444" blockSize="6" texelsPerBlock="1" packed="16" chroma="444">
            <component name="G" bits="12" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="12" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="12" numericFormat="UNORM" planeIndex="1"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R12X4_UNORM_PACK16"/>
            <plane index="1" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R12X4G12X4_UNORM_2PACK16"/>
        </format>
        <format name="VK_FORMAT_G16_B16R16_2PLANE_444_UNORM" class="16-bit 2-plane 444" blockSize="6" texelsPerBlock="1" chroma="444">
            <component name="G" bits="16" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="16" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="16" numericFormat="UNORM" planeIndex="1"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R16_UNORM"/>
            <plane index="1" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R16G16_UNORM"/>
        </format>
        <format name="VK_FORMAT_A4R4G4B4_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
            <component name="A" bits="4" numericFormat="UNORM"/>
            <component name="R" bits="4" numericFormat="UNORM"/>
            <component name="G" bits="4" numericFormat="UNORM"/>
            <component name="B" bits="4" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_A4B4G4R4_UNORM_PACK16" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
            <component name="A" bits="4" numericFormat="UNORM"/>
            <component name="B" bits="4" numericFormat="UNORM"/>
            <component name="G" bits="4" numericFormat="UNORM"/>
            <component name="R" bits="4" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_R16G16_SFIXED5_NV" class="32-bit" blockSize="4" texelsPerBlock="1">
            <component name="R" bits="16" numericFormat="SFIXED5"/>
            <component name="G" bits="16" numericFormat="SFIXED5"/>
        </format>
        <format name="VK_FORMAT_R10X6_UINT_PACK16_ARM" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
            <component name="R" bits="10" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_R10X6G10X6_UINT_2PACK16_ARM" class="32-bit" blockSize="4" texelsPerBlock="1" packed="16">
            <component name="R" bits="10" numericFormat="UINT"/>
            <component name="G" bits="10" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_R10X6G10X6B10X6A10X6_UINT_4PACK16_ARM" class="64-bit R10G10B10A10" blockSize="8" texelsPerBlock="1" packed="16">
            <component name="R" bits="10" numericFormat="UINT"/>
            <component name="G" bits="10" numericFormat="UINT"/>
            <component name="B" bits="10" numericFormat="UINT"/>
            <component name="A" bits="10" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_R12X4_UINT_PACK16_ARM" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
            <component name="R" bits="12" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_R12X4G12X4_UINT_2PACK16_ARM" class="32-bit" blockSize="4" texelsPerBlock="1" packed="16">
            <component name="R" bits="12" numericFormat="UINT"/>
            <component name="G" bits="12" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_R12X4G12X4B12X4A12X4_UINT_4PACK16_ARM" class="64-bit R12G12B12A12" blockSize="8" texelsPerBlock="1" packed="16">
            <component name="R" bits="12" numericFormat="UINT"/>
            <component name="G" bits="12" numericFormat="UINT"/>
            <component name="B" bits="12" numericFormat="UINT"/>
            <component name="A" bits="12" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_R14X2_UINT_PACK16_ARM" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
            <component name="R" bits="14" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_R14X2G14X2_UINT_2PACK16_ARM" class="32-bit" blockSize="4" texelsPerBlock="1" packed="16">
            <component name="R" bits="14" numericFormat="UINT"/>
            <component name="G" bits="14" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_R14X2G14X2B14X2A14X2_UINT_4PACK16_ARM" class="64-bit R14G14B14A14" blockSize="8" texelsPerBlock="1" packed="16">
            <component name="R" bits="14" numericFormat="UINT"/>
            <component name="G" bits="14" numericFormat="UINT"/>
            <component name="B" bits="14" numericFormat="UINT"/>
            <component name="A" bits="14" numericFormat="UINT"/>
        </format>
        <format name="VK_FORMAT_R14X2_UNORM_PACK16_ARM" class="16-bit" blockSize="2" texelsPerBlock="1" packed="16">
            <component name="R" bits="14" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_R14X2G14X2_UNORM_2PACK16_ARM" class="32-bit" blockSize="4" texelsPerBlock="1" packed="16">
            <component name="R" bits="14" numericFormat="UNORM"/>
            <component name="G" bits="14" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_R14X2G14X2B14X2A14X2_UNORM_4PACK16_ARM" class="64-bit R14G14B14A14" blockSize="8" texelsPerBlock="1" packed="16">
            <component name="R" bits="14" numericFormat="UNORM"/>
            <component name="G" bits="14" numericFormat="UNORM"/>
            <component name="B" bits="14" numericFormat="UNORM"/>
            <component name="A" bits="14" numericFormat="UNORM"/>
        </format>
        <format name="VK_FORMAT_G14X2_B14X2R14X2_2PLANE_420_UNORM_3PACK16_ARM" class="14-bit 2-plane 420" blockSize="6" texelsPerBlock="1" packed="16" chroma="420">
            <component name="G" bits="14" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="14" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="14" numericFormat="UNORM" planeIndex="1"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R14X2_UNORM_PACK16_ARM"/>
            <plane index="1" widthDivisor="2" heightDivisor="2" compatible="VK_FORMAT_R14X2G14X2_UNORM_2PACK16_ARM"/>
        </format>
        <format name="VK_FORMAT_G14X2_B14X2R14X2_2PLANE_422_UNORM_3PACK16_ARM" class="14-bit 2-plane 422" blockSize="6" texelsPerBlock="1" packed="16" chroma="422">
            <component name="G" bits="14" numericFormat="UNORM" planeIndex="0"/>
            <component name="B" bits="14" numericFormat="UNORM" planeIndex="1"/>
            <component name="R" bits="14" numericFormat="UNORM" planeIndex="1"/>
            <plane index="0" widthDivisor="1" heightDivisor="1" compatible="VK_FORMAT_R14X2_UNORM_PACK16_ARM"/>
            <plane index="1" widthDivisor="2" heightDivisor="1" compatible="VK_FORMAT_R14X2G14X2_UNORM_2PACK16_ARM"/>
        </format>
        <format name="VK_FORMAT_R8_BOOL_ARM" class="8-bit" blockSize="1" texelsPerBlock="1">
            <component name="R" bits="8" numericFormat="BOOL"/>
        </format>
    </formats>
    <spirvextensions comment="SPIR-V Extensions allowed in Vulkan and what is required to use it">
        <spirvextension name="SPV_KHR_variable_pointers">
            <enable version="VK_VERSION_1_1"/>
            <enable extension="VK_KHR_variable_pointers"/>
        </spirvextension>
        <spirvextension name="SPV_AMD_shader_explicit_vertex_parameter">
            <enable extension="VK_AMD_shader_explicit_vertex_parameter"/>
        </spirvextension>
        <spirvextension name="SPV_AMD_gcn_shader">
            <enable extension="VK_AMD_gcn_shader"/>
        </spirvextension>
        <spirvextension name="SPV_AMD_gpu_shader_half_float">
            <enable extension="VK_AMD_gpu_shader_half_float"/>
        </spirvextension>
        <spirvextension name="SPV_AMD_gpu_shader_int16">
            <enable extension="VK_AMD_gpu_shader_int16"/>
        </spirvextension>
        <spirvextension name="SPV_AMD_shader_ballot">
            <enable extension="VK_AMD_shader_ballot"/>
        </spirvextension>
        <spirvextension name="SPV_AMD_shader_fragment_mask">
            <enable extension="VK_AMD_shader_fragment_mask"/>
        </spirvextension>
        <spirvextension name="SPV_AMD_shader_image_load_store_lod">
            <enable extension="VK_AMD_shader_image_load_store_lod"/>
        </spirvextension>
        <spirvextension name="SPV_AMD_shader_trinary_minmax">
            <enable extension="VK_AMD_shader_trinary_minmax"/>
        </spirvextension>
        <spirvextension name="SPV_AMD_texture_gather_bias_lod">
            <enable extension="VK_AMD_texture_gather_bias_lod"/>
        </spirvextension>
        <spirvextension name="SPV_AMD_shader_early_and_late_fragment_tests">
            <enable extension="VK_AMD_shader_early_and_late_fragment_tests"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_shader_draw_parameters">
            <enable version="VK_VERSION_1_1"/>
            <enable extension="VK_KHR_shader_draw_parameters"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_8bit_storage">
            <enable version="VK_VERSION_1_2"/>
            <enable extension="VK_KHR_8bit_storage"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_16bit_storage">
            <enable version="VK_VERSION_1_1"/>
            <enable extension="VK_KHR_16bit_storage"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_shader_clock">
            <enable extension="VK_KHR_shader_clock"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_float_controls">
            <enable version="VK_VERSION_1_2"/>
            <enable extension="VK_KHR_shader_float_controls"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_storage_buffer_storage_class">
            <enable version="VK_VERSION_1_1"/>
            <enable extension="VK_KHR_storage_buffer_storage_class"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_post_depth_coverage">
            <enable extension="VK_EXT_post_depth_coverage"/>
        </spirvextension>
        <spirvextension name="SPV_EXT_shader_stencil_export">
            <enable extension="VK_EXT_shader_stencil_export"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_shader_ballot">
            <enable extension="VK_EXT_shader_subgroup_ballot"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_subgroup_vote">
            <enable extension="VK_EXT_shader_subgroup_vote"/>
        </spirvextension>
        <spirvextension name="SPV_NV_sample_mask_override_coverage">
            <enable extension="VK_NV_sample_mask_override_coverage"/>
        </spirvextension>
        <spirvextension name="SPV_NV_geometry_shader_passthrough">
            <enable extension="VK_NV_geometry_shader_passthrough"/>
        </spirvextension>
        <spirvextension name="SPV_NV_mesh_shader">
            <enable extension="VK_NV_mesh_shader"/>
        </spirvextension>
        <spirvextension name="SPV_NV_viewport_array2">
            <enable extension="VK_NV_viewport_array2"/>
        </spirvextension>
        <spirvextension name="SPV_NV_shader_subgroup_partitioned">
            <enable extension="VK_NV_shader_subgroup_partitioned"/>
        </spirvextension>
        <spirvextension name="SPV_NV_shader_invocation_reorder">
            <enable extension="VK_NV_ray_tracing_invocation_reorder"/>
        </spirvextension>
        <spirvextension name="SPV_EXT_shader_viewport_index_layer">
            <enable version="VK_VERSION_1_2"/>
            <enable extension="VK_EXT_shader_viewport_index_layer"/>
        </spirvextension>
        <spirvextension name="SPV_NVX_multiview_per_view_attributes">
            <enable extension="VK_NVX_multiview_per_view_attributes"/>
        </spirvextension>
        <spirvextension name="SPV_EXT_descriptor_indexing">
            <enable version="VK_VERSION_1_2"/>
            <enable extension="VK_EXT_descriptor_indexing"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_vulkan_memory_model">
            <enable version="VK_VERSION_1_2"/>
            <enable extension="VK_KHR_vulkan_memory_model"/>
        </spirvextension>
        <spirvextension name="SPV_NV_compute_shader_derivatives">
            <enable extension="VK_NV_compute_shader_derivatives"/>
        </spirvextension>
        <spirvextension name="SPV_NV_fragment_shader_barycentric">
            <enable extension="VK_NV_fragment_shader_barycentric"/>
        </spirvextension>
        <spirvextension name="SPV_NV_shader_image_footprint">
            <enable extension="VK_NV_shader_image_footprint"/>
        </spirvextension>
        <spirvextension name="SPV_NV_shading_rate">
            <enable extension="VK_NV_shading_rate_image"/>
        </spirvextension>
        <spirvextension name="SPV_NV_ray_tracing">
            <enable extension="VK_NV_ray_tracing"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_ray_tracing">
            <enable extension="VK_KHR_ray_tracing_pipeline"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_ray_query">
            <enable extension="VK_KHR_ray_query"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_ray_cull_mask">
            <enable extension="VK_KHR_ray_tracing_maintenance1"/>
        </spirvextension>
        <spirvextension name="SPV_GOOGLE_hlsl_functionality1">
            <enable extension="VK_GOOGLE_hlsl_functionality1"/>
        </spirvextension>
        <spirvextension name="SPV_GOOGLE_user_type">
            <enable extension="VK_GOOGLE_user_type"/>
        </spirvextension>
        <spirvextension name="SPV_GOOGLE_decorate_string">
            <enable extension="VK_GOOGLE_decorate_string"/>
        </spirvextension>
        <spirvextension name="SPV_EXT_fragment_invocation_density">
            <enable extension="VK_EXT_fragment_density_map"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_physical_storage_buffer">
            <enable version="VK_VERSION_1_2"/>
            <enable extension="VK_KHR_buffer_device_address"/>
        </spirvextension>
        <spirvextension name="SPV_EXT_physical_storage_buffer">
            <enable extension="VK_EXT_buffer_device_address"/>
        </spirvextension>
        <spirvextension name="SPV_NV_cooperative_matrix">
            <enable extension="VK_NV_cooperative_matrix"/>
        </spirvextension>
        <spirvextension name="SPV_NV_shader_sm_builtins">
            <enable extension="VK_NV_shader_sm_builtins"/>
        </spirvextension>
        <spirvextension name="SPV_EXT_fragment_shader_interlock">
            <enable extension="VK_EXT_fragment_shader_interlock"/>
        </spirvextension>
        <spirvextension name="SPV_EXT_demote_to_helper_invocation">
            <enable version="VK_VERSION_1_3"/>
            <enable extension="VK_EXT_shader_demote_to_helper_invocation"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_fragment_shading_rate">
            <enable extension="VK_KHR_fragment_shading_rate"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_non_semantic_info">
            <enable version="VK_VERSION_1_3"/>
            <enable extension="VK_KHR_shader_non_semantic_info"/>
        </spirvextension>
        <spirvextension name="SPV_EXT_shader_image_int64">
            <enable extension="VK_EXT_shader_image_atomic_int64"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_terminate_invocation">
            <enable version="VK_VERSION_1_3"/>
            <enable extension="VK_KHR_shader_terminate_invocation"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_multiview">
            <enable version="VK_VERSION_1_1"/>
            <enable extension="VK_KHR_multiview"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_workgroup_memory_explicit_layout">
            <enable extension="VK_KHR_workgroup_memory_explicit_layout"/>
        </spirvextension>
        <spirvextension name="SPV_EXT_shader_atomic_float_add">
            <enable extension="VK_EXT_shader_atomic_float"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_fragment_shader_barycentric">
            <enable extension="VK_KHR_fragment_shader_barycentric"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_subgroup_uniform_control_flow">
            <enable extension="VK_KHR_shader_subgroup_uniform_control_flow"/>
        </spirvextension>
        <spirvextension name="SPV_EXT_shader_atomic_float_min_max">
            <enable extension="VK_EXT_shader_atomic_float2"/>
        </spirvextension>
        <spirvextension name="SPV_EXT_shader_atomic_float16_add">
            <enable extension="VK_EXT_shader_atomic_float2"/>
        </spirvextension>
        <spirvextension name="SPV_NV_shader_atomic_fp16_vector">
            <enable extension="VK_NV_shader_atomic_float16_vector"/>
        </spirvextension>
        <spirvextension name="SPV_EXT_fragment_fully_covered">
            <enable extension="VK_EXT_conservative_rasterization"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_integer_dot_product">
            <enable version="VK_VERSION_1_3"/>
            <enable extension="VK_KHR_shader_integer_dot_product"/>
        </spirvextension>
        <spirvextension name="SPV_INTEL_shader_integer_functions2">
            <enable extension="VK_INTEL_shader_integer_functions2"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_device_group">
            <enable version="VK_VERSION_1_1"/>
            <enable extension="VK_KHR_device_group"/>
        </spirvextension>
        <spirvextension name="SPV_QCOM_image_processing">
            <enable extension="VK_QCOM_image_processing"/>
        </spirvextension>
        <spirvextension name="SPV_QCOM_image_processing2">
            <enable extension="VK_QCOM_image_processing2"/>
        </spirvextension>
        <spirvextension name="SPV_EXT_mesh_shader">
            <enable extension="VK_EXT_mesh_shader"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_ray_tracing_position_fetch">
            <enable extension="VK_KHR_ray_tracing_position_fetch"/>
        </spirvextension>
        <spirvextension name="SPV_EXT_shader_tile_image">
            <enable extension="VK_EXT_shader_tile_image"/>
        </spirvextension>
        <spirvextension name="SPV_EXT_opacity_micromap">
            <enable extension="VK_EXT_opacity_micromap"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_cooperative_matrix">
            <enable extension="VK_KHR_cooperative_matrix"/>
        </spirvextension>
        <spirvextension name="SPV_ARM_core_builtins">
            <enable extension="VK_ARM_shader_core_builtins"/>
        </spirvextension>
        <spirvextension name="SPV_HUAWEI_cluster_culling_shader">
            <enable extension="VK_HUAWEI_cluster_culling_shader"/>
        </spirvextension>
        <spirvextension name="SPV_HUAWEI_subpass_shading">
            <enable extension="VK_HUAWEI_subpass_shading"/>
        </spirvextension>
        <spirvextension name="SPV_NV_ray_tracing_motion_blur">
            <enable extension="VK_NV_ray_tracing_motion_blur"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_maximal_reconvergence">
            <enable extension="VK_KHR_shader_maximal_reconvergence"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_subgroup_rotate">
            <enable version="VK_VERSION_1_4"/>
            <enable extension="VK_KHR_shader_subgroup_rotate"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_expect_assume">
            <enable version="VK_VERSION_1_4"/>
            <enable extension="VK_KHR_shader_expect_assume"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_float_controls2">
            <enable version="VK_VERSION_1_4"/>
            <enable extension="VK_KHR_shader_float_controls2"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_fma">
            <enable extension="VK_KHR_shader_fma"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_quad_control">
            <enable extension="VK_KHR_shader_quad_control"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_bfloat16">
            <enable extension="VK_KHR_shader_bfloat16"/>
        </spirvextension>
        <spirvextension name="SPV_NV_raw_access_chains">
            <enable extension="VK_NV_raw_access_chains"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_compute_shader_derivatives">
            <enable extension="VK_KHR_compute_shader_derivatives"/>
        </spirvextension>
        <spirvextension name="SPV_EXT_replicated_composites">
            <enable extension="VK_EXT_shader_replicated_composites"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_relaxed_extended_instruction">
            <enable extension="VK_KHR_shader_relaxed_extended_instruction"/>
        </spirvextension>
        <spirvextension name="SPV_NV_cooperative_matrix2">
            <enable extension="VK_NV_cooperative_matrix2"/>
        </spirvextension>
        <spirvextension name="SPV_NV_tensor_addressing">
            <enable extension="VK_NV_cooperative_matrix2"/>
        </spirvextension>
        <spirvextension name="SPV_NV_linear_swept_spheres">
            <enable extension="VK_NV_ray_tracing_linear_swept_spheres"/>
        </spirvextension>
        <spirvextension name="SPV_NV_cluster_acceleration_structure">
            <enable extension="VK_NV_cluster_acceleration_structure"/>
        </spirvextension>
        <spirvextension name="SPV_NV_cooperative_vector">
            <enable extension="VK_NV_cooperative_vector"/>
        </spirvextension>
        <spirvextension name="SPV_EXT_shader_invocation_reorder">
            <enable extension="VK_EXT_ray_tracing_invocation_reorder"/>
        </spirvextension>
        <spirvextension name="SPV_QCOM_tile_shading">
            <enable extension="VK_QCOM_tile_shading"/>
        </spirvextension>
        <spirvextension name="SPV_ARM_tensors">
            <enable extension="VK_ARM_tensors"/>
        </spirvextension>
        <spirvextension name="SPV_EXT_float8">
            <enable extension="VK_EXT_shader_float8"/>
        </spirvextension>
        <spirvextension name="SPV_ARM_graph">
            <enable extension="VK_ARM_data_graph"/>
        </spirvextension>
        <spirvextension name="SPV_KHR_untyped_pointers">
            <enable extension="VK_KHR_shader_untyped_pointers"/>
        </spirvextension>
        <spirvextension name="SPV_EXT_shader_64bit_indexing">
            <enable extension="VK_EXT_shader_64bit_indexing"/>
        </spirvextension>
    </spirvextensions>
    <spirvcapabilities comment="SPIR-V Capabilities allowed in Vulkan and what is required to use it">
        <spirvcapability name="Matrix">
            <enable version="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="Shader">
            <enable version="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="InputAttachment">
            <enable version="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="Sampled1D">
            <enable version="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="Image1D">
            <enable version="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="SampledBuffer">
            <enable version="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="ImageBuffer">
            <enable version="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="ImageQuery">
            <enable version="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="DerivativeControl">
            <enable version="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="Geometry">
            <enable struct="VkPhysicalDeviceFeatures" feature="geometryShader" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="Tessellation">
            <enable struct="VkPhysicalDeviceFeatures" feature="tessellationShader" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="Float64">
            <enable struct="VkPhysicalDeviceFeatures" feature="shaderFloat64" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="Int64">
            <enable struct="VkPhysicalDeviceFeatures" feature="shaderInt64" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="Int64Atomics">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderBufferInt64Atomics" requires="VK_VERSION_1_2,VK_KHR_shader_atomic_int64"/>
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderSharedInt64Atomics" requires="VK_VERSION_1_2,VK_KHR_shader_atomic_int64"/>
            <enable struct="VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT" feature="shaderImageInt64Atomics" requires="VK_EXT_shader_image_atomic_int64"/>
        </spirvcapability>
        <spirvcapability name="AtomicFloat16AddEXT">
            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderBufferFloat16AtomicAdd" requires="VK_EXT_shader_atomic_float2"/>
            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderSharedFloat16AtomicAdd" requires="VK_EXT_shader_atomic_float2"/>
        </spirvcapability>
        <spirvcapability name="AtomicFloat32AddEXT">
            <enable struct="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT" feature="shaderBufferFloat32AtomicAdd" requires="VK_EXT_shader_atomic_float"/>
            <enable struct="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT" feature="shaderSharedFloat32AtomicAdd" requires="VK_EXT_shader_atomic_float"/>
            <enable struct="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT" feature="shaderImageFloat32AtomicAdd" requires="VK_EXT_shader_atomic_float"/>
        </spirvcapability>
        <spirvcapability name="AtomicFloat64AddEXT">
            <enable struct="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT" feature="shaderBufferFloat64AtomicAdd" requires="VK_EXT_shader_atomic_float"/>
            <enable struct="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT" feature="shaderSharedFloat64AtomicAdd" requires="VK_EXT_shader_atomic_float"/>
        </spirvcapability>
        <spirvcapability name="AtomicFloat16MinMaxEXT">
            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderBufferFloat16AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderSharedFloat16AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
        </spirvcapability>
        <spirvcapability name="AtomicFloat32MinMaxEXT">
            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderBufferFloat32AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderSharedFloat32AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderImageFloat32AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
        </spirvcapability>
        <spirvcapability name="AtomicFloat64MinMaxEXT">
            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderBufferFloat64AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderSharedFloat64AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
        </spirvcapability>
        <spirvcapability name="AtomicFloat16VectorNV">
            <enable struct="VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV" feature="shaderFloat16VectorAtomics" requires="VK_NV_shader_atomic_float16_vector"/>
        </spirvcapability>
        <spirvcapability name="Int64ImageEXT">
            <enable struct="VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT" feature="shaderImageInt64Atomics" requires="VK_EXT_shader_image_atomic_int64"/>
        </spirvcapability>
        <spirvcapability name="Int16">
            <enable struct="VkPhysicalDeviceFeatures" feature="shaderInt16" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="TessellationPointSize">
            <enable struct="VkPhysicalDeviceFeatures" feature="shaderTessellationAndGeometryPointSize" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="GeometryPointSize">
            <enable struct="VkPhysicalDeviceFeatures" feature="shaderTessellationAndGeometryPointSize" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="ImageGatherExtended">
            <enable struct="VkPhysicalDeviceFeatures" feature="shaderImageGatherExtended" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="StorageImageMultisample">
            <enable struct="VkPhysicalDeviceFeatures" feature="shaderStorageImageMultisample" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="UniformBufferArrayDynamicIndexing">
            <enable struct="VkPhysicalDeviceFeatures" feature="shaderUniformBufferArrayDynamicIndexing" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="SampledImageArrayDynamicIndexing">
            <enable struct="VkPhysicalDeviceFeatures" feature="shaderSampledImageArrayDynamicIndexing" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="StorageBufferArrayDynamicIndexing">
            <enable struct="VkPhysicalDeviceFeatures" feature="shaderStorageBufferArrayDynamicIndexing" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="StorageImageArrayDynamicIndexing">
            <enable struct="VkPhysicalDeviceFeatures" feature="shaderStorageImageArrayDynamicIndexing" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="ClipDistance">
            <enable struct="VkPhysicalDeviceFeatures" feature="shaderClipDistance" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="CullDistance">
            <enable struct="VkPhysicalDeviceFeatures" feature="shaderCullDistance" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="ImageCubeArray">
            <enable struct="VkPhysicalDeviceFeatures" feature="imageCubeArray" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="SampleRateShading">
            <enable struct="VkPhysicalDeviceFeatures" feature="sampleRateShading" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="SparseResidency">
            <enable struct="VkPhysicalDeviceFeatures" feature="shaderResourceResidency" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="MinLod">
            <enable struct="VkPhysicalDeviceFeatures" feature="shaderResourceMinLod" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="SampledCubeArray">
            <enable struct="VkPhysicalDeviceFeatures" feature="imageCubeArray" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="ImageMSArray">
            <enable struct="VkPhysicalDeviceFeatures" feature="shaderStorageImageMultisample" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="StorageImageExtendedFormats">
            <enable version="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="InterpolationFunction">
            <enable struct="VkPhysicalDeviceFeatures" feature="sampleRateShading" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="StorageImageReadWithoutFormat">
            <enable struct="VkPhysicalDeviceFeatures" feature="shaderStorageImageReadWithoutFormat" requires="VK_VERSION_1_0"/>
            <enable version="VK_VERSION_1_3"/>
            <enable extension="VK_KHR_format_feature_flags2"/>
        </spirvcapability>
        <spirvcapability name="StorageImageWriteWithoutFormat">
            <enable struct="VkPhysicalDeviceFeatures" feature="shaderStorageImageWriteWithoutFormat" requires="VK_VERSION_1_0"/>
            <enable version="VK_VERSION_1_3"/>
            <enable extension="VK_KHR_format_feature_flags2"/>
        </spirvcapability>
        <spirvcapability name="MultiViewport">
            <enable struct="VkPhysicalDeviceFeatures" feature="multiViewport" requires="VK_VERSION_1_0"/>
        </spirvcapability>
        <spirvcapability name="DrawParameters">
            <enable struct="VkPhysicalDeviceVulkan11Features" feature="shaderDrawParameters" requires="VK_VERSION_1_2"/>
            <enable struct="VkPhysicalDeviceShaderDrawParametersFeatures" feature="shaderDrawParameters" requires="VK_VERSION_1_1"/>
            <enable extension="VK_KHR_shader_draw_parameters"/>
        </spirvcapability>
        <spirvcapability name="MultiView">
            <enable struct="VkPhysicalDeviceVulkan11Features" feature="multiview" requires="VK_VERSION_1_2"/>
            <enable struct="VkPhysicalDeviceMultiviewFeatures" feature="multiview" requires="VK_KHR_multiview"/>
        </spirvcapability>
        <spirvcapability name="DeviceGroup">
            <enable version="VK_VERSION_1_1"/>
            <enable extension="VK_KHR_device_group"/>
        </spirvcapability>
        <spirvcapability name="VariablePointersStorageBuffer">
            <enable struct="VkPhysicalDeviceVulkan11Features" feature="variablePointersStorageBuffer" requires="VK_VERSION_1_2"/>
            <enable struct="VkPhysicalDeviceVariablePointersFeatures" feature="variablePointersStorageBuffer" requires="VK_KHR_variable_pointers"/>
        </spirvcapability>
        <spirvcapability name="VariablePointers">
            <enable struct="VkPhysicalDeviceVulkan11Features" feature="variablePointers" requires="VK_VERSION_1_2"/>
            <enable struct="VkPhysicalDeviceVariablePointersFeatures" feature="variablePointers" requires="VK_KHR_variable_pointers"/>
        </spirvcapability>
        <spirvcapability name="ShaderClockKHR">
            <enable extension="VK_KHR_shader_clock"/>
        </spirvcapability>
        <spirvcapability name="StencilExportEXT">
            <enable extension="VK_EXT_shader_stencil_export"/>
        </spirvcapability>
        <spirvcapability name="SubgroupBallotKHR">
            <enable extension="VK_EXT_shader_subgroup_ballot"/>
        </spirvcapability>
        <spirvcapability name="SubgroupVoteKHR">
            <enable extension="VK_EXT_shader_subgroup_vote"/>
        </spirvcapability>
        <spirvcapability name="ImageReadWriteLodAMD">
            <enable extension="VK_AMD_shader_image_load_store_lod"/>
        </spirvcapability>
        <spirvcapability name="ImageGatherBiasLodAMD">
            <enable extension="VK_AMD_texture_gather_bias_lod"/>
        </spirvcapability>
        <spirvcapability name="FragmentMaskAMD">
            <enable extension="VK_AMD_shader_fragment_mask"/>
        </spirvcapability>
        <spirvcapability name="SampleMaskOverrideCoverageNV">
            <enable extension="VK_NV_sample_mask_override_coverage"/>
        </spirvcapability>
        <spirvcapability name="GeometryShaderPassthroughNV">
            <enable extension="VK_NV_geometry_shader_passthrough"/>
        </spirvcapability>
        <spirvcapability name="ShaderViewportIndex">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderOutputViewportIndex" requires="VK_VERSION_1_2"/>
        </spirvcapability>
        <spirvcapability name="ShaderLayer">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderOutputLayer" requires="VK_VERSION_1_2"/>
        </spirvcapability>
        <spirvcapability name="ShaderViewportIndexLayerEXT">
            <enable extension="VK_EXT_shader_viewport_index_layer"/>
            <enable extension="VK_NV_viewport_array2"/>
        </spirvcapability>
        <spirvcapability name="ShaderViewportMaskNV">
            <enable extension="VK_NV_viewport_array2"/>
        </spirvcapability>
        <spirvcapability name="PerViewAttributesNV">
            <enable extension="VK_NVX_multiview_per_view_attributes"/>
        </spirvcapability>
        <spirvcapability name="StorageBuffer16BitAccess">
            <enable struct="VkPhysicalDeviceVulkan11Features" feature="storageBuffer16BitAccess" requires="VK_VERSION_1_2"/>
            <enable struct="VkPhysicalDevice16BitStorageFeatures" feature="storageBuffer16BitAccess" requires="VK_KHR_16bit_storage"/>
        </spirvcapability>
        <spirvcapability name="UniformAndStorageBuffer16BitAccess">
            <enable struct="VkPhysicalDeviceVulkan11Features" feature="uniformAndStorageBuffer16BitAccess" requires="VK_VERSION_1_2"/>
            <enable struct="VkPhysicalDevice16BitStorageFeatures" feature="uniformAndStorageBuffer16BitAccess" requires="VK_KHR_16bit_storage"/>
        </spirvcapability>
        <spirvcapability name="StoragePushConstant16">
            <enable struct="VkPhysicalDeviceVulkan11Features" feature="storagePushConstant16" requires="VK_VERSION_1_2"/>
            <enable struct="VkPhysicalDevice16BitStorageFeatures" feature="storagePushConstant16" requires="VK_KHR_16bit_storage"/>
        </spirvcapability>
        <spirvcapability name="StorageInputOutput16">
            <enable struct="VkPhysicalDeviceVulkan11Features" feature="storageInputOutput16" requires="VK_VERSION_1_2"/>
            <enable struct="VkPhysicalDevice16BitStorageFeatures" feature="storageInputOutput16" requires="VK_KHR_16bit_storage"/>
        </spirvcapability>
        <spirvcapability name="GroupNonUniform">
            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_BASIC_BIT" requires="VK_VERSION_1_1"/>
        </spirvcapability>
        <spirvcapability name="GroupNonUniformVote">
            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_VOTE_BIT" requires="VK_VERSION_1_1"/>
        </spirvcapability>
        <spirvcapability name="GroupNonUniformArithmetic">
            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_ARITHMETIC_BIT" requires="VK_VERSION_1_1"/>
        </spirvcapability>
        <spirvcapability name="GroupNonUniformBallot">
            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_BALLOT_BIT" requires="VK_VERSION_1_1"/>
        </spirvcapability>
        <spirvcapability name="GroupNonUniformShuffle">
            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_SHUFFLE_BIT" requires="VK_VERSION_1_1"/>
        </spirvcapability>
        <spirvcapability name="GroupNonUniformShuffleRelative">
            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT" requires="VK_VERSION_1_1"/>
        </spirvcapability>
        <spirvcapability name="GroupNonUniformClustered">
            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_CLUSTERED_BIT" requires="VK_VERSION_1_1"/>
        </spirvcapability>
        <spirvcapability name="GroupNonUniformQuad">
            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_QUAD_BIT" requires="VK_VERSION_1_1"/>
        </spirvcapability>
        <spirvcapability name="GroupNonUniformPartitionedNV">
            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV" requires="VK_NV_shader_subgroup_partitioned"/>
        </spirvcapability>
        <spirvcapability name="SampleMaskPostDepthCoverage">
            <enable extension="VK_EXT_post_depth_coverage"/>
        </spirvcapability>
        <spirvcapability name="ShaderNonUniform">
            <enable version="VK_VERSION_1_2"/>
            <enable extension="VK_EXT_descriptor_indexing"/>
        </spirvcapability>
        <spirvcapability name="RuntimeDescriptorArray">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="runtimeDescriptorArray" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
        </spirvcapability>
        <spirvcapability name="InputAttachmentArrayDynamicIndexing">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderInputAttachmentArrayDynamicIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
        </spirvcapability>
        <spirvcapability name="UniformTexelBufferArrayDynamicIndexing">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderUniformTexelBufferArrayDynamicIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
        </spirvcapability>
        <spirvcapability name="StorageTexelBufferArrayDynamicIndexing">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderStorageTexelBufferArrayDynamicIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
        </spirvcapability>
        <spirvcapability name="UniformBufferArrayNonUniformIndexing">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderUniformBufferArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
        </spirvcapability>
        <spirvcapability name="SampledImageArrayNonUniformIndexing">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderSampledImageArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
        </spirvcapability>
        <spirvcapability name="StorageBufferArrayNonUniformIndexing">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderStorageBufferArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
        </spirvcapability>
        <spirvcapability name="StorageImageArrayNonUniformIndexing">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderStorageImageArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
        </spirvcapability>
        <spirvcapability name="InputAttachmentArrayNonUniformIndexing">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderInputAttachmentArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
        </spirvcapability>
        <spirvcapability name="UniformTexelBufferArrayNonUniformIndexing">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderUniformTexelBufferArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
        </spirvcapability>
        <spirvcapability name="StorageTexelBufferArrayNonUniformIndexing">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderStorageTexelBufferArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
        </spirvcapability>
        <spirvcapability name="FragmentFullyCoveredEXT">
            <enable extension="VK_EXT_conservative_rasterization"/>
        </spirvcapability>
        <spirvcapability name="Float16">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderFloat16" requires="VK_VERSION_1_2,VK_KHR_shader_float16_int8"/>
            <enable extension="VK_AMD_gpu_shader_half_float"/>
        </spirvcapability>
        <spirvcapability name="Int8">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderInt8" requires="VK_VERSION_1_2,VK_KHR_shader_float16_int8"/>
        </spirvcapability>
        <spirvcapability name="StorageBuffer8BitAccess">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="storageBuffer8BitAccess" requires="VK_VERSION_1_2,VK_KHR_8bit_storage"/>
        </spirvcapability>
        <spirvcapability name="UniformAndStorageBuffer8BitAccess">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="uniformAndStorageBuffer8BitAccess" requires="VK_VERSION_1_2,VK_KHR_8bit_storage"/>
        </spirvcapability>
        <spirvcapability name="StoragePushConstant8">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="storagePushConstant8" requires="VK_VERSION_1_2,VK_KHR_8bit_storage"/>
        </spirvcapability>
        <spirvcapability name="VulkanMemoryModel">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="vulkanMemoryModel" requires="VK_VERSION_1_2,VK_KHR_vulkan_memory_model"/>
        </spirvcapability>
        <spirvcapability name="VulkanMemoryModelDeviceScope">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="vulkanMemoryModelDeviceScope" requires="VK_VERSION_1_2,VK_KHR_vulkan_memory_model"/>
        </spirvcapability>
        <spirvcapability name="DenormPreserve">
            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderDenormPreserveFloat16" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderDenormPreserveFloat32" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderDenormPreserveFloat64" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
        </spirvcapability>
        <spirvcapability name="DenormFlushToZero">
            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderDenormFlushToZeroFloat16" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderDenormFlushToZeroFloat32" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderDenormFlushToZeroFloat64" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
        </spirvcapability>
        <spirvcapability name="SignedZeroInfNanPreserve">
            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderSignedZeroInfNanPreserveFloat16" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderSignedZeroInfNanPreserveFloat32" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderSignedZeroInfNanPreserveFloat64" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
        </spirvcapability>
        <spirvcapability name="RoundingModeRTE">
            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderRoundingModeRTEFloat16" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderRoundingModeRTEFloat32" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderRoundingModeRTEFloat64" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
        </spirvcapability>
        <spirvcapability name="RoundingModeRTZ">
            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderRoundingModeRTZFloat16" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderRoundingModeRTZFloat32" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderRoundingModeRTZFloat64" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
        </spirvcapability>
        <spirvcapability name="ComputeDerivativeGroupQuadsKHR">
            <enable struct="VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR" feature="computeDerivativeGroupQuads" requires="VK_KHR_compute_shader_derivatives"/>
            <enable struct="VkPhysicalDeviceComputeShaderDerivativesFeaturesNV" feature="computeDerivativeGroupQuads" requires="VK_NV_compute_shader_derivatives"/>
        </spirvcapability>
        <spirvcapability name="ComputeDerivativeGroupLinearKHR">
            <enable struct="VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR" feature="computeDerivativeGroupLinear" requires="VK_KHR_compute_shader_derivatives"/>
            <enable struct="VkPhysicalDeviceComputeShaderDerivativesFeaturesNV" feature="computeDerivativeGroupLinear" requires="VK_NV_compute_shader_derivatives"/>
        </spirvcapability>
        <spirvcapability name="ImageFootprintNV">
            <enable struct="VkPhysicalDeviceShaderImageFootprintFeaturesNV" feature="imageFootprint" requires="VK_NV_shader_image_footprint"/>
        </spirvcapability>
        <spirvcapability name="MeshShadingNV">
            <enable extension="VK_NV_mesh_shader"/>
        </spirvcapability>
        <spirvcapability name="RayTracingKHR">
            <enable struct="VkPhysicalDeviceRayTracingPipelineFeaturesKHR" feature="rayTracingPipeline" requires="VK_KHR_ray_tracing_pipeline"/>
        </spirvcapability>
        <spirvcapability name="RayQueryKHR">
            <enable struct="VkPhysicalDeviceRayQueryFeaturesKHR" feature="rayQuery" requires="VK_KHR_ray_query"/>
        </spirvcapability>
        <spirvcapability name="RayTraversalPrimitiveCullingKHR">
            <enable struct="VkPhysicalDeviceRayTracingPipelineFeaturesKHR" feature="rayTraversalPrimitiveCulling" requires="VK_KHR_ray_tracing_pipeline"/>
            <enable struct="VkPhysicalDeviceRayQueryFeaturesKHR" feature="rayQuery" requires="VK_KHR_ray_query"/>
        </spirvcapability>
        <spirvcapability name="RayCullMaskKHR">
            <enable struct="VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR" feature="rayTracingMaintenance1" requires="VK_KHR_ray_tracing_maintenance1"/>
        </spirvcapability>
        <spirvcapability name="RayTracingNV">
            <enable extension="VK_NV_ray_tracing"/>
        </spirvcapability>
        <spirvcapability name="RayTracingMotionBlurNV">
            <enable struct="VkPhysicalDeviceRayTracingMotionBlurFeaturesNV" feature="rayTracingMotionBlur" requires="VK_NV_ray_tracing_motion_blur"/>
        </spirvcapability>
        <spirvcapability name="TransformFeedback">
            <enable struct="VkPhysicalDeviceTransformFeedbackFeaturesEXT" feature="transformFeedback" requires="VK_EXT_transform_feedback"/>
        </spirvcapability>
        <spirvcapability name="GeometryStreams">
            <enable struct="VkPhysicalDeviceTransformFeedbackFeaturesEXT" feature="geometryStreams" requires="VK_EXT_transform_feedback"/>
        </spirvcapability>
        <spirvcapability name="FragmentDensityEXT">
            <enable struct="VkPhysicalDeviceFragmentDensityMapFeaturesEXT" feature="fragmentDensityMap" requires="VK_EXT_fragment_density_map"/>
            <enable struct="VkPhysicalDeviceShadingRateImageFeaturesNV" feature="shadingRateImage" requires="VK_NV_shading_rate_image"/>
        </spirvcapability>
        <spirvcapability name="PhysicalStorageBufferAddresses">
            <enable struct="VkPhysicalDeviceVulkan12Features" feature="bufferDeviceAddress" requires="VK_VERSION_1_2,VK_KHR_buffer_device_address"/>
            <enable struct="VkPhysicalDeviceBufferDeviceAddressFeaturesEXT" feature="bufferDeviceAddress" requires="VK_EXT_buffer_device_address" alias="bufferDeviceAddressEXT"/>
        </spirvcapability>
        <spirvcapability name="CooperativeMatrixNV">
            <enable struct="VkPhysicalDeviceCooperativeMatrixFeaturesNV" feature="cooperativeMatrix" requires="VK_NV_cooperative_matrix" alias="cooperativeMatrixNV"/>
        </spirvcapability>
        <spirvcapability name="IntegerFunctions2INTEL">
            <enable struct="VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL" feature="shaderIntegerFunctions2" requires="VK_INTEL_shader_integer_functions2"/>
        </spirvcapability>
        <spirvcapability name="ShaderSMBuiltinsNV">
            <enable struct="VkPhysicalDeviceShaderSMBuiltinsFeaturesNV" feature="shaderSMBuiltins" requires="VK_NV_shader_sm_builtins"/>
        </spirvcapability>
        <spirvcapability name="FragmentShaderSampleInterlockEXT">
            <enable struct="VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT" feature="fragmentShaderSampleInterlock" requires="VK_EXT_fragment_shader_interlock"/>
        </spirvcapability>
        <spirvcapability name="FragmentShaderPixelInterlockEXT">
            <enable struct="VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT" feature="fragmentShaderPixelInterlock" requires="VK_EXT_fragment_shader_interlock"/>
        </spirvcapability>
        <spirvcapability name="FragmentShaderShadingRateInterlockEXT">
            <enable struct="VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT" feature="fragmentShaderShadingRateInterlock" requires="VK_EXT_fragment_shader_interlock"/>
            <enable struct="VkPhysicalDeviceShadingRateImageFeaturesNV" feature="shadingRateImage" requires="VK_NV_shading_rate_image"/>
        </spirvcapability>
        <spirvcapability name="DemoteToHelperInvocation">
            <enable struct="VkPhysicalDeviceVulkan13Features" feature="shaderDemoteToHelperInvocation" requires="VK_VERSION_1_3,VK_EXT_shader_demote_to_helper_invocation"/>
            <enable struct="VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT" feature="shaderDemoteToHelperInvocation" requires="VK_EXT_shader_demote_to_helper_invocation"/>
        </spirvcapability>
        <spirvcapability name="FragmentShadingRateKHR">
            <enable struct="VkPhysicalDeviceFragmentShadingRateFeaturesKHR" feature="pipelineFragmentShadingRate" requires="VK_KHR_fragment_shading_rate"/>
            <enable struct="VkPhysicalDeviceFragmentShadingRateFeaturesKHR" feature="primitiveFragmentShadingRate" requires="VK_KHR_fragment_shading_rate"/>
            <enable struct="VkPhysicalDeviceFragmentShadingRateFeaturesKHR" feature="attachmentFragmentShadingRate" requires="VK_KHR_fragment_shading_rate"/>
        </spirvcapability>
        <spirvcapability name="WorkgroupMemoryExplicitLayoutKHR">
            <enable struct="VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR" feature="workgroupMemoryExplicitLayout" requires="VK_KHR_workgroup_memory_explicit_layout"/>
        </spirvcapability>
        <spirvcapability name="WorkgroupMemoryExplicitLayout8BitAccessKHR">
            <enable struct="VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR" feature="workgroupMemoryExplicitLayout8BitAccess" requires="VK_KHR_workgroup_memory_explicit_layout"/>
        </spirvcapability>
        <spirvcapability name="WorkgroupMemoryExplicitLayout16BitAccessKHR">
            <enable struct="VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR" feature="workgroupMemoryExplicitLayout16BitAccess" requires="VK_KHR_workgroup_memory_explicit_layout"/>
        </spirvcapability>
        <spirvcapability name="DotProductInputAll">
            <enable struct="VkPhysicalDeviceVulkan13Features" feature="shaderIntegerDotProduct" requires="VK_VERSION_1_3,VK_KHR_shader_integer_dot_product"/>
            <enable struct="VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR" feature="shaderIntegerDotProduct" requires="VK_KHR_shader_integer_dot_product"/>
        </spirvcapability>
        <spirvcapability name="DotProductInput4x8Bit">
            <enable struct="VkPhysicalDeviceVulkan13Features" feature="shaderIntegerDotProduct" requires="VK_VERSION_1_3,VK_KHR_shader_integer_dot_product"/>
            <enable struct="VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR" feature="shaderIntegerDotProduct" requires="VK_KHR_shader_integer_dot_product"/>
        </spirvcapability>
        <spirvcapability name="DotProductInput4x8BitPacked">
            <enable struct="VkPhysicalDeviceVulkan13Features" feature="shaderIntegerDotProduct" requires="VK_VERSION_1_3,VK_KHR_shader_integer_dot_product"/>
            <enable struct="VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR" feature="shaderIntegerDotProduct" requires="VK_KHR_shader_integer_dot_product"/>
        </spirvcapability>
        <spirvcapability name="DotProduct">
            <enable struct="VkPhysicalDeviceVulkan13Features" feature="shaderIntegerDotProduct" requires="VK_VERSION_1_3,VK_KHR_shader_integer_dot_product"/>
            <enable struct="VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR" feature="shaderIntegerDotProduct" requires="VK_KHR_shader_integer_dot_product"/>
        </spirvcapability>
        <spirvcapability name="FragmentBarycentricKHR">
            <enable struct="VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR" feature="fragmentShaderBarycentric" requires="VK_KHR_fragment_shader_barycentric"/>
            <enable struct="VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV" feature="fragmentShaderBarycentric" requires="VK_NV_fragment_shader_barycentric"/>
        </spirvcapability>
        <spirvcapability name="TextureSampleWeightedQCOM">
            <enable struct="VkPhysicalDeviceImageProcessingFeaturesQCOM" feature="textureSampleWeighted" requires="VK_QCOM_image_processing"/>
        </spirvcapability>
        <spirvcapability name="TextureBoxFilterQCOM">
            <enable struct="VkPhysicalDeviceImageProcessingFeaturesQCOM" feature="textureBoxFilter" requires="VK_QCOM_image_processing"/>
        </spirvcapability>
        <spirvcapability name="TextureBlockMatchQCOM">
            <enable struct="VkPhysicalDeviceImageProcessingFeaturesQCOM" feature="textureBlockMatch" requires="VK_QCOM_image_processing"/>
        </spirvcapability>
        <spirvcapability name="TextureBlockMatch2QCOM">
            <enable struct="VkPhysicalDeviceImageProcessing2FeaturesQCOM" feature="textureBlockMatch2" requires="VK_QCOM_image_processing2"/>
        </spirvcapability>
        <spirvcapability name="MeshShadingEXT">
            <enable extension="VK_EXT_mesh_shader"/>
        </spirvcapability>
        <spirvcapability name="RayTracingOpacityMicromapEXT">
            <enable extension="VK_EXT_opacity_micromap"/>
        </spirvcapability>
        <spirvcapability name="CoreBuiltinsARM">
            <enable struct="VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM" feature="shaderCoreBuiltins" requires="VK_ARM_shader_core_builtins"/>
        </spirvcapability>
        <spirvcapability name="ShaderInvocationReorderNV">
            <enable extension="VK_NV_ray_tracing_invocation_reorder"/>
        </spirvcapability>
        <spirvcapability name="ClusterCullingShadingHUAWEI">
            <enable struct="VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI" feature="clustercullingShader" requires="VK_HUAWEI_cluster_culling_shader"/>
        </spirvcapability>
        <spirvcapability name="RayTracingPositionFetchKHR">
            <enable struct="VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR" feature="rayTracingPositionFetch" requires="VK_KHR_ray_tracing_position_fetch"/>
        </spirvcapability>
        <spirvcapability name="RayQueryPositionFetchKHR">
            <enable struct="VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR" feature="rayTracingPositionFetch" requires="VK_KHR_ray_tracing_position_fetch"/>
        </spirvcapability>
        <spirvcapability name="TileImageColorReadAccessEXT">
            <enable struct="VkPhysicalDeviceShaderTileImageFeaturesEXT" feature="shaderTileImageColorReadAccess" requires="VK_EXT_shader_tile_image"/>
        </spirvcapability>
        <spirvcapability name="TileImageDepthReadAccessEXT">
            <enable struct="VkPhysicalDeviceShaderTileImageFeaturesEXT" feature="shaderTileImageDepthReadAccess" requires="VK_EXT_shader_tile_image"/>
        </spirvcapability>
        <spirvcapability name="TileImageStencilReadAccessEXT">
            <enable struct="VkPhysicalDeviceShaderTileImageFeaturesEXT" feature="shaderTileImageStencilReadAccess" requires="VK_EXT_shader_tile_image"/>
        </spirvcapability>
        <spirvcapability name="CooperativeMatrixKHR">
            <enable struct="VkPhysicalDeviceCooperativeMatrixFeaturesKHR" feature="cooperativeMatrix" requires="VK_KHR_cooperative_matrix"/>
        </spirvcapability>
        <spirvcapability name="ShaderEnqueueAMDX">
            <enable struct="VkPhysicalDeviceShaderEnqueueFeaturesAMDX" feature="shaderEnqueue" requires="VK_AMDX_shader_enqueue"/>
        </spirvcapability>
        <spirvcapability name="GroupNonUniformRotateKHR">
            <enable struct="VkPhysicalDeviceVulkan14Features" feature="shaderSubgroupRotate" requires="VK_VERSION_1_4,VK_KHR_shader_subgroup_rotate"/>
            <enable struct="VkPhysicalDeviceShaderSubgroupRotateFeatures" feature="shaderSubgroupRotate" requires="VK_KHR_shader_subgroup_rotate"/>
        </spirvcapability>
        <spirvcapability name="ExpectAssumeKHR">
            <enable struct="VkPhysicalDeviceVulkan14Features" feature="shaderExpectAssume" requires="VK_VERSION_1_4,VK_KHR_shader_expect_assume"/>
            <enable struct="VkPhysicalDeviceShaderExpectAssumeFeatures" feature="shaderExpectAssume" requires="VK_KHR_shader_expect_assume"/>
        </spirvcapability>
        <spirvcapability name="FloatControls2">
            <enable struct="VkPhysicalDeviceVulkan14Features" feature="shaderFloatControls2" requires="VK_VERSION_1_4,VK_KHR_shader_float_controls2"/>
            <enable struct="VkPhysicalDeviceShaderFloatControls2Features" feature="shaderFloatControls2" requires="VK_KHR_shader_float_controls2"/>
        </spirvcapability>
        <spirvcapability name="QuadControlKHR">
            <enable struct="VkPhysicalDeviceShaderQuadControlFeaturesKHR" feature="shaderQuadControl" requires="VK_KHR_shader_quad_control"/>
        </spirvcapability>
        <spirvcapability name="BFloat16TypeKHR">
            <enable struct="VkPhysicalDeviceShaderBfloat16FeaturesKHR" feature="shaderBFloat16Type" requires="VK_KHR_shader_bfloat16"/>
        </spirvcapability>
        <spirvcapability name="BFloat16DotProductKHR">
            <enable struct="VkPhysicalDeviceShaderBfloat16FeaturesKHR" feature="shaderBFloat16DotProduct" requires="VK_KHR_shader_bfloat16"/>
        </spirvcapability>
        <spirvcapability name="BFloat16CooperativeMatrixKHR">
            <enable struct="VkPhysicalDeviceShaderBfloat16FeaturesKHR" feature="shaderBFloat16CooperativeMatrix" requires="VK_KHR_shader_bfloat16"/>
        </spirvcapability>
        <spirvcapability name="RawAccessChainsNV">
            <enable struct="VkPhysicalDeviceRawAccessChainsFeaturesNV" feature="shaderRawAccessChains" requires="VK_NV_raw_access_chains"/>
        </spirvcapability>
        <spirvcapability name="ReplicatedCompositesEXT">
            <enable struct="VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT" feature="shaderReplicatedComposites" requires="VK_EXT_shader_replicated_composites"/>
        </spirvcapability>
        <spirvcapability name="TensorAddressingNV">
            <enable struct="VkPhysicalDeviceCooperativeMatrix2FeaturesNV" feature="cooperativeMatrixTensorAddressing" requires="VK_NV_cooperative_matrix2"/>
        </spirvcapability>
        <spirvcapability name="CooperativeMatrixReductionsNV">
            <enable struct="VkPhysicalDeviceCooperativeMatrix2FeaturesNV" feature="cooperativeMatrixReductions" requires="VK_NV_cooperative_matrix2"/>
        </spirvcapability>
        <spirvcapability name="CooperativeMatrixConversionsNV">
            <enable struct="VkPhysicalDeviceCooperativeMatrix2FeaturesNV" feature="cooperativeMatrixConversions" requires="VK_NV_cooperative_matrix2"/>
        </spirvcapability>
        <spirvcapability name="CooperativeMatrixPerElementOperationsNV">
            <enable struct="VkPhysicalDeviceCooperativeMatrix2FeaturesNV" feature="cooperativeMatrixPerElementOperations" requires="VK_NV_cooperative_matrix2"/>
        </spirvcapability>
        <spirvcapability name="CooperativeMatrixTensorAddressingNV">
            <enable struct="VkPhysicalDeviceCooperativeMatrix2FeaturesNV" feature="cooperativeMatrixTensorAddressing" requires="VK_NV_cooperative_matrix2"/>
        </spirvcapability>
        <spirvcapability name="CooperativeMatrixBlockLoadsNV">
            <enable struct="VkPhysicalDeviceCooperativeMatrix2FeaturesNV" feature="cooperativeMatrixBlockLoads" requires="VK_NV_cooperative_matrix2"/>
        </spirvcapability>
        <spirvcapability name="RayTracingSpheresGeometryNV">
            <enable struct="VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV" feature="spheres" requires="VK_NV_ray_tracing_linear_swept_spheres"/>
        </spirvcapability>
        <spirvcapability name="RayTracingLinearSweptSpheresGeometryNV">
            <enable struct="VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV" feature="linearSweptSpheres" requires="VK_NV_ray_tracing_linear_swept_spheres"/>
        </spirvcapability>
        <spirvcapability name="RayTracingClusterAccelerationStructureNV">
            <enable struct="VkPhysicalDeviceClusterAccelerationStructureFeaturesNV" feature="clusterAccelerationStructure" requires="VK_NV_cluster_acceleration_structure"/>
        </spirvcapability>
        <spirvcapability name="CooperativeVectorNV">
            <enable struct="VkPhysicalDeviceCooperativeVectorFeaturesNV" feature="cooperativeVector" requires="VK_NV_cooperative_vector"/>
        </spirvcapability>
        <spirvcapability name="CooperativeVectorTrainingNV">
            <enable struct="VkPhysicalDeviceCooperativeVectorFeaturesNV" feature="cooperativeVectorTraining" requires="VK_NV_cooperative_vector"/>
        </spirvcapability>
        <spirvcapability name="ShaderInvocationReorderEXT">
            <enable extension="VK_EXT_ray_tracing_invocation_reorder"/>
        </spirvcapability>
        <spirvcapability name="TileShadingQCOM">
            <enable struct="VkPhysicalDeviceTileShadingFeaturesQCOM" feature="tileShading" requires="VK_QCOM_tile_shading"/>
        </spirvcapability>
        <spirvcapability name="TensorsARM">
            <enable struct="VkPhysicalDeviceTensorFeaturesARM" feature="shaderTensorAccess" requires="VK_ARM_tensors"/>
        </spirvcapability>
        <spirvcapability name="StorageTensorArrayDynamicIndexingARM">
            <enable struct="VkPhysicalDeviceTensorFeaturesARM" feature="shaderStorageTensorArrayDynamicIndexing" requires="VK_ARM_tensors"/>
        </spirvcapability>
        <spirvcapability name="StorageTensorArrayNonUniformIndexingARM">
            <enable struct="VkPhysicalDeviceTensorFeaturesARM" feature="shaderStorageTensorArrayNonUniformIndexing" requires="VK_ARM_tensors"/>
        </spirvcapability>
        <spirvcapability name="Float8EXT">
            <enable struct="VkPhysicalDeviceShaderFloat8FeaturesEXT" feature="shaderFloat8" requires="VK_EXT_shader_float8"/>
        </spirvcapability>
        <spirvcapability name="Float8CooperativeMatrixEXT">
            <enable struct="VkPhysicalDeviceShaderFloat8FeaturesEXT" feature="shaderFloat8CooperativeMatrix" requires="VK_EXT_shader_float8"/>
        </spirvcapability>
        <spirvcapability name="GraphARM">
            <enable struct="VkPhysicalDeviceDataGraphFeaturesARM" feature="dataGraph" requires="VK_ARM_data_graph"/>
        </spirvcapability>
        <spirvcapability name="UntypedPointersKHR">
            <enable struct="VkPhysicalDeviceShaderUntypedPointersFeaturesKHR" feature="shaderUntypedPointers" requires="VK_KHR_shader_untyped_pointers"/>
        </spirvcapability>
        <spirvcapability name="FMAKHR">
            <enable struct="VkPhysicalDeviceShaderFmaFeaturesKHR" feature="shaderFmaFloat16" requires="VK_KHR_shader_fma"/>
            <enable struct="VkPhysicalDeviceShaderFmaFeaturesKHR" feature="shaderFmaFloat32" requires="VK_KHR_shader_fma"/>
            <enable struct="VkPhysicalDeviceShaderFmaFeaturesKHR" feature="shaderFmaFloat64" requires="VK_KHR_shader_fma"/>
        </spirvcapability>
        <spirvcapability name="Shader64BitIndexingEXT">
            <enable struct="VkPhysicalDeviceShader64BitIndexingFeaturesEXT" feature="shader64BitIndexing" requires="VK_EXT_shader_64bit_indexing"/>
        </spirvcapability>
    </spirvcapabilities>
    <sync comment="Machine readable representation of the synchronization objects and their mappings">
        <syncstage name="VK_PIPELINE_STAGE_2_NONE" alias="VK_PIPELINE_STAGE_NONE">
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT" alias="VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT">
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT" alias="VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_COPY_INDIRECT_BIT_KHR">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT" alias="VK_PIPELINE_STAGE_VERTEX_INPUT_BIT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
            <syncequivalent stage="VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT,VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT" alias="VK_PIPELINE_STAGE_VERTEX_SHADER_BIT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT" alias="VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT" alias="VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT" alias="VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT" alias="VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT" alias="VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT" alias="VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT" alias="VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT" alias="VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT">
            <syncsupport queues="VK_QUEUE_COMPUTE_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT" alias="VK_PIPELINE_STAGE_TRANSFER_BIT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT"/>
            <syncequivalent stage="VK_PIPELINE_STAGE_2_COPY_BIT,VK_PIPELINE_STAGE_2_BLIT_BIT,VK_PIPELINE_STAGE_2_RESOLVE_BIT,VK_PIPELINE_STAGE_2_CLEAR_BIT,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT" alias="VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT">
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_HOST_BIT" alias="VK_PIPELINE_STAGE_HOST_BIT">
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT" alias="VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
            <syncequivalent stage="VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT,VK_PIPELINE_STAGE_2_COPY_INDIRECT_BIT_KHR,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT,VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT,VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT,VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT,VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT,VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT" alias="VK_PIPELINE_STAGE_ALL_COMMANDS_BIT">
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_COPY_BIT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_RESOLVE_BIT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_BLIT_BIT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_CLEAR_BIT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
            <syncequivalent stage="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR">
            <syncsupport queues="VK_QUEUE_VIDEO_DECODE_BIT_KHR"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR">
            <syncsupport queues="VK_QUEUE_VIDEO_ENCODE_BIT_KHR"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT" alias="VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT" alias="VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT" alias="VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_MEMORY_DECOMPRESSION_BIT_EXT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR" alias="VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR" alias="VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR">
            <syncsupport queues="VK_QUEUE_COMPUTE_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR" alias="VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR">
            <syncsupport queues="VK_QUEUE_COMPUTE_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT" alias="VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT" alias="VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT" alias="VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT">
            <syncsupport queues="VK_QUEUE_COMPUTE_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV">
            <syncsupport queues="VK_QUEUE_OPTICAL_FLOW_BIT_NV"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_CONVERT_COOPERATIVE_VECTOR_MATRIX_BIT_NV">
            <syncsupport queues="VK_QUEUE_GRAPHICS_BIT,VK_QUEUE_COMPUTE_BIT,VK_QUEUE_TRANSFER_BIT"/>
        </syncstage>
        <syncstage name="VK_PIPELINE_STAGE_2_DATA_GRAPH_BIT_ARM">
            <syncsupport queues="VK_QUEUE_DATA_GRAPH_BIT_ARM"/>
        </syncstage>
        <syncaccess name="VK_ACCESS_2_NONE" alias="VK_ACCESS_NONE">
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT" alias="VK_ACCESS_INDIRECT_COMMAND_READ_BIT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,VK_PIPELINE_STAGE_2_COPY_INDIRECT_BIT_KHR"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_INDEX_READ_BIT" alias="VK_ACCESS_INDEX_READ_BIT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT,VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT" alias="VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT,VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_UNIFORM_READ_BIT" alias="VK_ACCESS_UNIFORM_READ_BIT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT" alias="VK_ACCESS_INPUT_ATTACHMENT_READ_BIT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_SHADER_READ_BIT" alias="VK_ACCESS_SHADER_READ_BIT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT,VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
            <syncequivalent access="VK_ACCESS_2_SHADER_SAMPLED_READ_BIT,VK_ACCESS_2_SHADER_STORAGE_READ_BIT,VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR,VK_ACCESS_2_SHADER_TILE_ATTACHMENT_READ_BIT_QCOM"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_SHADER_WRITE_BIT" alias="VK_ACCESS_SHADER_WRITE_BIT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
            <syncequivalent access="VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT,VK_ACCESS_2_SHADER_TILE_ATTACHMENT_WRITE_BIT_QCOM"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT" alias="VK_ACCESS_COLOR_ATTACHMENT_READ_BIT">
            <comment>Fragment shader stage is added by the VK_EXT_shader_tile_image extension</comment>
            <syncsupport stage="VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT" alias="VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT" alias="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT">
            <comment>Fragment shader stage is added by the VK_EXT_shader_tile_image extension</comment>
            <syncsupport stage="VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT,VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT" alias="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT,VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_TRANSFER_READ_BIT" alias="VK_ACCESS_TRANSFER_READ_BIT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT,VK_PIPELINE_STAGE_2_COPY_BIT,VK_PIPELINE_STAGE_2_RESOLVE_BIT,VK_PIPELINE_STAGE_2_BLIT_BIT,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR,VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT,VK_PIPELINE_STAGE_2_CONVERT_COOPERATIVE_VECTOR_MATRIX_BIT_NV"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_TRANSFER_WRITE_BIT" alias="VK_ACCESS_TRANSFER_WRITE_BIT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT,VK_PIPELINE_STAGE_2_COPY_BIT,VK_PIPELINE_STAGE_2_RESOLVE_BIT,VK_PIPELINE_STAGE_2_BLIT_BIT,VK_PIPELINE_STAGE_2_CLEAR_BIT,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR,VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT,VK_PIPELINE_STAGE_2_CONVERT_COOPERATIVE_VECTOR_MATRIX_BIT_NV"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_HOST_READ_BIT" alias="VK_ACCESS_HOST_READ_BIT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_HOST_BIT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_HOST_WRITE_BIT" alias="VK_ACCESS_HOST_WRITE_BIT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_HOST_BIT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_MEMORY_READ_BIT" alias="VK_ACCESS_MEMORY_READ_BIT">
            <comment>TODO/Suggestion. Introduce 'synclist' (could be a different name) element
            that specifies the list of stages, accesses, etc. This list can be used by
            'syncaccess' or 'syncstage' elements. For example, 'syncsupport' in addition to the
            'stage' attribute can support 'list' attribute to reference 'synclist'.
            We can have the lists defined for ALL stages and it can be shared between MEMORY_READ
            and MEMORY_WRITE accesses. Similarly, ALL shader stages list is often used. This proposal
            is a way to fix duplication problem. When new stage is added multiple places needs to be
            updated. It is potential source of bugs. The expectation such setup will produce more
            robust system and also more simple structure to review and validate.
            </comment>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_MEMORY_WRITE_BIT" alias="VK_ACCESS_MEMORY_WRITE_BIT">
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_SHADER_SAMPLED_READ_BIT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_SHADER_STORAGE_READ_BIT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR">
            <syncsupport stage="VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR">
            <syncsupport stage="VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR">
            <syncsupport stage="VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR">
            <syncsupport stage="VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT" alias="VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT" alias="VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT,VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT" alias="VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT" alias="VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT" alias="VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT" alias="VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_MEMORY_DECOMPRESSION_READ_BIT_EXT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_MEMORY_DECOMPRESSION_BIT_EXT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_MEMORY_DECOMPRESSION_WRITE_BIT_EXT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_MEMORY_DECOMPRESSION_BIT_EXT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR" alias="VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR">
            <syncsupport stage="VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR" alias="VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR">
            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR" alias="VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR">
            <syncsupport stage="VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT" alias="VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT" alias="VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI">
            <syncsupport stage="VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR">
            <syncsupport stage="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT,VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT,VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT,VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR,VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT,VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI,VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_MICROMAP_READ_BIT_EXT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT,VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT">
            <syncsupport stage="VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV">
            <syncsupport stage="VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV">
            <syncsupport stage="VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_SHADER_TILE_ATTACHMENT_READ_BIT_QCOM">
            <syncsupport stage="VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_SHADER_TILE_ATTACHMENT_WRITE_BIT_QCOM">
            <syncsupport stage="VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_DATA_GRAPH_READ_BIT_ARM">
            <syncsupport stage="VK_PIPELINE_STAGE_2_DATA_GRAPH_BIT_ARM"/>
        </syncaccess>
        <syncaccess name="VK_ACCESS_2_DATA_GRAPH_WRITE_BIT_ARM">
            <syncsupport stage="VK_PIPELINE_STAGE_2_DATA_GRAPH_BIT_ARM"/>
        </syncaccess>
        <syncpipeline name="graphics primitive">
            <syncpipelinestage>VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_COPY_INDIRECT_BIT_KHR</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR</syncpipelinestage>
            <syncpipelinestage order="None" before="VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT">VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT</syncpipelinestage>
            <syncpipelinestage order="None">VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT</syncpipelinestage>
        </syncpipeline>
        <syncpipeline name="graphics mesh" depends="VK_NV_mesh_shader,VK_EXT_mesh_shader">
            <syncpipelinestage>VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR</syncpipelinestage>
            <syncpipelinestage order="None" before="VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT">VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT</syncpipelinestage>
            <syncpipelinestage order="None">VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT</syncpipelinestage>
        </syncpipeline>
        <syncpipeline name="compute">
            <syncpipelinestage>VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_COPY_INDIRECT_BIT_KHR</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT</syncpipelinestage>
            <syncpipelinestage order="None">VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT</syncpipelinestage>
        </syncpipeline>
        <syncpipeline name="transfer">
            <syncpipelinestage>VK_PIPELINE_STAGE_2_COPY_INDIRECT_BIT_KHR</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_TRANSFER_BIT</syncpipelinestage>
        </syncpipeline>
        <syncpipeline name="host">
            <syncpipelinestage>VK_PIPELINE_STAGE_2_HOST_BIT</syncpipelinestage>
        </syncpipeline>
        <syncpipeline name="subpass shading" depends="VK_HUAWEI_subpass_shading">
            <syncpipelinestage>VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI</syncpipelinestage>
        </syncpipeline>
        <syncpipeline name="command preprocessing" depends="VK_EXT_device_generated_commands,VK_NV_device_generated_commands">
            <syncpipelinestage>VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT</syncpipelinestage>
        </syncpipeline>
        <syncpipeline name="memory decompression" depends="VK_EXT_memory_decompression">
            <syncpipelinestage>VK_PIPELINE_STAGE_2_MEMORY_DECOMPRESSION_BIT_EXT</syncpipelinestage>
        </syncpipeline>
        <syncpipeline name="acceleration structure build" depends="VK_KHR_acceleration_structure,VK_NV_ray_tracing">
            <syncpipelinestage>VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR</syncpipelinestage>
        </syncpipeline>
        <syncpipeline name="acceleration structure copy" depends="VK_KHR_acceleration_structure,VK_NV_ray_tracing">
            <syncpipelinestage>VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR</syncpipelinestage>
        </syncpipeline>
        <syncpipeline name="opacity micromap" depends="VK_EXT_opacity_micromap">
            <syncpipelinestage>VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT</syncpipelinestage>
        </syncpipeline>
        <syncpipeline name="ray tracing" depends="VK_KHR_ray_tracing_pipeline,VK_NV_ray_tracing">
            <syncpipelinestage>VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT</syncpipelinestage>
            <syncpipelinestage>VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR</syncpipelinestage>
        </syncpipeline>
        <syncpipeline name="video decode" depends="VK_KHR_video_decode_queue">
            <syncpipelinestage>VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR</syncpipelinestage>
        </syncpipeline>
        <syncpipeline name="video encode" depends="VK_KHR_video_encode_queue">
            <syncpipelinestage>VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR</syncpipelinestage>
        </syncpipeline>
        <syncpipeline name="optical flow" depends="VK_NV_optical_flow">
            <syncpipelinestage>VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV</syncpipelinestage>
        </syncpipeline>
        <syncpipeline name="convert cooperative vector matrix layout" depends="VK_NV_cooperative_vector">
            <syncpipelinestage>VK_PIPELINE_STAGE_2_CONVERT_COOPERATIVE_VECTOR_MATRIX_BIT_NV</syncpipelinestage>
        </syncpipeline>
        <syncpipeline name="data_graph" depends="VK_ARM_data_graph">
            <syncpipelinestage>VK_PIPELINE_STAGE_2_DATA_GRAPH_BIT_ARM</syncpipelinestage>
        </syncpipeline>
    </sync>
    <videocodecs>
        <videocodec name="Decode">
            <videocapabilities struct="VkVideoDecodeCapabilitiesKHR"/>
            <videoformat name="Decode Output" usage="VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR"/>
            <videoformat name="DPB" usage="VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR"/>
        </videocodec>
        <videocodec name="Encode">
            <videocapabilities struct="VkVideoEncodeCapabilitiesKHR"/>
            <videocapabilities struct="VkVideoEncodeQuantizationMapCapabilitiesKHR"/>
            <videocapabilities struct="VkVideoEncodeIntraRefreshCapabilitiesKHR"/>
            <videocapabilities struct="VkVideoEncodeRgbConversionCapabilitiesVALVE"/>
            <videoformat name="Encode Input" usage="VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR"/>
            <videoformat name="DPB" usage="VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR"/>
            <videoformat name="Quantization Delta Map" usage="VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR">
                <videorequirecapabilities struct="VkVideoEncodeCapabilitiesKHR" member="flags" value="VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR"/>
                <videoformatproperties struct="VkVideoFormatQuantizationMapPropertiesKHR"/>
            </videoformat>
            <videoformat name="Emphasis Map" usage="VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR">
                <videorequirecapabilities struct="VkVideoEncodeCapabilitiesKHR" member="flags" value="VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR"/>
                <videoformatproperties struct="VkVideoFormatQuantizationMapPropertiesKHR"/>
            </videoformat>
        </videocodec>
        <videocodec name="H.264 Decode" extend="Decode" value="VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR">
            <videoprofiles struct="VkVideoDecodeH264ProfileInfoKHR">
                <videoprofilemember name="stdProfileIdc">
                    <videoprofile name="Baseline" value="STD_VIDEO_H264_PROFILE_IDC_BASELINE"/>
                    <videoprofile name="Main" value="STD_VIDEO_H264_PROFILE_IDC_MAIN"/>
                    <videoprofile name="High" value="STD_VIDEO_H264_PROFILE_IDC_HIGH"/>
                    <videoprofile name="High 4:4:4 Predictive" value="STD_VIDEO_H264_PROFILE_IDC_HIGH_444_PREDICTIVE"/>
                </videoprofilemember>
                <videoprofilemember name="pictureLayout">
                    <videoprofile name="progressive" value="VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR"/>
                    <videoprofile name="interlaced (interleaved lines)" value="VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR"/>
                    <videoprofile name="interlaced (separate planes)" value="VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR"/>
                </videoprofilemember>
            </videoprofiles>
            <videocapabilities struct="VkVideoDecodeH264CapabilitiesKHR"/>
        </videocodec>
        <videocodec name="H.265 Decode" extend="Decode" value="VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR">
            <videoprofiles struct="VkVideoDecodeH265ProfileInfoKHR">
                <videoprofilemember name="stdProfileIdc">
                    <videoprofile name="Main" value="STD_VIDEO_H265_PROFILE_IDC_MAIN"/>
                    <videoprofile name="Main 10" value="STD_VIDEO_H265_PROFILE_IDC_MAIN_10"/>
                    <videoprofile name="Main Still Picture" value="STD_VIDEO_H265_PROFILE_IDC_MAIN_STILL_PICTURE"/>
                    <videoprofile name="Format range extensions" value="STD_VIDEO_H265_PROFILE_IDC_FORMAT_RANGE_EXTENSIONS"/>
                    <videoprofile name="Screen content coding extensions" value="STD_VIDEO_H265_PROFILE_IDC_SCC_EXTENSIONS"/>
                </videoprofilemember>
            </videoprofiles>
            <videocapabilities struct="VkVideoDecodeH265CapabilitiesKHR"/>
        </videocodec>
        <videocodec name="VP9 Decode" extend="Decode" value="VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR">
            <videoprofiles struct="VkVideoDecodeVP9ProfileInfoKHR">
                <videoprofilemember name="stdProfile">
                    <videoprofile name="Profile 0" value="STD_VIDEO_VP9_PROFILE_0"/>
                    <videoprofile name="Profile 1" value="STD_VIDEO_VP9_PROFILE_1"/>
                    <videoprofile name="Profile 2" value="STD_VIDEO_VP9_PROFILE_2"/>
                    <videoprofile name="Profile 3" value="STD_VIDEO_VP9_PROFILE_3"/>
                </videoprofilemember>
            </videoprofiles>
            <videocapabilities struct="VkVideoDecodeVP9CapabilitiesKHR"/>
        </videocodec>
        <videocodec name="AV1 Decode" extend="Decode" value="VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR">
            <videoprofiles struct="VkVideoDecodeAV1ProfileInfoKHR">
                <videoprofilemember name="stdProfile">
                    <videoprofile name="Main" value="STD_VIDEO_AV1_PROFILE_MAIN"/>
                    <videoprofile name="High" value="STD_VIDEO_AV1_PROFILE_HIGH"/>
                    <videoprofile name="Professional" value="STD_VIDEO_AV1_PROFILE_PROFESSIONAL"/>
                </videoprofilemember>
                <videoprofilemember name="filmGrainSupport">
                    <videoprofile name="with film grain support" value="VK_TRUE"/>
                    <videoprofile name="without film grain support" value="VK_FALSE"/>
                </videoprofilemember>
            </videoprofiles>
            <videocapabilities struct="VkVideoDecodeAV1CapabilitiesKHR"/>
        </videocodec>
        <videocodec name="H.264 Encode" extend="Encode" value="VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR">
            <videoprofiles struct="VkVideoEncodeH264ProfileInfoKHR">
                <videoprofilemember name="stdProfileIdc">
                    <videoprofile name="Baseline" value="STD_VIDEO_H264_PROFILE_IDC_BASELINE"/>
                    <videoprofile name="Main" value="STD_VIDEO_H264_PROFILE_IDC_MAIN"/>
                    <videoprofile name="High" value="STD_VIDEO_H264_PROFILE_IDC_HIGH"/>
                    <videoprofile name="High 4:4:4 Predictive" value="STD_VIDEO_H264_PROFILE_IDC_HIGH_444_PREDICTIVE"/>
                </videoprofilemember>
            </videoprofiles>
            <videocapabilities struct="VkVideoEncodeH264CapabilitiesKHR"/>
            <videocapabilities struct="VkVideoEncodeH264QuantizationMapCapabilitiesKHR"/>
        </videocodec>
        <videocodec name="H.265 Encode" extend="Encode" value="VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR">
            <videoprofiles struct="VkVideoEncodeH265ProfileInfoKHR">
                <videoprofilemember name="stdProfileIdc">
                    <videoprofile name="Main" value="STD_VIDEO_H265_PROFILE_IDC_MAIN"/>
                    <videoprofile name="Main 10" value="STD_VIDEO_H265_PROFILE_IDC_MAIN_10"/>
                    <videoprofile name="Main Still Picture" value="STD_VIDEO_H265_PROFILE_IDC_MAIN_STILL_PICTURE"/>
                    <videoprofile name="Format range extensions" value="STD_VIDEO_H265_PROFILE_IDC_FORMAT_RANGE_EXTENSIONS"/>
                    <videoprofile name="Screen content coding extensions" value="STD_VIDEO_H265_PROFILE_IDC_SCC_EXTENSIONS"/>
                </videoprofilemember>
            </videoprofiles>
            <videocapabilities struct="VkVideoEncodeH265CapabilitiesKHR"/>
            <videocapabilities struct="VkVideoEncodeH265QuantizationMapCapabilitiesKHR"/>
            <videoformat extend="Quantization Delta Map">
                <videoformatproperties struct="VkVideoFormatH265QuantizationMapPropertiesKHR"/>
            </videoformat>
            <videoformat extend="Emphasis Map">
                <videoformatproperties struct="VkVideoFormatH265QuantizationMapPropertiesKHR"/>
            </videoformat>
        </videocodec>
        <videocodec name="AV1 Encode" extend="Encode" value="VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR">
            <videoprofiles struct="VkVideoEncodeAV1ProfileInfoKHR">
                <videoprofilemember name="stdProfile">
                    <videoprofile name="Main" value="STD_VIDEO_AV1_PROFILE_MAIN"/>
                    <videoprofile name="High" value="STD_VIDEO_AV1_PROFILE_HIGH"/>
                    <videoprofile name="Professional" value="STD_VIDEO_AV1_PROFILE_PROFESSIONAL"/>
                </videoprofilemember>
            </videoprofiles>
            <videocapabilities struct="VkVideoEncodeAV1CapabilitiesKHR"/>
            <videoformat extend="Quantization Delta Map">
                <videoformatproperties struct="VkVideoFormatAV1QuantizationMapPropertiesKHR"/>
            </videoformat>
            <videoformat extend="Emphasis Map">
                <videoformatproperties struct="VkVideoFormatAV1QuantizationMapPropertiesKHR"/>
            </videoformat>
        </videocodec>
    </videocodecs>
</registry>

<<<

`xr.xml`: >>>

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE xml>
<?xml-model href="registry.rnc" type="application/relax-ng-compact-syntax"?>
<?xml-model href="registry.sch" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<registry>
    <comment>
Copyright (c) 2017-2022, The Khronos Group Inc.

SPDX-License-Identifier: Apache-2.0 OR MIT

------------------------------------------------------------------------

This file, xr.xml, is the OpenXR API Registry. It is a critically important
and normative part of the OpenXR Specification, including a canonical
machine-readable definition of the API, parameter and member validation
language incorporated into the Specification and reference pages, and other
material which is registered by Khronos, such as tags used by extension and
layer authors. The only authoritative version of xr.xml is the one
maintained in the default branch of the Khronos OpenXR GitHub project.
    </comment>

    <!-- SECTION: OpenXR vendor IDs for physical devices without PCI vendor IDs -->
    <vendorids>
        <vendorid name="KHR" id="0x10000" comment="This is the next available Khronos vendor ID"/>
    </vendorids>

    <!-- SECTION: OpenXR vendor/author tags for extensions and layers -->
    <tags>
        <!--  Sorted alphabetically by tag name -->
        <tag name="ACER"       author="Acer"                        contact="OC Lin @aceroc"/>
        <tag name="ALMALENCE"  author="Almalence"                   contact="Ivan Chupakhin @ivan.chupakhin, Dmitry Shmunk @dmitry.shmunk"/>
        <tag name="ARM"        author="Arm Limited"                 contact="Andreas Loeve Selvik @selvik, Sam Martin @sammartin"/>
        <tag name="BYTEDANCE"  author="Bytedance"                   contact="Will Fu @willfu, Bangsen Han @Hansenn"/>
        <tag name="COLLABORA"  author="Collabora"                   contact="Ryan Pavlik @rpavlik"/>
        <tag name="DANWILLM"   author="Daniel Willmott"             contact="Daniel Willmott @danwillm"/>
        <tag name="EPIC"       author="Epic"                        contact="Nick Whiting @whitingn"/>
        <tag name="EXT"        author="Multivendor"                 contact="Ryan Pavlik @rpavlik"/>
        <tag name="EXTX"       author="Multivendor experimental"    contact="Brad Grantham @bradgrantham-lunarg"/>
        <tag name="FB"         author="Facebook"                    contact="Cass Everitt @casseveritt, Jonathan Wright @Nelno"/>
        <tag name="FREDEMMOTT" author="Frederick Emmott"            contact="Frederick Emmott @fredemmott"/>
        <tag name="GOOGLE"     author="Google"                      contact="Kaye Mason @chaleur"/>
        <tag name="HTC"        author="HTC"                         contact="Chris Kuo @ggkuo, Kyle Chen @kylechen76"/>
        <tag name="HTCX"       author="HTC"                         contact="Chris Kuo @ggkuo, Kyle Chen @kylechen76"/>
        <tag name="HUAWEI"     author="Huawei"                      contact="Yihong Huang @rachelhuang, Li jingya @yzljy"/>
        <tag name="INTEL"      author="Intel"                       contact="Javier Martinez @javier"/>
        <tag name="KHR"        author="Khronos"                     contact="Brent Insko @insko"/>
        <tag name="LUNARG"     author="LunarG"                      contact="Brad Grantham @bradgrantham-lunarg"/>
        <tag name="LIV"        author="LIV"                         contact="Arthur Brainville @Ybalrid, Steffan Donal @liv_ruu"/>
        <tag name="META"       author="Meta Platforms"              contact="Cass Everitt @casseveritt, Jonathan Wright @Nelno"/>
        <tag name="ML"         author="Magic Leap"                  contact="Jey Michaelraj @jeymichael"/>
        <tag name="MND"        author="Monado Project"              contact="Jakob Bornecrantz @wallbraker, Ryan Pavlik @rpavlik"/>
        <tag name="MNDX"       author="Monado Project experimental" contact="Jakob Bornecrantz @wallbraker, Ryan Pavlik @rpavlik"/>
        <tag name="MSFT"       author="Microsoft"                   contact="Alex Turner @alexturn, Yin Li @yl_msft, Bryce Hutchings @brycehutchings, Lachlan Ford @laford_msft, Minmin Gong @gongminmin "/>
        <tag name="NV"         author="NVIDIA Corporation"          contact="Satish Salian @ssalian, Robert Menzel"/>
        <tag name="OCULUS"     author="Oculus"                      contact="Cass Everitt @casseveritt, Jonathan Wright @Nelno"/>
        <tag name="OPPO"       author="OPPO"                        contact="Buyi Xu @fantastxu, Haomiao Jiang @hjiang36"/>
        <tag name="PLUTO"      author="Pluto VR"                    contact="Jared Cheshier @Jared, Sophia Baldonado @sophia"/>
        <tag name="QCOM"       author="Qualcomm Technologies"       contact="Armelle @alaine_qcom, Martin Renschler @martinr"/>
        <tag name="STARBREEZE" author="Starbreeze"                  contact="David Srour @dsrour"/>
        <tag name="TOBII"      author="Tobii"                       contact="Denny RÃ¶nngren @denron"/>
        <tag name="ULTRALEAP"  author="Ultraleap"                   contact="Robert Blenkinsopp @rblenkinsopp"/>
        <tag name="UNITY"      author="Unity Technologies"          contact="Jack Pritz @jackpritz, Peter Kuhn @peterunity"/>
        <tag name="VALVE"      author="Valve"                       contact="Joe Ludwig @JoeLudwig"/>
        <tag name="VARJO"      author="Varjo"                       contact="Sergiy Dubovik @dubik, RÃ©mi Arnaud @VarjoRemi"/>
    </tags>

    <!-- SECTION: OpenXR type definitions -->
    <types>
        <type name="openxr_platform_defines" category="include">#include "openxr_platform_defines.h"</type>

        <type requires="android/native_window.h" name="ANativeWindow"/>
        <type requires="jni.h" name="jobject"/>
        <type requires="CL/cl_gl_ext.h" name="CGLContextObj"/>
        <type requires="d3dcommon.h" name="D3D_FEATURE_LEVEL"/>
        <type requires="D3D11.h" name="ID3D11Device"/>
        <type requires="D3D11.h" name="ID3D11Texture2D"/>
        <type requires="D3D12.h" name="ID3D12CommandQueue"/>
        <type requires="D3D12.h" name="ID3D12Device"/>
        <type requires="D3D12.h" name="ID3D12Resource"/>
        <type requires="EGL/egl.h" name="EGLDisplay"/>
        <type requires="EGL/egl.h" name="EGLConfig"/>
        <type requires="EGL/egl.h" name="EGLContext"/>
        <type requires="EGL/egl.h" name="EGLenum"/>
        <type requires="EGL/egl.h" name="PFNEGLGETPROCADDRESSPROC"/>
        <type requires="GL/glxext.h" name="GLXFBConfig"/>
        <type requires="GL/glxext.h" name="GLXDrawable"/>
        <type requires="GL/glxext.h" name="GLXContext"/>
        <type requires="GL/wglext.h" name="HGLRC"/>
        <type requires="unknwn.h" name="IUnknown"/>
        <type requires="wayland-client.h" name="wl_display"/>
        <type requires="windows.h" name="HDC"/>
        <type requires="windows.h" name="LUID"/>
        <type requires="windows.h" name="LARGE_INTEGER"/>
        <type requires="X11/Xlib.h" name="Display"/>
        <type requires="X11/Xlib.h" name="VisualID"/>
        <type requires="X11/Xlib.h" name="Window"/>
        <type requires="xcb/glx.h" name="xcb_glx_fbconfig_t"/>
        <type requires="xcb/glx.h" name="xcb_glx_drawable_t"/>
        <type requires="xcb/glx.h" name="xcb_glx_context_t"/>
        <type requires="xcb/xcb.h" name="xcb_connection_t"/>
        <type requires="xcb/xcb.h" name="xcb_visualid_t"/>
        <type requires="xcb/xcb.h" name="xcb_window_t"/>
        <type requires="vulkan/vulkan.h" name="PFN_vkGetInstanceProcAddr"/>
        <type requires="vulkan/vulkan.h" name="VkAllocationCallbacks"/>
        <type requires="vulkan/vulkan.h" name="VkComponentSwizzle"/>
        <type requires="vulkan/vulkan.h" name="VkDevice"/>
        <type requires="vulkan/vulkan.h" name="VkDeviceCreateInfo"/>
        <type requires="vulkan/vulkan.h" name="VkFilter"/>
        <type requires="vulkan/vulkan.h" name="VkFormat"/>
        <type requires="vulkan/vulkan.h" name="VkImage"/>
        <type requires="vulkan/vulkan.h" name="VkImageCreateFlags"/>
        <type requires="vulkan/vulkan.h" name="VkImageUsageFlags"/>
        <type requires="vulkan/vulkan.h" name="VkInstance"/>
        <type requires="vulkan/vulkan.h" name="VkInstanceCreateInfo"/>
        <type requires="vulkan/vulkan.h" name="VkPhysicalDevice"/>
        <type requires="vulkan/vulkan.h" name="VkResult"/>
        <type requires="vulkan/vulkan.h" name="VkSamplerAddressMode"/>
        <type requires="vulkan/vulkan.h" name="VkSamplerMipmapMode"/>
        <type requires="time.h" name="timespec"/>

        <type category="define">#define <name>XR_MAKE_VERSION</name>(major, minor, patch) \
    ((((major) &amp; 0xffffULL) &lt;&lt; 48) | (((minor) &amp; 0xffffULL) &lt;&lt; 32) | ((patch) &amp; 0xffffffffULL))</type>
        <type category="define">#define <name>XR_VERSION_MAJOR</name>(version) (uint16_t)(((uint64_t)(version) &gt;&gt; 48)&amp; 0xffffULL)</type>
        <type category="define">#define <name>XR_VERSION_MINOR</name>(version) (uint16_t)(((uint64_t)(version) &gt;&gt; 32) &amp; 0xffffULL)</type>
        <type category="define">#define <name>XR_VERSION_PATCH</name>(version) (uint32_t)((uint64_t)(version) &amp; 0xffffffffULL)</type>

        <!--
        NOTE: The following group of lines defining the two version constants
        must not be re-arranged or re-flowed, since scripts/update_version.py
        updates them automatically by processing a line at a time.
        -->
        <type category="define">// OpenXR current version number.
#define <name>XR_CURRENT_API_VERSION</name> <type>XR_MAKE_VERSION</type>(1, 0, 26)</type>

        <!--
        NOTE: For avoidance of ambiguity, there should only be 1 <name> tag immediately in
        each <type>. This is why XR_MAY_ALIAS appears multiple times below, but only once with
        the <name> tags wrapping it. It does not particularly matter which of the copies of
        names gets marked up, but it seems reasonable that the most meaningful one is marked up.
        -->
        <type category="define">
#if !defined(XR_MAY_ALIAS)
#if defined(__clang__) || (defined(__GNUC__) &amp;&amp; (__GNUC__ &gt; 4))
#define <name>XR_MAY_ALIAS</name> __attribute__((__may_alias__))
#else
#define XR_MAY_ALIAS
#endif
#endif</type>

        <type category="define">
#if !defined(XR_DEFINE_HANDLE)
#if (XR_PTR_SIZE == 8)
    #define <name>XR_DEFINE_HANDLE</name>(object) typedef struct object##_T* object;
#else
    #define XR_DEFINE_HANDLE(object) typedef uint64_t object;
#endif
#endif
        </type>

        <type category="define">
#if !defined(XR_NULL_HANDLE)
#if (XR_PTR_SIZE == 8) &amp;&amp; XR_CPP_NULLPTR_SUPPORTED
    #define <name>XR_NULL_HANDLE</name> nullptr
#else
    #define XR_NULL_HANDLE 0
#endif
#endif
        </type>

        <type category="define">
#if !defined(XR_DEFINE_ATOM)
    #define <name>XR_DEFINE_ATOM</name>(object) typedef uint64_t object;
#endif
        </type>

        <type category="define">
#define <name>XR_NULL_PATH</name> 0</type>

        <type category="define">
#define <name>XR_NULL_SYSTEM_ID</name> 0</type>

        <type category="define">
#define <name>XR_SUCCEEDED</name>(result) ((result) &gt;= 0)</type>

        <type category="define">
#define <name>XR_UNQUALIFIED_SUCCESS</name>(result) ((result) == 0)</type>

        <type category="define">
#define <name>XR_FAILED</name>(result) ((result) &lt; 0)</type>

        <type category="define">
#define <name>XR_NO_DURATION</name> 0</type>

        <type category="define">
#define <name>XR_INFINITE_DURATION</name> 0x7fffffffffffffffLL</type>

        <type category="define">
#define <name>XR_MIN_HAPTIC_DURATION</name> -1</type>

        <type category="define">
#define <name>XR_FREQUENCY_UNSPECIFIED</name> 0</type>

        <type category="define">
#define <name>XR_MAX_EVENT_DATA_SIZE</name> sizeof(XrEventDataBuffer)</type>

        <type category="define">
#define <name>XR_MIN_COMPOSITION_LAYERS_SUPPORTED</name> 16</type>

        <!-- XR_EXT_hand_tracking -->
        <type category="define">
#define <name>XR_HAND_JOINT_COUNT_EXT</name> 26</type>

        <!-- XR_MSFT_controller_model -->
        <type category="define">
#define <name>XR_NULL_CONTROLLER_MODEL_KEY_MSFT</name> 0</type>

        <!-- XR_FB_render_model -->
        <type category="define">
#define <name>XR_NULL_RENDER_MODEL_KEY_FB</name> 0</type>

        <!-- XR_HTC_facial_tracking -->
        <type category="define">
#define <name>XR_FACIAL_EXPRESSION_EYE_COUNT_HTC</name> 14</type>
        <type category="define">
#define <name>XR_FACIAL_EXPRESSION_LIP_COUNT_HTC</name> 37</type>

        <!-- XR_ULTRALEAP_hand_tracking_forearm -->
        <type category="define">
#define <name>XR_HAND_FOREARM_JOINT_COUNT_ULTRALEAP</name> 27</type>

        <!-- Value types -->
        <type category="basetype">typedef <type>uint32_t</type> <name>XrBool32</name>;</type>
        <type category="basetype">typedef <type>uint64_t</type> <name>XrFlags64</name>;</type>
        <type category="basetype">typedef <type>int64_t</type> <name>XrTime</name>;</type>
        <type category="basetype">typedef <type>int64_t</type> <name>XrDuration</name>;</type>
        <type category="basetype">typedef <type>uint64_t</type> <name>XrVersion</name>;</type>

        <!-- Atoms, allocated by the runtime (if implementation requires) and never freed -->
        <type category="basetype"><type>XR_DEFINE_ATOM</type>(<name>XrPath</name>)</type>
        <type category="basetype"><type>XR_DEFINE_ATOM</type>(<name>XrSystemId</name>)</type>
        <!-- XR_MSFT_controller_model -->
        <type category="basetype"><type>XR_DEFINE_ATOM</type>(<name>XrControllerModelKeyMSFT</name>)</type>
        <!-- XR_FB_spatial_entity -->
        <type category="basetype"><type>XR_DEFINE_ATOM</type>(<name>XrAsyncRequestIdFB</name>)</type>
        <!-- XR_FB_render_model -->
        <type category="basetype"><type>XR_DEFINE_ATOM</type>(<name>XrRenderModelKeyFB</name>)</type>

        <!-- Basic C types, pulled in via openxr_platform_defines.h -->
        <type requires="openxr_platform_defines" name="void"/>
        <type requires="openxr_platform_defines" name="char"/>
        <type requires="openxr_platform_defines" name="wchar_t"/>
        <type requires="openxr_platform_defines" name="float"/>
        <type requires="openxr_platform_defines" name="int8_t"/>
        <type requires="openxr_platform_defines" name="uint8_t"/>
        <type requires="openxr_platform_defines" name="int16_t"/>
        <type requires="openxr_platform_defines" name="uint16_t"/>
        <type requires="openxr_platform_defines" name="int32_t"/>
        <type requires="openxr_platform_defines" name="uint32_t"/>
        <type requires="openxr_platform_defines" name="int64_t"/>
        <type requires="openxr_platform_defines" name="uint64_t"/>
        <type requires="openxr_platform_defines" name="size_t"/>
        <type requires="openxr_platform_defines" name="uintptr_t"/>

        <!-- Bitmask types -->
        <type bitvalues="XrInstanceCreateFlagBits"           category="bitmask">typedef <type>XrFlags64</type> <name>XrInstanceCreateFlags</name>;</type>
        <type bitvalues="XrSessionCreateFlagBits"            category="bitmask">typedef <type>XrFlags64</type> <name>XrSessionCreateFlags</name>;</type>
        <type bitvalues="XrSwapchainCreateFlagBits"          category="bitmask">typedef <type>XrFlags64</type> <name>XrSwapchainCreateFlags</name>;</type>
        <type bitvalues="XrSwapchainUsageFlagBits"           category="bitmask">typedef <type>XrFlags64</type> <name>XrSwapchainUsageFlags</name>;</type>
        <type bitvalues="XrViewStateFlagBits"                category="bitmask">typedef <type>XrFlags64</type> <name>XrViewStateFlags</name>;</type>
        <type bitvalues="XrCompositionLayerFlagBits"         category="bitmask">typedef <type>XrFlags64</type> <name>XrCompositionLayerFlags</name>;</type>
        <type bitvalues="XrSpaceLocationFlagBits"            category="bitmask">typedef <type>XrFlags64</type> <name>XrSpaceLocationFlags</name>;</type>
        <type bitvalues="XrSpaceVelocityFlagBits"            category="bitmask">typedef <type>XrFlags64</type> <name>XrSpaceVelocityFlags</name>;</type>
        <type bitvalues="XrInputSourceLocalizedNameFlagBits" category="bitmask">typedef <type>XrFlags64</type> <name>XrInputSourceLocalizedNameFlags</name>;</type>

        <!-- Bitmask types for XR_KHR_vulkan_enable2 -->
        <type bitvalues="XrVulkanInstanceCreateFlagBitsKHR" category="bitmask">typedef <type>XrFlags64</type> <name>XrVulkanInstanceCreateFlagsKHR</name>;</type>
        <type bitvalues="XrVulkanDeviceCreateFlagBitsKHR"   category="bitmask">typedef <type>XrFlags64</type> <name>XrVulkanDeviceCreateFlagsKHR</name>;</type>

        <!-- Bitmask types for XR_EXT_debug_utils -->
        <type bitvalues="XrDebugUtilsMessageSeverityFlagBitsEXT" category="bitmask">typedef <type>XrFlags64</type> <name>XrDebugUtilsMessageSeverityFlagsEXT</name>;</type>
        <type bitvalues="XrDebugUtilsMessageTypeFlagBitsEXT"     category="bitmask">typedef <type>XrFlags64</type> <name>XrDebugUtilsMessageTypeFlagsEXT</name>;</type>

        <!-- Bitmask types for XR_EXTX_overlay -->
        <type bitvalues="XrOverlayMainSessionFlagBitsEXTX"   category="bitmask">typedef <type>XrFlags64</type> <name>XrOverlayMainSessionFlagsEXTX</name>;</type>
        <type bitvalues="XrOverlaySessionCreateFlagBitsEXTX" category="bitmask">typedef <type>XrFlags64</type> <name>XrOverlaySessionCreateFlagsEXTX</name>;</type>

        <!-- Bitmask types for XR_FB_android_surface_swapchain_create -->
        <type bitvalues="XrAndroidSurfaceSwapchainFlagBitsFB" category="bitmask">typedef <type>XrFlags64</type> <name>XrAndroidSurfaceSwapchainFlagsFB</name>;</type>

        <!-- Bitmask types for XR_FB_composition_layer_image_layout -->
        <type bitvalues="XrCompositionLayerImageLayoutFlagBitsFB" category="bitmask">typedef <type>XrFlags64</type> <name>XrCompositionLayerImageLayoutFlagsFB</name>;</type>

        <!-- Bitmask types for XR_FB_composition_layer_secure_content -->
        <type bitvalues="XrCompositionLayerSecureContentFlagBitsFB" category="bitmask">typedef <type>XrFlags64</type> <name>XrCompositionLayerSecureContentFlagsFB</name>;</type>

        <!-- Bitmask types for XR_FB_foveation -->
        <type bitvalues="XrSwapchainCreateFoveationFlagBitsFB" category="bitmask">typedef <type>XrFlags64</type> <name>XrSwapchainCreateFoveationFlagsFB</name>;</type>
        <type bitvalues="XrSwapchainStateFoveationFlagBitsFB"  category="bitmask">typedef <type>XrFlags64</type> <name>XrSwapchainStateFoveationFlagsFB</name>;</type>

        <!-- Bitmask types for XR_FB_triangle_mesh -->
        <type bitvalues="XrTriangleMeshFlagBitsFB" category="bitmask">typedef <type>XrFlags64</type> <name>XrTriangleMeshFlagsFB</name>;</type>

        <!-- Bitmask types for XR_FB_passthrough -->
        <type bitvalues="XrPassthroughFlagBitsFB"             category="bitmask">typedef <type>XrFlags64</type> <name>XrPassthroughFlagsFB</name>;</type>
        <type bitvalues="XrPassthroughStateChangedFlagBitsFB" category="bitmask">typedef <type>XrFlags64</type> <name>XrPassthroughStateChangedFlagsFB</name>;</type>
        <type bitvalues="XrPassthroughCapabilityFlagBitsFB"   category="bitmask">typedef <type>XrFlags64</type> <name>XrPassthroughCapabilityFlagsFB</name>;</type>

        <!-- Bitmask types for XR_FB_hand_tracking_aim -->
        <type bitvalues="XrHandTrackingAimFlagBitsFB" category="bitmask">typedef <type>XrFlags64</type> <name>XrHandTrackingAimFlagsFB</name>;</type>

        <!-- Bitmask types for XR_FB_keyboard_tracking -->
        <type bitvalues="XrKeyboardTrackingFlagBitsFB"      category="bitmask">typedef <type>XrFlags64</type> <name>XrKeyboardTrackingFlagsFB</name>;</type>
        <type bitvalues="XrKeyboardTrackingQueryFlagBitsFB" category="bitmask">typedef <type>XrFlags64</type> <name>XrKeyboardTrackingQueryFlagsFB</name>;</type>

        <!-- Bitmask types for XR_FB_space_warp -->
        <type bitvalues="XrCompositionLayerSpaceWarpInfoFlagBitsFB" category="bitmask">typedef <type>XrFlags64</type> <name>XrCompositionLayerSpaceWarpInfoFlagsFB</name>;</type>

        <!-- Bitmask types for XR_FB_render_model -->
        <type bitvalues="XrRenderModelFlagBitsFB" category="bitmask">typedef <type>XrFlags64</type> <name>XrRenderModelFlagsFB</name>;</type>

        <!-- Bitmask types for XR_ALMALENCE_digital_lens_control -->
        <type bitvalues="XrDigitalLensControlFlagBitsALMALENCE" category="bitmask">typedef <type>XrFlags64</type> <name>XrDigitalLensControlFlagsALMALENCE</name>;</type>

        <!-- Bitmask types for XR_FB_composition_layer_settings -->
        <type bitvalues="XrCompositionLayerSettingsFlagBitsFB" category="bitmask">typedef <type>XrFlags64</type> <name>XrCompositionLayerSettingsFlagsFB</name>;</type>

        <!-- Bitmask types for XR_META_performance_metrics -->
        <type bitvalues="XrPerformanceMetricsCounterFlagBitsMETA" category="bitmask">typedef <type>XrFlags64</type> <name>XrPerformanceMetricsCounterFlagsMETA</name>;</type>

        <!-- Bitmask types for XR_HTC_foveation -->
        <type bitvalues="XrFoveationDynamicFlagBitsHTC" category="bitmask">typedef <type>XrFlags64</type> <name>XrFoveationDynamicFlagsHTC</name>;</type>

        <!-- Handles referring to internally-maintained objects. -->
        <!-- These types which can be 64-bit integers or opaque pointers, selected at compile time based on pointer size -->
        <type category="handle"><type>XR_DEFINE_HANDLE</type>(<name>XrInstance</name>)</type>
        <type category="handle" parent="XrInstance"><type>XR_DEFINE_HANDLE</type>(<name>XrSession</name>)</type>
        <type category="handle" parent="XrInstance"><type>XR_DEFINE_HANDLE</type>(<name>XrActionSet</name>)</type>
        <type category="handle" parent="XrActionSet"><type>XR_DEFINE_HANDLE</type>(<name>XrAction</name>)</type>
        <type category="handle" parent="XrSession"><type>XR_DEFINE_HANDLE</type>(<name>XrSwapchain</name>)</type>
        <type category="handle" parent="XrSession"><type>XR_DEFINE_HANDLE</type>(<name>XrSpace</name>)</type>
        <type category="handle" parent="XrInstance"><type>XR_DEFINE_HANDLE</type>(<name>XrDebugUtilsMessengerEXT</name>)</type>
        <type category="handle" parent="XrSession"><type>XR_DEFINE_HANDLE</type>(<name>XrSpatialAnchorMSFT</name>)</type>

        <!-- XR_EXT_hand_tracking -->
        <type category="handle" parent="XrSession"><type>XR_DEFINE_HANDLE</type>(<name>XrHandTrackerEXT</name>)</type>

        <!-- XR_FB_foveation -->
        <type category="handle" parent="XrSession"><type>XR_DEFINE_HANDLE</type>(<name>XrFoveationProfileFB</name>)</type>

        <!-- XR_FB_triangle_mesh -->
        <type category="handle" parent="XrSession"><type>XR_DEFINE_HANDLE</type>(<name>XrTriangleMeshFB</name>)</type>

        <!-- XR_FB_passthrough -->
        <type category="handle" parent="XrSession"><type>XR_DEFINE_HANDLE</type>(<name>XrPassthroughFB</name>)</type>
        <type category="handle" parent="XrSession"><type>XR_DEFINE_HANDLE</type>(<name>XrPassthroughLayerFB</name>)</type>
        <type category="handle" parent="XrSession"><type>XR_DEFINE_HANDLE</type>(<name>XrGeometryInstanceFB</name>)</type>

        <!-- XR_HTC_facial_tracking -->
        <type category="handle" parent="XrInstance"><type>XR_DEFINE_HANDLE</type>(<name>XrFacialTrackerHTC</name>)</type>

        <!-- XR_HTC_passthrough -->
        <type category="handle" parent="XrSession"><type>XR_DEFINE_HANDLE</type>(<name>XrPassthroughHTC</name>)</type>

        <!-- enums and flag bits generated from corresponding <enums> tags below -->
        <type name="XrStructureType" category="enum"/>
        <type name="XrResult" category="enum"/>
        <type name="XrObjectType" category="enum"/>
        <type name="XrInstanceCreateFlagBits" category="enum"/>
        <type name="XrSessionCreateFlagBits" category="enum"/>
        <type name="XrSwapchainCreateFlagBits" category="enum"/>
        <type name="XrSwapchainUsageFlagBits" category="enum"/>
        <type name="XrViewStateFlagBits" category="enum"/>
        <type name="XrCompositionLayerFlagBits" category="enum"/>
        <type name="XrSpaceLocationFlagBits" category="enum"/>
        <type name="XrSpaceVelocityFlagBits" category="enum"/>
        <type name="XrInputSourceLocalizedNameFlagBits" category="enum"/>
        <type name="XrAndroidThreadTypeKHR" category="enum"/>
        <type name="XrEyeVisibility" category="enum"/>
        <type name="XrActionType" category="enum"/>
        <type name="XrReferenceSpaceType" category="enum"/>
        <type name="XrFormFactor" category="enum"/>
        <type name="XrViewConfigurationType" category="enum"/>
        <type name="XrEnvironmentBlendMode" category="enum"/>
        <type name="XrSessionState" category="enum"/>
        <type name="XrPerfSettingsDomainEXT" category="enum"/>
        <type name="XrPerfSettingsSubDomainEXT" category="enum"/>
        <type name="XrPerfSettingsLevelEXT" category="enum"/>
        <type name="XrPerfSettingsNotificationLevelEXT" category="enum"/>

        <!-- flag bits for XR_KHR_vulkan_enable2 -->
        <type name="XrVulkanInstanceCreateFlagBitsKHR" category="enum"/>
        <type name="XrVulkanDeviceCreateFlagBitsKHR" category="enum"/>

        <!-- flag bits for XR_EXT_debug_utils -->
        <type name="XrDebugUtilsMessageSeverityFlagBitsEXT" category="enum"/>
        <type name="XrDebugUtilsMessageTypeFlagBitsEXT" category="enum"/>

        <!-- flag bits for XR_EXTX_overlay -->
        <type name="XrOverlayMainSessionFlagBitsEXTX" category="enum"/>
        <type name="XrOverlaySessionCreateFlagBitsEXTX" category="enum"/>

        <!-- enums for XR_KHR_visibility_mask -->
        <type name="XrVisibilityMaskTypeKHR" category="enum"/>

        <!-- enums for XR_MSFT_spatial_graph_bridge -->
        <type name="XrSpatialGraphNodeTypeMSFT" category="enum"/>

        <!-- flag bits for XR_FB_android_surface_swapchain_create -->
        <type name="XrAndroidSurfaceSwapchainFlagBitsFB" category="enum"/>

        <!-- flag bits for XR_FB_composition_layer_image_layout -->
        <type name="XrCompositionLayerImageLayoutFlagBitsFB" category="enum"/>

        <!-- enums for XR_FB_composition_layer_alpha_blend -->
        <type name="XrBlendFactorFB" category="enum"/>

        <!-- flag bits for XR_FB_composition_layer_secure_content -->
        <type name="XrCompositionLayerSecureContentFlagBitsFB" category="enum"/>

        <!-- enums for XR_FB_spatial_entity -->
        <type name="XrSpaceComponentTypeFB" category="enum"/>

        <!-- flag bits for XR_FB_foveation -->
        <type name="XrSwapchainCreateFoveationFlagBitsFB" category="enum"/>
        <type name="XrSwapchainStateFoveationFlagBitsFB" category="enum"/>

        <!-- enums and flag bits for XR_FB_triangle_mesh -->
        <type name="XrTriangleMeshFlagBitsFB" category="enum"/>
        <type name="XrWindingOrderFB" category="enum"/>

        <!-- enums and flag bits for XR_FB_passthrough -->
        <type name="XrPassthroughFlagBitsFB" category="enum"/>
        <type name="XrPassthroughLayerPurposeFB" category="enum"/>
        <type name="XrPassthroughStateChangedFlagBitsFB" category="enum"/>
        <type name="XrPassthroughCapabilityFlagBitsFB" category="enum"/>

        <!-- flag bits for XR_FB_space_warp -->
        <type name="XrCompositionLayerSpaceWarpInfoFlagBitsFB" category="enum"/>

        <!-- flag bits for XR_FB_render_model -->
        <type name="XrRenderModelFlagBitsFB" category="enum"/>

        <!-- enums for XR_FB_spatial_entity_query -->
        <type name="XrSpaceQueryActionFB" category="enum"/>

        <!-- enums for XR_FB_spatial_entity_storage -->
        <type name="XrSpaceStorageLocationFB" category="enum"/>
        <type name="XrSpacePersistenceModeFB" category="enum"/>

        <!-- flag bits for XR_FB_hand_tracking_aim -->
        <type name="XrHandTrackingAimFlagBitsFB" category="enum"/>

        <!-- flag bits for XR_FB_keyboard_tracking -->
        <type name="XrKeyboardTrackingFlagBitsFB" category="enum"/>
        <type name="XrKeyboardTrackingQueryFlagBitsFB" category="enum"/>

        <!-- flag bits for XR_ALMALENCE_digital_lens_control -->
        <type name="XrDigitalLensControlFlagBitsALMALENCE" category="enum"/>

        <!-- flag bits for XR_FB_composition_layer_settings -->
        <type name="XrCompositionLayerSettingsFlagBitsFB" category="enum"/>

        <!-- enum and flag bits for XR_META_performance_metrics -->
        <type name="XrPerformanceMetricsCounterFlagBitsMETA" category="enum"/>
        <type name="XrPerformanceMetricsCounterUnitMETA" category="enum"/>

        <!-- XR_HTC_facial_tracking -->
        <type name="XrFacialTrackingTypeHTC" category="enum"/>
        <type name="XrEyeExpressionHTC" category="enum"/>
        <type name="XrLipExpressionHTC" category="enum"/>

        <!-- enum for XR_HTC_passthrough -->
        <type name="XrPassthroughFormHTC" category="enum"/>

        <!-- enums for XR_HTC_foveation -->
        <type name="XrFoveationModeHTC" category="enum"/>
        <type name="XrFoveationDynamicFlagBitsHTC" category="enum"/>
        <type name="XrFoveationLevelHTC" category="enum"/>


        <!-- Struct types -->
        <type category="struct" name="XrVector2f">
            <member><type>float</type>          <name>x</name></member>
            <member><type>float</type>          <name>y</name></member>
        </type>
        <type category="struct" name="XrVector3f">
            <member><type>float</type>          <name>x</name></member>
            <member><type>float</type>          <name>y</name></member>
            <member><type>float</type>          <name>z</name></member>
        </type>
        <type category="struct" name="XrVector4f">
            <member><type>float</type>          <name>x</name></member>
            <member><type>float</type>          <name>y</name></member>
            <member><type>float</type>          <name>z</name></member>
            <member><type>float</type>          <name>w</name></member>
        </type>
        <type category="struct" name="XrColor4f">
            <member><type>float</type>          <name>r</name></member>
            <member><type>float</type>          <name>g</name></member>
            <member><type>float</type>          <name>b</name></member>
            <member><type>float</type>          <name>a</name></member>
        </type>
        <type category="struct" name="XrQuaternionf">
            <member><type>float</type>          <name>x</name></member>
            <member><type>float</type>          <name>y</name></member>
            <member><type>float</type>          <name>z</name></member>
            <member><type>float</type>          <name>w</name></member>
        </type>
        <type category="struct" name="XrPosef">
            <member><type>XrQuaternionf</type>  <name>orientation</name></member>
            <member><type>XrVector3f</type>     <name>position</name></member>
        </type>
        <type category="struct" name="XrOffset2Df">
            <member><type>float</type>          <name>x</name></member>
            <member><type>float</type>          <name>y</name></member>
        </type>
        <type category="struct" name="XrExtent2Df">
            <member><type>float</type>          <name>width</name></member>
            <member><type>float</type>          <name>height</name></member>
        </type>
        <type category="struct" name="XrRect2Df">
            <member><type>XrOffset2Df</type>    <name>offset</name></member>
            <member><type>XrExtent2Df</type>    <name>extent</name></member>
        </type>
        <type category="struct" name="XrOffset2Di">
            <member><type>int32_t</type>          <name>x</name></member>
            <member><type>int32_t</type>          <name>y</name></member>
        </type>
        <type category="struct" name="XrExtent2Di">
            <member><type>int32_t</type>          <name>width</name></member>
            <member><type>int32_t</type>          <name>height</name></member>
        </type>
        <type category="struct" name="XrRect2Di">
            <member><type>XrOffset2Di</type>          <name>offset</name></member>
            <member><type>XrExtent2Di</type>          <name>extent</name></member>
        </type>

        <comment>
        XrBaseInStructure and XrBaseOutStructure use "struct" in their member definitions
        because they are recursive structures and this is easier than modifying the tooling
        to output forward declarations.
        </comment>
        <type category="struct" name="XrBaseInStructure" mayalias="true">
            <member><type>XrStructureType</type> <name>type</name></member>
            <member>const struct <type>XrBaseInStructure</type>* <name>next</name></member>
        </type>
        <type category="struct" name="XrBaseOutStructure" mayalias="true">
            <member><type>XrStructureType</type> <name>type</name></member>
            <member>struct <type>XrBaseOutStructure</type>* <name>next</name></member>
        </type>
        <type category="struct" name="XrApiLayerProperties" returnedonly="true">
            <member values="XR_TYPE_API_LAYER_PROPERTIES"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*           <name>next</name></member>
            <member><type>char</type>            <name>layerName</name>[<enum>XR_MAX_API_LAYER_NAME_SIZE</enum>]</member>
            <member><type>XrVersion</type>       <name>specVersion</name></member>
            <member><type>uint32_t</type>        <name>layerVersion</name></member>
            <member><type>char</type>            <name>description</name>[<enum>XR_MAX_API_LAYER_DESCRIPTION_SIZE</enum>]</member>
        </type>
        <type category="struct" name="XrExtensionProperties" returnedonly="true">
            <member values="XR_TYPE_EXTENSION_PROPERTIES"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*           <name>next</name></member>
            <member><type>char</type>            <name>extensionName</name>[<enum>XR_MAX_EXTENSION_NAME_SIZE</enum>]</member>
            <member><type>uint32_t</type>        <name>extensionVersion</name></member>
        </type>
        <type category="struct" name="XrApplicationInfo">
            <member><type>char</type>            <name>applicationName</name>[<enum>XR_MAX_APPLICATION_NAME_SIZE</enum>]</member>
            <member><type>uint32_t</type>        <name>applicationVersion</name></member>
            <member><type>char</type>            <name>engineName</name>[<enum>XR_MAX_ENGINE_NAME_SIZE</enum>]</member>
            <member><type>uint32_t</type>        <name>engineVersion</name></member>
            <member><type>XrVersion</type>       <name>apiVersion</name></member>
        </type>
        <type category="struct" name="XrInstanceCreateInfo">
            <member values="XR_TYPE_INSTANCE_CREATE_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*            <name>next</name></member>
            <member optional="true"><type>XrInstanceCreateFlags</type>  <name>createFlags</name></member>
            <member><type>XrApplicationInfo</type> <name>applicationInfo</name></member>
            <member optional="true"><type>uint32_t</type>               <name>enabledApiLayerCount</name></member>
            <member len="enabledApiLayerCount,null-terminated">const <type>char</type>* const*      <name>enabledApiLayerNames</name></member>
            <member optional="true"><type>uint32_t</type>               <name>enabledExtensionCount</name></member>
            <member len="enabledExtensionCount,null-terminated">const <type>char</type>* const*      <name>enabledExtensionNames</name></member>
        </type>
        <type category="struct" name="XrInstanceProperties" returnedonly="true">
            <member values="XR_TYPE_INSTANCE_PROPERTIES"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                                          <name>next</name></member>
            <member><type>XrVersion</type>                                      <name>runtimeVersion</name></member>
            <member><type>char</type>                                           <name>runtimeName</name>[<enum>XR_MAX_RUNTIME_NAME_SIZE</enum>]</member>
        </type>
        <type category="struct" name="XrSystemGetInfo">
            <member values="XR_TYPE_SYSTEM_GET_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*        <name>next</name></member>
            <member><type>XrFormFactor</type> <name>formFactor</name></member>
        </type>
        <type category="struct" name="XrSystemProperties" returnedonly="true">
            <member values="XR_TYPE_SYSTEM_PROPERTIES"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*           <name>next</name></member>
            <member><type>XrSystemId</type>      <name>systemId</name></member>
            <member><type>uint32_t</type>        <name>vendorId</name></member>
            <member><type>char</type>            <name>systemName</name>[<enum>XR_MAX_SYSTEM_NAME_SIZE</enum>]</member>
            <member><type>XrSystemGraphicsProperties</type> <name>graphicsProperties</name></member>
            <member><type>XrSystemTrackingProperties</type> <name>trackingProperties</name></member>
        </type>
        <type category="struct" name="XrSystemGraphicsProperties">
            <member><type>uint32_t</type>            <name>maxSwapchainImageHeight</name></member>
            <member><type>uint32_t</type>            <name>maxSwapchainImageWidth</name></member>
            <member><type>uint32_t</type>            <name>maxLayerCount</name></member>
        </type>
        <type category="struct" name="XrSystemTrackingProperties">
            <member><type>XrBool32</type>        <name>orientationTracking</name></member>
            <member><type>XrBool32</type>        <name>positionTracking</name></member>
        </type>
        <type category="struct" name="XrGraphicsBindingOpenGLWin32KHR" structextends="XrSessionCreateInfo" protect="XR_USE_PLATFORM_WIN32">
            <member values="XR_TYPE_GRAPHICS_BINDING_OPENGL_WIN32_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>HDC</type> <name>hDC</name></member>
            <member><type>HGLRC</type> <name>hGLRC</name></member>
        </type>
        <type category="struct" name="XrGraphicsBindingOpenGLXlibKHR" structextends="XrSessionCreateInfo" protect="XR_USE_PLATFORM_XLIB">
            <member values="XR_TYPE_GRAPHICS_BINDING_OPENGL_XLIB_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>Display</type>* <name>xDisplay</name></member>
            <member><type>uint32_t</type> <name>visualid</name></member>
            <member><type>GLXFBConfig</type> <name>glxFBConfig</name></member>
            <member><type>GLXDrawable</type> <name>glxDrawable</name></member>
            <member><type>GLXContext</type> <name>glxContext</name></member>
        </type>
        <type category="struct" name="XrGraphicsBindingOpenGLXcbKHR" structextends="XrSessionCreateInfo" protect="XR_USE_PLATFORM_XCB">
            <member values="XR_TYPE_GRAPHICS_BINDING_OPENGL_XCB_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>xcb_connection_t</type>* <name>connection</name></member>
            <member><type>uint32_t</type> <name>screenNumber</name></member>
            <member><type>xcb_glx_fbconfig_t</type> <name>fbconfigid</name></member>
            <member><type>xcb_visualid_t</type> <name>visualid</name></member>
            <member><type>xcb_glx_drawable_t</type> <name>glxDrawable</name></member>
            <member><type>xcb_glx_context_t</type> <name>glxContext</name></member>
        </type>
        <type category="struct" name="XrGraphicsBindingOpenGLWaylandKHR" structextends="XrSessionCreateInfo" protect="XR_USE_PLATFORM_WAYLAND">
            <member values="XR_TYPE_GRAPHICS_BINDING_OPENGL_WAYLAND_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member>struct <type>wl_display</type>* <name>display</name></member>
        </type>
        <type category="struct" name="XrGraphicsBindingD3D11KHR" structextends="XrSessionCreateInfo">
            <member values="XR_TYPE_GRAPHICS_BINDING_D3D11_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>ID3D11Device</type>* <name>device</name></member>
        </type>
        <type category="struct" name="XrGraphicsBindingD3D12KHR" structextends="XrSessionCreateInfo">
            <member values="XR_TYPE_GRAPHICS_BINDING_D3D12_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>ID3D12Device</type>* <name>device</name></member>
            <member><type>ID3D12CommandQueue</type>* <name>queue</name></member>
        </type>
        <type category="struct" name="XrGraphicsBindingOpenGLESAndroidKHR" structextends="XrSessionCreateInfo" protect="XR_USE_PLATFORM_ANDROID">
            <member values="XR_TYPE_GRAPHICS_BINDING_OPENGL_ES_ANDROID_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>EGLDisplay</type> <name>display</name></member>
            <member><type>EGLConfig</type> <name>config</name></member>
            <member><type>EGLContext</type> <name>context</name></member>
        </type>
        <type category="struct" name="XrGraphicsBindingVulkanKHR" structextends="XrSessionCreateInfo">
            <member values="XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                <name>next</name></member>
            <member><type>VkInstance</type>                 <name>instance</name></member>
            <member><type>VkPhysicalDevice</type>           <name>physicalDevice</name></member>
            <member><type>VkDevice</type>                   <name>device</name></member>
            <member><type>uint32_t</type>                   <name>queueFamilyIndex</name></member>
            <member><type>uint32_t</type>                   <name>queueIndex</name></member>
        </type>
        <type category="struct" name="XrSessionCreateInfo">
            <member values="XR_TYPE_SESSION_CREATE_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*     <name>next</name></member>
            <member optional="true"><type>XrSessionCreateFlags</type>        <name>createFlags</name></member>
            <member><type>XrSystemId</type>        <name>systemId</name></member>
        </type>
        <type category="struct" name="XrSessionBeginInfo">
            <member values="XR_TYPE_SESSION_BEGIN_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*     <name>next</name></member>
            <member><type>XrViewConfigurationType</type>      <name>primaryViewConfigurationType</name></member>
        </type>
        <type category="struct" name="XrSwapchainCreateInfo">
            <member values="XR_TYPE_SWAPCHAIN_CREATE_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*     <name>next</name></member>
            <member optional="true"><type>XrSwapchainCreateFlags</type>       <name>createFlags</name></member>
            <member optional="true"><type>XrSwapchainUsageFlags</type>        <name>usageFlags</name></member>
            <member><type>int64_t</type>        <name>format</name></member>
            <member><type>uint32_t</type>       <name>sampleCount</name></member>
            <member><type>uint32_t</type>       <name>width</name></member>
            <member><type>uint32_t</type>       <name>height</name></member>
            <member><type>uint32_t</type>       <name>faceCount</name></member>
            <member><type>uint32_t</type>       <name>arraySize</name></member>
            <member><type>uint32_t</type>       <name>mipCount</name></member>
        </type>
        <type category="struct" name="XrSwapchainImageBaseHeader" returnedonly="true">
            <member><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*           <name>next</name></member>
        </type>
        <type category="struct" name="XrSwapchainImageOpenGLKHR" parentstruct="XrSwapchainImageBaseHeader" returnedonly="true">
            <member values="XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                      <name>next</name></member>
            <member><type>uint32_t</type>                   <name>image</name></member>
        </type>
        <type category="struct" name="XrSwapchainImageOpenGLESKHR" parentstruct="XrSwapchainImageBaseHeader" returnedonly="true">
            <member values="XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_ES_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                          <name>next</name></member>
            <member><type>uint32_t</type>                       <name>image</name></member>
        </type>
        <type category="struct" name="XrSwapchainImageVulkanKHR" parentstruct="XrSwapchainImageBaseHeader" returnedonly="true">
            <member values="XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                      <name>next</name></member>
            <member><type>VkImage</type>                    <name>image</name></member>
        </type>
        <type category="struct" name="XrSwapchainImageD3D11KHR" parentstruct="XrSwapchainImageBaseHeader" returnedonly="true">
            <member values="XR_TYPE_SWAPCHAIN_IMAGE_D3D11_KHR"> <type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                      <name>next</name></member>
            <member><type>ID3D11Texture2D</type>*           <name>texture</name></member>
        </type>
        <type category="struct" name="XrSwapchainImageD3D12KHR" parentstruct="XrSwapchainImageBaseHeader" returnedonly="true">
            <member values="XR_TYPE_SWAPCHAIN_IMAGE_D3D12_KHR"> <type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                      <name>next</name></member>
            <member><type>ID3D12Resource</type>*            <name>texture</name></member>
        </type>
        <type category="struct" name="XrSwapchainImageAcquireInfo">
            <member values="XR_TYPE_SWAPCHAIN_IMAGE_ACQUIRE_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*        <name>next</name></member>
        </type>
        <type category="struct" name="XrSwapchainImageWaitInfo">
            <member values="XR_TYPE_SWAPCHAIN_IMAGE_WAIT_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*        <name>next</name></member>
            <member><type>XrDuration</type>         <name>timeout</name></member>
        </type>
        <type category="struct" name="XrSwapchainImageReleaseInfo">
            <member values="XR_TYPE_SWAPCHAIN_IMAGE_RELEASE_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*        <name>next</name></member>
        </type>
        <type category="struct" name="XrReferenceSpaceCreateInfo">
            <member values="XR_TYPE_REFERENCE_SPACE_CREATE_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                     <name>next</name></member>
            <member><type>XrReferenceSpaceType</type>            <name>referenceSpaceType</name></member>
            <member><type>XrPosef</type>                         <name>poseInReferenceSpace</name></member>
        </type>
        <type category="struct" name="XrActionSpaceCreateInfo">
            <member values="XR_TYPE_ACTION_SPACE_CREATE_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                     <name>next</name></member>
            <member><type>XrAction</type>                        <name>action</name></member>
            <member optional="true"><type>XrPath</type>          <name>subactionPath</name></member>
            <member><type>XrPosef</type>                         <name>poseInActionSpace</name></member>
        </type>
        <type category="struct" name="XrSpaceLocation">
            <member values="XR_TYPE_SPACE_LOCATION"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                                  <name>next</name></member>
            <member optional="true"><type>XrSpaceLocationFlags</type>   <name>locationFlags</name></member>
            <member><type>XrPosef</type>                                <name>pose</name></member>
        </type>
        <type category="struct" name="XrSpaceVelocity" structextends="XrSpaceLocation">
            <member values="XR_TYPE_SPACE_VELOCITY"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                                  <name>next</name></member>
            <member optional="true"><type>XrSpaceVelocityFlags</type>   <name>velocityFlags</name></member>
            <member><type>XrVector3f</type>                             <name>linearVelocity</name></member>
            <member><type>XrVector3f</type>                             <name>angularVelocity</name></member>
        </type>
        <type category="struct" name="XrFovf">
            <member><type>float</type>        <name>angleLeft</name></member>
            <member><type>float</type>        <name>angleRight</name></member>
            <member><type>float</type>        <name>angleUp</name></member>
            <member><type>float</type>        <name>angleDown</name></member>
        </type>
        <type category="struct" name="XrView">
            <member values="XR_TYPE_VIEW"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*          <name>next</name></member>
            <member><type>XrPosef</type>        <name>pose</name></member>
            <member><type>XrFovf</type>         <name>fov</name></member>
        </type>
        <type category="struct" name="XrViewLocateInfo">
            <member values="XR_TYPE_VIEW_LOCATE_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*    <name>next</name></member>
            <member><type>XrViewConfigurationType</type> <name>viewConfigurationType</name></member>
            <member><type>XrTime</type>         <name>displayTime</name></member>
            <member><type>XrSpace</type>        <name>space</name></member>
        </type>
        <type category="struct" name="XrViewState">
            <member values="XR_TYPE_VIEW_STATE"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                            <name>next</name></member>
            <member optional="true"><type>XrViewStateFlags</type> <name>viewStateFlags</name></member>
        </type>
        <type category="struct" name="XrViewConfigurationView">
            <member values="XR_TYPE_VIEW_CONFIGURATION_VIEW"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*          <name>next</name></member>
            <member><type>uint32_t</type>       <name>recommendedImageRectWidth</name></member>
            <member><type>uint32_t</type>       <name>maxImageRectWidth</name></member>
            <member><type>uint32_t</type>       <name>recommendedImageRectHeight</name></member>
            <member><type>uint32_t</type>       <name>maxImageRectHeight</name></member>
            <member><type>uint32_t</type>       <name>recommendedSwapchainSampleCount</name></member>
            <member><type>uint32_t</type>       <name>maxSwapchainSampleCount</name></member>
        </type>
        <type category="struct" name="XrSwapchainSubImage">
            <member><type>XrSwapchain</type>                            <name>swapchain</name></member>
            <member><type>XrRect2Di</type>                              <name>imageRect</name></member>
            <member><type>uint32_t</type>                               <name>imageArrayIndex</name></member>
        </type>
        <type category="struct" name="XrCompositionLayerBaseHeader">
            <member><type>XrStructureType</type>                        <name>type</name></member>
            <member>const <type>void</type>*                            <name>next</name></member>
            <member optional="true"><type>XrCompositionLayerFlags</type> <name>layerFlags</name></member>
            <member><type>XrSpace</type>                                <name>space</name></member>
        </type>
        <type category="struct" name="XrCompositionLayerProjectionView">
            <member values="XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                            <name>next</name></member>
            <member><type>XrPosef</type>                                <name>pose</name></member>
            <member><type>XrFovf</type>                                 <name>fov</name></member>
            <member><type>XrSwapchainSubImage</type>                    <name>subImage</name></member>
        </type>
        <type category="struct" name="XrCompositionLayerProjection" parentstruct="XrCompositionLayerBaseHeader">
            <member values="XR_TYPE_COMPOSITION_LAYER_PROJECTION"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                            <name>next</name></member>
            <member optional="true"><type>XrCompositionLayerFlags</type> <name>layerFlags</name></member>
            <member><type>XrSpace</type>                                <name>space</name></member>
            <member><type>uint32_t</type>                               <name>viewCount</name></member>
            <member len="viewCount">const <type>XrCompositionLayerProjectionView</type>* <name>views</name></member>
        </type>
        <type category="struct" name="XrCompositionLayerQuad" parentstruct="XrCompositionLayerBaseHeader">
            <member values="XR_TYPE_COMPOSITION_LAYER_QUAD"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                            <name>next</name></member>
            <member optional="true"><type>XrCompositionLayerFlags</type> <name>layerFlags</name></member>
            <member><type>XrSpace</type>                                <name>space</name></member>
            <member><type>XrEyeVisibility</type>                        <name>eyeVisibility</name></member>
            <member><type>XrSwapchainSubImage</type>                    <name>subImage</name></member>
            <member><type>XrPosef</type>                                <name>pose</name></member>
            <member><type>XrExtent2Df</type>                            <name>size</name></member>
        </type>
        <type category="struct" name="XrCompositionLayerCylinderKHR" parentstruct="XrCompositionLayerBaseHeader">
            <member values="XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                            <name>next</name></member>
            <member optional="true"><type>XrCompositionLayerFlags</type> <name>layerFlags</name></member>
            <member><type>XrSpace</type>                                <name>space</name></member>
            <member><type>XrEyeVisibility</type>                        <name>eyeVisibility</name></member>
            <member><type>XrSwapchainSubImage</type>                    <name>subImage</name></member>
            <member><type>XrPosef</type>                                <name>pose</name></member>
            <member><type>float</type>                                  <name>radius</name></member>
            <member><type>float</type>                                  <name>centralAngle</name></member>
            <member><type>float</type>                                  <name>aspectRatio</name></member>
        </type>
        <type category="struct" name="XrCompositionLayerCubeKHR" parentstruct="XrCompositionLayerBaseHeader">
            <member values="XR_TYPE_COMPOSITION_LAYER_CUBE_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                            <name>next</name></member>
            <member optional="true"><type>XrCompositionLayerFlags</type> <name>layerFlags</name></member>
            <member><type>XrSpace</type>                                <name>space</name></member>
            <member><type>XrEyeVisibility</type>                        <name>eyeVisibility</name></member>
            <member><type>XrSwapchain</type>                            <name>swapchain</name></member>
            <member><type>uint32_t</type>                               <name>imageArrayIndex</name></member>
            <member><type>XrQuaternionf</type>                          <name>orientation</name></member>
        </type>
        <type category="struct" name="XrCompositionLayerEquirectKHR" parentstruct="XrCompositionLayerBaseHeader">
            <member values="XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                            <name>next</name></member>
            <member optional="true"><type>XrCompositionLayerFlags</type> <name>layerFlags</name></member>
            <member><type>XrSpace</type>                                <name>space</name></member>
            <member><type>XrEyeVisibility</type>                        <name>eyeVisibility</name></member>
            <member><type>XrSwapchainSubImage</type>                    <name>subImage</name></member>
            <member><type>XrPosef</type>                                <name>pose</name></member>
            <member><type>float</type>                                  <name>radius</name></member>
            <member><type>XrVector2f</type>                             <name>scale</name></member>
            <member><type>XrVector2f</type>                             <name>bias</name></member>
        </type>
        <type category="struct" name="XrCompositionLayerDepthInfoKHR" structextends="XrCompositionLayerProjectionView">
            <member values="XR_TYPE_COMPOSITION_LAYER_DEPTH_INFO_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                            <name>next</name></member>
            <member><type>XrSwapchainSubImage</type>                    <name>subImage</name></member>
            <member><type>float</type>                                  <name>minDepth</name></member>
            <member><type>float</type>                                  <name>maxDepth</name></member>
            <member><type>float</type>                                  <name>nearZ</name></member>
            <member><type>float</type>                                  <name>farZ</name></member>
        </type>
        <type category="struct" name="XrFrameBeginInfo">
            <member values="XR_TYPE_FRAME_BEGIN_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*     <name>next</name></member>
            <!-- This is currently empty, awaiting future extensions. -->
        </type>
        <type category="struct" name="XrFrameEndInfo">
            <member values="XR_TYPE_FRAME_END_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                 <name>next</name></member>
            <member><type>XrTime</type>                      <name>displayTime</name></member>
            <member><type>XrEnvironmentBlendMode</type>      <name>environmentBlendMode</name></member>
            <member optional="true"><type>uint32_t</type>    <name>layerCount</name></member>
            <member optional="true" len="layerCount">const <type>XrCompositionLayerBaseHeader</type>* const*   <name>layers</name></member>
        </type>
        <type category="struct" name="XrFrameWaitInfo">
            <member values="XR_TYPE_FRAME_WAIT_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                 <name>next</name></member>
        </type>
        <type category="struct" name="XrFrameState">
            <member values="XR_TYPE_FRAME_STATE"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                       <name>next</name></member>
            <member><type>XrTime</type>                      <name>predictedDisplayTime</name></member>
            <member><type>XrDuration</type>                  <name>predictedDisplayPeriod</name></member>
            <member><type>XrBool32</type>                    <name>shouldRender</name></member>
        </type>
        <type category="struct" name="XrHapticBaseHeader">
            <member><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*     <name>next</name></member>
        </type>
        <type category="struct" name="XrHapticVibration" parentstruct="XrHapticBaseHeader">
            <member values="XR_TYPE_HAPTIC_VIBRATION"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                 <name>next</name></member>
            <member><type>XrDuration</type>                  <name>duration</name></member>
            <member optional="true"><type>float</type>       <name>frequency</name></member>
            <member><type>float</type>                       <name>amplitude</name></member>
        </type>
        <type category="struct" name="XrEventDataBaseHeader" returnedonly="true"> <!-- top-level, parentstruct="XrBaseOutStructure" causes validation failures -->
            <member><type>XrStructureType</type>             <name>type</name></member>
            <member>const <type>void</type>*                 <name>next</name></member>
        </type>
        <type category="struct" name="XrEventDataBuffer"> <!-- top-level, parentstruct="XrBaseInStructure" causes validation failures -->
            <member values="XR_TYPE_EVENT_DATA_BUFFER"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                 <name>next</name></member>
            <member><type>uint8_t</type>                     <name>varying</name>[4000]</member>
        </type>
        <type category="struct" name="XrEventDataEventsLost" parentstruct="XrEventDataBaseHeader" returnedonly="true">
            <member values="XR_TYPE_EVENT_DATA_EVENTS_LOST"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                 <name>next</name></member>
            <member><type>uint32_t</type>                    <name>lostEventCount</name></member>
        </type>
        <type category="struct" name="XrEventDataInstanceLossPending" parentstruct="XrEventDataBaseHeader" returnedonly="true">
            <member values="XR_TYPE_EVENT_DATA_INSTANCE_LOSS_PENDING"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                 <name>next</name></member>
            <member><type>XrTime</type>                      <name>lossTime</name></member>
        </type>
        <type category="struct" name="XrEventDataSessionStateChanged" parentstruct="XrEventDataBaseHeader" returnedonly="true">
            <member values="XR_TYPE_EVENT_DATA_SESSION_STATE_CHANGED"> <type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                 <name>next</name></member>
            <member><type>XrSession</type>                   <name>session</name></member>
            <member><type>XrSessionState</type>              <name>state</name></member>
            <member><type>XrTime</type>                      <name>time</name></member>
        </type>
        <type category="struct" name="XrEventDataReferenceSpaceChangePending" parentstruct="XrEventDataBaseHeader" returnedonly="true">
            <member values="XR_TYPE_EVENT_DATA_REFERENCE_SPACE_CHANGE_PENDING"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                 <name>next</name></member>
            <member><type>XrSession</type>                   <name>session</name></member>
            <member><type>XrReferenceSpaceType</type>        <name>referenceSpaceType</name></member>
            <member><type>XrTime</type>                      <name>changeTime</name></member>
            <member><type>XrBool32</type>                    <name>poseValid</name></member>
            <member><type>XrPosef</type>                     <name>poseInPreviousSpace</name></member>
        </type>
        <type category="struct" name="XrEventDataPerfSettingsEXT" parentstruct="XrEventDataBaseHeader" returnedonly="true">
            <member values="XR_TYPE_EVENT_DATA_PERF_SETTINGS_EXT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                 <name>next</name></member>
            <member><type>XrPerfSettingsDomainEXT</type>     <name>domain</name></member>
            <member><type>XrPerfSettingsSubDomainEXT</type>  <name>subDomain</name></member>
            <member><type>XrPerfSettingsNotificationLevelEXT</type>   <name>fromLevel</name></member>
            <member><type>XrPerfSettingsNotificationLevelEXT</type>   <name>toLevel</name></member>
        </type>
        <type category="struct" name="XrEventDataVisibilityMaskChangedKHR" parentstruct="XrEventDataBaseHeader" returnedonly="true">
            <member values="XR_TYPE_EVENT_DATA_VISIBILITY_MASK_CHANGED_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                 <name>next</name></member>
            <member><type>XrSession</type>                   <name>session</name></member>
            <member><type>XrViewConfigurationType</type>     <name>viewConfigurationType</name></member>
            <member><type>uint32_t</type>                    <name>viewIndex</name></member>
        </type>
        <type category="struct" name="XrViewConfigurationProperties">
            <member values="XR_TYPE_VIEW_CONFIGURATION_PROPERTIES"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                       <name>next</name></member>
            <member><type>XrViewConfigurationType</type>     <name>viewConfigurationType</name></member>
            <member><type>XrBool32</type>                    <name>fovMutable</name></member>
        </type>
        <type category="struct" name="XrActionStateBoolean">
            <member values="XR_TYPE_ACTION_STATE_BOOLEAN"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                       <name>next</name></member>
            <member><type>XrBool32</type>                    <name>currentState</name></member>
            <member><type>XrBool32</type>                    <name>changedSinceLastSync</name></member>
            <member><type>XrTime</type>                      <name>lastChangeTime</name></member>
            <member><type>XrBool32</type>                    <name>isActive</name></member>
        </type>
        <type category="struct" name="XrActionStateFloat">
            <member values="XR_TYPE_ACTION_STATE_FLOAT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                       <name>next</name></member>
            <member><type>float</type>                       <name>currentState</name></member>
            <member><type>XrBool32</type>                    <name>changedSinceLastSync</name></member>
            <member><type>XrTime</type>                      <name>lastChangeTime</name></member>
            <member><type>XrBool32</type>                    <name>isActive</name></member>
        </type>

        <type category="struct" name="XrActionStateVector2f">
            <member values="XR_TYPE_ACTION_STATE_VECTOR2F"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                       <name>next</name></member>
            <member><type>XrVector2f</type>                  <name>currentState</name></member>
            <member><type>XrBool32</type>                    <name>changedSinceLastSync</name></member>
            <member><type>XrTime</type>                      <name>lastChangeTime</name></member>
            <member><type>XrBool32</type>                    <name>isActive</name></member>
        </type>

        <type category="struct" name="XrActionStatePose">
            <member values="XR_TYPE_ACTION_STATE_POSE"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                       <name>next</name></member>
            <member><type>XrBool32</type>                    <name>isActive</name></member>
        </type>

        <type category="struct" name="XrActionStateGetInfo">
            <member values="XR_TYPE_ACTION_STATE_GET_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                        <name>next</name></member>
            <member><type>XrAction</type>                           <name>action</name></member>
            <member optional="true"><type>XrPath</type>             <name>subactionPath</name></member>
        </type>

        <type category="struct" name="XrHapticActionInfo">
            <member values="XR_TYPE_HAPTIC_ACTION_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                        <name>next</name></member>
            <member><type>XrAction</type>                           <name>action</name></member>
            <member optional="true"><type>XrPath</type>             <name>subactionPath</name></member>
        </type>

        <type category="struct" name="XrActionSetCreateInfo">
            <member values="XR_TYPE_ACTION_SET_CREATE_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                 <name>next</name></member>
            <member><type>char</type>                        <name>actionSetName</name>[<enum>XR_MAX_ACTION_SET_NAME_SIZE</enum>]</member>
            <member><type>char</type>                        <name>localizedActionSetName</name>[<enum>XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE</enum>]</member>
            <member><type>uint32_t</type>                    <name>priority</name></member>
        </type>

        <type category="struct" name="XrActionSuggestedBinding">
            <member><type>XrAction</type>                    <name>action</name></member>
            <member><type>XrPath</type>                      <name>binding</name></member>
        </type>

        <type category="struct" name="XrInteractionProfileSuggestedBinding">
            <member values="XR_TYPE_INTERACTION_PROFILE_SUGGESTED_BINDING"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                 <name>next</name></member>
            <member><type>XrPath</type>                      <name>interactionProfile</name></member>
            <member><type>uint32_t</type>                    <name>countSuggestedBindings</name></member>
            <member len="countSuggestedBindings">const <type>XrActionSuggestedBinding</type>*   <name>suggestedBindings</name></member>
        </type>

        <type category="struct" name="XrActiveActionSet">
            <member><type>XrActionSet</type>                 <name>actionSet</name></member>
            <member><type>XrPath</type>                      <name>subactionPath</name></member>
        </type>

        <type category="struct" name="XrSessionActionSetsAttachInfo">
            <member values="XR_TYPE_SESSION_ACTION_SETS_ATTACH_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                   <name>next</name></member>
            <member><type>uint32_t</type>                      <name>countActionSets</name></member>
            <member len="countActionSets">const <type>XrActionSet</type>* <name>actionSets</name></member>
        </type>

        <type category="struct" name="XrActionsSyncInfo">
            <member values="XR_TYPE_ACTIONS_SYNC_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                 <name>next</name></member>
            <member optional="true"><type>uint32_t</type>    <name>countActiveActionSets</name></member>
            <member optional="true" len="countActiveActionSets">const <type>XrActiveActionSet</type>* <name>activeActionSets</name></member>
        </type>

        <type category="struct" name="XrBoundSourcesForActionEnumerateInfo">
            <member values="XR_TYPE_BOUND_SOURCES_FOR_ACTION_ENUMERATE_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                     <name>next</name></member>
            <member><type>XrAction</type>                        <name>action</name></member>
        </type>

        <type category="struct" name="XrInputSourceLocalizedNameGetInfo">
            <member values="XR_TYPE_INPUT_SOURCE_LOCALIZED_NAME_GET_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                     <name>next</name></member>
            <member><type>XrPath</type>                          <name>sourcePath</name></member>
            <member><type>XrInputSourceLocalizedNameFlags</type> <name>whichComponents</name></member>
        </type>

        <type category="struct" name="XrEventDataInteractionProfileChanged" parentstruct="XrEventDataBaseHeader" returnedonly="true">
            <member values="XR_TYPE_EVENT_DATA_INTERACTION_PROFILE_CHANGED"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                 <name>next</name></member>
            <member><type>XrSession</type>                   <name>session</name></member>
        </type>

        <type category="struct" name="XrInteractionProfileState">
            <member values="XR_TYPE_INTERACTION_PROFILE_STATE"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                       <name>next</name></member>
            <member><type>XrPath</type>                      <name>interactionProfile</name></member>
        </type>

        <type category="struct" name="XrActionCreateInfo">
            <member values="XR_TYPE_ACTION_CREATE_INFO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                 <name>next</name></member>
            <member><type>char</type>                        <name>actionName</name>[<enum>XR_MAX_ACTION_NAME_SIZE</enum>]</member>
            <member><type>XrActionType</type>                <name>actionType</name></member>
            <member optional="true"><type>uint32_t</type>    <name>countSubactionPaths</name></member>
            <member len="countSubactionPaths" optional="true">const <type>XrPath</type>* <name>subactionPaths</name></member>
            <member><type>char</type>                        <name>localizedActionName</name>[<enum>XR_MAX_LOCALIZED_ACTION_NAME_SIZE</enum>]</member>
        </type>
        <type category="struct" name="XrInstanceCreateInfoAndroidKHR" structextends="XrInstanceCreateInfo">
            <member values="XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                <name>next</name></member>
            <member><type>void</type>*                      <name>applicationVM</name></member>
            <member><type>void</type>*                      <name>applicationActivity</name></member>
        </type>
        <type category="struct" name="XrVulkanSwapchainFormatListCreateInfoKHR">
            <member values="XR_TYPE_VULKAN_SWAPCHAIN_FORMAT_LIST_CREATE_INFO_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                            <name>next</name></member>
            <member optional="true"><type>uint32_t</type>               <name>viewFormatCount</name></member>
            <member len="viewFormatCount">const <type>VkFormat</type>*  <name>viewFormats</name></member>
        </type>
        <type category="struct" name="XrDebugUtilsObjectNameInfoEXT">
            <member values="XR_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                                        <name>next</name></member>
            <member><type>XrObjectType</type>                                       <name>objectType</name></member>
            <member><type>uint64_t</type>                                           <name>objectHandle</name></member>
            <member optional="true" len="null-terminated">const <type>char</type>*  <name>objectName</name></member>
        </type>
        <type category="struct" name="XrDebugUtilsLabelEXT">
            <member values="XR_TYPE_DEBUG_UTILS_LABEL_EXT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                                            <name>next</name></member>
            <member len="null-terminated">const <type>char</type>*                      <name>labelName</name></member>
        </type>
        <type category="struct" name="XrDebugUtilsMessengerCallbackDataEXT">
            <member values="XR_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT"><type>XrStructureType</type>               <name>type</name></member>
            <member>const <type>void</type>*                                                                            <name>next</name></member>
            <member len="null-terminated">const <type>char</type>*                                                      <name>messageId</name></member>
            <member len="null-terminated">const <type>char</type>*                                                      <name>functionName</name></member>
            <member len="null-terminated">const <type>char</type>*                                                      <name>message</name></member>
            <member optional="true"><type>uint32_t</type>                                                               <name>objectCount</name></member>
            <member noautovalidity="true" optional="true" len="objectCount"><type>XrDebugUtilsObjectNameInfoEXT</type>* <name>objects</name></member>
            <member optional="true"><type>uint32_t</type>                                                               <name>sessionLabelCount</name></member>
            <member noautovalidity="true" optional="true" len="sessionLabelCount"><type>XrDebugUtilsLabelEXT</type>*    <name>sessionLabels</name></member>
        </type>
        <type category="struct" name="XrDebugUtilsMessengerCreateInfoEXT" structextends="XrInstanceCreateInfo">
            <member values="XR_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                            <name>next</name></member>
            <member><type>XrDebugUtilsMessageSeverityFlagsEXT</type>    <name>messageSeverities</name></member>
            <member><type>XrDebugUtilsMessageTypeFlagsEXT</type>        <name>messageTypes</name></member>
            <member><type>PFN_xrDebugUtilsMessengerCallbackEXT</type>   <name>userCallback</name></member>
            <member optional="true"><type>void</type>*                  <name>userData</name></member>
        </type>

        <!-- struct types for XR_KHR_visibility_mask -->
        <type category="struct" name="XrVisibilityMaskKHR">
            <member values="XR_TYPE_VISIBILITY_MASK_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                 <name>next</name></member>
            <member optional="true"><type>uint32_t</type>                                   <name>vertexCapacityInput</name></member>
            <member optional="true"><type>uint32_t</type>                                   <name>vertexCountOutput</name></member>
            <member optional="true" len="vertexCapacityInput"><type>XrVector2f</type>*      <name>vertices</name></member>
            <member optional="true"><type>uint32_t</type>                                   <name>indexCapacityInput</name></member>
            <member optional="true"><type>uint32_t</type>                                   <name>indexCountOutput</name></member>
            <member optional="true" len="indexCapacityInput"><type>uint32_t</type>*         <name>indices</name></member>
        </type>

        <type category="struct" name="XrGraphicsRequirementsOpenGLKHR">
            <member values="XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*     <name>next</name></member>
            <member><type>XrVersion</type> <name>minApiVersionSupported</name></member>
            <member><type>XrVersion</type> <name>maxApiVersionSupported</name></member>
        </type>
        <type category="struct" name="XrGraphicsRequirementsOpenGLESKHR">
            <member values="XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_ES_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*     <name>next</name></member>
            <member><type>XrVersion</type> <name>minApiVersionSupported</name></member>
            <member><type>XrVersion</type> <name>maxApiVersionSupported</name></member>
        </type>
        <type category="struct" name="XrGraphicsRequirementsVulkanKHR">
            <member values="XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*     <name>next</name></member>
            <member><type>XrVersion</type> <name>minApiVersionSupported</name></member>
            <member><type>XrVersion</type> <name>maxApiVersionSupported</name></member>
        </type>
        <type category="struct" name="XrGraphicsRequirementsD3D11KHR">
            <member values="XR_TYPE_GRAPHICS_REQUIREMENTS_D3D11_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>LUID</type>  <name>adapterLuid</name></member>
            <member><type>D3D_FEATURE_LEVEL</type>  <name>minFeatureLevel</name></member>
        </type>
        <type category="struct" name="XrGraphicsRequirementsD3D12KHR">
            <member values="XR_TYPE_GRAPHICS_REQUIREMENTS_D3D12_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>LUID</type>  <name>adapterLuid</name></member>
            <member><type>D3D_FEATURE_LEVEL</type>  <name>minFeatureLevel</name></member>
        </type>

        <!-- XR_KHR_vulkan_enable2 structs -->
        <type category="struct" name="XrVulkanInstanceCreateInfoKHR">
            <member values="XR_TYPE_VULKAN_INSTANCE_CREATE_INFO_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                    <name>next</name></member>
            <member><type>XrSystemId</type>                     <name>systemId</name></member>
            <member optional="true"><type>XrVulkanInstanceCreateFlagsKHR</type> <name>createFlags</name></member>
            <member><type>PFN_vkGetInstanceProcAddr</type>      <name>pfnGetInstanceProcAddr</name></member>
            <member>const <type>VkInstanceCreateInfo</type>*    <name>vulkanCreateInfo</name></member>
            <member optional="true">const <type>VkAllocationCallbacks</type>*   <name>vulkanAllocator</name></member>
        </type>
        <type category="struct" name="XrVulkanDeviceCreateInfoKHR">
            <member values="XR_TYPE_VULKAN_DEVICE_CREATE_INFO_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                    <name>next</name></member>
            <member><type>XrSystemId</type>                     <name>systemId</name></member>
            <member optional="true"><type>XrVulkanDeviceCreateFlagsKHR</type>   <name>createFlags</name></member>
            <member><type>PFN_vkGetInstanceProcAddr</type>      <name>pfnGetInstanceProcAddr</name></member>
            <member><type>VkPhysicalDevice</type>               <name>vulkanPhysicalDevice</name></member>
            <member>const <type>VkDeviceCreateInfo</type>*      <name>vulkanCreateInfo</name></member>
            <member optional="true">const <type>VkAllocationCallbacks</type>*   <name>vulkanAllocator</name></member>
        </type>
        <type category="struct" name="XrGraphicsBindingVulkan2KHR" alias="XrGraphicsBindingVulkanKHR"/>
        <type category="struct" name="XrVulkanGraphicsDeviceGetInfoKHR">
            <member values="XR_TYPE_VULKAN_GRAPHICS_DEVICE_GET_INFO_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*         <name>next</name></member>
            <member><type>XrSystemId</type>          <name>systemId</name></member>
            <member><type>VkInstance</type>          <name>vulkanInstance</name></member>
        </type>
        <type category="struct" name="XrSwapchainImageVulkan2KHR" alias="XrSwapchainImageVulkanKHR"/>
        <type category="struct" name="XrGraphicsRequirementsVulkan2KHR" alias="XrGraphicsRequirementsVulkanKHR"/>

        <!-- XR_META_vulkan_swapchain_create_info structs -->
        <type category="struct" name="XrVulkanSwapchainCreateInfoMETA" structextends="XrSwapchainCreateInfo">
            <member values="XR_TYPE_VULKAN_SWAPCHAIN_CREATE_INFO_META"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*          <name>next</name></member>
            <member><type>VkImageCreateFlags</type>   <name>additionalCreateFlags</name></member>
            <member><type>VkImageUsageFlags</type>    <name>additionalUsageFlags</name></member>
        </type>

        <!-- XR_EXTX_overlay structs -->
        <type category="struct" name="XrSessionCreateInfoOverlayEXTX" structextends="XrSessionCreateInfo">
            <member values="XR_TYPE_SESSION_CREATE_INFO_OVERLAY_EXTX"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                                                      <name>next</name></member>
            <member><type>XrOverlaySessionCreateFlagsEXTX</type>                                                         <name>createFlags</name></member>
            <member><type>uint32_t</type>                                                         <name>sessionLayersPlacement</name></member>
        </type>
        <type category="struct" name="XrEventDataMainSessionVisibilityChangedEXTX" parentstruct="XrEventDataBaseHeader" returnedonly="true">
            <member values="XR_TYPE_EVENT_DATA_MAIN_SESSION_VISIBILITY_CHANGED_EXTX"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                                                                     <name>next</name></member>
            <member><type>XrBool32</type>                                                                        <name>visible</name></member>
            <member><type>XrOverlayMainSessionFlagsEXTX</type>                                                    <name>flags</name></member>
        </type>

        <!-- XR_FB_display_refresh_rate structs -->
        <type category="struct" name="XrEventDataDisplayRefreshRateChangedFB" parentstruct="XrEventDataBaseHeader" returnedonly="true">
            <member values="XR_TYPE_EVENT_DATA_DISPLAY_REFRESH_RATE_CHANGED_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                                                                     <name>next</name></member>
            <member><type>float</type>                                                                           <name>fromDisplayRefreshRate</name></member>
            <member><type>float</type>                                                                           <name>toDisplayRefreshRate</name></member>
        </type>

        <!-- struct types for XR_EXT_view_configuration_depth_range -->
        <type category="struct" name="XrViewConfigurationDepthRangeEXT" structextends="XrViewConfigurationView">
            <member values="XR_TYPE_VIEW_CONFIGURATION_DEPTH_RANGE_EXT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>float</type> <name>recommendedNearZ</name></member>
            <member><type>float</type> <name>minNearZ</name></member>
            <member><type>float</type> <name>recommendedFarZ</name></member>
            <member><type>float</type> <name>maxFarZ</name></member>
        </type>

        <!-- struct types for XR_EPIC_view_configuration_fov -->
        <type category="struct" name="XrViewConfigurationViewFovEPIC" structextends="XrViewConfigurationView">
            <member values="XR_TYPE_VIEW_CONFIGURATION_VIEW_FOV_EPIC"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*           <name>next</name></member>
            <member><type>XrFovf</type>                <name>recommendedFov</name></member>
            <member><type>XrFovf</type>                <name>maxMutableFov</name></member>
        </type>

        <!-- struct types for XR_EXT_dpad_binding -->
        <type category="struct" name="XrInteractionProfileDpadBindingEXT" parentstruct="XrBindingModificationBaseHeaderKHR">
            <member values="XR_TYPE_INTERACTION_PROFILE_DPAD_BINDING_EXT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                               <name>next</name></member>
            <member><type>XrPath</type>                                    <name>binding</name></member>
            <member><type>XrActionSet</type>                               <name>actionSet</name></member>
            <member><type>float</type>                                     <name>forceThreshold</name></member>
            <member><type>float</type>                                     <name>forceThresholdReleased</name></member>
            <member><type>float</type>                                     <name>centerRegion</name></member>
            <member><type>float</type>                                     <name>wedgeAngle</name></member>
            <member><type>XrBool32</type>                                  <name>isSticky</name></member>
            <member optional="true">const <type>XrHapticBaseHeader</type>* <name>onHaptic</name></member>
            <member optional="true">const <type>XrHapticBaseHeader</type>* <name>offHaptic</name></member>
        </type>

        <!-- struct types for XR_VALVE_analog_threshold -->
        <type category="struct" name="XrInteractionProfileAnalogThresholdVALVE" parentstruct="XrBindingModificationBaseHeaderKHR">
            <member values="XR_TYPE_INTERACTION_PROFILE_ANALOG_THRESHOLD_VALVE"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*           <name>next</name></member>
            <member><type>XrAction</type>              <name>action</name></member>
            <member><type>XrPath</type>                <name>binding</name></member>
            <member><type>float</type>                 <name>onThreshold</name></member>
            <member><type>float</type>                 <name>offThreshold</name></member>
            <member optional="true">const <type>XrHapticBaseHeader</type>* <name>onHaptic</name></member>
            <member optional="true">const <type>XrHapticBaseHeader</type>* <name>offHaptic</name></member>
        </type>

        <!-- struct types for XR_KHR_binding_modification -->
        <type category="struct" name="XrBindingModificationsKHR" structextends="XrInteractionProfileSuggestedBinding">
            <member values="XR_TYPE_BINDING_MODIFICATIONS_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*           <name>next</name></member>
            <member optional="true"><type>uint32_t</type>    <name>bindingModificationCount</name></member>
            <member optional="true" len="bindingModificationCount">const <type>XrBindingModificationBaseHeaderKHR</type>* const*  <name>bindingModifications</name></member>
        </type>

        <type category="struct" name="XrBindingModificationBaseHeaderKHR">
            <member noautovalidity="true"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*     <name>next</name></member>
        </type>

        <!-- The PFN_xrVoidFunction type are used by XrGetInstanceProcAddr below -->
        <type category="funcpointer">typedef void (XRAPI_PTR *<name>PFN_xrVoidFunction</name>)(void);</type>

        <!-- The PFN_xrDebugUtilsMessengerCallbackEXT type are used by the XR_EXT_debug_utils extension -->
        <type category="funcpointer" requires="XrDebugUtilsMessengerCallbackDataEXT">typedef XrBool32 (XRAPI_PTR *<name>PFN_xrDebugUtilsMessengerCallbackEXT</name>)(
            <type>XrDebugUtilsMessageSeverityFlagsEXT</type>              messageSeverity,
            <type>XrDebugUtilsMessageTypeFlagsEXT</type>                  messageTypes,
            const <type>XrDebugUtilsMessengerCallbackDataEXT</type>*      callbackData,
            <type>void</type>*                                            userData);
        </type>

        <!-- types for XR_EXT_eye_gaze_interaction -->
        <type category="struct" name="XrSystemEyeGazeInteractionPropertiesEXT" returnedonly="true" structextends="XrSystemProperties">
            <member values="XR_TYPE_SYSTEM_EYE_GAZE_INTERACTION_PROPERTIES_EXT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*    <name>next</name></member>
            <member><type>XrBool32</type> <name>supportsEyeGazeInteraction</name></member>
        </type>

        <type category="struct" name="XrEyeGazeSampleTimeEXT" structextends="XrSpaceLocation">
            <member values="XR_TYPE_EYE_GAZE_SAMPLE_TIME_EXT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*   <name>next</name></member>
            <member><type>XrTime</type>  <name>time</name></member>
        </type>

        <!-- types for XR_MSFT_spatial_anchor -->
        <type category="struct" name="XrSpatialAnchorCreateInfoMSFT">
            <member values="XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrSpace</type>     <name>space</name></member>
            <member><type>XrPosef</type>     <name>pose</name></member>
            <member><type>XrTime</type>      <name>time</name></member>
        </type>
        <type category="struct" name="XrSpatialAnchorSpaceCreateInfoMSFT">
            <member values="XR_TYPE_SPATIAL_ANCHOR_SPACE_CREATE_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                     <name>next</name></member>
            <member><type>XrSpatialAnchorMSFT</type>             <name>anchor</name></member>
            <member><type>XrPosef</type>                         <name>poseInAnchorSpace</name></member>
        </type>

        <!-- types for XR_FB_composition_layer_image_layout -->
        <type category="struct" name="XrCompositionLayerImageLayoutFB" structextends="XrCompositionLayerBaseHeader">
            <member values="XR_TYPE_COMPOSITION_LAYER_IMAGE_LAYOUT_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member optional="true"><type>XrCompositionLayerImageLayoutFlagsFB</type> <name>flags</name></member>
        </type>

        <!-- types for XR_FB_composition_layer_alpha_blend -->
        <type category="struct" name="XrCompositionLayerAlphaBlendFB" structextends="XrCompositionLayerBaseHeader">
            <member values="XR_TYPE_COMPOSITION_LAYER_ALPHA_BLEND_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>XrBlendFactorFB</type> <name>srcFactorColor</name></member>
            <member><type>XrBlendFactorFB</type> <name>dstFactorColor</name></member>
            <member><type>XrBlendFactorFB</type> <name>srcFactorAlpha</name></member>
            <member><type>XrBlendFactorFB</type> <name>dstFactorAlpha</name></member>
        </type>

        <!-- types for XR_MNDX_egl_enable -->
        <type category="struct" name="XrGraphicsBindingEGLMNDX" structextends="XrSessionCreateInfo">
            <member values="XR_TYPE_GRAPHICS_BINDING_EGL_MNDX"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>PFNEGLGETPROCADDRESSPROC</type> <name>getProcAddress</name></member>
            <member><type>EGLDisplay</type> <name>display</name></member>
            <member><type>EGLConfig</type> <name>config</name></member>
            <member><type>EGLContext</type> <name>context</name></member>
        </type>

        <!-- types for XR_MSFT_spatial_graph_bridge -->
        <type category="handle" parent="XrSession"><type>XR_DEFINE_HANDLE</type>(<name>XrSpatialGraphNodeBindingMSFT</name>)</type>
        <type category="struct" name="XrSpatialGraphNodeSpaceCreateInfoMSFT">
            <member values="XR_TYPE_SPATIAL_GRAPH_NODE_SPACE_CREATE_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                            <name>next</name></member>
            <member><type>XrSpatialGraphNodeTypeMSFT</type>             <name>nodeType</name></member>
            <member><type>uint8_t</type>                                <name>nodeId</name>[XR_GUID_SIZE_MSFT]</member>
            <member><type>XrPosef</type>                                <name>pose</name></member>
        </type>
        <type category="struct" name="XrSpatialGraphStaticNodeBindingCreateInfoMSFT">
            <member values="XR_TYPE_SPATIAL_GRAPH_STATIC_NODE_BINDING_CREATE_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrSpace</type>     <name>space</name></member>
            <member><type>XrPosef</type>     <name>poseInSpace</name></member>
            <member><type>XrTime</type>      <name>time</name></member>
        </type>
        <type category="struct" name="XrSpatialGraphNodeBindingPropertiesGetInfoMSFT">
            <member values="XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_GET_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
        </type>
        <type category="struct" name="XrSpatialGraphNodeBindingPropertiesMSFT">
            <member values="XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*   <name>next</name></member>
            <member><type>uint8_t</type> <name>nodeId</name>[XR_GUID_SIZE_MSFT]</member>
            <member><type>XrPosef</type> <name>poseInNodeSpace</name></member>
        </type>

        <!-- XR_EXT_hand_tracking -->
        <type name="XrHandEXT" category="enum"/>
        <type name="XrHandJointEXT" category="enum"/>
        <type name="XrHandJointSetEXT" category="enum"/>

        <type category="struct" name="XrSystemHandTrackingPropertiesEXT" returnedonly="true" structextends="XrSystemProperties">
            <member values="XR_TYPE_SYSTEM_HAND_TRACKING_PROPERTIES_EXT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>XrBool32</type> <name>supportsHandTracking</name></member>
        </type>
        <type category="struct" name="XrHandTrackerCreateInfoEXT">
            <member values="XR_TYPE_HAND_TRACKER_CREATE_INFO_EXT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrHandEXT</type> <name>hand</name></member>
            <member><type>XrHandJointSetEXT</type> <name>handJointSet</name></member>
        </type>
        <type category="struct" name="XrHandJointsLocateInfoEXT">
            <member values="XR_TYPE_HAND_JOINTS_LOCATE_INFO_EXT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrSpace</type> <name>baseSpace</name></member>
            <member><type>XrTime</type> <name>time</name></member>
        </type>
        <type category="struct" name="XrHandJointLocationEXT">
            <member optional="true"><type>XrSpaceLocationFlags</type> <name>locationFlags</name></member>
            <member><type>XrPosef</type> <name>pose</name></member>
            <member><type>float</type> <name>radius</name></member>
        </type>
        <type category="struct" name="XrHandJointVelocityEXT">
            <member><type>XrSpaceVelocityFlags</type> <name>velocityFlags</name></member>
            <member><type>XrVector3f</type> <name>linearVelocity</name></member>
            <member><type>XrVector3f</type> <name>angularVelocity</name></member>
        </type>
        <type category="struct" name="XrHandJointLocationsEXT">
            <member values="XR_TYPE_HAND_JOINT_LOCATIONS_EXT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>XrBool32</type> <name>isActive</name></member>
            <member><type>uint32_t</type> <name>jointCount</name></member>
            <member len="jointCount"><type>XrHandJointLocationEXT</type>* <name>jointLocations</name></member>
        </type>
        <type category="struct" name="XrHandJointVelocitiesEXT" structextends="XrHandJointLocationsEXT">
            <member values="XR_TYPE_HAND_JOINT_VELOCITIES_EXT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>uint32_t</type> <name>jointCount</name></member>
            <member len="jointCount"><type>XrHandJointVelocityEXT</type>* <name>jointVelocities</name></member>
        </type>

        <!-- XR_EXT_controller_hand_joints_motion_range -->
        <type name="XrHandJointsMotionRangeEXT" category="enum"/>
        <type category="struct" name="XrHandJointsMotionRangeInfoEXT" structextends="XrHandJointsLocateInfoEXT">
            <member values="XR_TYPE_HAND_JOINTS_MOTION_RANGE_INFO_EXT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrHandJointsMotionRangeEXT</type> <name>handJointsMotionRange</name></member>
        </type>

        <!-- XR_MSFT_hand_tracking_mesh -->
        <type name="XrHandPoseTypeMSFT" category="enum"/>
        <type category="struct" name="XrHandMeshSpaceCreateInfoMSFT">
            <member values="XR_TYPE_HAND_MESH_SPACE_CREATE_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                     <name>next</name></member>
            <member><type>XrHandPoseTypeMSFT</type>              <name>handPoseType</name></member>
            <member><type>XrPosef</type>                         <name>poseInHandMeshSpace</name></member>
        </type>
        <type category="struct" name="XrHandMeshUpdateInfoMSFT">
            <member values="XR_TYPE_HAND_MESH_UPDATE_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrTime</type> <name>time</name></member>
            <member><type>XrHandPoseTypeMSFT</type> <name>handPoseType</name></member>
        </type>
        <type category="struct" name="XrHandMeshMSFT">
            <member values="XR_TYPE_HAND_MESH_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>XrBool32</type> <name>isActive</name></member>
            <member><type>XrBool32</type> <name>indexBufferChanged</name></member>
            <member><type>XrBool32</type> <name>vertexBufferChanged</name></member>
            <member><type>XrHandMeshIndexBufferMSFT</type> <name>indexBuffer</name></member>
            <member><type>XrHandMeshVertexBufferMSFT</type> <name>vertexBuffer</name></member>
        </type>
        <type category="struct" name="XrHandMeshIndexBufferMSFT">
            <member optional="true"><type>uint32_t</type> <name>indexBufferKey</name></member>
            <member><type>uint32_t</type> <name>indexCapacityInput</name></member>
            <member optional="true"><type>uint32_t</type> <name>indexCountOutput</name></member>
            <member len="indexCapacityInput"><type>uint32_t</type>* <name>indices</name></member>
        </type>
        <type category="struct" name="XrHandMeshVertexBufferMSFT">
            <member optional="true"><type>XrTime</type> <name>vertexUpdateTime</name></member>
            <member><type>uint32_t</type> <name>vertexCapacityInput</name></member>
            <member optional="true"><type>uint32_t</type> <name>vertexCountOutput</name></member>
            <member len="vertexCapacityInput"><type>XrHandMeshVertexMSFT</type>* <name>vertices</name></member>
        </type>
        <type category="struct" name="XrHandMeshVertexMSFT">
            <member><type>XrVector3f</type> <name>position</name></member>
            <member><type>XrVector3f</type> <name>normal</name></member>
        </type>
        <type category="struct" name="XrSystemHandTrackingMeshPropertiesMSFT" returnedonly="true" structextends="XrSystemProperties">
            <member values="XR_TYPE_SYSTEM_HAND_TRACKING_MESH_PROPERTIES_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>XrBool32</type> <name>supportsHandTrackingMesh</name></member>
            <member><type>uint32_t</type> <name>maxHandMeshIndexCount</name></member>
            <member><type>uint32_t</type> <name>maxHandMeshVertexCount</name></member>
        </type>
        <type category="struct" name="XrHandPoseTypeInfoMSFT" structextends="XrHandTrackerCreateInfoEXT">
            <member values="XR_TYPE_HAND_POSE_TYPE_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*        <name>next</name></member>
            <member><type>XrHandPoseTypeMSFT</type> <name>handPoseType</name></member>
        </type>

        <!-- XR_MSFT_secondary_view_configuration -->
        <type category="struct" name="XrSecondaryViewConfigurationSessionBeginInfoMSFT" structextends="XrSessionBeginInfo">
            <member values="XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SESSION_BEGIN_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>uint32_t</type> <name>viewConfigurationCount</name></member>
            <member len="viewConfigurationCount">const <type>XrViewConfigurationType</type>* <name>enabledViewConfigurationTypes</name></member>
        </type>
        <type category="struct" name="XrSecondaryViewConfigurationStateMSFT">
            <member values="XR_TYPE_SECONDARY_VIEW_CONFIGURATION_STATE_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>XrViewConfigurationType</type> <name>viewConfigurationType</name></member>
            <member><type>XrBool32</type> <name>active</name></member>
        </type>
        <type category="struct" name="XrSecondaryViewConfigurationFrameStateMSFT" structextends="XrFrameState">
            <member values="XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_STATE_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>uint32_t</type> <name>viewConfigurationCount</name></member>
            <member len="viewConfigurationCount"><type>XrSecondaryViewConfigurationStateMSFT</type>* <name>viewConfigurationStates</name></member>
        </type>
        <type category="struct" name="XrSecondaryViewConfigurationFrameEndInfoMSFT" structextends="XrFrameEndInfo">
            <member values="XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_END_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>uint32_t</type> <name>viewConfigurationCount</name></member>
            <member len="viewConfigurationCount">const <type>XrSecondaryViewConfigurationLayerInfoMSFT</type>* <name>viewConfigurationLayersInfo</name></member>
        </type>
        <type category="struct" name="XrSecondaryViewConfigurationLayerInfoMSFT">
            <member values="XR_TYPE_SECONDARY_VIEW_CONFIGURATION_LAYER_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrViewConfigurationType</type> <name>viewConfigurationType</name></member>
            <member><type>XrEnvironmentBlendMode</type> <name>environmentBlendMode</name></member>
            <member><type>uint32_t</type> <name>layerCount</name></member>
            <member len="layerCount">const <type>XrCompositionLayerBaseHeader</type>* const* <name>layers</name></member>
        </type>
        <type category="struct" name="XrSecondaryViewConfigurationSwapchainCreateInfoMSFT" structextends="XrSwapchainCreateInfo">
            <member values="XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SWAPCHAIN_CREATE_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrViewConfigurationType</type> <name>viewConfigurationType</name></member>
        </type>

        <!-- XR_MSFT_holographic_window_attachment -->
        <type category="struct" name="XrHolographicWindowAttachmentMSFT" structextends="XrSessionCreateInfo" protect="XR_USE_PLATFORM_WIN32">
            <member values="XR_TYPE_HOLOGRAPHIC_WINDOW_ATTACHMENT_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>IUnknown</type>* <name>holographicSpace</name></member>
            <member><type>IUnknown</type>* <name>coreWindow</name></member>
        </type>

        <!-- XR_FB_android_surface_swapchain_create -->
        <type category="struct" name="XrAndroidSurfaceSwapchainCreateInfoFB" structextends="XrSwapchainCreateInfo" protect="XR_USE_PLATFORM_ANDROID">
            <member values="XR_TYPE_ANDROID_SURFACE_SWAPCHAIN_CREATE_INFO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrAndroidSurfaceSwapchainFlagsFB</type> <name>createFlags</name></member>
        </type>

        <!-- XR_FB_swapchain_update_state structs -->
        <type category="struct" name="XrSwapchainStateBaseHeaderFB">
            <member><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
        </type>

        <!-- XR_FB_swapchain_update_state_android_surface structs -->
        <type category="struct" name="XrSwapchainStateAndroidSurfaceDimensionsFB" parentstruct="XrSwapchainStateBaseHeaderFB" protect="XR_USE_PLATFORM_ANDROID">
            <member values="XR_TYPE_SWAPCHAIN_STATE_ANDROID_SURFACE_DIMENSIONS_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>uint32_t</type> <name>width</name></member>
            <member><type>uint32_t</type> <name>height</name></member>
        </type>

        <!-- XR_FB_swapchain_update_state_opengl_es structs -->
        <type category="struct" name="XrSwapchainStateSamplerOpenGLESFB" parentstruct="XrSwapchainStateBaseHeaderFB" protect="XR_USE_GRAPHICS_API_OPENGL_ES">
            <member values="XR_TYPE_SWAPCHAIN_STATE_SAMPLER_OPENGL_ES_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>EGLenum</type> <name>minFilter</name></member>
            <member><type>EGLenum</type> <name>magFilter</name></member>
            <member><type>EGLenum</type> <name>wrapModeS</name></member>
            <member><type>EGLenum</type> <name>wrapModeT</name></member>
            <member><type>EGLenum</type> <name>swizzleRed</name></member>
            <member><type>EGLenum</type> <name>swizzleGreen</name></member>
            <member><type>EGLenum</type> <name>swizzleBlue</name></member>
            <member><type>EGLenum</type> <name>swizzleAlpha</name></member>
            <member><type>float</type> <name>maxAnisotropy</name></member>
            <member><type>XrColor4f</type> <name>borderColor</name></member>
        </type>

        <!-- XR_FB_swapchain_update_state_vulkan structs -->
        <type category="struct" name="XrSwapchainStateSamplerVulkanFB" parentstruct="XrSwapchainStateBaseHeaderFB" protect="XR_USE_GRAPHICS_API_VULKAN">
            <member values="XR_TYPE_SWAPCHAIN_STATE_SAMPLER_VULKAN_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>VkFilter</type> <name>minFilter</name></member>
            <member><type>VkFilter</type> <name>magFilter</name></member>
            <member><type>VkSamplerMipmapMode</type> <name>mipmapMode</name></member>
            <member><type>VkSamplerAddressMode</type> <name>wrapModeS</name></member>
            <member><type>VkSamplerAddressMode</type> <name>wrapModeT</name></member>
            <member><type>VkComponentSwizzle</type> <name>swizzleRed</name></member>
            <member><type>VkComponentSwizzle</type> <name>swizzleGreen</name></member>
            <member><type>VkComponentSwizzle</type> <name>swizzleBlue</name></member>
            <member><type>VkComponentSwizzle</type> <name>swizzleAlpha</name></member>
            <member><type>float</type> <name>maxAnisotropy</name></member>
            <member><type>XrColor4f</type> <name>borderColor</name></member>
        </type>

        <!-- XR_FB_composition_layer_secure_content structs -->
        <type category="struct" name="XrCompositionLayerSecureContentFB" structextends="XrCompositionLayerBaseHeader">
            <member values="XR_TYPE_COMPOSITION_LAYER_SECURE_CONTENT_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrCompositionLayerSecureContentFlagsFB</type> <name>flags</name></member>
        </type>

        <!-- XR_KHR_loader_init -->
        <type category="struct" name="XrLoaderInitInfoBaseHeaderKHR">
            <member><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                <name>next</name></member>
        </type>

        <!-- XR_KHR_loader_init_android -->
        <type category="struct" name="XrLoaderInitInfoAndroidKHR" parentstruct="XrLoaderInitInfoBaseHeaderKHR">
            <member values="XR_TYPE_LOADER_INIT_INFO_ANDROID_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                <name>next</name></member>
            <member><type>void</type>*                      <name>applicationVM</name></member>
            <member><type>void</type>*                      <name>applicationContext</name></member>
        </type>

        <!-- XR_KHR_composition_layer_equirect2 -->
        <type category="struct" name="XrCompositionLayerEquirect2KHR" parentstruct="XrCompositionLayerBaseHeader">
            <member values="XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                            <name>next</name></member>
            <member optional="true"><type>XrCompositionLayerFlags</type> <name>layerFlags</name></member>
            <member><type>XrSpace</type>                                <name>space</name></member>
            <member><type>XrEyeVisibility</type>                        <name>eyeVisibility</name></member>
            <member><type>XrSwapchainSubImage</type>                    <name>subImage</name></member>
            <member><type>XrPosef</type>                                <name>pose</name></member>
            <member><type>float</type>                                  <name>radius</name></member>
            <member><type>float</type>                                  <name>centralHorizontalAngle</name></member>
            <member><type>float</type>                                  <name>upperVerticalAngle</name></member>
            <member><type>float</type>                                  <name>lowerVerticalAngle</name></member>
        </type>

        <!-- XR_KHR_composition_layer_color_scale_bias -->
        <type category="struct" name="XrCompositionLayerColorScaleBiasKHR" structextends="XrCompositionLayerBaseHeader">
            <member values="XR_TYPE_COMPOSITION_LAYER_COLOR_SCALE_BIAS_KHR"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                     <name>next</name></member>
            <member><type>XrColor4f</type>                       <name>colorScale</name></member>
            <member><type>XrColor4f</type>                       <name>colorBias</name></member>
        </type>

        <!-- XR_MSFT_controller_model -->
        <type category="struct" name="XrControllerModelKeyStateMSFT">
            <member values="XR_TYPE_CONTROLLER_MODEL_KEY_STATE_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>XrControllerModelKeyMSFT</type> <name>modelKey</name></member>
        </type>
        <type category="struct" name="XrControllerModelNodePropertiesMSFT">
            <member values="XR_TYPE_CONTROLLER_MODEL_NODE_PROPERTIES_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>char</type> <name>parentNodeName</name>[XR_MAX_CONTROLLER_MODEL_NODE_NAME_SIZE_MSFT]</member>
            <member><type>char</type> <name>nodeName</name>[XR_MAX_CONTROLLER_MODEL_NODE_NAME_SIZE_MSFT]</member>
        </type>
        <type category="struct" name="XrControllerModelPropertiesMSFT">
            <member values="XR_TYPE_CONTROLLER_MODEL_PROPERTIES_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member optional="true"><type>uint32_t</type> <name>nodeCapacityInput</name></member>
            <member optional="true"><type>uint32_t</type> <name>nodeCountOutput</name></member>
            <member optional="true" len="nodeCapacityInput"><type>XrControllerModelNodePropertiesMSFT</type>* <name>nodeProperties</name></member>
        </type>
        <type category="struct" name="XrControllerModelNodeStateMSFT">
            <member values="XR_TYPE_CONTROLLER_MODEL_NODE_STATE_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>XrPosef</type> <name>nodePose</name></member>
        </type>
        <type category="struct" name="XrControllerModelStateMSFT">
            <member values="XR_TYPE_CONTROLLER_MODEL_STATE_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member optional="true"><type>uint32_t</type> <name>nodeCapacityInput</name></member>
            <member optional="true"><type>uint32_t</type> <name>nodeCountOutput</name></member>
            <member optional="true" len="nodeCapacityInput"><type>XrControllerModelNodeStateMSFT</type>* <name>nodeStates</name></member>
        </type>

        <!-- XR_MSFT_scene_understanding -->
        <type category="handle" parent="XrSession">
            <type>XR_DEFINE_HANDLE</type>(<name>XrSceneObserverMSFT</name>)</type>
        <type category="handle" parent="XrSceneObserverMSFT">
            <type>XR_DEFINE_HANDLE</type>(<name>XrSceneMSFT</name>)</type>
        <type name="XrSceneObjectTypeMSFT" category="enum"/>
        <type name="XrScenePlaneAlignmentTypeMSFT" category="enum"/>
        <type name="XrSceneComputeStateMSFT" category="enum"/>
        <type name="XrSceneComputeFeatureMSFT" category="enum"/>
        <type name="XrSceneComputeConsistencyMSFT" category="enum"/>
        <type name="XrSceneComponentTypeMSFT" category="enum"/>
        <type name="XrMeshComputeLodMSFT" category="enum"/>
        <type category="struct" name="XrUuidMSFT">
            <member><type>uint8_t</type> <name>bytes</name>[16]</member>
        </type>
        <type category="struct" name="XrSceneObserverCreateInfoMSFT">
            <member values="XR_TYPE_SCENE_OBSERVER_CREATE_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
        </type>
        <type category="struct" name="XrSceneCreateInfoMSFT">
            <member values="XR_TYPE_SCENE_CREATE_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
        </type>
        <type category="struct" name="XrNewSceneComputeInfoMSFT">
            <member values="XR_TYPE_NEW_SCENE_COMPUTE_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>uint32_t</type> <name>requestedFeatureCount</name></member>
            <member len="requestedFeatureCount">const <type>XrSceneComputeFeatureMSFT</type>* <name>requestedFeatures</name></member>
            <member><type>XrSceneComputeConsistencyMSFT</type> <name>consistency</name></member>
            <member><type>XrSceneBoundsMSFT</type> <name>bounds</name></member>
        </type>
        <type category="struct" name="XrVisualMeshComputeLodInfoMSFT" structextends="XrNewSceneComputeInfoMSFT">
            <member values="XR_TYPE_VISUAL_MESH_COMPUTE_LOD_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrMeshComputeLodMSFT</type> <name>lod</name></member>
        </type>
        <type category="struct" name="XrSceneSphereBoundMSFT">
            <member><type>XrVector3f</type> <name>center</name></member>
            <member><type>float</type> <name>radius</name></member>
        </type>
        <type category="struct" name="XrSceneOrientedBoxBoundMSFT">
            <member><type>XrPosef</type> <name>pose</name></member>
            <member><type>XrVector3f</type> <name>extents</name></member>
        </type>
        <type category="struct" name="XrSceneFrustumBoundMSFT">
            <member><type>XrPosef</type> <name>pose</name></member>
            <member><type>XrFovf</type> <name>fov</name></member>
            <member><type>float</type> <name>farDistance</name></member>
        </type>
        <type category="struct" name="XrSceneBoundsMSFT">
            <member><type>XrSpace</type> <name>space</name></member>
            <member><type>XrTime</type> <name>time</name></member>
            <member optional="true"><type>uint32_t</type> <name>sphereCount</name></member>
            <member optional="true" len="sphereCount">const <type>XrSceneSphereBoundMSFT</type>* <name>spheres</name></member>
            <member optional="true"><type>uint32_t</type> <name>boxCount</name></member>
            <member optional="true" len="boxCount">const <type>XrSceneOrientedBoxBoundMSFT</type>* <name>boxes</name></member>
            <member optional="true"><type>uint32_t</type> <name>frustumCount</name></member>
            <member optional="true" len="frustumCount">const <type>XrSceneFrustumBoundMSFT</type>* <name>frustums</name></member>
        </type>
        <type category="struct" name="XrSceneComponentMSFT">
            <member><type>XrSceneComponentTypeMSFT</type> <name>componentType</name></member>
            <member><type>XrUuidMSFT</type> <name>id</name></member>
            <member optional="true"><type>XrUuidMSFT</type> <name>parentId</name></member>
            <member><type>XrTime</type> <name>updateTime</name></member>
        </type>
        <type category="struct" name="XrSceneComponentsMSFT">
            <member values="XR_TYPE_SCENE_COMPONENTS_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member optional="true"><type>uint32_t</type> <name>componentCapacityInput</name></member>
            <member><type>uint32_t</type> <name>componentCountOutput</name></member>
            <member optional="true" len="componentCapacityInput"><type>XrSceneComponentMSFT</type>* <name>components</name></member>
        </type>
        <type category="struct" name="XrSceneComponentsGetInfoMSFT">
            <member values="XR_TYPE_SCENE_COMPONENTS_GET_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrSceneComponentTypeMSFT</type> <name>componentType</name></member>
        </type>
        <type category="struct" name="XrSceneComponentLocationMSFT">
            <member optional="true"><type>XrSpaceLocationFlags</type> <name>flags</name></member>
            <member><type>XrPosef</type> <name>pose</name></member>
        </type>
        <type category="struct" name="XrSceneComponentLocationsMSFT">
            <member values="XR_TYPE_SCENE_COMPONENT_LOCATIONS_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member optional="true"><type>uint32_t</type> <name>locationCount</name></member>
            <member optional="true" len="locationCount"><type>XrSceneComponentLocationMSFT</type>* <name>locations</name></member>
        </type>
        <type category="struct" name="XrSceneComponentsLocateInfoMSFT">
            <member values="XR_TYPE_SCENE_COMPONENTS_LOCATE_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrSpace</type> <name>baseSpace</name></member>
            <member><type>XrTime</type> <name>time</name></member>
            <member optional="true"><type>uint32_t</type> <name>componentIdCount</name></member>
            <member optional="true" len="componentIdCount">const <type>XrUuidMSFT</type>* <name>componentIds</name></member>
        </type>
        <type category="struct" name="XrSceneObjectMSFT">
            <member><type>XrSceneObjectTypeMSFT</type> <name>objectType</name></member>
        </type>
        <type category="struct" name="XrSceneObjectsMSFT" structextends="XrSceneComponentsMSFT">
            <member values="XR_TYPE_SCENE_OBJECTS_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member optional="true"><type>uint32_t</type> <name>sceneObjectCount</name></member>
            <member optional="true" len="sceneObjectCount"><type>XrSceneObjectMSFT</type>* <name>sceneObjects</name></member>
        </type>
        <type category="struct" name="XrSceneComponentParentFilterInfoMSFT" structextends="XrSceneComponentsGetInfoMSFT">
            <member values="XR_TYPE_SCENE_COMPONENT_PARENT_FILTER_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrUuidMSFT</type> <name>parentId</name></member>
        </type>
        <type category="struct" name="XrSceneObjectTypesFilterInfoMSFT" structextends="XrSceneComponentsGetInfoMSFT">
            <member values="XR_TYPE_SCENE_OBJECT_TYPES_FILTER_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member optional="true"><type>uint32_t</type> <name>objectTypeCount</name></member>
            <member optional="true" len="objectTypeCount">const <type>XrSceneObjectTypeMSFT</type>* <name>objectTypes</name></member>
        </type>
        <type category="struct" name="XrScenePlaneMSFT">
            <member><type>XrScenePlaneAlignmentTypeMSFT</type> <name>alignment</name></member>
            <member><type>XrExtent2Df</type> <name>size</name></member>
            <member><type>uint64_t</type> <name>meshBufferId</name></member>
            <member><type>XrBool32</type> <name>supportsIndicesUint16</name></member>
        </type>
        <type category="struct" name="XrScenePlanesMSFT" structextends="XrSceneComponentsMSFT">
            <member values="XR_TYPE_SCENE_PLANES_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member optional="true"><type>uint32_t</type> <name>scenePlaneCount</name></member>
            <member optional="true" len="scenePlaneCount"><type>XrScenePlaneMSFT</type>* <name>scenePlanes</name></member>
        </type>
        <type category="struct" name="XrScenePlaneAlignmentFilterInfoMSFT" structextends="XrSceneComponentsGetInfoMSFT">
            <member values="XR_TYPE_SCENE_PLANE_ALIGNMENT_FILTER_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member optional="true"><type>uint32_t</type> <name>alignmentCount</name></member>
            <member optional="true" len="alignmentCount">const <type>XrScenePlaneAlignmentTypeMSFT</type>* <name>alignments</name></member>
        </type>
        <type category="struct" name="XrSceneMeshMSFT">
            <member><type>uint64_t</type> <name>meshBufferId</name></member>
            <member><type>XrBool32</type> <name>supportsIndicesUint16</name></member>
        </type>
        <type category="struct" name="XrSceneMeshesMSFT" structextends="XrSceneComponentsMSFT">
            <member values="XR_TYPE_SCENE_MESHES_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member optional="true"><type>uint32_t</type> <name>sceneMeshCount</name></member>
            <member optional="true" len="sceneMeshCount"><type>XrSceneMeshMSFT</type>* <name>sceneMeshes</name></member>
        </type>
        <type category="struct" name="XrSceneMeshBuffersGetInfoMSFT">
            <member values="XR_TYPE_SCENE_MESH_BUFFERS_GET_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>uint64_t</type> <name>meshBufferId</name></member>
        </type>
        <type category="struct" name="XrSceneMeshBuffersMSFT">
            <member values="XR_TYPE_SCENE_MESH_BUFFERS_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
        </type>
        <type category="struct" name="XrSceneMeshVertexBufferMSFT">
            <member values="XR_TYPE_SCENE_MESH_VERTEX_BUFFER_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member optional="true"><type>uint32_t</type> <name>vertexCapacityInput</name></member>
            <member><type>uint32_t</type> <name>vertexCountOutput</name></member>
            <member optional="true" len="vertexCapacityInput"><type>XrVector3f</type>* <name>vertices</name></member>
        </type>
        <type category="struct" name="XrSceneMeshIndicesUint32MSFT">
            <member values="XR_TYPE_SCENE_MESH_INDICES_UINT32_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member optional="true"><type>uint32_t</type> <name>indexCapacityInput</name></member>
            <member><type>uint32_t</type> <name>indexCountOutput</name></member>
            <member optional="true" len="indexCapacityInput"><type>uint32_t</type>* <name>indices</name></member>
        </type>
        <type category="struct" name="XrSceneMeshIndicesUint16MSFT">
            <member values="XR_TYPE_SCENE_MESH_INDICES_UINT16_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member optional="true"><type>uint32_t</type> <name>indexCapacityInput</name></member>
            <member><type>uint32_t</type> <name>indexCountOutput</name></member>
            <member optional="true" len="indexCapacityInput"><type>uint16_t</type>* <name>indices</name></member>
        </type>

        <!-- XR_MSFT_scene_understanding_serialization -->
        <type category="struct" name="XrSerializedSceneFragmentDataGetInfoMSFT">
            <member values="XR_TYPE_SERIALIZED_SCENE_FRAGMENT_DATA_GET_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrUuidMSFT</type> <name>sceneFragmentId</name></member>
        </type>
        <type category="struct" name="XrDeserializeSceneFragmentMSFT">
            <member optional="true"><type>uint32_t</type> <name>bufferSize</name></member>
            <member optional="true" len="bufferSize">const <type>uint8_t</type>* <name>buffer</name></member>
        </type>
        <type category="struct" name="XrSceneDeserializeInfoMSFT">
            <member values="XR_TYPE_SCENE_DESERIALIZE_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member optional="true"><type>uint32_t</type> <name>fragmentCount</name></member>
            <member optional="true" len="fragmentCount">const <type>XrDeserializeSceneFragmentMSFT</type>* <name>fragments</name></member>
        </type>

        <!-- XR_FB_color_space structs -->
        <type name="XrColorSpaceFB" category="enum"/>
        <type category="struct" name="XrSystemColorSpacePropertiesFB" returnedonly="true" structextends="XrSystemProperties">
            <member values="XR_TYPE_SYSTEM_COLOR_SPACE_PROPERTIES_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>XrColorSpaceFB</type> <name>colorSpace</name></member>
        </type>

        <!-- XR_FB_spatial_entity structs -->
        <type category="struct" name="XrSystemSpatialEntityPropertiesFB" structextends="XrSystemProperties" returnedonly="true">
            <member values="XR_TYPE_SYSTEM_SPATIAL_ENTITY_PROPERTIES_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrBool32</type>    <name>supportsSpatialEntity</name></member>
        </type>
        <type category="struct" name="XrSpatialAnchorCreateInfoFB">
            <member values="XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrSpace</type>     <name>space</name></member>
            <member><type>XrPosef</type>     <name>poseInSpace</name></member>
            <member><type>XrTime</type>      <name>time</name></member>
        </type>
        <type category="struct" name="XrSpaceComponentStatusSetInfoFB">
            <member values="XR_TYPE_SPACE_COMPONENT_STATUS_SET_INFO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*            <name>next</name></member>
            <member><type>XrSpaceComponentTypeFB</type> <name>componentType</name></member>
            <member><type>XrBool32</type>               <name>enabled</name></member>
            <member><type>XrDuration</type>             <name>timeout</name></member>
        </type>
        <type category="struct" name="XrSpaceComponentStatusFB" returnedonly="true">
            <member values="XR_TYPE_SPACE_COMPONENT_STATUS_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*       <name>next</name></member>
            <member><type>XrBool32</type>    <name>enabled</name></member>
            <member><type>XrBool32</type>    <name>changePending</name></member>
        </type>
        <type category="struct" name="XrEventDataSpatialAnchorCreateCompleteFB" parentstruct="XrEventDataBaseHeader" returnedonly="true">
            <member values="XR_TYPE_EVENT_DATA_SPATIAL_ANCHOR_CREATE_COMPLETE_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*        <name>next</name></member>
            <member><type>XrAsyncRequestIdFB</type> <name>requestId</name></member>
            <member><type>XrResult</type>           <name>result</name></member>
            <member><type>XrSpace</type>            <name>space</name></member>
            <member><type>XrUuidEXT</type>          <name>uuid</name></member>
        </type>
        <type category="struct" name="XrEventDataSpaceSetStatusCompleteFB" parentstruct="XrEventDataBaseHeader" returnedonly="true">
            <member values="XR_TYPE_EVENT_DATA_SPACE_SET_STATUS_COMPLETE_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*            <name>next</name></member>
            <member><type>XrAsyncRequestIdFB</type>     <name>requestId</name></member>
            <member><type>XrResult</type>               <name>result</name></member>
            <member><type>XrSpace</type>                <name>space</name></member>
            <member><type>XrUuidEXT</type>              <name>uuid</name></member>
            <member><type>XrSpaceComponentTypeFB</type> <name>componentType</name></member>
            <member><type>XrBool32</type>               <name>enabled</name></member>
        </type>

        <!-- XR_FB_foveation structs -->
        <type category="struct" name="XrFoveationProfileCreateInfoFB">
            <member values="XR_TYPE_FOVEATION_PROFILE_CREATE_INFO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                                                             <name>next</name></member>
        </type>
        <type category="struct" name="XrSwapchainCreateInfoFoveationFB" structextends="XrSwapchainCreateInfo">
            <member values="XR_TYPE_SWAPCHAIN_CREATE_INFO_FOVEATION_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                                             <name>next</name></member>
            <member optional="true"><type>XrSwapchainCreateFoveationFlagsFB</type> <name>flags</name></member>
        </type>
        <type category="struct" name="XrSwapchainStateFoveationFB" parentstruct="XrSwapchainStateBaseHeaderFB">
            <member values="XR_TYPE_SWAPCHAIN_STATE_FOVEATION_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                                            <name>next</name></member>
            <member optional="true"><type>XrSwapchainStateFoveationFlagsFB</type> <name>flags</name></member>
            <member><type>XrFoveationProfileFB</type>                             <name>profile</name></member>
        </type>

        <!-- XR_FB_foveation_vulkan structs -->
        <type category="struct" name="XrSwapchainImageFoveationVulkanFB" structextends="XrSwapchainImageVulkanKHR" returnedonly="true">
            <member values="XR_TYPE_SWAPCHAIN_IMAGE_FOVEATION_VULKAN_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*    <name>next</name></member>
            <member><type>VkImage</type>  <name>image</name></member>
            <member><type>uint32_t</type> <name>width</name></member>
            <member><type>uint32_t</type> <name>height</name></member>
        </type>

        <!-- XR_FB_foveation_configuration structs -->
        <type name="XrFoveationLevelFB" category="enum"/>
        <type name="XrFoveationDynamicFB" category="enum"/>
        <type category="struct" name="XrFoveationLevelProfileCreateInfoFB" structextends="XrFoveationProfileCreateInfoFB">
            <member values="XR_TYPE_FOVEATION_LEVEL_PROFILE_CREATE_INFO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                <name>next</name></member>
            <member><type>XrFoveationLevelFB</type>   <name>level</name></member>
            <member><type>float</type>                <name>verticalOffset</name></member>
            <member><type>XrFoveationDynamicFB</type> <name>dynamic</name></member>
        </type>

        <!-- XR_FB_hand_tracking_mesh structs -->
        <type category="struct" name="XrVector4sFB">
            <member><type>int16_t</type>          <name>x</name></member>
            <member><type>int16_t</type>          <name>y</name></member>
            <member><type>int16_t</type>          <name>z</name></member>
            <member><type>int16_t</type>          <name>w</name></member>
        </type>
        <type category="struct" name="XrHandTrackingMeshFB">
            <member values="XR_TYPE_HAND_TRACKING_MESH_FB"><type>XrStructureType</type>   <name>type</name></member>
            <member><type>void</type>*                                                    <name>next</name></member>
            <member optional="true"><type>uint32_t</type>                                 <name>jointCapacityInput</name></member>
            <member optional="true"><type>uint32_t</type>                                 <name>jointCountOutput</name></member>
            <member optional="true" len="jointCapacityInput"><type>XrPosef</type>*        <name>jointBindPoses</name></member>
            <member optional="true" len="jointCapacityInput"><type>float</type>*          <name>jointRadii</name></member>
            <member optional="true" len="jointCapacityInput"><type>XrHandJointEXT</type>* <name>jointParents</name></member>
            <member optional="true"><type>uint32_t</type>                                 <name>vertexCapacityInput</name></member>
            <member optional="true"><type>uint32_t</type>                                 <name>vertexCountOutput</name></member>
            <member optional="true" len="vertexCapacityInput"><type>XrVector3f</type>*    <name>vertexPositions</name></member>
            <member optional="true" len="vertexCapacityInput"><type>XrVector3f</type>*    <name>vertexNormals</name></member>
            <member optional="true" len="vertexCapacityInput"><type>XrVector2f</type>*    <name>vertexUVs</name></member>
            <member optional="true" len="vertexCapacityInput"><type>XrVector4sFB</type>*  <name>vertexBlendIndices</name></member>
            <member optional="true" len="vertexCapacityInput"><type>XrVector4f</type>*    <name>vertexBlendWeights</name></member>
            <member optional="true"><type>uint32_t</type>                                 <name>indexCapacityInput</name></member>
            <member optional="true"><type>uint32_t</type>                                 <name>indexCountOutput</name></member>
            <member optional="true" len="indexCapacityInput"><type>int16_t</type>*        <name>indices</name></member>
        </type>
        <type category="struct" name="XrHandTrackingScaleFB" returnedonly="true" structextends="XrHandJointLocationsEXT">
            <member values="XR_TYPE_HAND_TRACKING_SCALE_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>float</type> <name>sensorOutput</name></member>
            <member><type>float</type> <name>currentOutput</name></member>
            <member><type>XrBool32</type> <name>overrideHandScale</name></member>
            <member optional="true"><type>float</type> <name>overrideValueInput</name></member>
        </type>

        <!-- XR_FB_hand_tracking_aim structs -->
        <type category="struct" name="XrHandTrackingAimStateFB" returnedonly="true" structextends="XrHandJointLocationsEXT">
            <member values="XR_TYPE_HAND_TRACKING_AIM_STATE_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>XrHandTrackingAimFlagsFB</type> <name>status</name></member>
            <member><type>XrPosef</type> <name>aimPose</name></member>
            <member><type>float</type> <name>pinchStrengthIndex</name></member>
            <member><type>float</type> <name>pinchStrengthMiddle</name></member>
            <member><type>float</type> <name>pinchStrengthRing</name></member>
            <member><type>float</type> <name>pinchStrengthLittle</name></member>
        </type>

        <!-- XR_FB_hand_tracking_capsules structs -->
        <type category="struct" name="XrHandCapsuleFB" returnedonly="true">
            <member><type>XrVector3f</type> <name>points</name>[<enum>XR_HAND_TRACKING_CAPSULE_POINT_COUNT_FB</enum>]</member>
            <member><type>float</type> <name>radius</name></member>
            <member><type>XrHandJointEXT</type> <name>joint</name></member>
        </type>
        <type category="struct" name="XrHandTrackingCapsulesStateFB" returnedonly="true" structextends="XrHandJointLocationsEXT">
            <member values="XR_TYPE_HAND_TRACKING_CAPSULES_STATE_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>XrHandCapsuleFB</type> <name>capsules</name>[<enum>XR_HAND_TRACKING_CAPSULE_COUNT_FB</enum>]</member>
        </type>

        <!-- XR_FB_render_model structs -->
        <type category="struct" name="XrRenderModelPathInfoFB">
            <member values="XR_TYPE_RENDER_MODEL_PATH_INFO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                                                      <name>next</name></member>
            <member><type>XrPath</type>                                                     <name>path</name></member>
        </type>
        <type category="struct" name="XrRenderModelPropertiesFB">
            <member values="XR_TYPE_RENDER_MODEL_PROPERTIES_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                                                       <name>next</name></member>
            <member><type>uint32_t</type>                                                    <name>vendorId</name></member>
            <member><type>char</type>                                                        <name>modelName</name>[XR_MAX_RENDER_MODEL_NAME_SIZE_FB]</member>
            <member><type>XrRenderModelKeyFB</type>                                          <name>modelKey</name></member>
            <member><type>uint32_t</type>                                                    <name>modelVersion</name></member>
            <member><type>XrRenderModelFlagsFB</type>                                        <name>flags</name></member>
        </type>
        <type category="struct" name="XrRenderModelBufferFB">
            <member values="XR_TYPE_RENDER_MODEL_BUFFER_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                                                   <name>next</name></member>
            <member optional="true"><type>uint32_t</type>                                <name>bufferCapacityInput</name></member>
            <member optional="true"><type>uint32_t</type>                                <name>bufferCountOutput</name></member>
            <member optional="true" len="bufferCapacityInput"><type>uint8_t</type>*      <name>buffer</name></member>
        </type>
        <type category="struct" name="XrRenderModelLoadInfoFB">
            <member values="XR_TYPE_RENDER_MODEL_LOAD_INFO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                                                      <name>next</name></member>
            <member><type>XrRenderModelKeyFB</type>                                         <name>modelKey</name></member>
        </type>
        <type category="struct" name="XrSystemRenderModelPropertiesFB" returnedonly="true" structextends="XrSystemProperties">
            <member values="XR_TYPE_SYSTEM_RENDER_MODEL_PROPERTIES_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                                                         <name>next</name></member>
            <member><type>XrBool32</type>                                                      <name>supportsRenderModelLoading</name></member>
        </type>
        <type category="struct" name="XrRenderModelCapabilitiesRequestFB" returnedonly="true" structextends="XrSystemProperties">
            <member values="XR_TYPE_RENDER_MODEL_CAPABILITIES_REQUEST_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                                                         <name>next</name></member>
            <member><type>XrRenderModelFlagsFB</type>                                          <name>flags</name></member>
        </type>

        <!-- XR_FB_spatial_entity_query structs -->
        <type category="struct" name="XrSpaceQueryInfoBaseHeaderFB">
            <member><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*     <name>next</name></member>
        </type>
        <type category="struct" name="XrSpaceFilterInfoBaseHeaderFB">
            <member><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*     <name>next</name></member>
        </type>
        <type category="struct" name="XrSpaceQueryInfoFB" parentstruct="XrSpaceQueryInfoBaseHeaderFB">
            <member values="XR_TYPE_SPACE_QUERY_INFO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                                          <name>next</name></member>
            <member><type>XrSpaceQueryActionFB</type>                                 <name>queryAction</name></member>
            <member><type>uint32_t</type>                                             <name>maxResultCount</name></member>
            <member><type>XrDuration</type>                                           <name>timeout</name></member>
            <member optional="true">const <type>XrSpaceFilterInfoBaseHeaderFB</type>* <name>filter</name></member>
            <member optional="true">const <type>XrSpaceFilterInfoBaseHeaderFB</type>* <name>excludeFilter</name></member>
        </type>
        <type category="struct" name="XrSpaceStorageLocationFilterInfoFB" structextends="XrSpaceFilterInfoBaseHeaderFB">
            <member values="XR_TYPE_SPACE_STORAGE_LOCATION_FILTER_INFO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*              <name>next</name></member>
            <member><type>XrSpaceStorageLocationFB</type> <name>location</name></member>
        </type>
        <type category="struct" name="XrSpaceUuidFilterInfoFB" parentstruct="XrSpaceFilterInfoBaseHeaderFB">
            <member values="XR_TYPE_SPACE_UUID_FILTER_INFO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                <name>next</name></member>
            <member><type>uint32_t</type>                   <name>uuidCount</name></member>
            <member len="uuidCount"><type>XrUuidEXT</type>* <name>uuids</name></member>
        </type>
        <type category="struct" name="XrSpaceComponentFilterInfoFB" parentstruct="XrSpaceFilterInfoBaseHeaderFB">
            <member values="XR_TYPE_SPACE_COMPONENT_FILTER_INFO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*            <name>next</name></member>
            <member><type>XrSpaceComponentTypeFB</type> <name>componentType</name></member>
        </type>
        <type category="struct" name="XrSpaceQueryResultFB" returnedonly="true">
            <member><type>XrSpace</type>   <name>space</name></member>
            <member><type>XrUuidEXT</type> <name>uuid</name></member>
        </type>
        <type category="struct" name="XrSpaceQueryResultsFB">
            <member values="XR_TYPE_SPACE_QUERY_RESULTS_FB"><type>XrStructureType</type>         <name>type</name></member>
            <member><type>void</type>*                                                           <name>next</name></member>
            <member optional="true"><type>uint32_t</type>                                        <name>resultCapacityInput</name></member>
            <member optional="true"><type>uint32_t</type>                                        <name>resultCountOutput</name></member>
            <member optional="true" len="resultCapacityInput"><type>XrSpaceQueryResultFB</type>* <name>results</name></member>
        </type>
        <type category="struct" name="XrEventDataSpaceQueryResultsAvailableFB" parentstruct="XrEventDataBaseHeader" returnedonly="true">
            <member values="XR_TYPE_EVENT_DATA_SPACE_QUERY_RESULTS_AVAILABLE_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*        <name>next</name></member>
            <member><type>XrAsyncRequestIdFB</type> <name>requestId</name></member>
        </type>
        <type category="struct" name="XrEventDataSpaceQueryCompleteFB" parentstruct="XrEventDataBaseHeader" returnedonly="true">
            <member values="XR_TYPE_EVENT_DATA_SPACE_QUERY_COMPLETE_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*        <name>next</name></member>
            <member><type>XrAsyncRequestIdFB</type> <name>requestId</name></member>
            <member><type>XrResult</type>           <name>result</name></member>
        </type>

        <!-- XR_FB_spatial_entity_storage structs -->
        <type category="struct" name="XrSpaceSaveInfoFB">
            <member values="XR_TYPE_SPACE_SAVE_INFO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*              <name>next</name></member>
            <member><type>XrSpace</type>                  <name>space</name></member>
            <member><type>XrSpaceStorageLocationFB</type> <name>location</name></member>
            <member><type>XrSpacePersistenceModeFB</type> <name>persistenceMode</name></member>
        </type>
        <type category="struct" name="XrSpaceEraseInfoFB">
            <member values="XR_TYPE_SPACE_ERASE_INFO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*              <name>next</name></member>
            <member><type>XrSpace</type>                  <name>space</name></member>
            <member><type>XrSpaceStorageLocationFB</type> <name>location</name></member>
        </type>
        <type category="struct" name="XrEventDataSpaceSaveCompleteFB" parentstruct="XrEventDataBaseHeader" returnedonly="true">
            <member values="XR_TYPE_EVENT_DATA_SPACE_SAVE_COMPLETE_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*              <name>next</name></member>
            <member><type>XrAsyncRequestIdFB</type>       <name>requestId</name></member>
            <member><type>XrResult</type>                 <name>result</name></member>
            <member><type>XrSpace</type>                  <name>space</name></member>
            <member><type>XrUuidEXT</type>                <name>uuid</name></member>
            <member><type>XrSpaceStorageLocationFB</type> <name>location</name></member>
        </type>
        <type category="struct" name="XrEventDataSpaceEraseCompleteFB" parentstruct="XrEventDataBaseHeader" returnedonly="true">
            <member values="XR_TYPE_EVENT_DATA_SPACE_ERASE_COMPLETE_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*              <name>next</name></member>
            <member><type>XrAsyncRequestIdFB</type>       <name>requestId</name></member>
            <member><type>XrResult</type>                 <name>result</name></member>
            <member><type>XrSpace</type>                  <name>space</name></member>
            <member><type>XrUuidEXT</type>                <name>uuid</name></member>
            <member><type>XrSpaceStorageLocationFB</type> <name>location</name></member>
        </type>

        <!-- XR_FB_spatial_entity_container structs -->
        <type category="struct" name="XrSpaceContainerFB">
            <member values="XR_TYPE_SPACE_CONTAINER_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                                         <name>next</name></member>
            <member optional="true"><type>uint32_t</type>                            <name>uuidCapacityInput</name></member>
            <member optional="true"><type>uint32_t</type>                            <name>uuidCountOutput</name></member>
            <member optional="true" len="uuidCapacityInput"><type>XrUuidEXT</type>*  <name>uuids</name></member>
        </type>

        <!-- XR_FB_scene structs -->
        <type category="struct" name="XrExtent3DfFB">
            <member><type>float</type> <name>width</name></member>
            <member><type>float</type> <name>height</name></member>
            <member><type>float</type> <name>depth</name></member>
        </type>
        <type category="struct" name="XrOffset3DfFB">
            <member><type>float</type> <name>x</name></member>
            <member><type>float</type> <name>y</name></member>
            <member><type>float</type> <name>z</name></member>
        </type>
        <type category="struct" name="XrRect3DfFB">
            <member><type>XrOffset3DfFB</type> <name>offset</name></member>
            <member><type>XrExtent3DfFB</type> <name>extent</name></member>
        </type>
        <type category="struct" name="XrSemanticLabelsFB">
            <member values="XR_TYPE_SEMANTIC_LABELS_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                                     <name>next</name></member>
            <member optional="true"><type>uint32_t</type>                        <name>bufferCapacityInput</name></member>
            <member optional="true"><type>uint32_t</type>                        <name>bufferCountOutput</name></member>
            <member optional="true" len="bufferCapacityInput"><type>char</type>* <name>buffer</name></member>
        </type>
        <type category="struct" name="XrRoomLayoutFB">
            <member values="XR_TYPE_ROOM_LAYOUT_FB"><type>XrStructureType</type>        <name>type</name></member>
            <member>const <type>void</type>*                                            <name>next</name></member>
            <member><type>XrUuidEXT</type>                                              <name>floorUuid</name></member>
            <member><type>XrUuidEXT</type>                                              <name>ceilingUuid</name></member>
            <member optional="true"><type>uint32_t</type>                               <name>wallUuidCapacityInput</name></member>
            <member optional="true"><type>uint32_t</type>                               <name>wallUuidCountOutput</name></member>
            <member optional="true" len="wallUuidCapacityInput"><type>XrUuidEXT</type>* <name>wallUuids</name></member>
        </type>
        <type category="struct" name="XrBoundary2DFB">
            <member values="XR_TYPE_BOUNDARY_2D_FB"><type>XrStructureType</type>       <name>type</name></member>
            <member>const <type>void</type>*                                           <name>next</name></member>
            <member optional="true"><type>uint32_t</type>                              <name>vertexCapacityInput</name></member>
            <member optional="true"><type>uint32_t</type>                              <name>vertexCountOutput</name></member>
            <member optional="true" len="vertexCapacityInput"><type>XrVector2f</type>* <name>vertices</name></member>
        </type>

        <!-- XR_FB_keyboard_tracking structs -->
        <type category="struct" name="XrSystemKeyboardTrackingPropertiesFB" returnedonly="true" structextends="XrSystemProperties">
            <member values="XR_TYPE_SYSTEM_KEYBOARD_TRACKING_PROPERTIES_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>XrBool32</type> <name>supportsKeyboardTracking</name></member>
        </type>
        <type category="struct" name="XrKeyboardTrackingDescriptionFB" returnedonly="true">
            <member><type>uint64_t</type> <name>trackedKeyboardId</name></member>
            <member><type>XrVector3f</type> <name>size</name></member>
            <member><type>XrKeyboardTrackingFlagsFB</type> <name>flags</name></member>
            <member><type>char</type> <name>name</name>[XR_MAX_KEYBOARD_TRACKING_NAME_SIZE_FB]</member>
        </type>
        <type category="struct" name="XrKeyboardSpaceCreateInfoFB">
            <member values="XR_TYPE_KEYBOARD_SPACE_CREATE_INFO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>uint64_t</type> <name>trackedKeyboardId</name></member>
        </type>
        <type category="struct" name="XrKeyboardTrackingQueryFB">
            <member values="XR_TYPE_KEYBOARD_TRACKING_QUERY_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>* <name>next</name></member>
            <member><type>XrKeyboardTrackingQueryFlagsFB</type>   <name>flags</name></member>
        </type>

        <!-- XR_VARJO_composition_layer_depth_test -->
        <type category="struct" name="XrCompositionLayerDepthTestVARJO" structextends="XrCompositionLayerProjection">
            <member values="XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_VARJO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                            <name>next</name></member>
            <member><type>float</type>                                  <name>depthTestRangeNearZ</name></member>
            <member><type>float</type>                                  <name>depthTestRangeFarZ</name></member>
        </type>

        <!-- XR_VARJO_foveated_rendering -->
        <type category="struct" name="XrViewLocateFoveatedRenderingVARJO" structextends="XrViewLocateInfo">
            <member values="XR_TYPE_VIEW_LOCATE_FOVEATED_RENDERING_VARJO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrBool32</type> <name>foveatedRenderingActive</name></member>
        </type>

        <type category="struct" name="XrFoveatedViewConfigurationViewVARJO" structextends="XrViewConfigurationView">
            <member values="XR_TYPE_FOVEATED_VIEW_CONFIGURATION_VIEW_VARJO"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*          <name>next</name></member>
            <member><type>XrBool32</type>       <name>foveatedRenderingActive</name></member>
        </type>

        <type category="struct" name="XrSystemFoveatedRenderingPropertiesVARJO" returnedonly="true" structextends="XrSystemProperties">
            <member values="XR_TYPE_SYSTEM_FOVEATED_RENDERING_PROPERTIES_VARJO"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*          <name>next</name></member>
            <member><type>XrBool32</type>       <name>supportsFoveatedRendering</name></member>
        </type>

        <!-- XR_MSFT_composition_layer_reprojection -->
        <type name="XrReprojectionModeMSFT" category="enum"/>
        <type category="struct" name="XrCompositionLayerReprojectionInfoMSFT" structextends="XrCompositionLayerProjection">
            <member values="XR_TYPE_COMPOSITION_LAYER_REPROJECTION_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*               <name>next</name></member>
            <member><type>XrReprojectionModeMSFT</type>    <name>reprojectionMode</name></member>
        </type>
        <type category="struct" name="XrCompositionLayerReprojectionPlaneOverrideMSFT" structextends="XrCompositionLayerProjection">
            <member values="XR_TYPE_COMPOSITION_LAYER_REPROJECTION_PLANE_OVERRIDE_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*               <name>next</name></member>
            <member><type>XrVector3f</type>                <name>position</name></member>
            <member><type>XrVector3f</type>                <name>normal</name></member>
            <member><type>XrVector3f</type>                <name>velocity</name></member>
        </type>

        <!-- XR_FB_triangle_mesh -->
        <type category="struct" name="XrTriangleMeshCreateInfoFB">
            <member values="XR_TYPE_TRIANGLE_MESH_CREATE_INFO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                                             <name>next</name></member>
            <member optional="true"><type>XrTriangleMeshFlagsFB</type>                   <name>flags</name></member>
            <member><type>XrWindingOrderFB</type>                                        <name>windingOrder</name></member>
            <member><type>uint32_t</type>                                                <name>vertexCount</name></member>
            <member optional="true" noautovalidity="true">const <type>XrVector3f</type>* <name>vertexBuffer</name></member>
            <member><type>uint32_t</type>                                                <name>triangleCount</name></member>
            <member optional="true" noautovalidity="true">const <type>uint32_t</type>*   <name>indexBuffer</name></member>
        </type>

        <!-- XR_FB_passthrough -->
        <type category="struct" name="XrSystemPassthroughPropertiesFB" returnedonly="true" structextends="XrSystemProperties">
            <member values="XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrBool32</type>    <name>supportsPassthrough</name></member>
        </type>
        <type category="struct" name="XrSystemPassthroughProperties2FB" returnedonly="true" structextends="XrSystemProperties">
            <member values="XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES2_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                       <name>next</name></member>
            <member><type>XrPassthroughCapabilityFlagsFB</type>    <name>capabilities</name></member>
        </type>
        <type category="struct" name="XrPassthroughCreateInfoFB">
            <member values="XR_TYPE_PASSTHROUGH_CREATE_INFO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*          <name>next</name></member>
            <member><type>XrPassthroughFlagsFB</type> <name>flags</name></member>
        </type>
        <type category="struct" name="XrPassthroughLayerCreateInfoFB">
            <member values="XR_TYPE_PASSTHROUGH_LAYER_CREATE_INFO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                 <name>next</name></member>
            <member><type>XrPassthroughFB</type>             <name>passthrough</name></member>
            <member><type>XrPassthroughFlagsFB</type>        <name>flags</name></member>
            <member><type>XrPassthroughLayerPurposeFB</type> <name>purpose</name></member>
        </type>
        <type category="struct" name="XrCompositionLayerPassthroughFB" structextends="XrCompositionLayerBaseHeader">
            <member values="XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*             <name>next</name></member>
            <member><type>XrCompositionLayerFlags</type> <name>flags</name></member>
            <member><type>XrSpace</type>                 <name>space</name></member>
            <member><type>XrPassthroughLayerFB</type>    <name>layerHandle</name></member>
        </type>
        <type category="struct" name="XrGeometryInstanceCreateInfoFB">
            <member values="XR_TYPE_GEOMETRY_INSTANCE_CREATE_INFO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*          <name>next</name></member>
            <member><type>XrPassthroughLayerFB</type> <name>layer</name></member>
            <member><type>XrTriangleMeshFB</type>     <name>mesh</name></member>
            <member><type>XrSpace</type>              <name>baseSpace</name></member>
            <member><type>XrPosef</type>              <name>pose</name></member>
            <member><type>XrVector3f</type>           <name>scale</name></member>
        </type>
        <type category="struct" name="XrGeometryInstanceTransformFB">
            <member values="XR_TYPE_GEOMETRY_INSTANCE_TRANSFORM_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrSpace</type>     <name>baseSpace</name></member>
            <member><type>XrTime</type>      <name>time</name></member>
            <member><type>XrPosef</type>     <name>pose</name></member>
            <member><type>XrVector3f</type>  <name>scale</name></member>
        </type>
        <type category="struct" name="XrPassthroughStyleFB">
            <member values="XR_TYPE_PASSTHROUGH_STYLE_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>float</type>       <name>textureOpacityFactor</name></member>
            <member><type>XrColor4f</type>   <name>edgeColor</name></member>
        </type>
        <type category="struct" name="XrPassthroughColorMapMonoToRgbaFB" structextends="XrPassthroughStyleFB">
            <member values="XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_RGBA_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrColor4f</type>   <name>textureColorMap</name>[XR_PASSTHROUGH_COLOR_MAP_MONO_SIZE_FB]</member>
        </type>
        <type category="struct" name="XrPassthroughColorMapMonoToMonoFB" structextends="XrPassthroughStyleFB">
            <member values="XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_MONO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>uint8_t</type>     <name>textureColorMap</name>[XR_PASSTHROUGH_COLOR_MAP_MONO_SIZE_FB]</member>
        </type>
        <type category="struct" name="XrPassthroughBrightnessContrastSaturationFB" structextends="XrPassthroughStyleFB">
            <member values="XR_TYPE_PASSTHROUGH_BRIGHTNESS_CONTRAST_SATURATION_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>float</type>       <name>brightness</name></member>
            <member><type>float</type>       <name>contrast</name></member>
            <member><type>float</type>       <name>saturation</name></member>
        </type>
        <type category="struct" name="XrEventDataPassthroughStateChangedFB">
            <member values="XR_TYPE_EVENT_DATA_PASSTHROUGH_STATE_CHANGED_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                      <name>next</name></member>
            <member><type>XrPassthroughStateChangedFlagsFB</type> <name>flags</name></member>
        </type>

        <!-- XR_FB_passthrough_keyboard_hands -->
        <type category="struct" name="XrPassthroughKeyboardHandsIntensityFB">
            <member values="XR_TYPE_PASSTHROUGH_KEYBOARD_HANDS_INTENSITY_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>float</type>       <name>leftHandIntensity</name></member>
            <member><type>float</type>       <name>rightHandIntensity</name></member>
        </type>

        <!-- XR_MSFT_spatial_anchor_persistence -->
        <type category="handle" parent="XrSession"><type>XR_DEFINE_HANDLE</type>(<name>XrSpatialAnchorStoreConnectionMSFT</name>)</type>

        <type category="struct" name="XrSpatialAnchorPersistenceNameMSFT">
            <member><type>char</type> <name>name</name>[<enum>XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_MSFT</enum>]</member>
        </type>
        <type category="struct" name="XrSpatialAnchorPersistenceInfoMSFT">
            <member values="XR_TYPE_SPATIAL_ANCHOR_PERSISTENCE_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                            <name>next</name></member>
            <member><type>XrSpatialAnchorPersistenceNameMSFT</type>     <name>spatialAnchorPersistenceName</name></member>
            <member><type>XrSpatialAnchorMSFT</type>                    <name>spatialAnchor</name></member>
        </type>
        <type category="struct" name="XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT">
            <member values="XR_TYPE_SPATIAL_ANCHOR_FROM_PERSISTED_ANCHOR_CREATE_INFO_MSFT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                            <name>next</name></member>
            <member><type>XrSpatialAnchorStoreConnectionMSFT</type>     <name>spatialAnchorStore</name></member>
            <member><type>XrSpatialAnchorPersistenceNameMSFT</type>     <name>spatialAnchorPersistenceName</name></member>
        </type>

        <!-- XR_HTC_facial_tracking -->
        <type category="struct" name="XrFacialTrackerCreateInfoHTC">
            <member values="XR_TYPE_FACIAL_TRACKER_CREATE_INFO_HTC"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*             <name>next</name></member>
            <member><type>XrFacialTrackingTypeHTC</type> <name>facialTrackingType</name></member>
        </type>
        <type category="struct" name="XrSystemFacialTrackingPropertiesHTC" returnedonly="true" structextends="XrSystemProperties">
            <member values="XR_TYPE_SYSTEM_FACIAL_TRACKING_PROPERTIES_HTC"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*    <name>next</name></member>
            <member><type>XrBool32</type> <name>supportEyeFacialTracking</name></member>
            <member><type>XrBool32</type> <name>supportLipFacialTracking</name></member>
        </type>
        <type category="struct" name="XrFacialExpressionsHTC">
            <member values="XR_TYPE_FACIAL_EXPRESSIONS_HTC"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrBool32</type>    <name>isActive</name></member>
            <member><type>XrTime</type>      <name>sampleTime</name></member>
            <member><type>uint32_t</type>    <name>expressionCount</name></member>
            <member><type>float</type>*      <name>expressionWeightings</name></member>
        </type>

        <!-- XR_HTC_passthrough -->
        <type category="struct" name="XrPassthroughCreateInfoHTC">
            <member values="XR_TYPE_PASSTHROUGH_CREATE_INFO_HTC"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*               <name>next</name></member>
            <member><type>XrPassthroughFormHTC</type>      <name>form</name></member>
        </type>
        <type category="struct" name="XrPassthroughColorHTC">
            <member values="XR_TYPE_PASSTHROUGH_COLOR_HTC"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>float</type>       <name>alpha</name></member>
        </type>
        <type category="struct" name="XrPassthroughMeshTransformInfoHTC" structextends="XrCompositionLayerPassthroughHTC">
            <member values="XR_TYPE_PASSTHROUGH_MESH_TRANSFORM_INFO_HTC"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                         <name>next</name></member>
            <member><type>uint32_t</type>                            <name>vertexCount</name></member>
            <member len="vertexCount">const <type>XrVector3f</type>* <name>vertices</name></member>
            <member><type>uint32_t</type>                            <name>indexCount</name></member>
            <member len="indexCount">const <type>uint32_t</type>*    <name>indices</name></member>
            <member><type>XrSpace</type>                             <name>baseSpace</name></member>
            <member><type>XrTime</type>                              <name>time</name></member>
            <member><type>XrPosef</type>                             <name>pose</name></member>
            <member><type>XrVector3f</type>                          <name>scale</name></member>
        </type>
        <type category="struct" name="XrCompositionLayerPassthroughHTC" parentstruct="XrCompositionLayerBaseHeader">
            <member values="XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_HTC"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*             <name>next</name></member>
            <member><type>XrCompositionLayerFlags</type> <name>layerFlags</name></member>
            <member><type>XrSpace</type>                 <name>space</name></member>
            <member><type>XrPassthroughHTC</type>        <name>passthrough</name></member>
            <member><type>XrPassthroughColorHTC</type>   <name>color</name></member>
        </type>

        <!-- XR_HTCX_vive_tracker_interaction structs -->
        <type category="struct" name="XrViveTrackerPathsHTCX" returnedonly="true">
            <member values="XR_TYPE_VIVE_TRACKER_PATHS_HTCX"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                  <name>next</name></member>
            <member><type>XrPath</type>                 <name>persistentPath</name></member>
            <member optional="true"><type>XrPath</type> <name>rolePath</name></member>
        </type>
        <type category="struct" name="XrEventDataViveTrackerConnectedHTCX" returnedonly="true" parentstruct="XrEventDataBaseHeader">
            <member values="XR_TYPE_EVENT_DATA_VIVE_TRACKER_CONNECTED_HTCX"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                   <name>next</name></member>
            <member><type>XrViveTrackerPathsHTCX</type>*       <name>paths</name></member>
        </type>


        <!-- XR_FB_space_warp -->
        <type category="struct" name="XrCompositionLayerSpaceWarpInfoFB" structextends="XrCompositionLayerProjectionView">
            <member values="XR_TYPE_COMPOSITION_LAYER_SPACE_WARP_INFO_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                            <name>next</name></member>
            <member optional="true"><type>XrCompositionLayerSpaceWarpInfoFlagsFB</type> <name>layerFlags</name></member>
            <member><type>XrSwapchainSubImage</type>                    <name>motionVectorSubImage</name></member>
            <member><type>XrPosef</type>                                <name>appSpaceDeltaPose</name></member>
            <member><type>XrSwapchainSubImage</type>                    <name>depthSubImage</name></member>
            <member><type>float</type>                                  <name>minDepth</name></member>
            <member><type>float</type>                                  <name>maxDepth</name></member>
            <member><type>float</type>                                  <name>nearZ</name></member>
            <member><type>float</type>                                  <name>farZ</name></member>
        </type>
        <type category="struct" name="XrSystemSpaceWarpPropertiesFB" returnedonly="true" structextends="XrSystemProperties">
            <member values="XR_TYPE_SYSTEM_SPACE_WARP_PROPERTIES_FB"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*    <name>next</name></member>
            <member><type>uint32_t</type> <name>recommendedMotionVectorImageRectWidth</name></member>
            <member><type>uint32_t</type> <name>recommendedMotionVectorImageRectHeight</name></member>
        </type>


        <!-- XR_VARJO_marker_tracking -->
        <type category="struct" name="XrSystemMarkerTrackingPropertiesVARJO" returnedonly="true" structextends="XrSystemProperties">
            <member values="XR_TYPE_SYSTEM_MARKER_TRACKING_PROPERTIES_VARJO"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*                     <name>next</name></member>
            <member><type>XrBool32</type>                  <name>supportsMarkerTracking</name></member>
        </type>

        <type category="struct" name="XrEventDataMarkerTrackingUpdateVARJO" returnedonly="true" parentstruct="XrEventDataBaseHeader">
            <member values="XR_TYPE_EVENT_DATA_MARKER_TRACKING_UPDATE_VARJO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>uint64_t</type>    <name>markerId</name></member>
            <member><type>XrBool32</type>    <name>isActive</name></member>
            <member><type>XrBool32</type>    <name>isPredicted</name></member>
            <member><type>XrTime</type>      <name>time</name></member>
        </type>

        <type category="struct" name="XrMarkerSpaceCreateInfoVARJO">
            <member values="XR_TYPE_MARKER_SPACE_CREATE_INFO_VARJO"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                <name>next</name></member>
            <member><type>uint64_t</type>                   <name>markerId</name></member>
            <member><type>XrPosef</type>                    <name>poseInMarkerSpace</name></member>
        </type>

        <!-- XR_EXT_uuid -->
        <type category="struct" name="XrUuidEXT">
            <member><type>uint8_t</type> <name>data</name>[<enum>XR_UUID_SIZE_EXT</enum>]</member>
        </type>

        <!-- XR_ALMALENCE_digital_lens_control -->
        <type category="struct" name="XrDigitalLensControlALMALENCE">
            <member values="XR_TYPE_DIGITAL_LENS_CONTROL_ALMALENCE"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                        <name>next</name></member>
            <member><type>XrDigitalLensControlFlagsALMALENCE</type> <name>flags</name></member>
        </type>

        <!-- XR_ULTRALEAP_hand_tracking_forearm -->
        <type name="XrHandForearmJointULTRALEAP" category="enum"/>

        <!-- XR_FB_composition_layer_settings structs -->
        <type category="struct" name="XrCompositionLayerSettingsFB" structextends="XrCompositionLayerBaseHeader">
            <member values="XR_TYPE_COMPOSITION_LAYER_SETTINGS_FB"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                       <name>next</name></member>
            <member><type>XrCompositionLayerSettingsFlagsFB</type> <name>layerFlags</name></member>
        </type>

        <!-- XR_META_performance_metrics -->
        <type category="struct" name="XrPerformanceMetricsStateMETA">
            <member values="XR_TYPE_PERFORMANCE_METRICS_STATE_META"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>* <name>next</name></member>
            <member><type>XrBool32</type>    <name>enabled</name></member>
        </type>

        <type category="struct" name="XrPerformanceMetricsCounterMETA">
            <member values="XR_TYPE_PERFORMANCE_METRICS_COUNTER_META"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                                          <name>next</name></member>
            <member optional="true"><type>XrPerformanceMetricsCounterFlagsMETA</type> <name>counterFlags</name></member>
            <member><type>XrPerformanceMetricsCounterUnitMETA</type>                  <name>counterUnit</name></member>
            <member><type>uint32_t</type>                                             <name>uintValue</name></member>
            <member><type>float</type>                                                <name>floatValue</name></member>
        </type>

        <!-- XR_META_headset_id structs -->
        <type category="struct" name="XrSystemHeadsetIdPropertiesMETA" returnedonly="true" structextends="XrSystemProperties">
            <member values="XR_TYPE_SYSTEM_HEADSET_ID_PROPERTIES_META"><type>XrStructureType</type> <name>type</name></member>
            <member><type>void</type>*     <name>next</name></member>
            <member><type>XrUuidEXT</type> <name>id</name></member>
        </type>

        <!-- XR_HTC_foveation structs -->
        <type category="struct" name="XrFoveationApplyInfoHTC">
            <member values="XR_TYPE_FOVEATION_APPLY_INFO_HTC"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*            <name>next</name></member>
            <member><type>XrFoveationModeHTC</type>     <name>mode</name></member>
            <member><type>uint32_t</type>               <name>subImageCount</name></member>
            <member len="subImageCount"><type>XrSwapchainSubImage</type>*      <name>subImages</name></member>
        </type>
        <type category="struct" name="XrFoveationConfigurationHTC">
            <member><type>XrFoveationLevelHTC</type>      <name>level</name></member>
            <member><type>float</type>                    <name>clearFovDegree</name></member>
            <member><type>XrVector2f</type>               <name>focalCenterOffset</name></member>
        </type>
        <type category="struct" name="XrFoveationDynamicModeInfoHTC" structextends="XrFoveationApplyInfoHTC">
            <member values="XR_TYPE_FOVEATION_DYNAMIC_MODE_INFO_HTC"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                                          <name>next</name></member>
            <member optional="true"><type>XrFoveationDynamicFlagsHTC</type>                             <name>dynamicFlags</name></member>
        </type>
        <type category="struct" name="XrFoveationCustomModeInfoHTC" structextends="XrFoveationApplyInfoHTC">
            <member values="XR_TYPE_FOVEATION_CUSTOM_MODE_INFO_HTC"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                                          <name>next</name></member>
            <member><type>uint32_t</type>                             <name>configCount</name></member>
            <member len="configCount">const <type>XrFoveationConfigurationHTC</type>* <name>configs</name></member>
        </type>

        <!-- XR_EXT_active_action_set_priority -->
        <type category="struct" name="XrActiveActionSetPrioritiesEXT" structextends="XrActionsSyncInfo">
            <member values="XR_TYPE_ACTIVE_ACTION_SET_PRIORITIES_EXT"><type>XrStructureType</type> <name>type</name></member>
            <member>const <type>void</type>*                                                       <name>next</name></member>
            <member><type>uint32_t</type>                                                          <name>actionSetPriorityCount</name></member>
            <member len="actionSetPriorityCount">const <type>XrActiveActionSetPriorityEXT</type>*  <name>actionSetPriorities</name></member>
        </type>

        <type category="struct" name="XrActiveActionSetPriorityEXT">
            <member><type>XrActionSet</type> <name>actionSet</name></member>
            <member><type>uint32_t</type>    <name>priorityOverride</name></member>
        </type>
    </types>

    <!-- SECTION: OpenXR enumerant (token) definitions. -->

    <enums name="API Constants" comment="Misc. hardcoded constants - not an enumerated type">
        <!-- This is part of the header boilerplate -->
        <enum value="1"     name="XR_TRUE"/>
        <enum value="0"     name="XR_FALSE"/>
        <enum value="128"   name="XR_MAX_EXTENSION_NAME_SIZE"/>
        <enum value="256"   name="XR_MAX_API_LAYER_NAME_SIZE"/>
        <enum value="256"   name="XR_MAX_API_LAYER_DESCRIPTION_SIZE"/>
        <enum value="256"   name="XR_MAX_SYSTEM_NAME_SIZE"/>
        <enum value="128"   name="XR_MAX_APPLICATION_NAME_SIZE"/>
        <enum value="128"   name="XR_MAX_ENGINE_NAME_SIZE"/>
        <enum value="128"   name="XR_MAX_RUNTIME_NAME_SIZE"/>
        <enum value="256"   name="XR_MAX_PATH_LENGTH"/>
        <enum value="64"    name="XR_MAX_STRUCTURE_NAME_SIZE"/>
        <enum value="64"    name="XR_MAX_RESULT_STRING_SIZE"/>
        <enum value="32"    name="XR_MAX_GRAPHICS_APIS_SUPPORTED"/>
        <enum value="64"    name="XR_MAX_ACTION_SET_NAME_SIZE"/>
        <enum value="64"    name="XR_MAX_ACTION_NAME_SIZE"/>
        <enum value="128"   name="XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE"/>
        <enum value="128"   name="XR_MAX_LOCALIZED_ACTION_NAME_SIZE"/>
    </enums>

    <!-- Unlike OpenGL, most tokens in OpenXR are actual typed enumerants in
         their own numeric namespaces. The "name" attribute is the C enum
         type name, and is pulled in from a <type> definition above
         (slightly clunky, but retains the type / enum distinction). "type"
         attributes of "enum" or "bitmask" indicate that these values should
         be generated inside an appropriate definition. -->

    <enums name="XrStructureType" type="enum" comment="Structure type enumerant">
        <enum value="0"    name="XR_TYPE_UNKNOWN"/>
        <enum value="1"    name="XR_TYPE_API_LAYER_PROPERTIES"/>
        <enum value="2"    name="XR_TYPE_EXTENSION_PROPERTIES"/>
        <enum value="3"    name="XR_TYPE_INSTANCE_CREATE_INFO"/>
        <enum value="4"    name="XR_TYPE_SYSTEM_GET_INFO"/>
        <enum value="5"    name="XR_TYPE_SYSTEM_PROPERTIES"/>
        <enum value="6"    name="XR_TYPE_VIEW_LOCATE_INFO"/>
        <enum value="7"    name="XR_TYPE_VIEW"/>
        <enum value="8"    name="XR_TYPE_SESSION_CREATE_INFO"/>
        <enum value="9"    name="XR_TYPE_SWAPCHAIN_CREATE_INFO"/>
        <enum value="10"   name="XR_TYPE_SESSION_BEGIN_INFO"/>
        <enum value="11"   name="XR_TYPE_VIEW_STATE"/>
        <enum value="12"   name="XR_TYPE_FRAME_END_INFO"/>
        <enum value="13"   name="XR_TYPE_HAPTIC_VIBRATION"/>
        <enum value="16"   name="XR_TYPE_EVENT_DATA_BUFFER"/>
        <enum value="17"   name="XR_TYPE_EVENT_DATA_INSTANCE_LOSS_PENDING"/>
        <enum value="18"   name="XR_TYPE_EVENT_DATA_SESSION_STATE_CHANGED"/>
        <enum value="23"   name="XR_TYPE_ACTION_STATE_BOOLEAN"/>
        <enum value="24"   name="XR_TYPE_ACTION_STATE_FLOAT"/>
        <enum value="25"   name="XR_TYPE_ACTION_STATE_VECTOR2F"/>
        <enum value="27"   name="XR_TYPE_ACTION_STATE_POSE"/>
        <enum value="28"   name="XR_TYPE_ACTION_SET_CREATE_INFO"/>
        <enum value="29"   name="XR_TYPE_ACTION_CREATE_INFO"/>
        <enum value="32"   name="XR_TYPE_INSTANCE_PROPERTIES"/>
        <enum value="33"   name="XR_TYPE_FRAME_WAIT_INFO"/>
        <enum value="35"   name="XR_TYPE_COMPOSITION_LAYER_PROJECTION"/>
        <enum value="36"   name="XR_TYPE_COMPOSITION_LAYER_QUAD"/>
        <enum value="37"   name="XR_TYPE_REFERENCE_SPACE_CREATE_INFO"/>
        <enum value="38"   name="XR_TYPE_ACTION_SPACE_CREATE_INFO"/>
        <enum value="40"   name="XR_TYPE_EVENT_DATA_REFERENCE_SPACE_CHANGE_PENDING"/>
        <enum value="41"   name="XR_TYPE_VIEW_CONFIGURATION_VIEW"/>
        <enum value="42"   name="XR_TYPE_SPACE_LOCATION"/>
        <enum value="43"   name="XR_TYPE_SPACE_VELOCITY"/>
        <enum value="44"   name="XR_TYPE_FRAME_STATE"/>
        <enum value="45"   name="XR_TYPE_VIEW_CONFIGURATION_PROPERTIES"/>
        <enum value="46"   name="XR_TYPE_FRAME_BEGIN_INFO"/>
        <enum value="48"   name="XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW"/>
        <enum value="49"   name="XR_TYPE_EVENT_DATA_EVENTS_LOST"/>
        <enum value="51"   name="XR_TYPE_INTERACTION_PROFILE_SUGGESTED_BINDING"/>
        <enum value="52"   name="XR_TYPE_EVENT_DATA_INTERACTION_PROFILE_CHANGED"/>
        <enum value="53"   name="XR_TYPE_INTERACTION_PROFILE_STATE"/>
        <enum value="55"   name="XR_TYPE_SWAPCHAIN_IMAGE_ACQUIRE_INFO"/>
        <enum value="56"   name="XR_TYPE_SWAPCHAIN_IMAGE_WAIT_INFO"/>
        <enum value="57"   name="XR_TYPE_SWAPCHAIN_IMAGE_RELEASE_INFO"/>
        <enum value="58"   name="XR_TYPE_ACTION_STATE_GET_INFO"/>
        <enum value="59"   name="XR_TYPE_HAPTIC_ACTION_INFO"/>
        <enum value="60"   name="XR_TYPE_SESSION_ACTION_SETS_ATTACH_INFO"/>
        <enum value="61"   name="XR_TYPE_ACTIONS_SYNC_INFO"/>
        <enum value="62"   name="XR_TYPE_BOUND_SOURCES_FOR_ACTION_ENUMERATE_INFO"/>
        <enum value="63"   name="XR_TYPE_INPUT_SOURCE_LOCALIZED_NAME_GET_INFO"/>
    </enums>
    <enums name="XrResult" type="enum" comment="Error and return codes">
        <!-- Return codes for successful operation execution (positive values) -->
        <enum value="0"     name="XR_SUCCESS"                                   comment="Function successfully completed."/>
        <enum value="1"     name="XR_TIMEOUT_EXPIRED"                           comment="The specified timeout time occurred before the operation could complete."/>
        <enum value="3"     name="XR_SESSION_LOSS_PENDING"                      comment="The session will be lost soon."/>
        <enum value="4"     name="XR_EVENT_UNAVAILABLE"                         comment="No event was available."/>
        <enum value="7"     name="XR_SPACE_BOUNDS_UNAVAILABLE"                  comment="The space's bounds are not known at the moment."/>
        <enum value="8"     name="XR_SESSION_NOT_FOCUSED"                       comment="The session is not in the focused state."/>
        <enum value="9"     name="XR_FRAME_DISCARDED"                           comment="A frame has been discarded from composition."/>
        <!-- Error codes (negative values) -->
        <enum value="-1"    name="XR_ERROR_VALIDATION_FAILURE"                  comment="The function usage was invalid in some way."/>
        <enum value="-2"    name="XR_ERROR_RUNTIME_FAILURE"                     comment="The runtime failed to handle the function in an unexpected way that is not covered by another error result. "/>
        <enum value="-3"    name="XR_ERROR_OUT_OF_MEMORY"                       comment="A memory allocation has failed."/>
        <enum value="-4"    name="XR_ERROR_API_VERSION_UNSUPPORTED"             comment="The runtime does not support the requested API version."/>
        <enum value="-6"    name="XR_ERROR_INITIALIZATION_FAILED"               comment="Initialization of object could not be completed."/>
        <enum value="-7"    name="XR_ERROR_FUNCTION_UNSUPPORTED"                comment="The requested function was not found or is otherwise unsupported."/>
        <enum value="-8"    name="XR_ERROR_FEATURE_UNSUPPORTED"                 comment="The requested feature is not supported."/>
        <enum value="-9"    name="XR_ERROR_EXTENSION_NOT_PRESENT"               comment="A requested extension is not supported."/>
        <enum value="-10"   name="XR_ERROR_LIMIT_REACHED"                       comment="The runtime supports no more of the requested resource."/>
        <enum value="-11"   name="XR_ERROR_SIZE_INSUFFICIENT"                   comment="The supplied size was smaller than required."/>
        <enum value="-12"   name="XR_ERROR_HANDLE_INVALID"                      comment="A supplied object handle was invalid."/>
        <enum value="-13"   name="XR_ERROR_INSTANCE_LOST"                       comment="The slink:XrInstance was lost or could not be found. It will need to be destroyed and optionally recreated."/>
        <enum value="-14"   name="XR_ERROR_SESSION_RUNNING"                     comment="The session &lt;&lt;session_running, is already running&gt;&gt;."/>
        <enum value="-16"   name="XR_ERROR_SESSION_NOT_RUNNING"                 comment="The session &lt;&lt;session_not_running, is not yet running&gt;&gt;."/>
        <enum value="-17"   name="XR_ERROR_SESSION_LOST"                        comment="The slink:XrSession was lost. It will need to be destroyed and optionally recreated."/>
        <enum value="-18"   name="XR_ERROR_SYSTEM_INVALID"                      comment="The provided basetype:XrSystemId was invalid."/>
        <enum value="-19"   name="XR_ERROR_PATH_INVALID"                        comment="The provided basetype:XrPath was not valid."/>
        <enum value="-20"   name="XR_ERROR_PATH_COUNT_EXCEEDED"                 comment="The maximum number of supported semantic paths has been reached."/>
        <enum value="-21"   name="XR_ERROR_PATH_FORMAT_INVALID"                 comment="The semantic path character format is invalid."/>
        <enum value="-22"   name="XR_ERROR_PATH_UNSUPPORTED"                    comment="The semantic path is unsupported."/>
        <enum value="-23"   name="XR_ERROR_LAYER_INVALID"                       comment="The layer was NULL or otherwise invalid."/>
        <enum value="-24"   name="XR_ERROR_LAYER_LIMIT_EXCEEDED"                comment="The number of specified layers is greater than the supported number."/>
        <enum value="-25"   name="XR_ERROR_SWAPCHAIN_RECT_INVALID"              comment="The image rect was negatively sized or otherwise invalid."/>
        <enum value="-26"   name="XR_ERROR_SWAPCHAIN_FORMAT_UNSUPPORTED"        comment="The image format is not supported by the runtime or platform."/>
        <enum value="-27"   name="XR_ERROR_ACTION_TYPE_MISMATCH"                comment="The API used to retrieve an action's state does not match the action's type."/>
        <enum value="-28"   name="XR_ERROR_SESSION_NOT_READY"                   comment="The session is not in the ready state."/>
        <enum value="-29"   name="XR_ERROR_SESSION_NOT_STOPPING"                comment="The session is not in the stopping state."/>
        <enum value="-30"   name="XR_ERROR_TIME_INVALID"                        comment="The provided basetype:XrTime was zero, negative, or out of range."/>
        <enum value="-31"   name="XR_ERROR_REFERENCE_SPACE_UNSUPPORTED"         comment="The specified reference space is not supported by the runtime or system."/>
        <enum value="-32"   name="XR_ERROR_FILE_ACCESS_ERROR"                   comment="The file could not be accessed."/>
        <enum value="-33"   name="XR_ERROR_FILE_CONTENTS_INVALID"               comment="The file's contents were invalid."/>
        <enum value="-34"   name="XR_ERROR_FORM_FACTOR_UNSUPPORTED"             comment="The specified form factor is not supported by the current runtime or platform."/>
        <enum value="-35"   name="XR_ERROR_FORM_FACTOR_UNAVAILABLE"             comment="The specified form factor is supported, but the device is currently not available, e.g. not plugged in or powered off."/>
        <enum value="-36"   name="XR_ERROR_API_LAYER_NOT_PRESENT"               comment="A requested API layer is not present or could not be loaded."/>
        <enum value="-37"   name="XR_ERROR_CALL_ORDER_INVALID"                  comment="The call was made without having made a previously required call."/>
        <enum value="-38"   name="XR_ERROR_GRAPHICS_DEVICE_INVALID"             comment="The given graphics device is not in a valid state. The graphics device could be lost or initialized without meeting graphics requirements."/>
        <enum value="-39"   name="XR_ERROR_POSE_INVALID"                        comment="The supplied pose was invalid with respect to the requirements."/>
        <enum value="-40"   name="XR_ERROR_INDEX_OUT_OF_RANGE"                  comment="The supplied index was outside the range of valid indices."/>
        <enum value="-41"   name="XR_ERROR_VIEW_CONFIGURATION_TYPE_UNSUPPORTED" comment="The specified view configuration type is not supported by the runtime or platform."/>
        <enum value="-42"   name="XR_ERROR_ENVIRONMENT_BLEND_MODE_UNSUPPORTED"  comment="The specified environment blend mode is not supported by the runtime or platform."/>
        <enum value="-44"   name="XR_ERROR_NAME_DUPLICATED"                     comment="The name provided was a duplicate of an already-existing resource."/>
        <enum value="-45"   name="XR_ERROR_NAME_INVALID"                        comment="The name provided was invalid."/>
        <enum value="-46"   name="XR_ERROR_ACTIONSET_NOT_ATTACHED"              comment="A referenced action set is not attached to the session."/>
        <enum value="-47"   name="XR_ERROR_ACTIONSETS_ALREADY_ATTACHED"         comment="The session already has attached action sets."/>
        <enum value="-48"   name="XR_ERROR_LOCALIZED_NAME_DUPLICATED"           comment="The localized name provided was a duplicate of an already-existing resource."/>
        <enum value="-49"   name="XR_ERROR_LOCALIZED_NAME_INVALID"              comment="The localized name provided was invalid."/>
        <enum value="-50"   name="XR_ERROR_GRAPHICS_REQUIREMENTS_CALL_MISSING"  comment="The fname:xrGetGraphicsRequirements* call was not made before calling fname:xrCreateSession."/>
        <enum value="-51"   name="XR_ERROR_RUNTIME_UNAVAILABLE"                 comment="The loader was unable to find or load a runtime."/>
        <unused start="-100"/>
    </enums>
    <enums name="XrObjectType" type="enum" comment="Enums to track objects of various types">
        <enum value="0"   name="XR_OBJECT_TYPE_UNKNOWN"/>
        <enum value="1"   name="XR_OBJECT_TYPE_INSTANCE"   comment="XrInstance"/>
        <enum value="2"   name="XR_OBJECT_TYPE_SESSION"    comment="XrSession"/>
        <enum value="3"   name="XR_OBJECT_TYPE_SWAPCHAIN"  comment="XrSwapchain"/>
        <enum value="4"   name="XR_OBJECT_TYPE_SPACE"      comment="XrSpace"/>
        <enum value="5"   name="XR_OBJECT_TYPE_ACTION_SET" comment="XrActionSet"/>
        <enum value="6"   name="XR_OBJECT_TYPE_ACTION"     comment="XrAction"/>
    </enums>
    <enums name="XrAndroidThreadTypeKHR" type="enum" comment="Android Thread Types">
        <enum value="1"   name="XR_ANDROID_THREAD_TYPE_APPLICATION_MAIN_KHR"/>
        <enum value="2"   name="XR_ANDROID_THREAD_TYPE_APPLICATION_WORKER_KHR"/>
        <enum value="3"   name="XR_ANDROID_THREAD_TYPE_RENDERER_MAIN_KHR"/>
        <enum value="4"   name="XR_ANDROID_THREAD_TYPE_RENDERER_WORKER_KHR"/>
    </enums>
    <enums name="XrEyeVisibility" type="enum" comment="eye visibility selector">
        <enum value="0"   name="XR_EYE_VISIBILITY_BOTH"  comment="Display in both eyes."/>
        <enum value="1"   name="XR_EYE_VISIBILITY_LEFT"  comment="Display in the left eye only."/>
        <enum value="2"   name="XR_EYE_VISIBILITY_RIGHT" comment="Display in the right eye only."/>
    </enums>
    <enums name="XrActionType" type="enum">
        <enum value="1"     name="XR_ACTION_TYPE_BOOLEAN_INPUT"/>
        <enum value="2"     name="XR_ACTION_TYPE_FLOAT_INPUT"/>
        <enum value="3"     name="XR_ACTION_TYPE_VECTOR2F_INPUT"/>
        <enum value="4"     name="XR_ACTION_TYPE_POSE_INPUT"/>
        <enum value="100"   name="XR_ACTION_TYPE_VIBRATION_OUTPUT"/>
    </enums>
    <enums name="XrReferenceSpaceType" type="enum">
        <enum value="1"   name="XR_REFERENCE_SPACE_TYPE_VIEW"/>
        <enum value="2"   name="XR_REFERENCE_SPACE_TYPE_LOCAL"/>
        <enum value="3"   name="XR_REFERENCE_SPACE_TYPE_STAGE"/>
    </enums>
    <enums name="XrFormFactor" type="enum">
        <enum value="1"   name="XR_FORM_FACTOR_HEAD_MOUNTED_DISPLAY"/>
        <enum value="2"   name="XR_FORM_FACTOR_HANDHELD_DISPLAY"/>
    </enums>
    <enums name="XrViewConfigurationType" type="enum">
        <enum value="1"   name="XR_VIEW_CONFIGURATION_TYPE_PRIMARY_MONO"/>
        <enum value="2"   name="XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO"/>
    </enums>
    <enums name="XrEnvironmentBlendMode" type="enum">
        <enum value="1"   name="XR_ENVIRONMENT_BLEND_MODE_OPAQUE"/>
        <enum value="2"   name="XR_ENVIRONMENT_BLEND_MODE_ADDITIVE"/>
        <enum value="3"   name="XR_ENVIRONMENT_BLEND_MODE_ALPHA_BLEND"/>
    </enums>
    <enums name="XrSessionState" type="enum">
        <enum value="0"   name="XR_SESSION_STATE_UNKNOWN"/>
        <enum value="1"   name="XR_SESSION_STATE_IDLE"/>
        <enum value="2"   name="XR_SESSION_STATE_READY"/>
        <enum value="3"   name="XR_SESSION_STATE_SYNCHRONIZED"/>
        <enum value="4"   name="XR_SESSION_STATE_VISIBLE"/>
        <enum value="5"   name="XR_SESSION_STATE_FOCUSED"/>
        <enum value="6"   name="XR_SESSION_STATE_STOPPING"/>
        <enum value="7"   name="XR_SESSION_STATE_LOSS_PENDING"/>
        <enum value="8"   name="XR_SESSION_STATE_EXITING"/>
    </enums>

    <!--enums for Perf setting EXT-->
    <enums name="XrPerfSettingsLevelEXT" type="enum">
        <enum value="0"      name="XR_PERF_SETTINGS_LEVEL_POWER_SAVINGS_EXT"
        comment="Performance settings hint used by the application to indicate that it enters a non-XR
                 section (head-locked / static screen), during which power savings are to be prioritized"/>
        <enum value="25"     name="XR_PERF_SETTINGS_LEVEL_SUSTAINED_LOW_EXT"
        comment="Performance settings hint used by the application to indicate that it enters a low
                 and stable complexity section, during which reducing power is more important than
                 occasional late rendering frames"/>
        <enum value="50"     name="XR_PERF_SETTINGS_LEVEL_SUSTAINED_HIGH_EXT"
        comment="Performance settings hint used by the application to indicate that it enters
                 a high or dynamic complexity section, during which the XR Runtime strives for consistent
                 XR compositing and frame rendering within a thermally sustainable range"/>
        <enum value="75"     name="XR_PERF_SETTINGS_LEVEL_BOOST_EXT"
        comment="Performance settings hint used by the application to indicate that the application enters
                 a section with very high complexity, during which the XR Runtime is allowed to step
                 up beyond the thermally sustainable range"/>
    </enums>
    <enums name="XrPerfSettingsDomainEXT" type="enum">
        <enum value="1"   name="XR_PERF_SETTINGS_DOMAIN_CPU_EXT" comment="Indicates that the performance settings or notification applies to CPU domain"/>
        <enum value="2"   name="XR_PERF_SETTINGS_DOMAIN_GPU_EXT" comment="Indicates that the performance settings or notification applies to GPU domain"/>
    </enums>
    <enums name="XrPerfSettingsSubDomainEXT" type="enum">
        <enum value="1"   name="XR_PERF_SETTINGS_SUB_DOMAIN_COMPOSITING_EXT" comment="Indicates that the performance notification originates from the COMPOSITING sub-domain"/>
        <enum value="2"   name="XR_PERF_SETTINGS_SUB_DOMAIN_RENDERING_EXT"   comment="Indicates that the performance notification originates from the RENDERING sub-domain"/>
        <enum value="3"   name="XR_PERF_SETTINGS_SUB_DOMAIN_THERMAL_EXT"     comment="Indicates that the performance notification originates from the THERMAL sub-domain"/>
    </enums>
    <enums name="XrPerfSettingsNotificationLevelEXT" type="enum">
        <enum value="0"      name="XR_PERF_SETTINGS_NOTIF_LEVEL_NORMAL_EXT"
        comment="Notifies that the sub-domain has reached a level
                 where no further actions other than currently applied are necessary"/>
        <enum value="25"     name="XR_PERF_SETTINGS_NOTIF_LEVEL_WARNING_EXT"
        comment="Notifies that the sub-domain has reached an early warning level
                 where the application should start proactive mitigation actions
                 with the goal to return to the ename:XR_PERF_NOTIF_LEVEL_NORMAL level"/>
        <enum value="75"     name="XR_PERF_SETTINGS_NOTIF_LEVEL_IMPAIRED_EXT"
        comment="Notifies that the sub-domain has reached a critical
                 level with significant performance degradation.
                 The application should take drastic mitigation action"/>
    </enums>

    <!--enums for XR_KHR_visibility_mask -->
    <enums name="XrVisibilityMaskTypeKHR" type="enum" comment="">
        <enum value="1"   name="XR_VISIBILITY_MASK_TYPE_HIDDEN_TRIANGLE_MESH_KHR"  comment="exclusive mesh; indicates that which the viewer cannot see."/>
        <enum value="2"   name="XR_VISIBILITY_MASK_TYPE_VISIBLE_TRIANGLE_MESH_KHR" comment="inclusive mesh; indicates strictly that which the viewer can see."/>
        <enum value="3"   name="XR_VISIBILITY_MASK_TYPE_LINE_LOOP_KHR"             comment="line loop; traces the outline of the area the viewer can see."/>
    </enums>

    <!-- XR_EXT_hand_tracking -->
    <enums name="XrHandEXT" type="enum">
        <enum value="1"   name="XR_HAND_LEFT_EXT"/>
        <enum value="2"   name="XR_HAND_RIGHT_EXT"/>
    </enums>
    <enums name="XrHandJointEXT" type="enum">
        <enum value="0"    name="XR_HAND_JOINT_PALM_EXT"/>
        <enum value="1"    name="XR_HAND_JOINT_WRIST_EXT"/>
        <enum value="2"    name="XR_HAND_JOINT_THUMB_METACARPAL_EXT"/>
        <enum value="3"    name="XR_HAND_JOINT_THUMB_PROXIMAL_EXT"/>
        <enum value="4"    name="XR_HAND_JOINT_THUMB_DISTAL_EXT"/>
        <enum value="5"    name="XR_HAND_JOINT_THUMB_TIP_EXT"/>
        <enum value="6"    name="XR_HAND_JOINT_INDEX_METACARPAL_EXT"/>
        <enum value="7"    name="XR_HAND_JOINT_INDEX_PROXIMAL_EXT"/>
        <enum value="8"    name="XR_HAND_JOINT_INDEX_INTERMEDIATE_EXT"/>
        <enum value="9"    name="XR_HAND_JOINT_INDEX_DISTAL_EXT"/>
        <enum value="10"   name="XR_HAND_JOINT_INDEX_TIP_EXT"/>
        <enum value="11"   name="XR_HAND_JOINT_MIDDLE_METACARPAL_EXT"/>
        <enum value="12"   name="XR_HAND_JOINT_MIDDLE_PROXIMAL_EXT"/>
        <enum value="13"   name="XR_HAND_JOINT_MIDDLE_INTERMEDIATE_EXT"/>
        <enum value="14"   name="XR_HAND_JOINT_MIDDLE_DISTAL_EXT"/>
        <enum value="15"   name="XR_HAND_JOINT_MIDDLE_TIP_EXT"/>
        <enum value="16"   name="XR_HAND_JOINT_RING_METACARPAL_EXT"/>
        <enum value="17"   name="XR_HAND_JOINT_RING_PROXIMAL_EXT"/>
        <enum value="18"   name="XR_HAND_JOINT_RING_INTERMEDIATE_EXT"/>
        <enum value="19"   name="XR_HAND_JOINT_RING_DISTAL_EXT"/>
        <enum value="20"   name="XR_HAND_JOINT_RING_TIP_EXT"/>
        <enum value="21"   name="XR_HAND_JOINT_LITTLE_METACARPAL_EXT"/>
        <enum value="22"   name="XR_HAND_JOINT_LITTLE_PROXIMAL_EXT"/>
        <enum value="23"   name="XR_HAND_JOINT_LITTLE_INTERMEDIATE_EXT"/>
        <enum value="24"   name="XR_HAND_JOINT_LITTLE_DISTAL_EXT"/>
        <enum value="25"   name="XR_HAND_JOINT_LITTLE_TIP_EXT"/>
    </enums>
    <enums name="XrHandJointSetEXT" type="enum">
        <enum value="0"   name="XR_HAND_JOINT_SET_DEFAULT_EXT"/>
    </enums>

    <!-- XR_EXT_hand_joints_motion_range -->
    <enums name="XrHandJointsMotionRangeEXT" type="enum">
        <enum value="1"   name="XR_HAND_JOINTS_MOTION_RANGE_UNOBSTRUCTED_EXT"/>
        <enum value="2"   name="XR_HAND_JOINTS_MOTION_RANGE_CONFORMING_TO_CONTROLLER_EXT"/>
    </enums>

    <!-- XR_MSFT_hand_tracking_mesh -->
    <enums name="XrHandPoseTypeMSFT" type="enum">
        <enum value="0"   name="XR_HAND_POSE_TYPE_TRACKED_MSFT"/>
        <enum value="1"   name="XR_HAND_POSE_TYPE_REFERENCE_OPEN_PALM_MSFT"/>
    </enums>

    <!-- XR_FB_color_space -->
    <enums name="XrColorSpaceFB" type="enum">
        <enum value="0"   name="XR_COLOR_SPACE_UNMANAGED_FB"/>
        <enum value="1"   name="XR_COLOR_SPACE_REC2020_FB"/>
        <enum value="2"   name="XR_COLOR_SPACE_REC709_FB"/>
        <enum value="3"   name="XR_COLOR_SPACE_RIFT_CV1_FB"/>
        <enum value="4"   name="XR_COLOR_SPACE_RIFT_S_FB"/>
        <enum value="5"   name="XR_COLOR_SPACE_QUEST_FB"/>
        <enum value="6"   name="XR_COLOR_SPACE_P3_FB"/>
        <enum value="7"   name="XR_COLOR_SPACE_ADOBE_RGB_FB"/>
    </enums>

    <!-- XR_FB_composition_layer_alpha_blend -->
    <enums name="XrBlendFactorFB" type="enum">
        <enum value="0"   name="XR_BLEND_FACTOR_ZERO_FB"/>
        <enum value="1"   name="XR_BLEND_FACTOR_ONE_FB"/>
        <enum value="2"   name="XR_BLEND_FACTOR_SRC_ALPHA_FB"/>
        <enum value="3"   name="XR_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA_FB"/>
        <enum value="4"   name="XR_BLEND_FACTOR_DST_ALPHA_FB"/>
        <enum value="5"   name="XR_BLEND_FACTOR_ONE_MINUS_DST_ALPHA_FB"/>
    </enums>

    <!-- XR_MSFT_composition_layer_reprojection -->
    <enums name="XrReprojectionModeMSFT" type="enum">
        <enum value="1"   name="XR_REPROJECTION_MODE_DEPTH_MSFT"/>
        <enum value="2"   name="XR_REPROJECTION_MODE_PLANAR_FROM_DEPTH_MSFT"/>
        <enum value="3"   name="XR_REPROJECTION_MODE_PLANAR_MANUAL_MSFT"/>
        <enum value="4"   name="XR_REPROJECTION_MODE_ORIENTATION_ONLY_MSFT"/>
    </enums>

    <!-- XR_ULTRALEAP_hand_tracking_forearm -->
    <enums name="XrHandForearmJointULTRALEAP" type="enum">
        <enum value="0"    name="XR_HAND_FOREARM_JOINT_PALM_ULTRALEAP"/>
        <enum value="1"    name="XR_HAND_FOREARM_JOINT_WRIST_ULTRALEAP"/>
        <enum value="2"    name="XR_HAND_FOREARM_JOINT_THUMB_METACARPAL_ULTRALEAP"/>
        <enum value="3"    name="XR_HAND_FOREARM_JOINT_THUMB_PROXIMAL_ULTRALEAP"/>
        <enum value="4"    name="XR_HAND_FOREARM_JOINT_THUMB_DISTAL_ULTRALEAP"/>
        <enum value="5"    name="XR_HAND_FOREARM_JOINT_THUMB_TIP_ULTRALEAP"/>
        <enum value="6"    name="XR_HAND_FOREARM_JOINT_INDEX_METACARPAL_ULTRALEAP"/>
        <enum value="7"    name="XR_HAND_FOREARM_JOINT_INDEX_PROXIMAL_ULTRALEAP"/>
        <enum value="8"    name="XR_HAND_FOREARM_JOINT_INDEX_INTERMEDIATE_ULTRALEAP"/>
        <enum value="9"    name="XR_HAND_FOREARM_JOINT_INDEX_DISTAL_ULTRALEAP"/>
        <enum value="10"   name="XR_HAND_FOREARM_JOINT_INDEX_TIP_ULTRALEAP"/>
        <enum value="11"   name="XR_HAND_FOREARM_JOINT_MIDDLE_METACARPAL_ULTRALEAP"/>
        <enum value="12"   name="XR_HAND_FOREARM_JOINT_MIDDLE_PROXIMAL_ULTRALEAP"/>
        <enum value="13"   name="XR_HAND_FOREARM_JOINT_MIDDLE_INTERMEDIATE_ULTRALEAP"/>
        <enum value="14"   name="XR_HAND_FOREARM_JOINT_MIDDLE_DISTAL_ULTRALEAP"/>
        <enum value="15"   name="XR_HAND_FOREARM_JOINT_MIDDLE_TIP_ULTRALEAP"/>
        <enum value="16"   name="XR_HAND_FOREARM_JOINT_RING_METACARPAL_ULTRALEAP"/>
        <enum value="17"   name="XR_HAND_FOREARM_JOINT_RING_PROXIMAL_ULTRALEAP"/>
        <enum value="18"   name="XR_HAND_FOREARM_JOINT_RING_INTERMEDIATE_ULTRALEAP"/>
        <enum value="19"   name="XR_HAND_FOREARM_JOINT_RING_DISTAL_ULTRALEAP"/>
        <enum value="20"   name="XR_HAND_FOREARM_JOINT_RING_TIP_ULTRALEAP"/>
        <enum value="21"   name="XR_HAND_FOREARM_JOINT_LITTLE_METACARPAL_ULTRALEAP"/>
        <enum value="22"   name="XR_HAND_FOREARM_JOINT_LITTLE_PROXIMAL_ULTRALEAP"/>
        <enum value="23"   name="XR_HAND_FOREARM_JOINT_LITTLE_INTERMEDIATE_ULTRALEAP"/>
        <enum value="24"   name="XR_HAND_FOREARM_JOINT_LITTLE_DISTAL_ULTRALEAP"/>
        <enum value="25"   name="XR_HAND_FOREARM_JOINT_LITTLE_TIP_ULTRALEAP"/>
        <enum value="26"   name="XR_HAND_FOREARM_JOINT_ELBOW_ULTRALEAP"/>
    </enums>

    <!-- Flags -->
    <enums name="XrInstanceCreateFlagBits" type="bitmask">
        <!-- This is currently empty, awaiting future flags. -->
    </enums>
    <enums name="XrSessionCreateFlagBits" type="bitmask">
        <!-- This is currently empty, awaiting future flags. -->
    </enums>
    <enums name="XrSwapchainCreateFlagBits" type="bitmask">
        <enum bitpos="0" name="XR_SWAPCHAIN_CREATE_PROTECTED_CONTENT_BIT" comment="Content will be protected from CPU access"/>
        <enum bitpos="1" name="XR_SWAPCHAIN_CREATE_STATIC_IMAGE_BIT"      comment="Only one image will be acquired from this swapchain over its lifetime"/>
    </enums>
    <enums name="XrSwapchainUsageFlagBits" type="bitmask">
        <enum bitpos="0" name="XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT"         comment="Specifies that the image may: be a color rendering target."/>
        <enum bitpos="1" name="XR_SWAPCHAIN_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT" comment="Specifies that the image may: be a depth/stencil rendering target."/>
        <enum bitpos="2" name="XR_SWAPCHAIN_USAGE_UNORDERED_ACCESS_BIT"         comment="Specifies that the image may: be accessed out of order and that access may: be via atomic operations."/>
        <enum bitpos="3" name="XR_SWAPCHAIN_USAGE_TRANSFER_SRC_BIT"             comment="Specifies that the image may: be used as the source of a transfer operation."/>
        <enum bitpos="4" name="XR_SWAPCHAIN_USAGE_TRANSFER_DST_BIT"             comment="Specifies that the image may: be used as the destination of a transfer operation."/>
        <enum bitpos="5" name="XR_SWAPCHAIN_USAGE_SAMPLED_BIT"                  comment="Specifies that the image may: be sampled by a shader."/>
        <enum bitpos="6" name="XR_SWAPCHAIN_USAGE_MUTABLE_FORMAT_BIT"           comment="Specifies that the image may: be reinterpreted as another image format."/>
    </enums>
    <enums name="XrViewStateFlagBits" type="bitmask">
        <enum bitpos="0" name="XR_VIEW_STATE_ORIENTATION_VALID_BIT"   comment="Indicates validity of all slink:XrView orientations"/>
        <enum bitpos="1" name="XR_VIEW_STATE_POSITION_VALID_BIT"      comment="Indicates validity of all slink:XrView positions"/>
        <enum bitpos="2" name="XR_VIEW_STATE_ORIENTATION_TRACKED_BIT" comment="Indicates whether all slink:XrView orientations are actively tracked"/>
        <enum bitpos="3" name="XR_VIEW_STATE_POSITION_TRACKED_BIT"    comment="Indicates whether all slink:XrView positions are actively tracked"/>
    </enums>
    <enums name="XrCompositionLayerFlagBits" type="bitmask">
        <enum bitpos="0" name="XR_COMPOSITION_LAYER_CORRECT_CHROMATIC_ABERRATION_BIT" comment="Enables chromatic aberration correction when not done by default. This flag has no effect on any known conformant runtime, and is planned for deprecation for OpenXR 1.1"/>
        <enum bitpos="1" name="XR_COMPOSITION_LAYER_BLEND_TEXTURE_SOURCE_ALPHA_BIT"   comment="Enables the layer texture alpha channel."/>
        <enum bitpos="2" name="XR_COMPOSITION_LAYER_UNPREMULTIPLIED_ALPHA_BIT"        comment="Indicates the texture color channels have not been premultiplied by the texture alpha channel."/>
    </enums>

    <enums name="XrSpaceLocationFlagBits" type="bitmask">
        <enum bitpos="0" name="XR_SPACE_LOCATION_ORIENTATION_VALID_BIT"   comment="Indicates that the pname:orientation member contains valid data"/>
        <enum bitpos="1" name="XR_SPACE_LOCATION_POSITION_VALID_BIT"      comment="Indicates that the pname:position member contains valid data"/>
        <enum bitpos="2" name="XR_SPACE_LOCATION_ORIENTATION_TRACKED_BIT" comment="Indicates whether pname:pose member contains an actively tracked pname:orientation"/>
        <enum bitpos="3" name="XR_SPACE_LOCATION_POSITION_TRACKED_BIT"    comment="Indicates whether pname:pose member contains an actively tracked pname:position"/>
    </enums>
    <enums name="XrSpaceVelocityFlagBits" type="bitmask">
        <enum bitpos="0" name="XR_SPACE_VELOCITY_LINEAR_VALID_BIT"  comment="Indicates that the pname:linearVelocity member contains valid data. Applications must: not read the pname:linearVelocity field if this flag is unset."/>
        <enum bitpos="1" name="XR_SPACE_VELOCITY_ANGULAR_VALID_BIT" comment="Indicates that the pname:angularVelocity member contains valid data. Applications must: not read the pname:angularVelocity field if this flag is unset."/>
    </enums>

    <enums name="XrInputSourceLocalizedNameFlagBits" type="bitmask">
        <enum bitpos="0" name="XR_INPUT_SOURCE_LOCALIZED_NAME_USER_PATH_BIT"           comment="Asks for the part of the string which indicates the top level user path the source represents"/>
        <enum bitpos="1" name="XR_INPUT_SOURCE_LOCALIZED_NAME_INTERACTION_PROFILE_BIT" comment="Asks for the part of the string which represents the interaction profile of the source"/>
        <enum bitpos="2" name="XR_INPUT_SOURCE_LOCALIZED_NAME_COMPONENT_BIT"           comment="Asks for the part of the string which represents the component on the device which needs to be interacted with"/>
    </enums>

    <!-- flags for XR_EXT_debug_utils -->
    <enums name="XrVulkanInstanceCreateFlagBitsKHR" type="bitmask">
        <!-- This is currently empty, awaiting future flags. -->
    </enums>
    <enums name="XrVulkanDeviceCreateFlagBitsKHR" type="bitmask">
        <!-- This is currently empty, awaiting future flags. -->
    </enums>

    <!-- flags for XR_EXT_debug_utils -->
    <enums name="XrDebugUtilsMessageSeverityFlagBitsEXT" type="bitmask">
        <enum bitpos="0"  name="XR_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT" comment="Most verbose output severity, typically used for debugging."/>
        <enum bitpos="4"  name="XR_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT"    comment="General info message"/>
        <enum bitpos="8"  name="XR_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT" comment="Indicates the item may be the cause of issues."/>
        <enum bitpos="12" name="XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT"   comment="Indicates that the item is definitely related to erroneous behavior."/>
    </enums>
    <enums name="XrDebugUtilsMessageTypeFlagBitsEXT" type="bitmask">
        <enum bitpos="0" name="XR_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT"     comment="Indicates this is a general message"/>
        <enum bitpos="1" name="XR_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT"  comment="Indicates the message is related to a validation message"/>
        <enum bitpos="2" name="XR_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT" comment="Indicates the message is related to a potential performance situation"/>
        <enum bitpos="3" name="XR_DEBUG_UTILS_MESSAGE_TYPE_CONFORMANCE_BIT_EXT" comment="Indicates the message is related to a non-conformant runtime result"/>
    </enums>

    <!-- flags for XR_EXTX_overlay -->
    <enums name="XrOverlayMainSessionFlagBitsEXTX" type="bitmask">
        <enum bitpos="0" name="XR_OVERLAY_MAIN_SESSION_ENABLED_COMPOSITION_LAYER_INFO_DEPTH_BIT_EXTX" comment="Indicates the main session enabled `XR_KHR_composition_layer_depth`"/>
    </enums>
    <enums name="XrOverlaySessionCreateFlagBitsEXTX" type="bitmask">
    </enums>

    <!-- enumes XR_MSFT_spatial_graph_bridge -->
    <enums name="XrSpatialGraphNodeTypeMSFT" type="enum">
        <enum value="1"   name="XR_SPATIAL_GRAPH_NODE_TYPE_STATIC_MSFT"/>
        <enum value="2"   name="XR_SPATIAL_GRAPH_NODE_TYPE_DYNAMIC_MSFT"/>
    </enums>

    <!-- enumes XR_MSFT_scene_understanding -->
    <enums name="XrSceneObjectTypeMSFT" type="enum">
        <enum value="-1"   name="XR_SCENE_OBJECT_TYPE_UNCATEGORIZED_MSFT"/>
        <enum value="1"    name="XR_SCENE_OBJECT_TYPE_BACKGROUND_MSFT"/>
        <enum value="2"    name="XR_SCENE_OBJECT_TYPE_WALL_MSFT"/>
        <enum value="3"    name="XR_SCENE_OBJECT_TYPE_FLOOR_MSFT"/>
        <enum value="4"    name="XR_SCENE_OBJECT_TYPE_CEILING_MSFT"/>
        <enum value="5"    name="XR_SCENE_OBJECT_TYPE_PLATFORM_MSFT"/>
        <enum value="6"    name="XR_SCENE_OBJECT_TYPE_INFERRED_MSFT"/>
    </enums>
    <enums name="XrScenePlaneAlignmentTypeMSFT" type="enum">
        <enum value="0"   name="XR_SCENE_PLANE_ALIGNMENT_TYPE_NON_ORTHOGONAL_MSFT"/>
        <enum value="1"   name="XR_SCENE_PLANE_ALIGNMENT_TYPE_HORIZONTAL_MSFT"/>
        <enum value="2"   name="XR_SCENE_PLANE_ALIGNMENT_TYPE_VERTICAL_MSFT"/>
    </enums>
    <enums name="XrSceneComputeStateMSFT" type="enum">
        <enum value="0"   name="XR_SCENE_COMPUTE_STATE_NONE_MSFT"/>
        <enum value="1"   name="XR_SCENE_COMPUTE_STATE_UPDATING_MSFT"/>
        <enum value="2"   name="XR_SCENE_COMPUTE_STATE_COMPLETED_MSFT"/>
        <enum value="3"   name="XR_SCENE_COMPUTE_STATE_COMPLETED_WITH_ERROR_MSFT"/>
    </enums>
    <enums name="XrSceneComponentTypeMSFT" type="enum">
        <enum value="-1"   name="XR_SCENE_COMPONENT_TYPE_INVALID_MSFT"/>
        <enum value="1"    name="XR_SCENE_COMPONENT_TYPE_OBJECT_MSFT"/>
        <enum value="2"    name="XR_SCENE_COMPONENT_TYPE_PLANE_MSFT"/>
        <enum value="3"    name="XR_SCENE_COMPONENT_TYPE_VISUAL_MESH_MSFT"/>
        <enum value="4"    name="XR_SCENE_COMPONENT_TYPE_COLLIDER_MESH_MSFT"/>
    </enums>
    <enums name="XrSceneComputeFeatureMSFT" type="enum">
        <enum value="1"   name="XR_SCENE_COMPUTE_FEATURE_PLANE_MSFT"/>
        <enum value="2"   name="XR_SCENE_COMPUTE_FEATURE_PLANE_MESH_MSFT"/>
        <enum value="3"   name="XR_SCENE_COMPUTE_FEATURE_VISUAL_MESH_MSFT"/>
        <enum value="4"   name="XR_SCENE_COMPUTE_FEATURE_COLLIDER_MESH_MSFT"/>
    </enums>
    <enums name="XrSceneComputeConsistencyMSFT" type="enum">
        <enum value="1"   name="XR_SCENE_COMPUTE_CONSISTENCY_SNAPSHOT_COMPLETE_MSFT"/>
        <enum value="2"   name="XR_SCENE_COMPUTE_CONSISTENCY_SNAPSHOT_INCOMPLETE_FAST_MSFT"/>
        <enum value="3"   name="XR_SCENE_COMPUTE_CONSISTENCY_OCCLUSION_OPTIMIZED_MSFT"/>
    </enums>
    <enums name="XrMeshComputeLodMSFT" type="enum">
        <enum value="1"   name="XR_MESH_COMPUTE_LOD_COARSE_MSFT"/>
        <enum value="2"   name="XR_MESH_COMPUTE_LOD_MEDIUM_MSFT"/>
        <enum value="3"   name="XR_MESH_COMPUTE_LOD_FINE_MSFT"/>
        <enum value="4"   name="XR_MESH_COMPUTE_LOD_UNLIMITED_MSFT"/>
    </enums>

    <!-- flags for XR_FB_android_surface_swapchain_create -->
    <enums name="XrAndroidSurfaceSwapchainFlagBitsFB" type="bitmask">
        <enum bitpos="0" name="XR_ANDROID_SURFACE_SWAPCHAIN_SYNCHRONOUS_BIT_FB"    comment="Create the underlying BufferQueue in synchronous mode"/>
        <enum bitpos="1" name="XR_ANDROID_SURFACE_SWAPCHAIN_USE_TIMESTAMPS_BIT_FB" comment="Acquire most recent buffer whose presentation timestamp is not greater than display time of final composited frame"/>
    </enums>

    <!-- flags for XR_FB_composition_layer_image_layout -->
    <enums name="XrCompositionLayerImageLayoutFlagBitsFB" type="bitmask">
        <enum bitpos="0" name="XR_COMPOSITION_LAYER_IMAGE_LAYOUT_VERTICAL_FLIP_BIT_FB" comment="The coordinate origin of the swapchain image must be considered to be flipped vertically."/>
    </enums>

    <!-- flags for XR_FB_foveation -->
    <enums name="XrSwapchainCreateFoveationFlagBitsFB" type="bitmask">
        <enum bitpos="0" name="XR_SWAPCHAIN_CREATE_FOVEATION_SCALED_BIN_BIT_FB"           comment="Explicitly create the swapchain with scaled bin foveation support. The application must ensure that the swapchain is using the OpenGL graphics API and that the QCOM_texture_foveated extension is supported and enabled."/>
        <enum bitpos="1" name="XR_SWAPCHAIN_CREATE_FOVEATION_FRAGMENT_DENSITY_MAP_BIT_FB" comment="Explicitly create the swapchain with fragment density map foveation support. The application must ensure that the swapchain is using the Vulkan graphics API and that the VK_EXT_fragment_density_map extension is supported and enabled."/>
    </enums>
    <enums name="XrSwapchainStateFoveationFlagBitsFB" type="bitmask">
        <!-- This is currently empty, awaiting future flags. -->
    </enums>

    <!-- flags for XR_FB_composition_layer_secure_content -->
    <enums name="XrCompositionLayerSecureContentFlagBitsFB" type="bitmask">
        <enum bitpos="0" name="XR_COMPOSITION_LAYER_SECURE_CONTENT_EXCLUDE_LAYER_BIT_FB" comment="Indicates the layer will only be visible inside the HMD, and not visible to external sources"/>
        <enum bitpos="1" name="XR_COMPOSITION_LAYER_SECURE_CONTENT_REPLACE_LAYER_BIT_FB" comment="Indicates the layer will be displayed inside the HMD, but replaced by proxy content when written to external sources"/>
    </enums>

    <!-- enums for XR_FB_spatial_entity -->
    <enums name="XrSpaceComponentTypeFB" type="enum">
        <enum value="0"   name="XR_SPACE_COMPONENT_TYPE_LOCATABLE_FB"       comment="Enables tracking the 6 DOF pose of the slink:XrSpace with flink:xrLocateSpace."/>
        <enum value="1"   name="XR_SPACE_COMPONENT_TYPE_STORABLE_FB"        comment="Enables persistence operations: save and erase."/>
        <enum value="3"   name="XR_SPACE_COMPONENT_TYPE_BOUNDED_2D_FB"      comment="Bounded 2D component."/>
        <enum value="4"   name="XR_SPACE_COMPONENT_TYPE_BOUNDED_3D_FB"      comment="Bounded 3D component."/>
        <enum value="5"   name="XR_SPACE_COMPONENT_TYPE_SEMANTIC_LABELS_FB" comment="Semantic labels component."/>
        <enum value="6"   name="XR_SPACE_COMPONENT_TYPE_ROOM_LAYOUT_FB"     comment="Room layout component."/>
        <enum value="7"   name="XR_SPACE_COMPONENT_TYPE_SPACE_CONTAINER_FB" comment="Space container component."/>
    </enums>

    <!-- enums for XR_FB_foveation_configuration -->
    <enums name="XrFoveationLevelFB" type="enum">
        <enum value="0"   name="XR_FOVEATION_LEVEL_NONE_FB"   comment="No foveation"/>
        <enum value="1"   name="XR_FOVEATION_LEVEL_LOW_FB"    comment="Less foveation (higher periphery visual fidelity, lower performance)"/>
        <enum value="2"   name="XR_FOVEATION_LEVEL_MEDIUM_FB" comment="Medium foveation (medium periphery visual fidelity, medium performance)"/>
        <enum value="3"   name="XR_FOVEATION_LEVEL_HIGH_FB"   comment="High foveation (lower periphery visual fidelity, higher performance)"/>
    </enums>
    <enums name="XrFoveationDynamicFB" type="enum">
        <enum value="0"   name="XR_FOVEATION_DYNAMIC_DISABLED_FB"      comment="Static foveation at the maximum desired level"/>
        <enum value="1"   name="XR_FOVEATION_DYNAMIC_LEVEL_ENABLED_FB" comment="Dynamic changing foveation based on performance headroom available up to the maximum desired level"/>
    </enums>

    <!-- enums for XR_FB_triangle_mesh -->
    <enums name="XrWindingOrderFB" type="enum">
        <enum value="0"   name="XR_WINDING_ORDER_UNKNOWN_FB" comment="Winding order is unknown and the runtime cannot make any assumptions on the triangle orientation"/>
        <enum value="1"   name="XR_WINDING_ORDER_CW_FB"      comment="Clockwise winding order"/>
        <enum value="2"   name="XR_WINDING_ORDER_CCW_FB"     comment="Counter-clockwise winding order"/>
    </enums>
    <enums name="XrTriangleMeshFlagBitsFB" type="bitmask">
        <enum bitpos="0" name="XR_TRIANGLE_MESH_MUTABLE_BIT_FB" comment="The triangle mesh is mutable (can be modified after it is created)."/>
    </enums>

    <!-- enums for XR_FB_passthrough -->
    <enums name="XrPassthroughLayerPurposeFB" type="enum">
        <enum value="0"   name="XR_PASSTHROUGH_LAYER_PURPOSE_RECONSTRUCTION_FB" comment="Reconstruction passthrough (full screen environment)"/>
        <enum value="1"   name="XR_PASSTHROUGH_LAYER_PURPOSE_PROJECTED_FB"      comment="Projected passthrough (using a custom surface)"/>
    </enums>
    <enums name="XrPassthroughFlagBitsFB" type="bitmask">
        <enum bitpos="0" name="XR_PASSTHROUGH_IS_RUNNING_AT_CREATION_BIT_FB" comment="The object (passthrough, layer) is running at creation."/>
        <enum bitpos="1" name="XR_PASSTHROUGH_LAYER_DEPTH_BIT_FB"            comment="The passthrough system sends depth information to the compositor. Only applicable to layer objects."/>
    </enums>
    <enums name="XrPassthroughStateChangedFlagBitsFB" type="bitmask">
        <enum bitpos="0" name="XR_PASSTHROUGH_STATE_CHANGED_REINIT_REQUIRED_BIT_FB"       comment="Passthrough system requires reinitialization."/>
        <enum bitpos="1" name="XR_PASSTHROUGH_STATE_CHANGED_NON_RECOVERABLE_ERROR_BIT_FB" comment="Non-recoverable error has occurred. A device reboot or a firmware update may be required."/>
        <enum bitpos="2" name="XR_PASSTHROUGH_STATE_CHANGED_RECOVERABLE_ERROR_BIT_FB"     comment="A recoverable error has occurred. The runtime will attempt to recover, but some functionality may be temporarily unavailable."/>
        <enum bitpos="3" name="XR_PASSTHROUGH_STATE_CHANGED_RESTORED_ERROR_BIT_FB"        comment="The runtime has recovered from a previous error and is functioning normally."/>
    </enums>
    <enums name="XrPassthroughCapabilityFlagBitsFB" type="bitmask">
        <enum bitpos="0" name="XR_PASSTHROUGH_CAPABILITY_BIT_FB"             comment="The system supports passthrough."/>
        <enum bitpos="1" name="XR_PASSTHROUGH_CAPABILITY_COLOR_BIT_FB"       comment="The system can show passthrough with realistic colors. ename:XR_PASSTHROUGH_CAPABILITY_BIT_FB must: be set if ename:XR_PASSTHROUGH_CAPABILITY_COLOR_BIT_FB is set."/>
        <enum bitpos="2" name="XR_PASSTHROUGH_CAPABILITY_LAYER_DEPTH_BIT_FB" comment="The system supports passthrough layers composited using depth testing. ename:XR_PASSTHROUGH_CAPABILITY_BIT_FB must: be set if ename:XR_PASSTHROUGH_CAPABILITY_LAYER_DEPTH_BIT_FB is set."/>
    </enums>

    <!-- enums for XR_FB_spatial_entity_query -->
    <enums name="XrSpaceQueryActionFB" type="enum">
        <enum value="0"   name="XR_SPACE_QUERY_ACTION_LOAD_FB" comment="Tells the query to perform a load operation on any slink:XrSpace returned by the query."/>
    </enums>

    <!-- enums for XR_FB_spatial_entity_storage -->
    <enums name="XrSpaceStorageLocationFB" type="enum">
        <enum value="0"   name="XR_SPACE_STORAGE_LOCATION_INVALID_FB" comment="Invalid storage location"/>
        <enum value="1"   name="XR_SPACE_STORAGE_LOCATION_LOCAL_FB"   comment="Local device storage"/>
    </enums>
    <enums name="XrSpacePersistenceModeFB" type="enum">
        <enum value="0"   name="XR_SPACE_PERSISTENCE_MODE_INVALID_FB"    comment="Invalid storage persistence"/>
        <enum value="1"   name="XR_SPACE_PERSISTENCE_MODE_INDEFINITE_FB" comment="Store slink:XrSpace indefinitely, or until erased"/>
    </enums>

    <!-- flags for XR_FB_hand_tracking_aim -->
    <enums name="XrHandTrackingAimFlagBitsFB" type="bitmask">
        <enum bitpos="0" name="XR_HAND_TRACKING_AIM_COMPUTED_BIT_FB"        comment="Aiming data is computed from additional sources beyond the hand data in the base structure"/>
        <enum bitpos="1" name="XR_HAND_TRACKING_AIM_VALID_BIT_FB"           comment="Aiming data is valid"/>
        <enum bitpos="2" name="XR_HAND_TRACKING_AIM_INDEX_PINCHING_BIT_FB"  comment="Index finger pinch discrete signal"/>
        <enum bitpos="3" name="XR_HAND_TRACKING_AIM_MIDDLE_PINCHING_BIT_FB" comment="Middle finger pinch discrete signal"/>
        <enum bitpos="4" name="XR_HAND_TRACKING_AIM_RING_PINCHING_BIT_FB"   comment="Ring finger pinch discrete signal"/>
        <enum bitpos="5" name="XR_HAND_TRACKING_AIM_LITTLE_PINCHING_BIT_FB" comment="Little finger pinch discrete signal"/>
        <enum bitpos="6" name="XR_HAND_TRACKING_AIM_SYSTEM_GESTURE_BIT_FB"  comment="System gesture is active"/>
        <enum bitpos="7" name="XR_HAND_TRACKING_AIM_DOMINANT_HAND_BIT_FB"   comment="Hand is currently marked as dominant for the system"/>
        <enum bitpos="8" name="XR_HAND_TRACKING_AIM_MENU_PRESSED_BIT_FB"    comment="System menu gesture is active"/>
    </enums>

    <!-- flags for XR_FB_keyboard_tracking query state -->
    <enums name="XrKeyboardTrackingFlagBitsFB" type="bitmask">
        <enum bitpos="0" name="XR_KEYBOARD_TRACKING_EXISTS_BIT_FB"    comment="indicates that the system has a physically tracked keyboard to report.  If not set then no other bits should be considered to be valid or meaningful.  If set either XR_KEYBOARD_TRACKING_LOCAL_BIT_FB or XR_KEYBOARD_TRACKING_REMOTE_BIT_FB must also be set."/>
        <enum bitpos="1" name="XR_KEYBOARD_TRACKING_LOCAL_BIT_FB"     comment="indicates that the physically tracked keyboard is intended to be used in a local pairing with the system.  Mutally exclusive with XR_KEYBOARD_TRACKING_REMOTE_BIT_FB."/>
        <enum bitpos="2" name="XR_KEYBOARD_TRACKING_REMOTE_BIT_FB"    comment="indicates that the physically tracked keyboard is intended to be used while paired to a separate remote computing device. Mutally exclusive with XR_KEYBOARD_TRACKING_LOCAL_BIT_FB."/>
        <enum bitpos="3" name="XR_KEYBOARD_TRACKING_CONNECTED_BIT_FB" comment="indicates that the physically tracked keyboard is actively connected to the headset and capable of sending key data"/>
    </enums>

    <!-- flags for XR_FB_keyboard_tracking query -->
    <enums name="XrKeyboardTrackingQueryFlagBitsFB" type="bitmask">
        <enum bitpos="1" name="XR_KEYBOARD_TRACKING_QUERY_LOCAL_BIT_FB"  comment="indicates the query is for the physically tracked keyboard that is intended to be used in a local pairing with the System. Mutally exclusive with XR_KEYBOARD_TRACKING_QUERY_REMOTE_BIT_FB."/>
        <enum bitpos="2" name="XR_KEYBOARD_TRACKING_QUERY_REMOTE_BIT_FB" comment="indicates the query is for the physically tracked keyboard that may be connected to a separate remote computing device. Mutally exclusive with XR_KEYBOARD_TRACKING_QUERY_LOCAL_BIT_FB."/>
    </enums>

    <!-- flags for XR_FB_space_warp -->
    <enums name="XrCompositionLayerSpaceWarpInfoFlagBitsFB" type="bitmask">
        <enum bitpos="0" name="XR_COMPOSITION_LAYER_SPACE_WARP_INFO_FRAME_SKIP_BIT_FB" comment="Skip current frame's space warp extrapolation"/>
    </enums>

    <!-- flags for XR_FB_render_model -->
    <enums name="XrRenderModelFlagBitsFB" type="bitmask">
        <enum bitpos="0" name="XR_RENDER_MODEL_SUPPORTS_GLTF_2_0_SUBSET_1_BIT_FB" comment="Minimal level of support.  Can only contain a single mesh.  Can only contain a single texture.  Can not contain transparency.  Assumes unlit rendering.  Requires Extension KHR_texturebasisu."/>
        <enum bitpos="1" name="XR_RENDER_MODEL_SUPPORTS_GLTF_2_0_SUBSET_2_BIT_FB" comment="All of XR_RENDER_MODEL_SUPPORTS_GLTF_2_0_SUBSET_1_BIT_FB support plus: Multiple meshes. Multiple Textures. Texture Transparency."/>
    </enums>

    <!-- enums for XR_HTC_facial_tracking -->
    <enums name="XrFacialTrackingTypeHTC" type="enum">
        <enum value="1"   name="XR_FACIAL_TRACKING_TYPE_EYE_DEFAULT_HTC" comment="Specifies this handle will observe eye expressions, with values indexed by elink:XrEyeExpressionHTC whose count is dlink:XR_FACIAL_EXPRESSION_EYE_COUNT_HTC."/>
        <enum value="2"   name="XR_FACIAL_TRACKING_TYPE_LIP_DEFAULT_HTC" comment="Specifies this handle will observe lip expressions, with values indexed by elink:XrLipExpressionHTC whose count is dlink:XR_FACIAL_EXPRESSION_LIP_COUNT_HTC."/>
    </enums>

    <!-- enums for XR_HTC_passthrough -->
    <enums name="XrPassthroughFormHTC" type="enum">
        <enum value="0"   name="XR_PASSTHROUGH_FORM_PLANAR_HTC"    comment="Presents the passthrough with full of the entire screen."/>
        <enum value="1"   name="XR_PASSTHROUGH_FORM_PROJECTED_HTC" comment="Presents the passthrough projecting onto a custom mesh."/>
    </enums>

    <enums name="XrEyeExpressionHTC" type="enum">
        <enum value="0"    name="XR_EYE_EXPRESSION_LEFT_BLINK_HTC"/>
        <enum value="1"    name="XR_EYE_EXPRESSION_LEFT_WIDE_HTC"/>
        <enum value="2"    name="XR_EYE_EXPRESSION_RIGHT_BLINK_HTC"/>
        <enum value="3"    name="XR_EYE_EXPRESSION_RIGHT_WIDE_HTC"/>
        <enum value="4"    name="XR_EYE_EXPRESSION_LEFT_SQUEEZE_HTC"/>
        <enum value="5"    name="XR_EYE_EXPRESSION_RIGHT_SQUEEZE_HTC"/>
        <enum value="6"    name="XR_EYE_EXPRESSION_LEFT_DOWN_HTC"/>
        <enum value="7"    name="XR_EYE_EXPRESSION_RIGHT_DOWN_HTC"/>
        <enum value="8"    name="XR_EYE_EXPRESSION_LEFT_OUT_HTC"/>
        <enum value="9"    name="XR_EYE_EXPRESSION_RIGHT_IN_HTC"/>
        <enum value="10"   name="XR_EYE_EXPRESSION_LEFT_IN_HTC"/>
        <enum value="11"   name="XR_EYE_EXPRESSION_RIGHT_OUT_HTC"/>
        <enum value="12"   name="XR_EYE_EXPRESSION_LEFT_UP_HTC"/>
        <enum value="13"   name="XR_EYE_EXPRESSION_RIGHT_UP_HTC"/>
    </enums>

    <enums name="XrLipExpressionHTC" type="enum">
        <enum value="0"    name="XR_LIP_EXPRESSION_JAW_RIGHT_HTC"/>
        <enum value="1"    name="XR_LIP_EXPRESSION_JAW_LEFT_HTC"/>
        <enum value="2"    name="XR_LIP_EXPRESSION_JAW_FORWARD_HTC"/>
        <enum value="3"    name="XR_LIP_EXPRESSION_JAW_OPEN_HTC"/>
        <enum value="4"    name="XR_LIP_EXPRESSION_MOUTH_APE_SHAPE_HTC"/>
        <enum value="5"    name="XR_LIP_EXPRESSION_MOUTH_UPPER_RIGHT_HTC"/>
        <enum value="6"    name="XR_LIP_EXPRESSION_MOUTH_UPPER_LEFT_HTC"/>
        <enum value="7"    name="XR_LIP_EXPRESSION_MOUTH_LOWER_RIGHT_HTC"/>
        <enum value="8"    name="XR_LIP_EXPRESSION_MOUTH_LOWER_LEFT_HTC"/>
        <enum value="9"    name="XR_LIP_EXPRESSION_MOUTH_UPPER_OVERTURN_HTC"/>
        <enum value="10"   name="XR_LIP_EXPRESSION_MOUTH_LOWER_OVERTURN_HTC"/>
        <enum value="11"   name="XR_LIP_EXPRESSION_MOUTH_POUT_HTC"/>
        <enum value="12"   name="XR_LIP_EXPRESSION_MOUTH_SMILE_RIGHT_HTC"/>
        <enum value="13"   name="XR_LIP_EXPRESSION_MOUTH_SMILE_LEFT_HTC"/>
        <enum value="14"   name="XR_LIP_EXPRESSION_MOUTH_SAD_RIGHT_HTC"/>
        <enum value="15"   name="XR_LIP_EXPRESSION_MOUTH_SAD_LEFT_HTC"/>
        <enum value="16"   name="XR_LIP_EXPRESSION_CHEEK_PUFF_RIGHT_HTC"/>
        <enum value="17"   name="XR_LIP_EXPRESSION_CHEEK_PUFF_LEFT_HTC"/>
        <enum value="18"   name="XR_LIP_EXPRESSION_CHEEK_SUCK_HTC"/>
        <enum value="19"   name="XR_LIP_EXPRESSION_MOUTH_UPPER_UPRIGHT_HTC"/>
        <enum value="20"   name="XR_LIP_EXPRESSION_MOUTH_UPPER_UPLEFT_HTC"/>
        <enum value="21"   name="XR_LIP_EXPRESSION_MOUTH_LOWER_DOWNRIGHT_HTC"/>
        <enum value="22"   name="XR_LIP_EXPRESSION_MOUTH_LOWER_DOWNLEFT_HTC"/>
        <enum value="23"   name="XR_LIP_EXPRESSION_MOUTH_UPPER_INSIDE_HTC"/>
        <enum value="24"   name="XR_LIP_EXPRESSION_MOUTH_LOWER_INSIDE_HTC"/>
        <enum value="25"   name="XR_LIP_EXPRESSION_MOUTH_LOWER_OVERLAY_HTC"/>
        <enum value="26"   name="XR_LIP_EXPRESSION_TONGUE_LONGSTEP1_HTC"/>
        <enum value="27"   name="XR_LIP_EXPRESSION_TONGUE_LEFT_HTC"/>
        <enum value="28"   name="XR_LIP_EXPRESSION_TONGUE_RIGHT_HTC"/>
        <enum value="29"   name="XR_LIP_EXPRESSION_TONGUE_UP_HTC"/>
        <enum value="30"   name="XR_LIP_EXPRESSION_TONGUE_DOWN_HTC"/>
        <enum value="31"   name="XR_LIP_EXPRESSION_TONGUE_ROLL_HTC"/>
        <enum value="32"   name="XR_LIP_EXPRESSION_TONGUE_LONGSTEP2_HTC"/>
        <enum value="33"   name="XR_LIP_EXPRESSION_TONGUE_UPRIGHT_MORPH_HTC"/>
        <enum value="34"   name="XR_LIP_EXPRESSION_TONGUE_UPLEFT_MORPH_HTC"/>
        <enum value="35"   name="XR_LIP_EXPRESSION_TONGUE_DOWNRIGHT_MORPH_HTC"/>
        <enum value="36"   name="XR_LIP_EXPRESSION_TONGUE_DOWNLEFT_MORPH_HTC"/>
    </enums>

    <!-- flags for XR_ALMALENCE_digital_lens_control -->
    <enums name="XrDigitalLensControlFlagBitsALMALENCE" type="bitmask">
        <enum bitpos="0" name="XR_DIGITAL_LENS_CONTROL_PROCESSING_DISABLE_BIT_ALMALENCE" comment="disables Digital Lens processing of render textures"/>
    </enums>

    <!-- flags for XR_FB_composition_layer_settings -->
    <enums name="XrCompositionLayerSettingsFlagBitsFB" type="bitmask">
        <enum bitpos="0" name="XR_COMPOSITION_LAYER_SETTINGS_NORMAL_SUPER_SAMPLING_BIT_FB"  comment="Indicates compositor may: use layer texture supersampling."/>
        <enum bitpos="1" name="XR_COMPOSITION_LAYER_SETTINGS_QUALITY_SUPER_SAMPLING_BIT_FB" comment="Indicates compositor may: use high quality layer texture supersampling."/>
        <enum bitpos="2" name="XR_COMPOSITION_LAYER_SETTINGS_NORMAL_SHARPENING_BIT_FB"      comment="Indicates compositor may: use layer texture sharpening."/>
        <enum bitpos="3" name="XR_COMPOSITION_LAYER_SETTINGS_QUALITY_SHARPENING_BIT_FB"     comment="Indicates compositor may: use high quality layer texture sharpening."/>
    </enums>

    <!-- flags for XR_META_performance_metrics -->
    <enums name="XrPerformanceMetricsCounterFlagBitsMETA" type="bitmask">
        <enum bitpos="0" name="XR_PERFORMANCE_METRICS_COUNTER_ANY_VALUE_VALID_BIT_META"   comment="Indicates any of the values in XrPerformanceMetricsCounterMETA is valid."/>
        <enum bitpos="1" name="XR_PERFORMANCE_METRICS_COUNTER_UINT_VALUE_VALID_BIT_META"  comment="Indicates the uintValue in XrPerformanceMetricsCounterMETA is valid."/>
        <enum bitpos="2" name="XR_PERFORMANCE_METRICS_COUNTER_FLOAT_VALUE_VALID_BIT_META" comment="Indicates the floatValue in XrPerformanceMetricsCounterMETA is valid."/>
    </enums>

    <enums name="XrPerformanceMetricsCounterUnitMETA" type="enum">
        <enum value="0"   name="XR_PERFORMANCE_METRICS_COUNTER_UNIT_GENERIC_META"      comment="the performance counter unit is generic (unspecified)."/>
        <enum value="1"   name="XR_PERFORMANCE_METRICS_COUNTER_UNIT_PERCENTAGE_META"   comment="the performance counter unit is percentage (%)."/>
        <enum value="2"   name="XR_PERFORMANCE_METRICS_COUNTER_UNIT_MILLISECONDS_META" comment="the performance counter unit is millisecond."/>
        <enum value="3"   name="XR_PERFORMANCE_METRICS_COUNTER_UNIT_BYTES_META"        comment="the performance counter unit is byte."/>
        <enum value="4"   name="XR_PERFORMANCE_METRICS_COUNTER_UNIT_HERTZ_META"        comment="the performance counter unit is hertz (Hz)."/>
    </enums>

    <!-- enums for XR_HTC_foveation -->
    <enums name="XrFoveationModeHTC" type="enum">
        <enum value="0"   name="XR_FOVEATION_MODE_DISABLE_HTC" comment="No foveation"/>
        <enum value="1"   name="XR_FOVEATION_MODE_FIXED_HTC"   comment="Apply system default setting with fixed clear FOV and periphery quality."/>
        <enum value="2"   name="XR_FOVEATION_MODE_DYNAMIC_HTC" comment="Allow system to set foveation dynamically according realtime system metric or other extensions."/>
        <enum value="3"   name="XR_FOVEATION_MODE_CUSTOM_HTC"  comment="Allow application to set foveation with desired clear FOV, periphery quality, and focal center offset."/>
    </enums>
    <enums name="XrFoveationDynamicFlagBitsHTC" type="bitmask">
        <enum bitpos="0" name="XR_FOVEATION_DYNAMIC_LEVEL_ENABLED_BIT_HTC"               comment="Allow system to set periphery pixel density dynamically."/>
        <enum bitpos="1" name="XR_FOVEATION_DYNAMIC_CLEAR_FOV_ENABLED_BIT_HTC"           comment="Allow system to set clear FOV degree dynamically."/>
        <enum bitpos="2" name="XR_FOVEATION_DYNAMIC_FOCAL_CENTER_OFFSET_ENABLED_BIT_HTC" comment="Allow system to set focal center offset dynamically."/>
    </enums>
    <enums name="XrFoveationLevelHTC" type="enum">
        <enum value="0"   name="XR_FOVEATION_LEVEL_NONE_HTC"   comment="No foveation"/>
        <enum value="1"   name="XR_FOVEATION_LEVEL_LOW_HTC"    comment="Light periphery pixel density drop and lower performance gain."/>
        <enum value="2"   name="XR_FOVEATION_LEVEL_MEDIUM_HTC" comment="Medium periphery pixel density drop and medium performance gain"/>
        <enum value="3"   name="XR_FOVEATION_LEVEL_HIGH_HTC"   comment="Heavy periphery pixel density drop and higher performance gain"/>
    </enums>


    <!-- SECTION: OpenXR command definitions -->
    <commands>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_OUT_OF_MEMORY">
            <proto><type>XrResult</type> <name>xrGetInstanceProcAddr</name></proto>
            <param optional="true"><type>XrInstance</type> <name>instance</name></param>
            <param len="null-terminated">const <type>char</type>* <name>name</name></param>
            <param><type>PFN_xrVoidFunction</type>* <name>function</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_SIZE_INSUFFICIENT">
            <proto><type>XrResult</type> <name>xrEnumerateApiLayerProperties</name></proto>
            <param optional="true"><type>uint32_t</type> <name>propertyCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>propertyCountOutput</name></param>
            <param optional="true" len="propertyCapacityInput"><type>XrApiLayerProperties</type>* <name>properties</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_SIZE_INSUFFICIENT,XR_ERROR_RUNTIME_UNAVAILABLE,XR_ERROR_API_LAYER_NOT_PRESENT">
            <proto><type>XrResult</type> <name>xrEnumerateInstanceExtensionProperties</name></proto>
            <param optional="true" len="null-terminated">const <type>char</type>* <name>layerName</name></param>
            <param optional="true"><type>uint32_t</type> <name>propertyCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>propertyCountOutput</name></param>
            <param optional="true" len="propertyCapacityInput"><type>XrExtensionProperties</type>* <name>properties</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_RUNTIME_UNAVAILABLE,XR_ERROR_NAME_INVALID,XR_ERROR_INITIALIZATION_FAILED,XR_ERROR_EXTENSION_NOT_PRESENT,XR_ERROR_API_VERSION_UNSUPPORTED,XR_ERROR_API_LAYER_NOT_PRESENT">
            <proto><type>XrResult</type> <name>xrCreateInstance</name></proto>
            <param>const <type>XrInstanceCreateInfo</type>* <name>createInfo</name></param>
            <param><type>XrInstance</type>* <name>instance</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_HANDLE_INVALID">
            <proto><type>XrResult</type> <name>xrDestroyInstance</name></proto>
            <param externsync="true_with_children"><type>XrInstance</type> <name>instance</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST">
            <proto><type>XrResult</type> <name>xrResultToString</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrResult</type> <name>value</name></param>
            <param><type>char</type> <name>buffer</name>[<enum>XR_MAX_RESULT_STRING_SIZE</enum>]</param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST">
            <proto><type>XrResult</type> <name>xrStructureTypeToString</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrStructureType</type> <name>value</name></param>
            <param><type>char</type> <name>buffer</name>[<enum>XR_MAX_STRUCTURE_NAME_SIZE</enum>]</param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST">
            <proto><type>XrResult</type> <name>xrGetInstanceProperties</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrInstanceProperties</type>* <name>instanceProperties</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_FORM_FACTOR_UNSUPPORTED,XR_ERROR_FORM_FACTOR_UNAVAILABLE">
            <proto><type>XrResult</type> <name>xrGetSystem</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param>const <type>XrSystemGetInfo</type>* <name>getInfo</name></param>
            <param><type>XrSystemId</type>* <name>systemId</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_SYSTEM_INVALID">
            <proto><type>XrResult</type> <name>xrGetSystemProperties</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrSystemId</type> <name>systemId</name></param>
            <param><type>XrSystemProperties</type>* <name>properties</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_SYSTEM_INVALID,XR_ERROR_INITIALIZATION_FAILED,XR_ERROR_GRAPHICS_REQUIREMENTS_CALL_MISSING,XR_ERROR_GRAPHICS_DEVICE_INVALID">
            <proto><type>XrResult</type> <name>xrCreateSession</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param>const <type>XrSessionCreateInfo</type>* <name>createInfo</name></param>
            <param><type>XrSession</type>* <name>session</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_HANDLE_INVALID">
            <proto><type>XrResult</type> <name>xrDestroySession</name></proto>
            <param externsync="true_with_children"><type>XrSession</type> <name>session</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_HANDLE_INVALID">
            <proto><type>XrResult</type> <name>xrDestroySpace</name></proto>
            <param externsync="true_with_children"><type>XrSpace</type> <name>space</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SIZE_INSUFFICIENT">
            <proto><type>XrResult</type> <name>xrEnumerateSwapchainFormats</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param optional="true"><type>uint32_t</type> <name>formatCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>formatCountOutput</name></param>
            <param optional="true" len="formatCapacityInput"><type>int64_t</type>* <name>formats</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_SWAPCHAIN_FORMAT_UNSUPPORTED,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrCreateSwapchain</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrSwapchainCreateInfo</type>* <name>createInfo</name></param>
            <param><type>XrSwapchain</type>* <name>swapchain</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_HANDLE_INVALID">
            <proto><type>XrResult</type> <name>xrDestroySwapchain</name></proto>
            <param externsync="true_with_children"><type>XrSwapchain</type> <name>swapchain</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SIZE_INSUFFICIENT">
            <proto><type>XrResult</type> <name>xrEnumerateSwapchainImages</name></proto>
            <param><type>XrSwapchain</type> <name>swapchain</name></param>
            <param optional="true"><type>uint32_t</type> <name>imageCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>imageCountOutput</name></param>
            <param optional="true" len="imageCapacityInput"><type>XrSwapchainImageBaseHeader</type>* <name>images</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_CALL_ORDER_INVALID">
            <proto><type>XrResult</type> <name>xrAcquireSwapchainImage</name></proto>
            <param><type>XrSwapchain</type>         <name>swapchain</name></param>
            <param optional="true">const <type>XrSwapchainImageAcquireInfo</type>* <name>acquireInfo</name></param>
            <param><type>uint32_t</type>* <name>index</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING,XR_TIMEOUT_EXPIRED" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_CALL_ORDER_INVALID">
            <proto><type>XrResult</type> <name>xrWaitSwapchainImage</name></proto>
            <param><type>XrSwapchain</type> <name>swapchain</name></param>
            <param>const <type>XrSwapchainImageWaitInfo</type>* <name>waitInfo</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_CALL_ORDER_INVALID">
            <proto><type>XrResult</type> <name>xrReleaseSwapchainImage</name></proto>
            <param><type>XrSwapchain</type>         <name>swapchain</name></param>
            <param optional="true">const <type>XrSwapchainImageReleaseInfo</type>* <name>releaseInfo</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_VIEW_CONFIGURATION_TYPE_UNSUPPORTED,XR_ERROR_SESSION_RUNNING,XR_ERROR_SESSION_NOT_READY">
            <proto><type>XrResult</type> <name>xrBeginSession</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrSessionBeginInfo</type>* <name>beginInfo</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SESSION_NOT_STOPPING,XR_ERROR_SESSION_NOT_RUNNING">
            <proto><type>XrResult</type> <name>xrEndSession</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SESSION_NOT_RUNNING">
            <proto><type>XrResult</type> <name>xrRequestExitSession</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SIZE_INSUFFICIENT">
            <proto><type>XrResult</type> <name>xrEnumerateReferenceSpaces</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param optional="true"><type>uint32_t</type> <name>spaceCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>spaceCountOutput</name></param>
            <param optional="true" len="spaceCapacityInput"><type>XrReferenceSpaceType</type>* <name>spaces</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_REFERENCE_SPACE_UNSUPPORTED,XR_ERROR_POSE_INVALID">
            <proto><type>XrResult</type> <name>xrCreateReferenceSpace</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrReferenceSpaceCreateInfo</type>* <name>createInfo</name></param>
            <param><type>XrSpace</type>* <name>space</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_POSE_INVALID,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID,XR_ERROR_ACTION_TYPE_MISMATCH">
            <proto><type>XrResult</type> <name>xrCreateActionSpace</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrActionSpaceCreateInfo</type>* <name>createInfo</name></param>
            <param><type>XrSpace</type>* <name>space</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_TIME_INVALID">
            <proto><type>XrResult</type> <name>xrLocateSpace</name></proto>
            <param><type>XrSpace</type> <name>space</name></param>
            <param><type>XrSpace</type> <name>baseSpace</name></param>
            <param><type>XrTime</type>   <name>time</name></param>
            <param><type>XrSpaceLocation</type>* <name>location</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SIZE_INSUFFICIENT,XR_ERROR_SYSTEM_INVALID">
            <proto><type>XrResult</type> <name>xrEnumerateViewConfigurations</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrSystemId</type> <name>systemId</name></param>
            <param optional="true"><type>uint32_t</type> <name>viewConfigurationTypeCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>viewConfigurationTypeCountOutput</name></param>
            <param optional="true" len="viewConfigurationTypeCapacityInput"><type>XrViewConfigurationType</type>* <name>viewConfigurationTypes</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SIZE_INSUFFICIENT,XR_ERROR_VIEW_CONFIGURATION_TYPE_UNSUPPORTED,XR_ERROR_SYSTEM_INVALID">
            <proto><type>XrResult</type> <name>xrEnumerateEnvironmentBlendModes</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrSystemId</type> <name>systemId</name></param>
            <param><type>XrViewConfigurationType</type> <name>viewConfigurationType</name></param>
            <param optional="true"><type>uint32_t</type> <name>environmentBlendModeCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>environmentBlendModeCountOutput</name></param>
            <param optional="true" len="environmentBlendModeCapacityInput"><type>XrEnvironmentBlendMode</type>* <name>environmentBlendModes</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_VIEW_CONFIGURATION_TYPE_UNSUPPORTED,XR_ERROR_SYSTEM_INVALID">
            <proto><type>XrResult</type> <name>xrGetViewConfigurationProperties</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrSystemId</type> <name>systemId</name></param>
            <param><type>XrViewConfigurationType</type> <name>viewConfigurationType</name></param>
            <param><type>XrViewConfigurationProperties</type>* <name>configurationProperties</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SIZE_INSUFFICIENT,XR_ERROR_VIEW_CONFIGURATION_TYPE_UNSUPPORTED,XR_ERROR_SYSTEM_INVALID">
            <proto><type>XrResult</type> <name>xrEnumerateViewConfigurationViews</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrSystemId</type> <name>systemId</name></param>
            <param><type>XrViewConfigurationType</type> <name>viewConfigurationType</name></param>
            <param optional="true"><type>uint32_t</type> <name>viewCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>viewCountOutput</name></param>
            <param optional="true" len="viewCapacityInput"><type>XrViewConfigurationView</type>* <name>views</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING,XR_FRAME_DISCARDED" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SESSION_NOT_RUNNING,XR_ERROR_CALL_ORDER_INVALID">
            <proto><type>XrResult</type> <name>xrBeginFrame</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param optional="true">const <type>XrFrameBeginInfo</type>* <name>frameBeginInfo</name></param>
            <implicitexternsyncparams>
                <param>the pname:session parameter by any other flink:xrBeginFrame or flink:xrEndFrame call</param>
            </implicitexternsyncparams>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SIZE_INSUFFICIENT,XR_ERROR_VIEW_CONFIGURATION_TYPE_UNSUPPORTED,XR_ERROR_TIME_INVALID">
            <proto><type>XrResult</type> <name>xrLocateViews</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrViewLocateInfo</type>* <name>viewLocateInfo</name></param>
            <param><type>XrViewState</type>* <name>viewState</name></param>
            <param optional="true"><type>uint32_t</type> <name>viewCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>viewCountOutput</name></param>
            <param optional="true" len="viewCapacityInput"><type>XrView</type>* <name>views</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_TIME_INVALID,XR_ERROR_SWAPCHAIN_RECT_INVALID,XR_ERROR_SESSION_NOT_RUNNING,XR_ERROR_POSE_INVALID,XR_ERROR_LAYER_LIMIT_EXCEEDED,XR_ERROR_LAYER_INVALID,XR_ERROR_ENVIRONMENT_BLEND_MODE_UNSUPPORTED,XR_ERROR_CALL_ORDER_INVALID">
            <proto><type>XrResult</type> <name>xrEndFrame</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrFrameEndInfo</type>* <name>frameEndInfo</name></param>
            <implicitexternsyncparams>
                <param>the pname:session parameter by any other flink:xrBeginFrame or flink:xrEndFrame call</param>
            </implicitexternsyncparams>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SESSION_NOT_RUNNING">
            <proto><type>XrResult</type> <name>xrWaitFrame</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param optional="true">const <type>XrFrameWaitInfo</type>* <name>frameWaitInfo</name></param>
            <param><type>XrFrameState</type>* <name>frameState</name></param>
            <implicitexternsyncparams>
                <param>the pname:session parameter by any other flink:xrWaitFrame call</param>
            </implicitexternsyncparams>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING,XR_SESSION_NOT_FOCUSED" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID,XR_ERROR_ACTION_TYPE_MISMATCH,XR_ERROR_ACTIONSET_NOT_ATTACHED">
            <proto><type>XrResult</type> <name>xrApplyHapticFeedback</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrHapticActionInfo</type>* <name>hapticActionInfo</name></param>
            <param>const <type>XrHapticBaseHeader</type>* <name>hapticFeedback</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING,XR_SESSION_NOT_FOCUSED" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID,XR_ERROR_ACTION_TYPE_MISMATCH,XR_ERROR_ACTIONSET_NOT_ATTACHED">
            <proto><type>XrResult</type> <name>xrStopHapticFeedback</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrHapticActionInfo</type>* <name>hapticActionInfo</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_EVENT_UNAVAILABLE" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST">
            <proto><type>XrResult</type> <name>xrPollEvent</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrEventDataBuffer</type>* <name>eventData</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_PATH_FORMAT_INVALID,XR_ERROR_PATH_COUNT_EXCEEDED">
            <proto><type>XrResult</type> <name>xrStringToPath</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param len="null-terminated">const <type>char</type>* <name>pathString</name></param>
            <param><type>XrPath</type>* <name>path</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SIZE_INSUFFICIENT,XR_ERROR_PATH_INVALID">
            <proto><type>XrResult</type> <name>xrPathToString</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrPath</type> <name>path</name></param>
            <param optional="true"><type>uint32_t</type> <name>bufferCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>bufferCountOutput</name></param>
            <param optional="true" len="bufferCapacityInput"><type>char</type>* <name>buffer</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING,XR_SPACE_BOUNDS_UNAVAILABLE" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_REFERENCE_SPACE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrGetReferenceSpaceBoundsRect</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrReferenceSpaceType</type> <name>referenceSpaceType</name></param>
            <param><type>XrExtent2Df</type>* <name>bounds</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_ANDROID_THREAD_SETTINGS_ID_INVALID_KHR,XR_ERROR_ANDROID_THREAD_SETTINGS_FAILURE_KHR">
            <proto><type>XrResult</type> <name>xrSetAndroidApplicationThreadKHR</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrAndroidThreadTypeKHR</type> <name>threadType</name></param>
            <param><type>uint32_t</type> <name>threadId</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED">
            <proto><type>XrResult</type> <name>xrCreateSwapchainAndroidSurfaceKHR</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrSwapchainCreateInfo</type>* <name>info</name></param>
            <param><type>XrSwapchain</type>* <name>swapchain</name></param>
            <param><type>jobject</type>* <name>surface</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID,XR_ERROR_ACTION_TYPE_MISMATCH,XR_ERROR_ACTIONSET_NOT_ATTACHED">
            <proto><type>XrResult</type> <name>xrGetActionStateBoolean</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrActionStateGetInfo</type>* <name>getInfo</name></param>
            <param><type>XrActionStateBoolean</type>* <name>state</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID,XR_ERROR_ACTION_TYPE_MISMATCH,XR_ERROR_ACTIONSET_NOT_ATTACHED">
            <proto><type>XrResult</type> <name>xrGetActionStateFloat</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrActionStateGetInfo</type>* <name>getInfo</name></param>
            <param><type>XrActionStateFloat</type>* <name>state</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID,XR_ERROR_ACTION_TYPE_MISMATCH,XR_ERROR_ACTIONSET_NOT_ATTACHED">
            <proto><type>XrResult</type> <name>xrGetActionStateVector2f</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrActionStateGetInfo</type>* <name>getInfo</name></param>
            <param><type>XrActionStateVector2f</type>* <name>state</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID,XR_ERROR_ACTION_TYPE_MISMATCH,XR_ERROR_ACTIONSET_NOT_ATTACHED">
            <proto><type>XrResult</type> <name>xrGetActionStatePose</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrActionStateGetInfo</type>* <name>getInfo</name></param>
            <param><type>XrActionStatePose</type>* <name>state</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_PATH_FORMAT_INVALID,XR_ERROR_NAME_INVALID,XR_ERROR_NAME_DUPLICATED,XR_ERROR_LOCALIZED_NAME_INVALID,XR_ERROR_LOCALIZED_NAME_DUPLICATED">
            <proto><type>XrResult</type> <name>xrCreateActionSet</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param>const <type>XrActionSetCreateInfo</type>* <name>createInfo</name></param>
            <param><type>XrActionSet</type>* <name>actionSet</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_HANDLE_INVALID">
            <proto><type>XrResult</type> <name>xrDestroyActionSet</name></proto>
            <param externsync="true_with_children"><type>XrActionSet</type> <name>actionSet</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID,XR_ERROR_PATH_FORMAT_INVALID,XR_ERROR_NAME_INVALID,XR_ERROR_NAME_DUPLICATED,XR_ERROR_LOCALIZED_NAME_INVALID,XR_ERROR_LOCALIZED_NAME_DUPLICATED,XR_ERROR_ACTIONSETS_ALREADY_ATTACHED">
            <proto><type>XrResult</type> <name>xrCreateAction</name></proto>
            <param><type>XrActionSet</type> <name>actionSet</name></param>
            <param>const <type>XrActionCreateInfo</type>* <name>createInfo</name></param>
            <param><type>XrAction</type>* <name>action</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_HANDLE_INVALID">
            <proto><type>XrResult</type> <name>xrDestroyAction</name></proto>
            <param externsync="true_with_children"><type>XrAction</type> <name>action</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID,XR_ERROR_ACTIONSETS_ALREADY_ATTACHED">
            <proto><type>XrResult</type> <name>xrSuggestInteractionProfileBindings</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param>const <type>XrInteractionProfileSuggestedBinding</type>* <name>suggestedBindings</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_ACTIONSETS_ALREADY_ATTACHED">
            <proto><type>XrResult</type> <name>xrAttachSessionActionSets</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrSessionActionSetsAttachInfo</type>* <name>attachInfo</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID,XR_ERROR_ACTIONSET_NOT_ATTACHED">
            <proto><type>XrResult</type> <name>xrGetCurrentInteractionProfile</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrPath</type> <name>topLevelUserPath</name></param>
            <param><type>XrInteractionProfileState</type>* <name>interactionProfile</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING,XR_SESSION_NOT_FOCUSED" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID,XR_ERROR_ACTIONSET_NOT_ATTACHED">
            <proto><type>XrResult</type> <name>xrSyncActions</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrActionsSyncInfo</type>* <name>syncInfo</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SIZE_INSUFFICIENT,XR_ERROR_PATH_INVALID,XR_ERROR_ACTIONSET_NOT_ATTACHED">
            <proto><type>XrResult</type> <name>xrEnumerateBoundSourcesForAction</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrBoundSourcesForActionEnumerateInfo</type>* <name>enumerateInfo</name></param>
            <param optional="true"><type>uint32_t</type> <name>sourceCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>sourceCountOutput</name></param>
            <param optional="true" len="sourceCapacityInput"><type>XrPath</type>* <name>sources</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SIZE_INSUFFICIENT,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID,XR_ERROR_ACTIONSET_NOT_ATTACHED">
            <proto><type>XrResult</type> <name>xrGetInputSourceLocalizedName</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrInputSourceLocalizedNameGetInfo</type>* <name>getInfo</name></param>
            <param optional="true"><type>uint32_t</type> <name>bufferCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>bufferCountOutput</name></param>
            <param optional="true" len="bufferCapacityInput"><type>char</type>* <name>buffer</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SIZE_INSUFFICIENT,XR_ERROR_SYSTEM_INVALID">
            <proto><type>XrResult</type> <name>xrGetVulkanInstanceExtensionsKHR</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrSystemId</type> <name>systemId</name></param>
            <param optional="true"><type>uint32_t</type> <name>bufferCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>bufferCountOutput</name></param>
            <param optional="true" len="bufferCapacityInput"><type>char</type>* <name>buffer</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SIZE_INSUFFICIENT,XR_ERROR_SYSTEM_INVALID">
            <proto><type>XrResult</type> <name>xrGetVulkanDeviceExtensionsKHR</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrSystemId</type> <name>systemId</name></param>
            <param optional="true"><type>uint32_t</type> <name>bufferCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>bufferCountOutput</name></param>
            <param optional="true" len="bufferCapacityInput"><type>char</type>* <name>buffer</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SYSTEM_INVALID">
            <proto><type>XrResult</type> <name>xrGetVulkanGraphicsDeviceKHR</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrSystemId</type> <name>systemId</name></param>
            <param><type>VkInstance</type> <name>vkInstance</name></param>
            <param><type>VkPhysicalDevice</type>* <name>vkPhysicalDevice</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SYSTEM_INVALID">
            <proto><type>XrResult</type> <name>xrGetOpenGLGraphicsRequirementsKHR</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrSystemId</type> <name>systemId</name></param>
            <param><type>XrGraphicsRequirementsOpenGLKHR</type>* <name>graphicsRequirements</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SYSTEM_INVALID">
            <proto><type>XrResult</type> <name>xrGetOpenGLESGraphicsRequirementsKHR</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrSystemId</type> <name>systemId</name></param>
            <param><type>XrGraphicsRequirementsOpenGLESKHR</type>* <name>graphicsRequirements</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SYSTEM_INVALID">
            <proto><type>XrResult</type> <name>xrGetVulkanGraphicsRequirementsKHR</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrSystemId</type> <name>systemId</name></param>
            <param><type>XrGraphicsRequirementsVulkanKHR</type>* <name>graphicsRequirements</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SYSTEM_INVALID">
            <proto><type>XrResult</type> <name>xrGetD3D11GraphicsRequirementsKHR</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrSystemId</type> <name>systemId</name></param>
            <param><type>XrGraphicsRequirementsD3D11KHR</type>* <name>graphicsRequirements</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SYSTEM_INVALID">
            <proto><type>XrResult</type> <name>xrGetD3D12GraphicsRequirementsKHR</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrSystemId</type> <name>systemId</name></param>
            <param><type>XrGraphicsRequirementsD3D12KHR</type>* <name>graphicsRequirements</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST">
            <proto><type>XrResult</type> <name>xrPerfSettingsSetPerformanceLevelEXT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrPerfSettingsDomainEXT</type> <name>domain</name></param>
            <param><type>XrPerfSettingsLevelEXT</type> <name>level</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST">
            <proto><type>XrResult</type> <name>xrThermalGetTemperatureTrendEXT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrPerfSettingsDomainEXT</type> <name>domain</name></param>
            <param><type>XrPerfSettingsNotificationLevelEXT</type>* <name>notificationLevel</name></param>
            <param><type>float</type>* <name>tempHeadroom</name></param>
            <param><type>float</type>* <name>tempSlope</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_OUT_OF_MEMORY">
            <proto><type>XrResult</type> <name>xrSetDebugUtilsObjectNameEXT</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param externsync="nameInfo.objectHandle">const <type>XrDebugUtilsObjectNameInfoEXT</type>* <name>nameInfo</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED">
            <proto><type>XrResult</type> <name>xrCreateDebugUtilsMessengerEXT</name></proto>
            <param externsync="true_with_children"><type>XrInstance</type> <name>instance</name></param>
            <param>const <type>XrDebugUtilsMessengerCreateInfoEXT</type>* <name>createInfo</name></param>
            <param><type>XrDebugUtilsMessengerEXT</type>* <name>messenger</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_HANDLE_INVALID">
            <proto><type>XrResult</type> <name>xrDestroyDebugUtilsMessengerEXT</name></proto>
            <param externsync="true"><type>XrDebugUtilsMessengerEXT</type> <name>messenger</name></param>
            <implicitexternsyncparams>
                <param>the slink:XrInstance used to create pname:messenger, and all of its child handles</param>
            </implicitexternsyncparams>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST">
            <proto><type>XrResult</type>                                    <name>xrSubmitDebugUtilsMessageEXT</name></proto>
            <param><type>XrInstance</type>                                  <name>instance</name></param>
            <param><type>XrDebugUtilsMessageSeverityFlagsEXT</type>         <name>messageSeverity</name></param>
            <param><type>XrDebugUtilsMessageTypeFlagsEXT</type>             <name>messageTypes</name></param>
            <param>const <type>XrDebugUtilsMessengerCallbackDataEXT</type>* <name>callbackData</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST">
            <proto><type>XrResult</type> <name>xrSessionBeginDebugUtilsLabelRegionEXT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrDebugUtilsLabelEXT</type>* <name>labelInfo</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST">
            <proto><type>XrResult</type> <name>xrSessionEndDebugUtilsLabelRegionEXT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST">
            <proto><type>XrResult</type> <name>xrSessionInsertDebugUtilsLabelEXT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrDebugUtilsLabelEXT</type>* <name>labelInfo</name></param>
        </command>

        <!-- commands for XR_KHR_win32_convert_performance_counter_time -->
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_TIME_INVALID">
            <proto><type>XrResult</type> <name>xrConvertTimeToWin32PerformanceCounterKHR</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrTime</type>   <name>time</name></param>
            <param><type>LARGE_INTEGER</type>* <name>performanceCounter</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_TIME_INVALID">
            <proto><type>XrResult</type> <name>xrConvertWin32PerformanceCounterToTimeKHR</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param>const <type>LARGE_INTEGER</type>* <name>performanceCounter</name></param>
            <param><type>XrTime</type>* <name>time</name></param>
        </command>

        <!-- commands for XR_KHR_vulkan_enable2 -->
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_SYSTEM_INVALID">
            <proto><type>XrResult</type> <name>xrCreateVulkanInstanceKHR</name></proto>
            <param><type>XrInstance</type>                           <name>instance</name></param>
            <param>const <type>XrVulkanInstanceCreateInfoKHR</type>* <name>createInfo</name></param>
            <param><type>VkInstance</type>*                          <name>vulkanInstance</name></param>
            <param><type>VkResult</type>*                            <name>vulkanResult</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_SYSTEM_INVALID">
            <proto><type>XrResult</type> <name>xrCreateVulkanDeviceKHR</name></proto>
            <param><type>XrInstance</type>                          <name>instance</name></param>
            <param>const <type>XrVulkanDeviceCreateInfoKHR</type>*  <name>createInfo</name></param>
            <param><type>VkDevice</type>*                           <name>vulkanDevice</name></param>
            <param><type>VkResult</type>*                           <name>vulkanResult</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SYSTEM_INVALID">
            <proto><type>XrResult</type> <name>xrGetVulkanGraphicsDevice2KHR</name></proto>
            <param><type>XrInstance</type>                              <name>instance</name></param>
            <param>const <type>XrVulkanGraphicsDeviceGetInfoKHR</type>* <name>getInfo</name></param>
            <param><type>VkPhysicalDevice</type>*                       <name>vulkanPhysicalDevice</name></param>
        </command>
        <command name="xrGetVulkanGraphicsRequirements2KHR" alias="xrGetVulkanGraphicsRequirementsKHR"/>

        <!-- commands for XR_KHR_convert_timespec_time -->
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_TIME_INVALID">
            <proto><type>XrResult</type> <name>xrConvertTimeToTimespecTimeKHR</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrTime</type>   <name>time</name></param>
            <param>struct <type>timespec</type>* <name>timespecTime</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_TIME_INVALID">
            <proto><type>XrResult</type> <name>xrConvertTimespecTimeToTimeKHR</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param>const struct <type>timespec</type>* <name>timespecTime</name></param>
            <param><type>XrTime</type>* <name>time</name></param>
        </command>

        <!-- commands for XR_KHR_visibility_mask -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SIZE_INSUFFICIENT,XR_ERROR_VIEW_CONFIGURATION_TYPE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrGetVisibilityMaskKHR</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrViewConfigurationType</type> <name>viewConfigurationType</name></param>
            <param><type>uint32_t</type> <name>viewIndex</name></param>
            <param><type>XrVisibilityMaskTypeKHR</type> <name>visibilityMaskType</name></param>
            <param><type>XrVisibilityMaskKHR</type>* <name>visibilityMask</name></param>
        </command>

        <!-- commands for XR_MSFT_spatial_anchor -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_TIME_INVALID,XR_ERROR_POSE_INVALID,XR_ERROR_CREATE_SPATIAL_ANCHOR_FAILED_MSFT">
            <proto><type>XrResult</type> <name>xrCreateSpatialAnchorMSFT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrSpatialAnchorCreateInfoMSFT</type>* <name>createInfo</name></param>
            <param><type>XrSpatialAnchorMSFT</type>* <name>anchor</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_POSE_INVALID">
            <proto><type>XrResult</type> <name>xrCreateSpatialAnchorSpaceMSFT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrSpatialAnchorSpaceCreateInfoMSFT</type>* <name>createInfo</name></param>
            <param><type>XrSpace</type>* <name>space</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_HANDLE_INVALID">
            <proto><type>XrResult</type> <name>xrDestroySpatialAnchorMSFT</name></proto>
            <param externsync="true_with_children"><type>XrSpatialAnchorMSFT</type> <name>anchor</name></param>
        </command>

        <!-- commands for XR_EXT_conformance_automation -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID">
            <proto><type>XrResult</type> <name>xrSetInputDeviceActiveEXT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrPath</type> <name>interactionProfile</name></param>
            <param><type>XrPath</type> <name>topLevelPath</name></param>
            <param><type>XrBool32</type> <name>isActive</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID">
            <proto><type>XrResult</type> <name>xrSetInputDeviceStateBoolEXT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrPath</type> <name>topLevelPath</name></param>
            <param><type>XrPath</type> <name>inputSourcePath</name></param>
            <param><type>XrBool32</type> <name>state</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID">
            <proto><type>XrResult</type> <name>xrSetInputDeviceStateFloatEXT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrPath</type> <name>topLevelPath</name></param>
            <param><type>XrPath</type> <name>inputSourcePath</name></param>
            <param><type>float</type> <name>state</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID">
            <proto><type>XrResult</type> <name>xrSetInputDeviceStateVector2fEXT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrPath</type> <name>topLevelPath</name></param>
            <param><type>XrPath</type> <name>inputSourcePath</name></param>
            <param><type>XrVector2f</type> <name>state</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_POSE_INVALID,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID">
            <proto><type>XrResult</type> <name>xrSetInputDeviceLocationEXT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrPath</type> <name>topLevelPath</name></param>
            <param><type>XrPath</type> <name>inputSourcePath</name></param>
            <param><type>XrSpace</type> <name>space</name></param>
            <param><type>XrPosef</type> <name>pose</name></param>
        </command>

        <!-- commands for XR_KHR_loader_init -->
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE">
            <proto><type>XrResult</type> <name>xrInitializeLoaderKHR</name></proto>
            <param>const <type>XrLoaderInitInfoBaseHeaderKHR</type>* <name>loaderInitInfo</name></param>
        </command>

        <!-- commands for XR_MSFT_spatial_graph_bridge -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_POSE_INVALID">
            <proto><type>XrResult</type> <name>xrCreateSpatialGraphNodeSpaceMSFT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrSpatialGraphNodeSpaceCreateInfoMSFT</type>* <name>createInfo</name></param>
            <param><type>XrSpace</type>* <name>space</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_TIME_INVALID,XR_ERROR_POSE_INVALID">
            <proto><type>XrResult</type> <name>xrTryCreateSpatialGraphStaticNodeBindingMSFT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrSpatialGraphStaticNodeBindingCreateInfoMSFT</type>* <name>createInfo</name></param>
            <param><type>XrSpatialGraphNodeBindingMSFT</type>* <name>nodeBinding</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_HANDLE_INVALID">
            <proto><type>XrResult</type> <name>xrDestroySpatialGraphNodeBindingMSFT</name></proto>
            <param externsync="true_with_children"><type>XrSpatialGraphNodeBindingMSFT</type> <name>nodeBinding</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY">
            <proto><type>XrResult</type> <name>xrGetSpatialGraphNodeBindingPropertiesMSFT</name></proto>
            <param><type>XrSpatialGraphNodeBindingMSFT</type> <name>nodeBinding</name></param>
            <param optional="true">const <type>XrSpatialGraphNodeBindingPropertiesGetInfoMSFT</type>* <name>getInfo</name></param>
            <param><type>XrSpatialGraphNodeBindingPropertiesMSFT</type>* <name>properties</name></param>
        </command>

        <!-- XR_EXT_hand_tracking -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrCreateHandTrackerEXT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrHandTrackerCreateInfoEXT</type>* <name>createInfo</name></param>
            <param><type>XrHandTrackerEXT</type>* <name>handTracker</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_HANDLE_INVALID">
            <proto><type>XrResult</type> <name>xrDestroyHandTrackerEXT</name></proto>
            <param externsync="true_with_children"><type>XrHandTrackerEXT</type> <name>handTracker</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_TIME_INVALID">
            <proto><type>XrResult</type> <name>xrLocateHandJointsEXT</name></proto>
            <param><type>XrHandTrackerEXT</type> <name>handTracker</name></param>
            <param>const <type>XrHandJointsLocateInfoEXT</type>* <name>locateInfo</name></param>
            <param><type>XrHandJointLocationsEXT</type>* <name>locations</name></param>
        </command>

        <!-- XR_MSFT_hand_tracking_mesh -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_POSE_INVALID,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrCreateHandMeshSpaceMSFT</name></proto>
            <param><type>XrHandTrackerEXT</type> <name>handTracker</name></param>
            <param>const <type>XrHandMeshSpaceCreateInfoMSFT</type>* <name>createInfo</name></param>
            <param><type>XrSpace</type>* <name>space</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SIZE_INSUFFICIENT,XR_ERROR_TIME_INVALID,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrUpdateHandMeshMSFT</name></proto>
            <param><type>XrHandTrackerEXT</type> <name>handTracker</name></param>
            <param>const <type>XrHandMeshUpdateInfoMSFT</type>* <name>updateInfo</name></param>
            <param><type>XrHandMeshMSFT</type>* <name>handMesh</name></param>
        </command>

        <!-- XR_MSFT_controller_model -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID,XR_ERROR_CONTROLLER_MODEL_KEY_INVALID_MSFT">
            <proto><type>XrResult</type> <name>xrGetControllerModelKeyMSFT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrPath</type> <name>topLevelUserPath</name></param>
            <param><type>XrControllerModelKeyStateMSFT</type>* <name>controllerModelKeyState</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_SIZE_INSUFFICIENT,XR_ERROR_CONTROLLER_MODEL_KEY_INVALID_MSFT">
            <proto><type>XrResult</type> <name>xrLoadControllerModelMSFT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrControllerModelKeyMSFT</type> <name>modelKey</name></param>
            <param optional="true"><type>uint32_t</type> <name>bufferCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>bufferCountOutput</name></param>
            <param optional="true" len="bufferCapacityInput"><type>uint8_t</type>* <name>buffer</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_CONTROLLER_MODEL_KEY_INVALID_MSFT">
            <proto><type>XrResult</type> <name>xrGetControllerModelPropertiesMSFT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrControllerModelKeyMSFT</type> <name>modelKey</name></param>
            <param><type>XrControllerModelPropertiesMSFT</type>* <name>properties</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_CONTROLLER_MODEL_KEY_INVALID_MSFT">
            <proto><type>XrResult</type> <name>xrGetControllerModelStateMSFT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrControllerModelKeyMSFT</type> <name>modelKey</name></param>
            <param><type>XrControllerModelStateMSFT</type>* <name>state</name></param>
        </command>

        <!-- XR_MSFT_scene_understanding -->
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_SIZE_INSUFFICIENT,XR_ERROR_SYSTEM_INVALID">
            <proto><type>XrResult</type> <name>xrEnumerateSceneComputeFeaturesMSFT</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrSystemId</type> <name>systemId</name></param>
            <param optional="true"><type>uint32_t</type> <name>featureCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>featureCountOutput</name></param>
            <param optional="true" len="featureCapacityInput"><type>XrSceneComputeFeatureMSFT</type>* <name>features</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED">
            <proto><type>XrResult</type> <name>xrCreateSceneObserverMSFT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param optional="true">const <type>XrSceneObserverCreateInfoMSFT</type>* <name>createInfo</name></param>
            <param><type>XrSceneObserverMSFT</type>* <name>sceneObserver</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_HANDLE_INVALID">
            <proto><type>XrResult</type> <name>xrDestroySceneObserverMSFT</name></proto>
            <param externsync="true_with_children"><type>XrSceneObserverMSFT</type> <name>sceneObserver</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_COMPUTE_NEW_SCENE_NOT_COMPLETED_MSFT">
            <proto><type>XrResult</type> <name>xrCreateSceneMSFT</name></proto>
            <param><type>XrSceneObserverMSFT</type> <name>sceneObserver</name></param>
            <param optional="true">const <type>XrSceneCreateInfoMSFT</type>* <name>createInfo</name></param>
            <param><type>XrSceneMSFT</type>* <name>scene</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_HANDLE_INVALID">
            <proto><type>XrResult</type> <name>xrDestroySceneMSFT</name></proto>
            <param externsync="true_with_children"><type>XrSceneMSFT</type> <name>scene</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_TIME_INVALID,XR_ERROR_SCENE_COMPUTE_FEATURE_INCOMPATIBLE_MSFT,XR_ERROR_SCENE_COMPUTE_CONSISTENCY_MISMATCH_MSFT,XR_ERROR_POSE_INVALID,XR_ERROR_COMPUTE_NEW_SCENE_NOT_COMPLETED_MSFT">
            <proto><type>XrResult</type> <name>xrComputeNewSceneMSFT</name></proto>
            <param><type>XrSceneObserverMSFT</type> <name>sceneObserver</name></param>
            <param>const <type>XrNewSceneComputeInfoMSFT</type>* <name>computeInfo</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY">
            <proto><type>XrResult</type> <name>xrGetSceneComputeStateMSFT</name></proto>
            <param><type>XrSceneObserverMSFT</type> <name>sceneObserver</name></param>
            <param><type>XrSceneComputeStateMSFT</type>* <name>state</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_SIZE_INSUFFICIENT,XR_ERROR_SCENE_COMPONENT_TYPE_MISMATCH_MSFT">
            <proto><type>XrResult</type> <name>xrGetSceneComponentsMSFT</name></proto>
            <param><type>XrSceneMSFT</type> <name>scene</name></param>
            <param>const <type>XrSceneComponentsGetInfoMSFT</type>* <name>getInfo</name></param>
            <param><type>XrSceneComponentsMSFT</type>* <name>components</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_SIZE_INSUFFICIENT,XR_ERROR_TIME_INVALID">
            <proto><type>XrResult</type> <name>xrLocateSceneComponentsMSFT</name></proto>
            <param><type>XrSceneMSFT</type> <name>scene</name></param>
            <param>const <type>XrSceneComponentsLocateInfoMSFT</type>* <name>locateInfo</name></param>
            <param><type>XrSceneComponentLocationsMSFT</type>* <name>locations</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_SCENE_MESH_BUFFER_ID_INVALID_MSFT,XR_ERROR_SCENE_COMPONENT_ID_INVALID_MSFT">
            <proto><type>XrResult</type> <name>xrGetSceneMeshBuffersMSFT</name></proto>
            <param><type>XrSceneMSFT</type> <name>scene</name></param>
            <param>const <type>XrSceneMeshBuffersGetInfoMSFT</type>* <name>getInfo</name></param>
            <param><type>XrSceneMeshBuffersMSFT</type>* <name>buffers</name></param>
        </command>

        <!-- XR_MSFT_scene_understanding_serialization -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_COMPUTE_NEW_SCENE_NOT_COMPLETED_MSFT">
            <proto><type>XrResult</type> <name>xrDeserializeSceneMSFT</name></proto>
            <param><type>XrSceneObserverMSFT</type> <name>sceneObserver</name></param>
            <param>const <type>XrSceneDeserializeInfoMSFT</type>* <name>deserializeInfo</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_SIZE_INSUFFICIENT,XR_ERROR_SCENE_COMPONENT_ID_INVALID_MSFT">
            <proto><type>XrResult</type> <name>xrGetSerializedSceneFragmentDataMSFT</name></proto>
            <param><type>XrSceneMSFT</type> <name>scene</name></param>
            <param>const <type>XrSerializedSceneFragmentDataGetInfoMSFT</type>* <name>getInfo</name></param>
            <param optional="true"><type>uint32_t</type> <name>countInput</name></param>
            <param><type>uint32_t</type>* <name>readOutput</name></param>
            <param optional="true" len="countInput"><type>uint8_t</type>* <name>buffer</name></param>
        </command>

        <!-- XR_FB_display_refresh_rate -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SIZE_INSUFFICIENT">
            <proto><type>XrResult</type> <name>xrEnumerateDisplayRefreshRatesFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param optional="true"><type>uint32_t</type> <name>displayRefreshRateCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>displayRefreshRateCountOutput</name></param>
            <param optional="true" len="displayRefreshRateCapacityInput"><type>float</type>* <name>displayRefreshRates</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST">
            <proto><type>XrResult</type> <name>xrGetDisplayRefreshRateFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>float</type>* <name>displayRefreshRate</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_FEATURE_UNSUPPORTED,XR_ERROR_DISPLAY_REFRESH_RATE_UNSUPPORTED_FB">
            <proto><type>XrResult</type> <name>xrRequestDisplayRefreshRateFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>float</type> <name>displayRefreshRate</name></param>
        </command>

        <!-- XR_MSFT_perception_anchor_interop -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED">
            <proto><type>XrResult</type> <name>xrCreateSpatialAnchorFromPerceptionAnchorMSFT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>IUnknown</type>* <name>perceptionAnchor</name></param>
            <param><type>XrSpatialAnchorMSFT</type>* <name>anchor</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY">
            <proto><type>XrResult</type> <name>xrTryGetPerceptionAnchorFromSpatialAnchorMSFT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrSpatialAnchorMSFT</type> <name>anchor</name></param>
            <param><type>IUnknown</type>** <name>perceptionAnchor</name></param>
        </command>

        <!-- XR_FB_swapchain_update_state -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST">
            <proto><type>XrResult</type> <name>xrUpdateSwapchainFB</name></proto>
            <param><type>XrSwapchain</type> <name>swapchain</name></param>
            <param>const <type>XrSwapchainStateBaseHeaderFB</type>* <name>state</name></param>
        </command>

        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST">
            <proto><type>XrResult</type> <name>xrGetSwapchainStateFB</name></proto>
            <param><type>XrSwapchain</type> <name>swapchain</name></param>
            <param><type>XrSwapchainStateBaseHeaderFB</type>* <name>state</name></param>
        </command>

        <!-- XR_FB_color_space -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SIZE_INSUFFICIENT">
            <proto><type>XrResult</type> <name>xrEnumerateColorSpacesFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param optional="true"><type>uint32_t</type> <name>colorSpaceCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>colorSpaceCountOutput</name></param>
            <param optional="true" len="colorSpaceCapacityInput"><type>XrColorSpaceFB</type>* <name>colorSpaces</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_FEATURE_UNSUPPORTED,XR_ERROR_COLOR_SPACE_UNSUPPORTED_FB">
            <proto><type>XrResult</type> <name>xrSetColorSpaceFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrColorSpaceFB</type> <name>colorspace</name></param>
        </command>

        <!-- XR_FB_foveation -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED">
            <proto><type>XrResult</type> <name>xrCreateFoveationProfileFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrFoveationProfileCreateInfoFB</type>* <name>createInfo</name></param>
            <param><type>XrFoveationProfileFB</type>* <name>profile</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID">
            <proto><type>XrResult</type> <name>xrDestroyFoveationProfileFB</name></proto>
            <param externsync="true_with_children"><type>XrFoveationProfileFB</type> <name>profile</name></param>
        </command>

        <!-- XR_FB_hand_tracking_mesh -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SIZE_INSUFFICIENT,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrGetHandMeshFB</name></proto>
            <param><type>XrHandTrackerEXT</type> <name>handTracker</name></param>
            <param><type>XrHandTrackingMeshFB</type>* <name>mesh</name></param>
        </command>

        <!-- XR_FB_render_model -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY">
            <proto><type>XrResult</type> <name>xrEnumerateRenderModelPathsFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param optional="true"><type>uint32_t</type> <name>pathCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>pathCountOutput</name></param>
            <param optional="true" len="pathCapacityInput"><type>XrRenderModelPathInfoFB</type>* <name>paths</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING,XR_RENDER_MODEL_UNAVAILABLE_FB" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID,XR_ERROR_CALL_ORDER_INVALID">
            <proto><type>XrResult</type> <name>xrGetRenderModelPropertiesFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrPath</type> <name>path</name></param>
            <param><type>XrRenderModelPropertiesFB</type>* <name>properties</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING,XR_RENDER_MODEL_UNAVAILABLE_FB" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_RENDER_MODEL_KEY_INVALID_FB">
            <proto><type>XrResult</type> <name>xrLoadRenderModelFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrRenderModelLoadInfoFB</type>* <name>info</name></param>
            <param><type>XrRenderModelBufferFB</type>* <name>buffer</name></param>
        </command>

        <!-- XR_FB_keyboard_tracking -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrQuerySystemTrackedKeyboardFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrKeyboardTrackingQueryFB</type>* <name>queryInfo</name></param>
            <param><type>XrKeyboardTrackingDescriptionFB</type>* <name>keyboard</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrCreateKeyboardSpaceFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrKeyboardSpaceCreateInfoFB</type>* <name>createInfo</name></param>
            <param><type>XrSpace</type>* <name>keyboardSpace</name></param>
        </command>

        <!-- commands for XR_VARJO_environment_depth_estimation -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrSetEnvironmentDepthEstimationVARJO</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrBool32</type> <name>enabled</name></param>
        </command>

        <!-- XR_MSFT_composition_layer_reprojection -->
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SIZE_INSUFFICIENT,XR_ERROR_VIEW_CONFIGURATION_TYPE_UNSUPPORTED,XR_ERROR_SYSTEM_INVALID">
            <proto><type>XrResult</type> <name>xrEnumerateReprojectionModesMSFT</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>XrSystemId</type> <name>systemId</name></param>
            <param><type>XrViewConfigurationType</type> <name>viewConfigurationType</name></param>
            <param optional="true"><type>uint32_t</type> <name>modeCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>modeCountOutput</name></param>
            <param optional="true" len="modeCapacityInput"><type>XrReprojectionModeMSFT</type>* <name>modes</name></param>
        </command>

        <!-- commands for XR_OCULUS_audio_device_guid -->
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrGetAudioOutputDeviceGuidOculus</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>wchar_t</type> <name>buffer</name>[<enum>XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS</enum>]</param>
        </command>

        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrGetAudioInputDeviceGuidOculus</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param><type>wchar_t</type> <name>buffer</name>[<enum>XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS</enum>]</param>
        </command>

        <!-- XR_FB_spatial_entity -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_TIME_INVALID,XR_ERROR_POSE_INVALID,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrCreateSpatialAnchorFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrSpatialAnchorCreateInfoFB</type>* <name>info</name></param>
            <param><type>XrAsyncRequestIdFB</type>* <name>requestId</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrGetSpaceUuidFB</name></proto>
            <param><type>XrSpace</type> <name>space</name></param>
            <param><type>XrUuidEXT</type>* <name>uuid</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrEnumerateSpaceSupportedComponentsFB</name></proto>
            <param><type>XrSpace</type> <name>space</name></param>
            <param optional="true"><type>uint32_t</type> <name>componentTypeCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>componentTypeCountOutput</name></param>
            <param optional="true" len="componentTypeCapacityInput"><type>XrSpaceComponentTypeFB</type>* <name>componentTypes</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SPACE_COMPONENT_STATUS_PENDING_FB,XR_ERROR_SPACE_COMPONENT_STATUS_ALREADY_SET_FB,XR_ERROR_SPACE_COMPONENT_NOT_SUPPORTED_FB,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrSetSpaceComponentStatusFB</name></proto>
            <param><type>XrSpace</type> <name>space</name></param>
            <param>const <type>XrSpaceComponentStatusSetInfoFB</type>* <name>info</name></param>
            <param><type>XrAsyncRequestIdFB</type>* <name>requestId</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SPACE_COMPONENT_NOT_SUPPORTED_FB,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrGetSpaceComponentStatusFB</name></proto>
            <param><type>XrSpace</type> <name>space</name></param>
            <param><type>XrSpaceComponentTypeFB</type> <name>componentType</name></param>
            <param><type>XrSpaceComponentStatusFB</type>* <name>status</name></param>
        </command>

        <!-- XR_FB_triangle_mesh -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_INSUFFICIENT_RESOURCES_PASSTHROUGH_FB,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrCreateTriangleMeshFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrTriangleMeshCreateInfoFB</type>* <name>createInfo</name></param>
            <param><type>XrTriangleMeshFB</type>* <name>outTriangleMesh</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrDestroyTriangleMeshFB</name></proto>
            <param externsync="true_with_children"><type>XrTriangleMeshFB</type> <name>mesh</name></param>
            <implicitexternsyncparams>
                <param>the buffers returned from calls to flink:xrTriangleMeshGetVertexBufferFB and flink:xrTriangleMeshGetIndexBufferFB on pname:mesh</param>
            </implicitexternsyncparams>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrTriangleMeshGetVertexBufferFB</name></proto>
            <param><type>XrTriangleMeshFB</type> <name>mesh</name></param>
            <param><type>XrVector3f</type>** <name>outVertexBuffer</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrTriangleMeshGetIndexBufferFB</name></proto>
            <param><type>XrTriangleMeshFB</type> <name>mesh</name></param>
            <param><type>uint32_t</type>** <name>outIndexBuffer</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_FEATURE_UNSUPPORTED,XR_ERROR_CALL_ORDER_INVALID">
            <proto><type>XrResult</type> <name>xrTriangleMeshBeginUpdateFB</name></proto>
            <param><type>XrTriangleMeshFB</type> <name>mesh</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_FEATURE_UNSUPPORTED,XR_ERROR_CALL_ORDER_INVALID">
            <proto><type>XrResult</type> <name>xrTriangleMeshEndUpdateFB</name></proto>
            <param><type>XrTriangleMeshFB</type> <name>mesh</name></param>
            <param><type>uint32_t</type> <name>vertexCount</name></param>
            <param><type>uint32_t</type> <name>triangleCount</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_FEATURE_UNSUPPORTED,XR_ERROR_CALL_ORDER_INVALID">
            <proto><type>XrResult</type> <name>xrTriangleMeshBeginVertexBufferUpdateFB</name></proto>
            <param><type>XrTriangleMeshFB</type> <name>mesh</name></param>
            <param><type>uint32_t</type>* <name>outVertexCount</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_FEATURE_UNSUPPORTED,XR_ERROR_CALL_ORDER_INVALID">
            <proto><type>XrResult</type> <name>xrTriangleMeshEndVertexBufferUpdateFB</name></proto>
            <param><type>XrTriangleMeshFB</type> <name>mesh</name></param>
        </command>

        <!-- XR_FB_passthrough -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_UNKNOWN_PASSTHROUGH_FB,XR_ERROR_NOT_PERMITTED_PASSTHROUGH_FB,XR_ERROR_FEATURE_UNSUPPORTED,XR_ERROR_FEATURE_ALREADY_CREATED_PASSTHROUGH_FB">
            <proto><type>XrResult</type> <name>xrCreatePassthroughFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrPassthroughCreateInfoFB</type>* <name>createInfo</name></param>
            <param><type>XrPassthroughFB</type>* <name>outPassthrough</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrDestroyPassthroughFB</name></proto>
            <param externsync="true_with_children"><type>XrPassthroughFB</type> <name>passthrough</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_UNEXPECTED_STATE_PASSTHROUGH_FB,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrPassthroughStartFB</name></proto>
            <param><type>XrPassthroughFB</type> <name>passthrough</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_UNEXPECTED_STATE_PASSTHROUGH_FB,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrPassthroughPauseFB</name></proto>
            <param><type>XrPassthroughFB</type> <name>passthrough</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_UNKNOWN_PASSTHROUGH_FB,XR_ERROR_INSUFFICIENT_RESOURCES_PASSTHROUGH_FB,XR_ERROR_FEATURE_UNSUPPORTED,XR_ERROR_FEATURE_REQUIRED_PASSTHROUGH_FB">
            <proto><type>XrResult</type> <name>xrCreatePassthroughLayerFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrPassthroughLayerCreateInfoFB</type>* <name>createInfo</name></param>
            <param><type>XrPassthroughLayerFB</type>* <name>outLayer</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrDestroyPassthroughLayerFB</name></proto>
            <param externsync="true_with_children"><type>XrPassthroughLayerFB</type> <name>layer</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_UNEXPECTED_STATE_PASSTHROUGH_FB,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrPassthroughLayerPauseFB</name></proto>
            <param><type>XrPassthroughLayerFB</type> <name>layer</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_UNEXPECTED_STATE_PASSTHROUGH_FB,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrPassthroughLayerResumeFB</name></proto>
            <param><type>XrPassthroughLayerFB</type> <name>layer</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrPassthroughLayerSetStyleFB</name></proto>
            <param><type>XrPassthroughLayerFB</type> <name>layer</name></param>
            <param>const <type>XrPassthroughStyleFB</type>* <name>style</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_POSE_INVALID,XR_ERROR_INSUFFICIENT_RESOURCES_PASSTHROUGH_FB,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrCreateGeometryInstanceFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrGeometryInstanceCreateInfoFB</type>* <name>createInfo</name></param>
            <param><type>XrGeometryInstanceFB</type>* <name>outGeometryInstance</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrDestroyGeometryInstanceFB</name></proto>
            <param externsync="true_with_children"><type>XrGeometryInstanceFB</type> <name>instance</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_TIME_INVALID,XR_ERROR_POSE_INVALID,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrGeometryInstanceSetTransformFB</name></proto>
            <param><type>XrGeometryInstanceFB</type> <name>instance</name></param>
            <param>const <type>XrGeometryInstanceTransformFB</type>* <name>transformation</name></param>
        </command>

        <!-- XR_FB_spatial_entity_query -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrQuerySpacesFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrSpaceQueryInfoBaseHeaderFB</type>* <name>info</name></param>
            <param><type>XrAsyncRequestIdFB</type>* <name>requestId</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrRetrieveSpaceQueryResultsFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrAsyncRequestIdFB</type> <name>requestId</name></param>
            <param><type>XrSpaceQueryResultsFB</type>* <name>results</name></param>
        </command>

        <!-- XR_FB_spatial_entity_storage -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SPACE_COMPONENT_NOT_ENABLED_FB,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrSaveSpaceFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrSpaceSaveInfoFB</type>* <name>info</name></param>
            <param><type>XrAsyncRequestIdFB</type>* <name>requestId</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SPACE_COMPONENT_NOT_ENABLED_FB,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrEraseSpaceFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrSpaceEraseInfoFB</type>* <name>info</name></param>
            <param><type>XrAsyncRequestIdFB</type>* <name>requestId</name></param>
        </command>

        <!-- XR_FB_spatial_entity_container -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SPACE_COMPONENT_NOT_ENABLED_FB,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrGetSpaceContainerFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrSpace</type> <name>space</name></param>
            <param><type>XrSpaceContainerFB</type>* <name>spaceContainerOutput</name></param>
        </command>

        <!-- XR_FB_scene -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SPACE_COMPONENT_NOT_ENABLED_FB,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrGetSpaceBoundingBox2DFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrSpace</type> <name>space</name></param>
            <param><type>XrRect2Df</type>* <name>boundingBox2DOutput</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SPACE_COMPONENT_NOT_ENABLED_FB,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrGetSpaceBoundingBox3DFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrSpace</type> <name>space</name></param>
            <param><type>XrRect3DfFB</type>* <name>boundingBox3DOutput</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SPACE_COMPONENT_NOT_ENABLED_FB,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrGetSpaceSemanticLabelsFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrSpace</type> <name>space</name></param>
            <param><type>XrSemanticLabelsFB</type>* <name>semanticLabelsOutput</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SPACE_COMPONENT_NOT_ENABLED_FB,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrGetSpaceBoundary2DFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrSpace</type> <name>space</name></param>
            <param><type>XrBoundary2DFB</type>* <name>boundary2DOutput</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_SPACE_COMPONENT_NOT_ENABLED_FB,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrGetSpaceRoomLayoutFB</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrSpace</type> <name>space</name></param>
            <param><type>XrRoomLayoutFB</type>* <name>roomLayoutOutput</name></param>
        </command>

        <!-- XR_FB_passthrough_keyboard_hands -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrPassthroughLayerSetKeyboardHandsIntensityFB</name></proto>
            <param><type>XrPassthroughLayerFB</type> <name>layer</name></param>
            <param>const <type>XrPassthroughKeyboardHandsIntensityFB</type>* <name>intensity</name></param>
        </command>

        <!-- XR_MSFT_spatial_anchor_persistence -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED">
            <proto><type>XrResult</type> <name>xrCreateSpatialAnchorStoreConnectionMSFT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrSpatialAnchorStoreConnectionMSFT</type>* <name>spatialAnchorStore</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_HANDLE_INVALID,XR_ERROR_OUT_OF_MEMORY">
            <proto><type>XrResult</type> <name>xrDestroySpatialAnchorStoreConnectionMSFT</name></proto>
            <param externsync="true_with_children"><type>XrSpatialAnchorStoreConnectionMSFT</type> <name>spatialAnchorStore</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_SPATIAL_ANCHOR_NAME_INVALID_MSFT">
            <proto><type>XrResult</type> <name>xrPersistSpatialAnchorMSFT</name></proto>
            <param><type>XrSpatialAnchorStoreConnectionMSFT</type> <name>spatialAnchorStore</name></param>
            <param>const <type>XrSpatialAnchorPersistenceInfoMSFT</type>* <name>spatialAnchorPersistenceInfo</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_SIZE_INSUFFICIENT">
            <proto><type>XrResult</type> <name>xrEnumeratePersistedSpatialAnchorNamesMSFT</name></proto>
            <param><type>XrSpatialAnchorStoreConnectionMSFT</type> <name>spatialAnchorStore</name></param>
            <param optional="true"><type>uint32_t</type> <name>spatialAnchorNamesCapacityInput</name></param>
            <param optional="true"><type>uint32_t</type>* <name>spatialAnchorNamesCountOutput</name></param>
            <param optional="true" len="spatialAnchorNamesCapacityInput"><type>XrSpatialAnchorPersistenceNameMSFT</type>* <name>persistedAnchorNames</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_SPATIAL_ANCHOR_NAME_NOT_FOUND_MSFT,XR_ERROR_SPATIAL_ANCHOR_NAME_INVALID_MSFT">
            <proto><type>XrResult</type> <name>xrCreateSpatialAnchorFromPersistedNameMSFT</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT</type>* <name>spatialAnchorCreateInfo</name></param>
            <param><type>XrSpatialAnchorMSFT</type>* <name>spatialAnchor</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_SPATIAL_ANCHOR_NAME_NOT_FOUND_MSFT,XR_ERROR_SPATIAL_ANCHOR_NAME_INVALID_MSFT">
            <proto><type>XrResult</type> <name>xrUnpersistSpatialAnchorMSFT</name></proto>
            <param><type>XrSpatialAnchorStoreConnectionMSFT</type>        <name>spatialAnchorStore</name></param>
            <param>const <type>XrSpatialAnchorPersistenceNameMSFT</type>* <name>spatialAnchorPersistenceName</name></param>
        </command>
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY">
            <proto><type>XrResult</type> <name>xrClearSpatialAnchorStoreMSFT</name></proto>
            <param><type>XrSpatialAnchorStoreConnectionMSFT</type> <name>spatialAnchorStore</name></param>
        </command>

        <!-- XR_HTC_facial_tracking -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrCreateFacialTrackerHTC</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrFacialTrackerCreateInfoHTC</type>* <name>createInfo</name></param>
            <param><type>XrFacialTrackerHTC</type>* <name>facialTracker</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_HANDLE_INVALID">
            <proto><type>XrResult</type> <name>xrDestroyFacialTrackerHTC</name></proto>
            <param externsync="true_with_children"><type>XrFacialTrackerHTC</type> <name>facialTracker</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_TIME_INVALID">
            <proto><type>XrResult</type> <name>xrGetFacialExpressionsHTC</name></proto>
            <param><type>XrFacialTrackerHTC</type> <name>facialTracker</name></param>
            <param><type>XrFacialExpressionsHTC</type>* <name>facialExpressions</name></param>
        </command>

        <!-- XR_HTC_passthrough -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrCreatePassthroughHTC</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrPassthroughCreateInfoHTC</type>* <name>createInfo</name></param>
            <param><type>XrPassthroughHTC</type>* <name>passthrough</name></param>
        </command>
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID">
            <proto><type>XrResult</type> <name>xrDestroyPassthroughHTC</name></proto>
            <param externsync="true_with_children"><type>XrPassthroughHTC</type> <name>passthrough</name></param>
        </command>

        <!-- XR_HTCX_vive_tracker_interaction -->
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SIZE_INSUFFICIENT">
            <proto><type>XrResult</type> <name>xrEnumerateViveTrackerPathsHTCX</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param optional="true"><type>uint32_t</type> <name>pathCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>pathCountOutput</name></param>
            <param optional="true" len="pathCapacityInput"><type>XrViveTrackerPathsHTCX</type>* <name>paths</name></param>
        </command>

        <!-- commands for XR_VARJO_marker_tracking -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type>  <name>xrSetMarkerTrackingVARJO</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrBool32</type>  <name>enabled</name></param>
        </command>

        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_MARKER_ID_INVALID_VARJO,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrSetMarkerTrackingTimeoutVARJO</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>uint64_t</type> <name>markerId</name></param>
            <param><type>XrDuration</type> <name>timeout</name></param>
        </command>

        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_MARKER_ID_INVALID_VARJO,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrSetMarkerTrackingPredictionVARJO</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>uint64_t</type> <name>markerId</name></param>
            <param><type>XrBool32</type> <name>enabled</name></param>
        </command>

        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_MARKER_NOT_TRACKED_VARJO,XR_ERROR_MARKER_ID_INVALID_VARJO,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrGetMarkerSizeVARJO</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>uint64_t</type> <name>markerId</name></param>
            <param><type>XrExtent2Df</type>* <name>size</name></param>
        </command>

        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_OUT_OF_MEMORY,XR_ERROR_LIMIT_REACHED,XR_ERROR_POSE_INVALID,XR_ERROR_MARKER_ID_INVALID_VARJO,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type> <name>xrCreateMarkerSpaceVARJO</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrMarkerSpaceCreateInfoVARJO</type>* <name>createInfo</name></param>
            <param><type>XrSpace</type>* <name>space</name></param>
        </command>

        <!-- commands for XR_ALMALENCE_digital_lens_control -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST">
            <proto><type>XrResult</type> <name>xrSetDigitalLensControlALMALENCE</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrDigitalLensControlALMALENCE</type>* <name>digitalLensControl</name></param>
        </command>

        <!-- commands for XR_VARJO_view_offset -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_FEATURE_UNSUPPORTED">
            <proto><type>XrResult</type>  <name>xrSetViewOffsetVARJO</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>float</type> <name>offset</name></param>
        </command>

        <!-- commands for XR_META_performance_metrics -->
        <command successcodes="XR_SUCCESS" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SIZE_INSUFFICIENT">
            <proto><type>XrResult</type> <name>xrEnumeratePerformanceMetricsCounterPathsMETA</name></proto>
            <param><type>XrInstance</type> <name>instance</name></param>
            <param optional="true"><type>uint32_t</type> <name>counterPathCapacityInput</name></param>
            <param><type>uint32_t</type>* <name>counterPathCountOutput</name></param>
            <param optional="true" len="counterPathCapacityInput"><type>XrPath</type>* <name>counterPaths</name></param>
        </command>

        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST">
            <proto><type>XrResult</type> <name>xrSetPerformanceMetricsStateMETA</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrPerformanceMetricsStateMETA</type>* <name>state</name></param>
        </command>

        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST">
            <proto><type>XrResult</type> <name>xrGetPerformanceMetricsStateMETA</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrPerformanceMetricsStateMETA</type>* <name>state</name></param>
        </command>

        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_PATH_UNSUPPORTED,XR_ERROR_PATH_INVALID">
            <proto><type>XrResult</type> <name>xrQueryPerformanceMetricsCounterMETA</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param><type>XrPath</type> <name>counterPath</name></param>
            <param><type>XrPerformanceMetricsCounterMETA</type>* <name>counter</name></param>
        </command>

        <!-- commands for XR_HTC_foveation -->
        <command successcodes="XR_SUCCESS,XR_SESSION_LOSS_PENDING" errorcodes="XR_ERROR_FUNCTION_UNSUPPORTED,XR_ERROR_VALIDATION_FAILURE,XR_ERROR_RUNTIME_FAILURE,XR_ERROR_HANDLE_INVALID,XR_ERROR_INSTANCE_LOST,XR_ERROR_SESSION_LOST,XR_ERROR_LIMIT_REACHED">
            <proto><type>XrResult</type> <name>xrApplyFoveationHTC</name></proto>
            <param><type>XrSession</type> <name>session</name></param>
            <param>const <type>XrFoveationApplyInfoHTC</type>* <name>applyInfo</name></param>
        </command>

    </commands>

    <!-- SECTION: OpenXR API interface definitions -->
    <!--
        Note: Only explicitly specify types if they are not
        referenced by a function or another type. (For example,
        if they're expected to be in a next chain.)
        Types referenced by functions are included automatically.
    -->

    <feature api="openxr" name="XR_VERSION_1_0" number="1.0">
        <require comment="Header boilerplate">
            <type name="openxr_platform_defines"/>
        </require>
        <require comment="API version">
            <type name="XR_CURRENT_API_VERSION"/>
            <type name="XR_VERSION_MAJOR"/>
            <type name="XR_VERSION_MINOR"/>
            <type name="XR_VERSION_PATCH"/>
            <type name="XrVersion"/>
        </require>
        <require comment="API constants">
            <enum name="XR_TRUE"/>
            <enum name="XR_FALSE"/>
            <enum name="XR_MAX_EXTENSION_NAME_SIZE"/>
            <enum name="XR_MAX_API_LAYER_NAME_SIZE"/>
            <enum name="XR_MAX_API_LAYER_DESCRIPTION_SIZE"/>
            <enum name="XR_MAX_SYSTEM_NAME_SIZE"/>
            <enum name="XR_MAX_APPLICATION_NAME_SIZE"/>
            <enum name="XR_MAX_ENGINE_NAME_SIZE"/>
            <enum name="XR_MAX_RUNTIME_NAME_SIZE"/>
            <enum name="XR_MAX_PATH_LENGTH"/>
            <enum name="XR_MAX_STRUCTURE_NAME_SIZE"/>
            <enum name="XR_MAX_RESULT_STRING_SIZE"/>
            <type name="XR_MIN_COMPOSITION_LAYERS_SUPPORTED"/>
            <type name="XR_NULL_HANDLE"/>
            <type name="XR_NULL_SYSTEM_ID"/>
            <type name="XR_NULL_PATH"/>
            <type name="XR_SUCCEEDED"/>
            <type name="XR_FAILED"/>
            <type name="XR_UNQUALIFIED_SUCCESS"/>
            <type name="XR_NO_DURATION"/>
            <type name="XR_INFINITE_DURATION"/>
            <type name="XR_MIN_HAPTIC_DURATION"/>
            <type name="XR_FREQUENCY_UNSPECIFIED"/>
            <type name="XR_MAX_EVENT_DATA_SIZE"/>
        </require>
        <require comment="API macros">
            <type name="XR_MAY_ALIAS"/>
            <type name="XR_DEFINE_HANDLE"/>
        </require>
        <require comment="Instance">
            <command name="xrGetInstanceProcAddr"/>
            <command name="xrEnumerateApiLayerProperties"/>
            <command name="xrEnumerateInstanceExtensionProperties"/>
            <command name="xrCreateInstance"/>
            <command name="xrDestroyInstance"/>
            <command name="xrGetInstanceProperties"/>
            <command name="xrPollEvent"/>
            <command name="xrResultToString"/>
            <command name="xrStructureTypeToString"/>
        </require>
        <require comment="Device">
            <command name="xrGetSystem"/>
            <command name="xrGetSystemProperties"/>
            <command name="xrEnumerateEnvironmentBlendModes"/>
            <command name="xrCreateSession"/>
            <command name="xrDestroySession"/>
        </require>
        <require comment="Space">
            <command name="xrEnumerateReferenceSpaces"/>
            <command name="xrCreateReferenceSpace"/>
            <command name="xrGetReferenceSpaceBoundsRect"/>
            <command name="xrCreateActionSpace"/>
            <command name="xrLocateSpace"/>
            <command name="xrDestroySpace"/>
            <type    name="XrSpaceVelocity"/>
        </require>
        <require comment="ViewConfigurations">
            <command name="xrEnumerateViewConfigurations"/>
            <command name="xrGetViewConfigurationProperties"/>
            <command name="xrEnumerateViewConfigurationViews"/>
        </require>
        <require comment="Image">
            <command name="xrEnumerateSwapchainFormats"/>
            <command name="xrCreateSwapchain"/>
            <command name="xrDestroySwapchain"/>
            <command name="xrEnumerateSwapchainImages"/>
            <command name="xrAcquireSwapchainImage"/>
            <command name="xrWaitSwapchainImage"/>
            <command name="xrReleaseSwapchainImage"/>
        </require>
        <require comment="Session">
            <command name="xrBeginSession"/>
            <command name="xrEndSession"/>
            <command name="xrRequestExitSession"/>
        </require>
        <require comment="Display Timing">
            <command name="xrWaitFrame"/>
            <command name="xrBeginFrame"/>
            <command name="xrEndFrame"/>
            <command name="xrLocateViews"/>
        </require>
        <require comment="Semantic Paths">
            <command name="xrStringToPath"/>
            <command name="xrPathToString"/>
        </require>
        <require comment="Input">
            <command name="xrCreateActionSet"/>
            <command name="xrDestroyActionSet"/>
            <command name="xrCreateAction"/>
            <command name="xrDestroyAction"/>
            <command name="xrSuggestInteractionProfileBindings"/>
            <command name="xrAttachSessionActionSets"/>
            <command name="xrGetCurrentInteractionProfile"/>
            <command name="xrGetActionStateBoolean"/>
            <command name="xrGetActionStateFloat"/>
            <command name="xrGetActionStateVector2f"/>
            <command name="xrGetActionStatePose"/>
            <command name="xrSyncActions"/>
            <command name="xrEnumerateBoundSourcesForAction"/>
            <command name="xrGetInputSourceLocalizedName"/>
        </require>
        <require comment="Haptics">
            <command name="xrApplyHapticFeedback"/>
            <command name="xrStopHapticFeedback"/>
        </require>
        <require comment="Types not directly used by the API">
            <!-- Include <type name="typename"/> here for e.g. structs that
                 are not parameter types of functions, but still need to be
                 defined in the API.
             -->

            <!-- Utility types to handle polymorphism -->
            <type name="XrBaseInStructure"/>
            <type name="XrBaseOutStructure"/>

            <!-- Composition layer types used polymorphically by the core spec through XrCompositionLayerBaseHeader. -->
            <type name="XrCompositionLayerProjection"/>
            <type name="XrCompositionLayerQuad"/>

            <!-- Event data types used polymorphically by the core spec through XrEventDataBaseHeader -->
            <type name="XrEventDataBaseHeader"/>
            <type name="XrEventDataEventsLost"/>
            <type name="XrEventDataInstanceLossPending"/>
            <type name="XrEventDataSessionStateChanged"/>
            <type name="XrEventDataReferenceSpaceChangePending"/>
            <type name="XrEventDataInteractionProfileChanged"/>

            <!-- Haptic data type used polymorphically by the core spec via XrHapticBaseHeader -->
            <type name="XrHapticVibration"/>

            <!-- Unused, but documented types, included for completeness and regularity. -->
            <type name="XrOffset2Df"/>
            <type name="XrRect2Df"/>
            <type name="XrVector4f"/>


            <!-- Core-like basic data types, documented in core spec, though currently only used by KHR extensions: -->

            <!-- used in XR_KHR_composition_layer_color_scale_bias -->
            <type name="XrColor4f"/>
            <!-- used in XR_KHR_space bounds -->
            <type name="XrExtent2Df"/>
            <!-- used in XR_EXT_debug_utils -->
            <type name="XrObjectType"/>
        </require>
    </feature>

    <!-- SECTION: OpenXR extension interface definitions -->
    <extensions>
    <!-- Android Thread Settings extension -->
    <extension name="XR_KHR_android_thread_settings" number="4" type="instance" supported="openxr" protect="XR_USE_PLATFORM_ANDROID">
        <require>
            <enum value="5" name="XR_KHR_android_thread_settings_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_android_thread_settings&quot;" name="XR_KHR_ANDROID_THREAD_SETTINGS_EXTENSION_NAME"/>
            <enum offset="0" extends="XrResult" dir="-" name="XR_ERROR_ANDROID_THREAD_SETTINGS_ID_INVALID_KHR" comment="xrSetAndroidApplicationThreadKHR failed as thread id is invalid."/>
            <enum offset="1" extends="XrResult" dir="-" name="XR_ERROR_ANDROID_THREAD_SETTINGS_FAILURE_KHR" comment="xrSetAndroidApplicationThreadKHR failed setting the thread attributes/priority."/>
            <type name="XrAndroidThreadTypeKHR"/>
            <command name="xrSetAndroidApplicationThreadKHR"/>
        </require>
    </extension>

    <!-- Android Surface Swapchain extension -->
    <extension name="XR_KHR_android_surface_swapchain" number="5" type="instance" supported="openxr" protect="XR_USE_PLATFORM_ANDROID">
        <require>
            <enum value="4" name="XR_KHR_android_surface_swapchain_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_android_surface_swapchain&quot;" name="XR_KHR_ANDROID_SURFACE_SWAPCHAIN_EXTENSION_NAME"/>
            <command name="xrCreateSwapchainAndroidSurfaceKHR"/>
        </require>
    </extension>

    <!-- Non-core composition cube layer -->
    <extension name="XR_KHR_composition_layer_cube" number="7" type="instance" supported="openxr">
        <require>
            <enum value="8" name="XR_KHR_composition_layer_cube_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_composition_layer_cube&quot;" name="XR_KHR_COMPOSITION_LAYER_CUBE_EXTENSION_NAME"/>
            <type name="XrCompositionLayerCubeKHR"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_COMPOSITION_LAYER_CUBE_KHR"/>
        </require>
    </extension>

    <!-- Android Create Instance extension -->
    <extension name="XR_KHR_android_create_instance" number="9" type="instance" supported="openxr" protect="XR_USE_PLATFORM_ANDROID">
        <require>
            <enum value="3" name="XR_KHR_android_create_instance_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_android_create_instance&quot;" name="XR_KHR_ANDROID_CREATE_INSTANCE_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR"/>
            <type name="XrInstanceCreateInfoAndroidKHR"/>
        </require>
    </extension>

    <!-- Runtime support for additional per-layer depth info -->
    <extension name="XR_KHR_composition_layer_depth" number="11" type="instance" supported="openxr">
        <require>
            <enum value="6" name="XR_KHR_composition_layer_depth_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_composition_layer_depth&quot;" name="XR_KHR_COMPOSITION_LAYER_DEPTH_EXTENSION_NAME"/>
            <type name="XrCompositionLayerDepthInfoKHR"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_COMPOSITION_LAYER_DEPTH_INFO_KHR"/>
        </require>
    </extension>

    <!-- Reserved for headless "graphics binding" extension -->
    <extension name="XR_KHR_headless" number="14" type="instance" supported="disabled">
        <require>
            <enum value="4" name="XR_KHR_headless_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_headless&quot;" name="XR_KHR_HEADLESS_EXTENSION_NAME"/>
        </require>
    </extension>


    <!-- Vulkan image format list extension -->
    <extension name="XR_KHR_vulkan_swapchain_format_list" number="15" type="instance" requires="XR_KHR_vulkan_enable" supported="openxr" protect="XR_USE_GRAPHICS_API_VULKAN">
        <require>
            <enum value="4" name="XR_KHR_vulkan_swapchain_format_list_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_vulkan_swapchain_format_list&quot;" name="XR_KHR_VULKAN_SWAPCHAIN_FORMAT_LIST_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_VULKAN_SWAPCHAIN_FORMAT_LIST_CREATE_INFO_KHR"/>
            <type name="XrVulkanSwapchainFormatListCreateInfoKHR"/>
        </require>
    </extension>

    <!-- Performance Settings extension -->
    <extension name="XR_EXT_performance_settings" number="16" type="instance" supported="openxr">
        <require>
            <enum value="4" name="XR_EXT_performance_settings_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_performance_settings&quot;" name="XR_EXT_PERFORMANCE_SETTINGS_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_EVENT_DATA_PERF_SETTINGS_EXT"/>
            <type name="XrPerfSettingsDomainEXT"/>
            <type name="XrPerfSettingsSubDomainEXT"/>
            <type name="XrPerfSettingsLevelEXT"/>
            <type name="XrPerfSettingsNotificationLevelEXT"/>
            <type name="XrEventDataPerfSettingsEXT"/>
            <command name="xrPerfSettingsSetPerformanceLevelEXT"/>
        </require>
    </extension>

    <!-- Thermal Query extension -->
    <extension name="XR_EXT_thermal_query" number="17" type="instance" supported="openxr">
        <require>
            <enum value="2" name="XR_EXT_thermal_query_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_thermal_query&quot;" name="XR_EXT_THERMAL_QUERY_EXTENSION_NAME"/>
            <type name="XrPerfSettingsDomainEXT"/>
            <type name="XrPerfSettingsNotificationLevelEXT"/>
            <command name="xrThermalGetTemperatureTrendEXT"/>
        </require>
    </extension>

    <!-- Non-core composition cylinder layer -->
    <extension name="XR_KHR_composition_layer_cylinder" number="18" type="instance" supported="openxr">
        <require>
            <enum value="4" name="XR_KHR_composition_layer_cylinder_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_composition_layer_cylinder&quot;" name="XR_KHR_COMPOSITION_LAYER_CYLINDER_EXTENSION_NAME"/>
            <type name="XrCompositionLayerCylinderKHR"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR"/>
        </require>
    </extension>

    <!-- Non-core composition equilateral rect layer -->
    <extension name="XR_KHR_composition_layer_equirect" number="19" type="instance" supported="openxr">
        <require>
            <enum value="3" name="XR_KHR_composition_layer_equirect_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_composition_layer_equirect&quot;" name="XR_KHR_COMPOSITION_LAYER_EQUIRECT_EXTENSION_NAME"/>
            <type name="XrCompositionLayerEquirectKHR"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR"/>
        </require>
    </extension>

    <!-- Debug Utilities extension -->
    <extension name="XR_EXT_debug_utils" number="20" type="instance" supported="openxr">
        <require>
            <enum value="4"                                name="XR_EXT_debug_utils_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_debug_utils&quot;"   name="XR_EXT_DEBUG_UTILS_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType"     name="XR_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT"/>
            <enum offset="1" extends="XrStructureType"     name="XR_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT"/>
            <enum offset="2" extends="XrStructureType"     name="XR_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT"/>
            <enum offset="3" extends="XrStructureType"     name="XR_TYPE_DEBUG_UTILS_LABEL_EXT"/>
            <enum offset="0" extends="XrObjectType"        name="XR_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT"  comment="XrDebugUtilsMessengerEXT"/>
            <type name="PFN_xrDebugUtilsMessengerCallbackEXT"/>
            <type name="XrDebugUtilsObjectNameInfoEXT"/>
            <type name="XrDebugUtilsLabelEXT"/>
            <type name="XrDebugUtilsMessengerCallbackDataEXT"/>
            <type name="XrDebugUtilsMessengerCreateInfoEXT"/>
            <command name="xrSetDebugUtilsObjectNameEXT"/>
            <command name="xrCreateDebugUtilsMessengerEXT"/>
            <command name="xrDestroyDebugUtilsMessengerEXT"/>
            <command name="xrSubmitDebugUtilsMessageEXT"/>
            <command name="xrSessionBeginDebugUtilsLabelRegionEXT"/>
            <command name="xrSessionEndDebugUtilsLabelRegionEXT"/>
            <command name="xrSessionInsertDebugUtilsLabelEXT"/>
        </require>
    </extension>

    <!-- Reserved space for Variable rate rendering extension -->
    <extension name="XR_KHR_variable_rate_rendering" number="21" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_KHR_variable_rate_rendering_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_variable_rate_rendering&quot;" name="XR_KHR_VARIABLE_RATE_RENDERING_EXTENSION_NAME"/>
        </require>
    </extension>

    <!-- Reserved space for Overlays extension -->
    <extension name="XR_KHR_overlays" number="22" type="instance" supported="disabled">
        <require>
            <enum value="0" name="XR_KHR_overlays_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_overlays&quot;" name="XR_KHR_OVERLAYS_EXTENSION_NAME"/>
        </require>
    </extension>

    <!-- OpenGL graphics binding extension -->
    <extension name="XR_KHR_opengl_enable" number="24" type="instance" protect="XR_USE_GRAPHICS_API_OPENGL" supported="openxr">
        <require>
            <enum value="10" name="XR_KHR_opengl_enable_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_opengl_enable&quot;" name="XR_KHR_OPENGL_ENABLE_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType"     name="XR_TYPE_GRAPHICS_BINDING_OPENGL_WIN32_KHR"/>
            <enum offset="1" extends="XrStructureType"     name="XR_TYPE_GRAPHICS_BINDING_OPENGL_XLIB_KHR"/>
            <enum offset="2" extends="XrStructureType"     name="XR_TYPE_GRAPHICS_BINDING_OPENGL_XCB_KHR"/>
            <enum offset="3" extends="XrStructureType"     name="XR_TYPE_GRAPHICS_BINDING_OPENGL_WAYLAND_KHR"/>
            <enum offset="4" extends="XrStructureType"     name="XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR"/>
            <enum offset="5" extends="XrStructureType"     name="XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_KHR"/>
            <type name="XrGraphicsBindingOpenGLWin32KHR"/>
            <type name="XrGraphicsBindingOpenGLXlibKHR"/>
            <type name="XrGraphicsBindingOpenGLXcbKHR"/>
            <type name="XrGraphicsBindingOpenGLWaylandKHR"/>
            <type name="XrSwapchainImageOpenGLKHR"/>
            <type name="XrGraphicsRequirementsOpenGLKHR"/>
            <command name="xrGetOpenGLGraphicsRequirementsKHR"/>
        </require>
    </extension>

    <!-- OpenGL ES graphics binding extension -->
    <extension name="XR_KHR_opengl_es_enable" number="25" type="instance" protect="XR_USE_GRAPHICS_API_OPENGL_ES" supported="openxr">
        <require>
            <enum value="8" name="XR_KHR_opengl_es_enable_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_opengl_es_enable&quot;" name="XR_KHR_OPENGL_ES_ENABLE_EXTENSION_NAME"/>
            <enum offset="1" extends="XrStructureType"        name="XR_TYPE_GRAPHICS_BINDING_OPENGL_ES_ANDROID_KHR"/>
            <enum offset="2" extends="XrStructureType"        name="XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_ES_KHR"/>
            <enum offset="3" extends="XrStructureType"        name="XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_ES_KHR"/>
            <type name="XrGraphicsBindingOpenGLESAndroidKHR"/>
            <type name="XrSwapchainImageOpenGLESKHR"/>
            <type name="XrGraphicsRequirementsOpenGLESKHR"/>
            <command name="xrGetOpenGLESGraphicsRequirementsKHR"/>
        </require>
    </extension>

    <!-- Vulkan graphics binding extension -->
    <extension name="XR_KHR_vulkan_enable" number="26" type="instance" protect="XR_USE_GRAPHICS_API_VULKAN" supported="openxr">
        <require>
            <enum value="8" name="XR_KHR_vulkan_enable_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_vulkan_enable&quot;" name="XR_KHR_VULKAN_ENABLE_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType"     name="XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR"/>
            <enum offset="1" extends="XrStructureType"     name="XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR"/>
            <enum offset="2" extends="XrStructureType"     name="XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN_KHR"/>
            <type name="XrGraphicsBindingVulkanKHR"/>
            <type name="XrSwapchainImageVulkanKHR"/>
            <type name="XrGraphicsRequirementsVulkanKHR"/>
            <command name="xrGetVulkanInstanceExtensionsKHR"/>
            <command name="xrGetVulkanDeviceExtensionsKHR"/>
            <command name="xrGetVulkanGraphicsDeviceKHR"/>
            <command name="xrGetVulkanGraphicsRequirementsKHR"/>
        </require>
    </extension>

    <!-- Value used by obsolete D3D10 graphics binding extension -->
    <extension name="XR_KHR_D3D10_enable_obsolete" number="27" type="instance" supported="disabled">
        <require>
            <enum value="4" name="XR_KHR_D3D10_enable_obsolete_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_D3D10_enable_obsolete&quot;" name="XR_KHR_D3D10_ENABLE_OBSOLETE_EXTENSION_NAME"/>
        </require>
    </extension>

    <!-- D3D11 graphics binding extension -->
    <extension name="XR_KHR_D3D11_enable" number="28" type="instance" protect="XR_USE_GRAPHICS_API_D3D11" supported="openxr">
        <require>
            <enum value="9" name="XR_KHR_D3D11_enable_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_D3D11_enable&quot;" name="XR_KHR_D3D11_ENABLE_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType"    name="XR_TYPE_GRAPHICS_BINDING_D3D11_KHR"/>
            <enum offset="1" extends="XrStructureType"    name="XR_TYPE_SWAPCHAIN_IMAGE_D3D11_KHR"/>
            <enum offset="2" extends="XrStructureType"    name="XR_TYPE_GRAPHICS_REQUIREMENTS_D3D11_KHR"/>
            <type name="XrGraphicsBindingD3D11KHR"/>
            <type name="XrSwapchainImageD3D11KHR"/>
            <type name="XrGraphicsRequirementsD3D11KHR"/>
            <command name="xrGetD3D11GraphicsRequirementsKHR"/>
        </require>
    </extension>

    <!-- D3D12 graphics binding extension -->
    <extension name="XR_KHR_D3D12_enable" number="29" type="instance" protect="XR_USE_GRAPHICS_API_D3D12" supported="openxr">
        <require>
            <enum value="9" name="XR_KHR_D3D12_enable_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_D3D12_enable&quot;" name="XR_KHR_D3D12_ENABLE_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType"    name="XR_TYPE_GRAPHICS_BINDING_D3D12_KHR"/>
            <enum offset="1" extends="XrStructureType"    name="XR_TYPE_SWAPCHAIN_IMAGE_D3D12_KHR"/>
            <enum offset="2" extends="XrStructureType"    name="XR_TYPE_GRAPHICS_REQUIREMENTS_D3D12_KHR"/>
            <type name="XrGraphicsBindingD3D12KHR"/>
            <type name="XrSwapchainImageD3D12KHR"/>
            <type name="XrGraphicsRequirementsD3D12KHR"/>
            <command name="xrGetD3D12GraphicsRequirementsKHR"/>
        </require>
    </extension>

    <!-- Reserved space for Enable Metal extension -->
    <extension name="XR_KHR_metal_enable" number="30" type="instance" protect="XR_USE_GRAPHICS_API_METAL" supported="disabled">
        <require>
            <enum value="1" name="XR_KHR_metal_enable_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_metal_enable&quot;" name="XR_KHR_METAL_ENABLE_EXTENSION_NAME"/>
        </require>
    </extension>

    <!-- Eye gaze interaction extension -->
    <extension name="XR_EXT_eye_gaze_interaction" number="31" type="instance" supported="openxr">
        <require>
            <enum value="2" name="XR_EXT_eye_gaze_interaction_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_eye_gaze_interaction&quot;" name="XR_EXT_EYE_GAZE_INTERACTION_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_SYSTEM_EYE_GAZE_INTERACTION_PROPERTIES_EXT"/>
            <enum offset="1" extends="XrStructureType" name="XR_TYPE_EYE_GAZE_SAMPLE_TIME_EXT"/>
            <type name="XrSystemEyeGazeInteractionPropertiesEXT"/>
            <type name="XrEyeGazeSampleTimeEXT"/>
        </require>
    </extension>

    <!-- Visibility mask extension -->
    <extension name="XR_KHR_visibility_mask" number="32" type="instance" supported="openxr">
        <require>
            <enum value="2" name="XR_KHR_visibility_mask_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_visibility_mask&quot;" name="XR_KHR_VISIBILITY_MASK_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_VISIBILITY_MASK_KHR"/>
            <enum offset="1" extends="XrStructureType" name="XR_TYPE_EVENT_DATA_VISIBILITY_MASK_CHANGED_KHR"/>
            <type name="XrVisibilityMaskTypeKHR"/>
            <type name="XrVisibilityMaskKHR"/>
            <type name="XrEventDataVisibilityMaskChangedKHR"/>
            <command name="xrGetVisibilityMaskKHR"/>
        </require>
    </extension>

    <!-- Reserved space for EXT permissions support -->
    <extension name="XR_EXT_permissions_support" number="33" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_EXT_permissions_support_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_permissions_support&quot;" name="XR_EXT_PERMISSIONS_SUPPORT_EXTENSION_NAME"/>
        </require>
    </extension>

    <!-- Overlay preview extension -->
    <extension name="XR_EXTX_overlay" number="34" type="instance" provisional="true" supported="openxr">
        <require>
            <enum value="5" name="XR_EXTX_overlay_SPEC_VERSION"/>
            <enum value="&quot;XR_EXTX_overlay&quot;"  name="XR_EXTX_OVERLAY_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_SESSION_CREATE_INFO_OVERLAY_EXTX"/>
            <enum offset="3" extends="XrStructureType" name="XR_TYPE_EVENT_DATA_MAIN_SESSION_VISIBILITY_CHANGED_EXTX"/>
            <type name="XrSessionCreateInfoOverlayEXTX"/>
            <type name="XrEventDataMainSessionVisibilityChangedEXTX"/>
        </require>
    </extension>


    <!-- per-layer color scale and bias -->
    <extension name="XR_KHR_composition_layer_color_scale_bias" number="35" type="instance" supported="openxr">
        <require>
            <enum value="5" name="XR_KHR_composition_layer_color_scale_bias_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_composition_layer_color_scale_bias&quot;" name="XR_KHR_COMPOSITION_LAYER_COLOR_SCALE_BIAS_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_COMPOSITION_LAYER_COLOR_SCALE_BIAS_KHR"/>
            <type name="XrCompositionLayerColorScaleBiasKHR"/>
        </require>
    </extension>

    <extension name="XR_KHR_win32_convert_performance_counter_time" number="36" type="instance" supported="openxr" protect="XR_USE_PLATFORM_WIN32">
        <require>
            <enum value="1" name="XR_KHR_win32_convert_performance_counter_time_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_win32_convert_performance_counter_time&quot;" name="XR_KHR_WIN32_CONVERT_PERFORMANCE_COUNTER_TIME_EXTENSION_NAME"/>
            <command name="xrConvertWin32PerformanceCounterToTimeKHR"/>
            <command name="xrConvertTimeToWin32PerformanceCounterKHR"/>
        </require>
    </extension>

    <extension name="XR_KHR_convert_timespec_time" number="37" type="instance" supported="openxr" protect="XR_USE_TIMESPEC">
        <require>
            <enum value="1" name="XR_KHR_convert_timespec_time_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_convert_timespec_time&quot;" name="XR_KHR_CONVERT_TIMESPEC_TIME_EXTENSION_NAME"/>
            <command name="xrConvertTimespecTimeToTimeKHR"/>
            <command name="xrConvertTimeToTimespecTimeKHR"/>
        </require>
    </extension>

    <extension name="XR_VARJO_quad_views" number="38" type="instance" supported="openxr">
        <require>
            <enum value="1" name="XR_VARJO_quad_views_SPEC_VERSION"/>
            <enum value="&quot;XR_VARJO_quad_views&quot;" name="XR_VARJO_QUAD_VIEWS_EXTENSION_NAME"/>
            <enum offset="0" extends="XrViewConfigurationType" name="XR_VIEW_CONFIGURATION_TYPE_PRIMARY_QUAD_VARJO"/>
        </require>
    </extension>

    <extension name="XR_MSFT_unbounded_reference_space" number="39" type="instance" supported="openxr">
        <require>
            <enum value="1" name="XR_MSFT_unbounded_reference_space_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_unbounded_reference_space&quot;" name="XR_MSFT_UNBOUNDED_REFERENCE_SPACE_EXTENSION_NAME"/>

            <enum offset="0" extends="XrReferenceSpaceType" name="XR_REFERENCE_SPACE_TYPE_UNBOUNDED_MSFT"/>
        </require>
    </extension>

    <extension name="XR_MSFT_spatial_anchor" number="40" type="instance" supported="openxr">
        <require>
            <enum value="2" name="XR_MSFT_spatial_anchor_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_spatial_anchor&quot;" name="XR_MSFT_SPATIAL_ANCHOR_EXTENSION_NAME"/>

            <enum offset="0" extends="XrStructureType" name="XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_MSFT"/>
            <enum offset="1" extends="XrStructureType" name="XR_TYPE_SPATIAL_ANCHOR_SPACE_CREATE_INFO_MSFT"/>
            <command name="xrCreateSpatialAnchorMSFT"/>
            <command name="xrCreateSpatialAnchorSpaceMSFT"/>
            <command name="xrDestroySpatialAnchorMSFT"/>
            <enum offset="0" extends="XrObjectType" name="XR_OBJECT_TYPE_SPATIAL_ANCHOR_MSFT" comment="XrSpatialAnchorMSFT"/>
            <enum offset="1" dir="-" extends="XrResult" name="XR_ERROR_CREATE_SPATIAL_ANCHOR_FAILED_MSFT" comment="Spatial anchor could not be created at that location."/>
        </require>
    </extension>

    <extension name="XR_FB_composition_layer_image_layout" number="41" type="instance" supported="openxr">
        <require>
            <enum value="1"                                                name="XR_FB_composition_layer_image_layout_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_composition_layer_image_layout&quot;" name="XR_FB_COMPOSITION_LAYER_IMAGE_LAYOUT_EXTENSION_NAME"/>
            <type name="XrCompositionLayerImageLayoutFB"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_COMPOSITION_LAYER_IMAGE_LAYOUT_FB"/>
        </require>
    </extension>

    <extension name="XR_FB_composition_layer_alpha_blend" number="42" type="instance" supported="openxr">
        <require>
            <enum value="2"                                               name="XR_FB_composition_layer_alpha_blend_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_composition_layer_alpha_blend&quot;" name="XR_FB_COMPOSITION_LAYER_ALPHA_BLEND_EXTENSION_NAME"/>
            <type name="XrBlendFactorFB"/>
            <type name="XrCompositionLayerAlphaBlendFB"/>
            <enum offset="1" extends="XrStructureType" name="XR_TYPE_COMPOSITION_LAYER_ALPHA_BLEND_FB"/>
        </require>
    </extension>

    <extension name="XR_MND_headless" number="43" type="instance" supported="openxr">
        <require>
            <enum value="2" name="XR_MND_headless_SPEC_VERSION"/>
            <enum value="&quot;XR_MND_headless&quot;" name="XR_MND_HEADLESS_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_OCULUS_extension_44" number="44" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_OCULUS_extension_44_SPEC_VERSION"/>
            <enum value="&quot;XR_OCULUS_extension_44&quot;" name="XR_OCULUS_EXTENSION_44_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_OCULUS_android_session_state_enable" number="45" type="instance" supported="openxr">
        <require>
            <enum value="1" name="XR_OCULUS_android_session_state_enable_SPEC_VERSION"/>
            <enum value="&quot;XR_OCULUS_android_session_state_enable&quot;" name="XR_OCULUS_ANDROID_SESSION_STATE_ENABLE_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MND_extension_46" number="46" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_MND_extension_46_SPEC_VERSION"/>
            <enum value="&quot;XR_MND_extension_46&quot;" name="XR_MND_EXTENSION_46_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_EXT_view_configuration_depth_range" number="47" type="instance" supported="openxr">
        <require>
            <enum value="1" name="XR_EXT_view_configuration_depth_range_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_view_configuration_depth_range&quot;" name="XR_EXT_VIEW_CONFIGURATION_DEPTH_RANGE_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_VIEW_CONFIGURATION_DEPTH_RANGE_EXT"/>
            <type name="XrViewConfigurationDepthRangeEXT"/>
        </require>
    </extension>

    <extension name="XR_EXT_conformance_automation" number="48" type="instance" supported="openxr">
        <require>
            <enum value="3" name="XR_EXT_conformance_automation_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_conformance_automation&quot;" name="XR_EXT_CONFORMANCE_AUTOMATION_EXTENSION_NAME"/>
            <command name="xrSetInputDeviceActiveEXT"/>
            <command name="xrSetInputDeviceStateBoolEXT"/>
            <command name="xrSetInputDeviceStateFloatEXT"/>
            <command name="xrSetInputDeviceStateVector2fEXT"/>
            <command name="xrSetInputDeviceLocationEXT"/>
        </require>
    </extension>

    <extension name="XR_MNDX_egl_enable" number="49" type="instance" provisional="true" protect="XR_USE_PLATFORM_EGL" supported="openxr">
        <require>
            <enum value="1" name="XR_MNDX_egl_enable_SPEC_VERSION"/>
            <enum value="&quot;XR_MNDX_egl_enable&quot;" name="XR_MNDX_EGL_ENABLE_EXTENSION_NAME"/>
            <enum offset="4" extends="XrStructureType" name="XR_TYPE_GRAPHICS_BINDING_EGL_MNDX"/>
            <type name="XrGraphicsBindingEGLMNDX"/>
        </require>
    </extension>

    <extension name="XR_MSFT_spatial_graph_bridge" number="50" type="instance" supported="openxr">
        <require>
            <enum value="2"                                        name="XR_MSFT_spatial_graph_bridge_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_spatial_graph_bridge&quot;" name="XR_MSFT_SPATIAL_GRAPH_BRIDGE_EXTENSION_NAME"/>
            <type name="XrSpatialGraphNodeTypeMSFT"/>
            <type name="XrSpatialGraphNodeSpaceCreateInfoMSFT"/>
            <type name="XrSpatialGraphStaticNodeBindingCreateInfoMSFT"/>
            <type name="XrSpatialGraphNodeBindingPropertiesGetInfoMSFT"/>
            <type name="XrSpatialGraphNodeBindingPropertiesMSFT"/>
            <command name="xrCreateSpatialGraphNodeSpaceMSFT"/>
            <command name="xrTryCreateSpatialGraphStaticNodeBindingMSFT"/>
            <command name="xrDestroySpatialGraphNodeBindingMSFT"/>
            <command name="xrGetSpatialGraphNodeBindingPropertiesMSFT"/>
            <enum value="16"                           name="XR_GUID_SIZE_MSFT"/>
            <enum offset="0" extends="XrObjectType"    name="XR_OBJECT_TYPE_SPATIAL_GRAPH_NODE_BINDING_MSFT"              comment="XrSpatialGraphNodeBindingMSFT"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_SPATIAL_GRAPH_NODE_SPACE_CREATE_INFO_MSFT"/>
            <enum offset="1" extends="XrStructureType" name="XR_TYPE_SPATIAL_GRAPH_STATIC_NODE_BINDING_CREATE_INFO_MSFT"/>
            <enum offset="2" extends="XrStructureType" name="XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_GET_INFO_MSFT"/>
            <enum offset="3" extends="XrStructureType" name="XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_MSFT"/>
        </require>
    </extension>

    <extension name="XR_MSFT_hand_interaction" number="51" type="instance" supported="openxr">
        <require>
            <enum value="1" name="XR_MSFT_hand_interaction_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_hand_interaction&quot;" name="XR_MSFT_HAND_INTERACTION_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_EXT_hand_tracking" number="52" type="instance" supported="openxr">
        <require>
            <enum value="4" name="XR_EXT_hand_tracking_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_hand_tracking&quot;" name="XR_EXT_HAND_TRACKING_EXTENSION_NAME"/>

            <command name="xrCreateHandTrackerEXT"/>
            <command name="xrDestroyHandTrackerEXT"/>
            <command name="xrLocateHandJointsEXT"/>

            <type name="XrHandEXT"/>
            <type name="XrHandJointEXT"/>
            <type name="XrHandJointSetEXT"/>

            <type name="XrSystemHandTrackingPropertiesEXT"/>
            <type name="XrHandTrackerCreateInfoEXT"/>
            <type name="XrHandJointsLocateInfoEXT"/>
            <type name="XrHandJointLocationEXT"/>
            <type name="XrHandJointVelocityEXT"/>
            <type name="XrHandJointLocationsEXT"/>
            <type name="XrHandJointVelocitiesEXT"/>
            <type name="XR_HAND_JOINT_COUNT_EXT"/>

            <enum offset="0" extends="XrObjectType" name="XR_OBJECT_TYPE_HAND_TRACKER_EXT" comment="XrHandTrackerEXT"/>

            <enum offset="0" extends="XrStructureType" name="XR_TYPE_SYSTEM_HAND_TRACKING_PROPERTIES_EXT"/>
            <enum offset="1" extends="XrStructureType" name="XR_TYPE_HAND_TRACKER_CREATE_INFO_EXT"/>
            <enum offset="2" extends="XrStructureType" name="XR_TYPE_HAND_JOINTS_LOCATE_INFO_EXT"/>
            <enum offset="3" extends="XrStructureType" name="XR_TYPE_HAND_JOINT_LOCATIONS_EXT"/>
            <enum offset="4" extends="XrStructureType" name="XR_TYPE_HAND_JOINT_VELOCITIES_EXT"/>
        </require>
    </extension>

    <extension name="XR_MSFT_hand_tracking_mesh" number="53"
            requires="XR_EXT_hand_tracking" type="instance" supported="openxr">
        <require>
            <enum value="4" name="XR_MSFT_hand_tracking_mesh_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_hand_tracking_mesh&quot;" name="XR_MSFT_HAND_TRACKING_MESH_EXTENSION_NAME"/>

            <command name="xrCreateHandMeshSpaceMSFT"/>
            <command name="xrUpdateHandMeshMSFT"/>

            <type name="XrSystemHandTrackingMeshPropertiesMSFT"/>
            <type name="XrHandMeshSpaceCreateInfoMSFT"/>
            <type name="XrHandMeshUpdateInfoMSFT"/>
            <type name="XrHandMeshMSFT"/>
            <type name="XrHandMeshIndexBufferMSFT"/>
            <type name="XrHandMeshVertexBufferMSFT"/>
            <type name="XrHandMeshVertexMSFT"/>
            <type name="XrHandPoseTypeMSFT"/>
            <type name="XrHandPoseTypeInfoMSFT"/>

            <enum offset="0" extends="XrStructureType" name="XR_TYPE_SYSTEM_HAND_TRACKING_MESH_PROPERTIES_MSFT"/>
            <enum offset="1" extends="XrStructureType" name="XR_TYPE_HAND_MESH_SPACE_CREATE_INFO_MSFT"/>
            <enum offset="2" extends="XrStructureType" name="XR_TYPE_HAND_MESH_UPDATE_INFO_MSFT"/>
            <enum offset="3" extends="XrStructureType" name="XR_TYPE_HAND_MESH_MSFT"/>
            <enum offset="4" extends="XrStructureType" name="XR_TYPE_HAND_POSE_TYPE_INFO_MSFT"/>
        </require>
    </extension>

    <extension name="XR_MSFT_secondary_view_configuration" number="54" type="instance" supported="openxr">
        <require>
            <enum value="1" name="XR_MSFT_secondary_view_configuration_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_secondary_view_configuration&quot;" name="XR_MSFT_SECONDARY_VIEW_CONFIGURATION_EXTENSION_NAME"/>
            <type name="XrSecondaryViewConfigurationSessionBeginInfoMSFT"/>
            <type name="XrSecondaryViewConfigurationStateMSFT"/>
            <type name="XrSecondaryViewConfigurationFrameStateMSFT"/>
            <type name="XrSecondaryViewConfigurationFrameEndInfoMSFT"/>
            <type name="XrSecondaryViewConfigurationLayerInfoMSFT"/>
            <type name="XrSecondaryViewConfigurationSwapchainCreateInfoMSFT"/>
            <enum offset="0" extends="XrStructureType"  name="XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SESSION_BEGIN_INFO_MSFT"/>
            <enum offset="1" extends="XrStructureType"  name="XR_TYPE_SECONDARY_VIEW_CONFIGURATION_STATE_MSFT"/>
            <enum offset="2" extends="XrStructureType"  name="XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_STATE_MSFT"/>
            <enum offset="3" extends="XrStructureType"  name="XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_END_INFO_MSFT"/>
            <enum offset="4" extends="XrStructureType"  name="XR_TYPE_SECONDARY_VIEW_CONFIGURATION_LAYER_INFO_MSFT"/>
            <enum offset="5" extends="XrStructureType"  name="XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SWAPCHAIN_CREATE_INFO_MSFT"/>
            <enum offset="0" dir="-" extends="XrResult" name="XR_ERROR_SECONDARY_VIEW_CONFIGURATION_TYPE_NOT_ENABLED_MSFT"
                comment="The secondary view configuration was not enabled when creating the session."/>
        </require>
    </extension>

    <extension name="XR_MSFT_first_person_observer" number="55" type="instance" requires="XR_MSFT_secondary_view_configuration" supported="openxr">
        <require>
            <enum value="1" name="XR_MSFT_first_person_observer_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_first_person_observer&quot;" name="XR_MSFT_FIRST_PERSON_OBSERVER_EXTENSION_NAME"/>
            <enum offset="0" extends="XrViewConfigurationType" name="XR_VIEW_CONFIGURATION_TYPE_SECONDARY_MONO_FIRST_PERSON_OBSERVER_MSFT"/>
        </require>
    </extension>

    <extension name="XR_MSFT_controller_model" number="56" type="instance" supported="openxr">
        <require>
            <enum value="2" name="XR_MSFT_controller_model_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_controller_model&quot;" name="XR_MSFT_CONTROLLER_MODEL_EXTENSION_NAME"/>

            <type name="XrControllerModelKeyStateMSFT"/>
            <type name="XrControllerModelNodePropertiesMSFT"/>
            <type name="XrControllerModelPropertiesMSFT"/>
            <type name="XrControllerModelNodeStateMSFT"/>
            <type name="XrControllerModelStateMSFT"/>
            <type name="XrControllerModelKeyMSFT"/>
            <type name="XR_NULL_CONTROLLER_MODEL_KEY_MSFT"/>

            <command name="xrGetControllerModelKeyMSFT"/>
            <command name="xrLoadControllerModelMSFT"/>
            <command name="xrGetControllerModelPropertiesMSFT"/>
            <command name="xrGetControllerModelStateMSFT"/>

            <enum value="64" name="XR_MAX_CONTROLLER_MODEL_NODE_NAME_SIZE_MSFT"/>

            <enum offset="0" extends="XrStructureType"  name="XR_TYPE_CONTROLLER_MODEL_KEY_STATE_MSFT"/>
            <enum offset="1" extends="XrStructureType"  name="XR_TYPE_CONTROLLER_MODEL_NODE_PROPERTIES_MSFT"/>
            <enum offset="2" extends="XrStructureType"  name="XR_TYPE_CONTROLLER_MODEL_PROPERTIES_MSFT"/>
            <enum offset="3" extends="XrStructureType"  name="XR_TYPE_CONTROLLER_MODEL_NODE_STATE_MSFT"/>
            <enum offset="4" extends="XrStructureType"  name="XR_TYPE_CONTROLLER_MODEL_STATE_MSFT"/>
            <enum offset="0" dir="-" extends="XrResult" name="XR_ERROR_CONTROLLER_MODEL_KEY_INVALID_MSFT" comment="The controller model key is invalid."/>

        </require>
    </extension>

    <extension name="XR_MSFT_perception_anchor_interop" number="57" type="instance" supported="openxr" requires="XR_MSFT_spatial_anchor" protect="XR_USE_PLATFORM_WIN32">
        <require>
            <enum value="1" name="XR_MSFT_perception_anchor_interop_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_perception_anchor_interop&quot;" name="XR_MSFT_PERCEPTION_ANCHOR_INTEROP_EXTENSION_NAME"/>

            <command name="xrCreateSpatialAnchorFromPerceptionAnchorMSFT"/>
            <command name="xrTryGetPerceptionAnchorFromSpatialAnchorMSFT"/>

        </require>
    </extension>

    <extension name="XR_EXT_win32_appcontainer_compatible" number="58" type="instance" supported="openxr">
        <require>
            <enum value="1" name="XR_EXT_win32_appcontainer_compatible_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_win32_appcontainer_compatible&quot;" name="XR_EXT_WIN32_APPCONTAINER_COMPATIBLE_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_ML_extension_59" number="59" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_ML_extension_59_SPEC_VERSION"/>
            <enum value="&quot;XR_ML_extension_59&quot;" name="XR_ML_extension_59_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_EPIC_view_configuration_fov" number="60" type="instance" supported="openxr">
        <require>
            <enum value="2" name="XR_EPIC_view_configuration_fov_SPEC_VERSION"/>
            <enum value="&quot;XR_EPIC_view_configuration_fov&quot;" name="XR_EPIC_VIEW_CONFIGURATION_FOV_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_VIEW_CONFIGURATION_VIEW_FOV_EPIC"/>
            <type name="XrViewConfigurationViewFovEPIC"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_63" number="63" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_MSFT_extension_63_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_63&quot;" name="XR_MSFT_extension_63_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_holographic_window_attachment" number="64" type="instance" supported="openxr" protect="XR_USE_PLATFORM_WIN32">
        <require>
            <enum value="1" name="XR_MSFT_holographic_window_attachment_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_holographic_window_attachment&quot;" name="XR_MSFT_HOLOGRAPHIC_WINDOW_ATTACHMENT_EXTENSION_NAME"/>
            <type name="XrHolographicWindowAttachmentMSFT"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_HOLOGRAPHIC_WINDOW_ATTACHMENT_MSFT"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_65" number="65" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_MSFT_extension_65_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_65&quot;" name="XR_MSFT_extension_65_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_66" number="66" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_MSFT_extension_66_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_66&quot;" name="XR_MSFT_extension_66_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_composition_layer_reprojection" number="67" type="instance" supported="openxr">
        <require>
            <enum value="1" name="XR_MSFT_composition_layer_reprojection_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_composition_layer_reprojection&quot;" name="XR_MSFT_COMPOSITION_LAYER_REPROJECTION_EXTENSION_NAME"/>

            <type name="XrReprojectionModeMSFT"/>
            <type name="XrCompositionLayerReprojectionInfoMSFT"/>
            <type name="XrCompositionLayerReprojectionPlaneOverrideMSFT"/>

            <command name="xrEnumerateReprojectionModesMSFT"/>

            <enum offset="0" extends="XrStructureType" name="XR_TYPE_COMPOSITION_LAYER_REPROJECTION_INFO_MSFT"/>
            <enum offset="1" extends="XrStructureType" name="XR_TYPE_COMPOSITION_LAYER_REPROJECTION_PLANE_OVERRIDE_MSFT"/>
            <enum offset="0" dir="-" extends="XrResult" name="XR_ERROR_REPROJECTION_MODE_UNSUPPORTED_MSFT" comment="The reprojection mode is not supported."/>

        </require>
    </extension>

    <extension name="XR_LUNARG_extension_68" number="68" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_LUNARG_extension_68_SPEC_VERSION"/>
            <enum value="&quot;XR_LUNARG_extension_68&quot;" name="XR_LUNARG_extension_68_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_LUNARG_extension_69" number="69" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_LUNARG_extension_69_SPEC_VERSION"/>
            <enum value="&quot;XR_LUNARG_extension_69&quot;" name="XR_LUNARG_extension_69_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HUAWEI_controller_interaction" number="70" type="instance" supported="openxr">
        <require>
            <enum value="1" name="XR_HUAWEI_controller_interaction_SPEC_VERSION"/>
            <enum value="&quot;XR_HUAWEI_controller_interaction&quot;" name="XR_HUAWEI_CONTROLLER_INTERACTION_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_android_surface_swapchain_create" number="71" type="instance" supported="openxr" protect="XR_USE_PLATFORM_ANDROID" requires="XR_KHR_android_surface_swapchain">
        <require>
            <enum value="1" name="XR_FB_android_surface_swapchain_create_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_android_surface_swapchain_create&quot;" name="XR_FB_ANDROID_SURFACE_SWAPCHAIN_CREATE_EXTENSION_NAME"/>

            <type name="XrAndroidSurfaceSwapchainCreateInfoFB"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_ANDROID_SURFACE_SWAPCHAIN_CREATE_INFO_FB"/>
        </require>
    </extension>

    <extension name="XR_FB_swapchain_update_state" number="72" type="instance" supported="openxr">
        <require>
            <enum value="3" name="XR_FB_swapchain_update_state_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_swapchain_update_state&quot;" name="XR_FB_SWAPCHAIN_UPDATE_STATE_EXTENSION_NAME"/>

            <type name="XrSwapchainStateBaseHeaderFB"/>
            <command name="xrUpdateSwapchainFB"/>
            <command name="xrGetSwapchainStateFB"/>
        </require>
    </extension>

    <extension name="XR_FB_composition_layer_secure_content" number="73" type="instance" supported="openxr">
        <require>
            <enum value="1"                                                  name="XR_FB_composition_layer_secure_content_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_composition_layer_secure_content&quot;" name="XR_FB_COMPOSITION_LAYER_SECURE_CONTENT_EXTENSION_NAME"/>

            <enum offset="0" extends="XrStructureType"                       name="XR_TYPE_COMPOSITION_LAYER_SECURE_CONTENT_FB"/>
            <type name="XrCompositionLayerSecureContentFB"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_74" number="74" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_74_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_74&quot;" name="XR_FB_extension_74_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_75" number="75" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_75_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_75&quot;" name="XR_FB_extension_75_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_76" number="76" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_76_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_76&quot;" name="XR_FB_extension_76_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_77" number="77" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_77_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_77&quot;" name="XR_FB_extension_77_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_78" number="78" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_78_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_78&quot;" name="XR_FB_extension_78_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_EXT_dpad_binding" number="79" type="instance" supported="openxr" requires="XR_KHR_binding_modification">
        <require>
            <enum value="1"                               name="XR_EXT_dpad_binding_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_dpad_binding&quot;" name="XR_EXT_DPAD_BINDING_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType"    name="XR_TYPE_INTERACTION_PROFILE_DPAD_BINDING_EXT"/>
            <type name="XrInteractionProfileDpadBindingEXT"/>
        </require>
    </extension>

    <extension name="XR_VALVE_analog_threshold" number="80" type="instance" supported="openxr">
        <require>
            <enum value="2" name="XR_VALVE_analog_threshold_SPEC_VERSION"/>
            <enum value="&quot;XR_VALVE_analog_threshold&quot;" name="XR_VALVE_ANALOG_THRESHOLD_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_INTERACTION_PROFILE_ANALOG_THRESHOLD_VALVE"/>
            <type name="XrInteractionProfileAnalogThresholdVALVE"/>
        </require>
    </extension>

    <extension name="XR_EXT_hand_joints_motion_range" number="81" type="instance" supported="openxr" requires="XR_EXT_hand_tracking">
        <require>
            <enum value="1" name="XR_EXT_hand_joints_motion_range_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_hand_joints_motion_range&quot;" name="XR_EXT_HAND_JOINTS_MOTION_RANGE_EXTENSION_NAME"/>

            <type name="XrHandJointsMotionRangeEXT"/>

            <enum offset="0" extends="XrStructureType" name="XR_TYPE_HAND_JOINTS_MOTION_RANGE_INFO_EXT"/>
            <type name="XrHandJointsMotionRangeInfoEXT"/>
        </require>
    </extension>

    <extension name="XR_VALVE_extension_82" number="82" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_VALVE_extension_82_SPEC_VERSION"/>
            <enum value="&quot;XR_VALVE_extension_82&quot;" name="XR_VALVE_extension_82_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_VALVE_extension_83" number="83" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_VALVE_extension_83_SPEC_VERSION"/>
            <enum value="&quot;XR_VALVE_extension_83&quot;" name="XR_VALVE_extension_83_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_VALVE_extension_84" number="84" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_VALVE_extension_84_SPEC_VERSION"/>
            <enum value="&quot;XR_VALVE_extension_84&quot;" name="XR_VALVE_extension_84_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_VALVE_extension_85" number="85" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_VALVE_extension_85_SPEC_VERSION"/>
            <enum value="&quot;XR_VALVE_extension_85&quot;" name="XR_VALVE_extension_85_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_VALVE_extension_86" number="86" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_VALVE_extension_86_SPEC_VERSION"/>
            <enum value="&quot;XR_VALVE_extension_86&quot;" name="XR_VALVE_extension_86_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_VALVE_extension_87" number="87" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_VALVE_extension_87_SPEC_VERSION"/>
            <enum value="&quot;XR_VALVE_extension_87&quot;" name="XR_VALVE_extension_87_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_VALVE_extension_88" number="88" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_VALVE_extension_88_SPEC_VERSION"/>
            <enum value="&quot;XR_VALVE_extension_88&quot;" name="XR_VALVE_extension_88_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_KHR_loader_init" number="89" type="instance" supported="openxr">
        <require>
            <enum value="1" name="XR_KHR_loader_init_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_loader_init&quot;" name="XR_KHR_LOADER_INIT_EXTENSION_NAME"/>
            <type name="XrLoaderInitInfoBaseHeaderKHR"/>
            <command name="xrInitializeLoaderKHR"/>
        </require>
    </extension>

    <extension name="XR_KHR_loader_init_android" number="90" type="instance" supported="openxr" protect="XR_USE_PLATFORM_ANDROID" requires="XR_KHR_loader_init">
        <require>
            <enum value="1" name="XR_KHR_loader_init_android_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_loader_init_android&quot;" name="XR_KHR_LOADER_INIT_ANDROID_EXTENSION_NAME"/>
            <type name="XrLoaderInitInfoAndroidKHR"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_LOADER_INIT_INFO_ANDROID_KHR"/>
        </require>
    </extension>

    <extension name="XR_KHR_vulkan_enable2" number="91" type="instance" protect="XR_USE_GRAPHICS_API_VULKAN" supported="openxr">
        <require>
            <enum value="2" name="XR_KHR_vulkan_enable2_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_vulkan_enable2&quot;" name="XR_KHR_VULKAN_ENABLE2_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType"      name="XR_TYPE_VULKAN_INSTANCE_CREATE_INFO_KHR"/>
            <enum offset="1" extends="XrStructureType"      name="XR_TYPE_VULKAN_DEVICE_CREATE_INFO_KHR"/>
            <enum offset="3" extends="XrStructureType"      name="XR_TYPE_VULKAN_GRAPHICS_DEVICE_GET_INFO_KHR"/>
            <enum            extends="XrStructureType"      name="XR_TYPE_GRAPHICS_BINDING_VULKAN2_KHR"        alias="XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR"/>
            <enum            extends="XrStructureType"      name="XR_TYPE_SWAPCHAIN_IMAGE_VULKAN2_KHR"         alias="XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR"/>
            <enum            extends="XrStructureType"      name="XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN2_KHR"   alias="XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN_KHR"/>
            <type name="XrVulkanInstanceCreateInfoKHR"/>
            <type name="XrVulkanDeviceCreateInfoKHR"/>
            <type name="XrGraphicsBindingVulkan2KHR"/>
            <type name="XrVulkanGraphicsDeviceGetInfoKHR"/>
            <type name="XrSwapchainImageVulkan2KHR"/>
            <type name="XrGraphicsRequirementsVulkan2KHR"/>
            <command name="xrCreateVulkanInstanceKHR"/>
            <command name="xrCreateVulkanDeviceKHR"/>
            <command name="xrGetVulkanGraphicsDevice2KHR"/>
            <command name="xrGetVulkanGraphicsRequirements2KHR"/>
        </require>
    </extension>

    <extension name="XR_KHR_composition_layer_equirect2" number="92" type="instance" supported="openxr">
        <require>
            <enum value="1" name="XR_KHR_composition_layer_equirect2_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_composition_layer_equirect2&quot;" name="XR_KHR_COMPOSITION_LAYER_EQUIRECT2_EXTENSION_NAME"/>
            <type name="XrCompositionLayerEquirect2KHR"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR"/>
        </require>
    </extension>

    <extension name="XR_EXT_extension_93" number="93" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_EXT_extension_93_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_extension_93&quot;" name="XR_EXT_extension_93_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_EXT_extension_94" number="94" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_EXT_extension_94_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_extension_94&quot;" name="XR_EXT_extension_94_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_EXT_samsung_odyssey_controller" number="95" type="instance" supported="openxr">
        <require>
            <enum value="1" name="XR_EXT_samsung_odyssey_controller_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_samsung_odyssey_controller&quot;" name="XR_EXT_SAMSUNG_ODYSSEY_CONTROLLER_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_EXT_hp_mixed_reality_controller" number="96" type="instance" supported="openxr">
        <require>
            <enum value="1" name="XR_EXT_hp_mixed_reality_controller_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_hp_mixed_reality_controller&quot;" name="XR_EXT_HP_MIXED_REALITY_CONTROLLER_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MND_swapchain_usage_input_attachment_bit" number="97" type="instance" supported="openxr" promotedto="XR_KHR_swapchain_usage_input_attachment_bit">
        <require>
            <enum value="2" name="XR_MND_swapchain_usage_input_attachment_bit_SPEC_VERSION"/>
            <enum value="&quot;XR_MND_swapchain_usage_input_attachment_bit&quot;" name="XR_MND_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_EXTENSION_NAME"/>
            <!-- NOTE: This was added before the working group established a process, and has been normalized by promotion to KHR. Future vendor extensions MUST NOT extend core bitmasks. -->
            <enum bitpos="7" extends="XrSwapchainUsageFlagBits" name="XR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_MND" comment="Specifies that the image may: be used as a input attachment."/>
        </require>
    </extension>

    <extension name="XR_MSFT_scene_understanding" number="98" type="instance" supported="openxr">
        <require>
            <enum value="2" name="XR_MSFT_scene_understanding_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_scene_understanding&quot;" name="XR_MSFT_SCENE_UNDERSTANDING_EXTENSION_NAME"/>
            <type name="XrUuidMSFT"/>
            <type name="XrSceneObserverCreateInfoMSFT"/>
            <type name="XrSceneCreateInfoMSFT"/>
            <type name="XrNewSceneComputeInfoMSFT"/>
            <type name="XrVisualMeshComputeLodInfoMSFT"/>
            <type name="XrSceneSphereBoundMSFT"/>
            <type name="XrSceneOrientedBoxBoundMSFT"/>
            <type name="XrSceneFrustumBoundMSFT"/>
            <type name="XrSceneBoundsMSFT"/>
            <type name="XrSceneComponentMSFT"/>
            <type name="XrSceneComponentsMSFT"/>
            <type name="XrSceneComponentsGetInfoMSFT"/>
            <type name="XrSceneComponentLocationMSFT"/>
            <type name="XrSceneComponentLocationsMSFT"/>
            <type name="XrSceneComponentsLocateInfoMSFT"/>
            <type name="XrSceneObjectMSFT"/>
            <type name="XrSceneObjectsMSFT"/>
            <type name="XrSceneComponentParentFilterInfoMSFT"/>
            <type name="XrSceneObjectTypesFilterInfoMSFT"/>
            <type name="XrScenePlaneMSFT"/>
            <type name="XrScenePlanesMSFT"/>
            <type name="XrScenePlaneAlignmentFilterInfoMSFT"/>
            <type name="XrSceneMeshMSFT"/>
            <type name="XrSceneMeshesMSFT"/>
            <type name="XrSceneMeshBuffersGetInfoMSFT"/>
            <type name="XrSceneMeshBuffersMSFT"/>
            <type name="XrSceneMeshVertexBufferMSFT"/>
            <type name="XrSceneMeshIndicesUint32MSFT"/>
            <type name="XrSceneMeshIndicesUint16MSFT"/>
            <type name="XrSceneObjectTypeMSFT"/>
            <type name="XrScenePlaneAlignmentTypeMSFT"/>
            <type name="XrSceneComputeStateMSFT"/>
            <type name="XrSceneComponentTypeMSFT"/>
            <type name="XrSceneComputeFeatureMSFT"/>
            <type name="XrSceneComputeConsistencyMSFT"/>
            <type name="XrMeshComputeLodMSFT"/>
            <command name="xrEnumerateSceneComputeFeaturesMSFT"/>
            <command name="xrCreateSceneObserverMSFT"/>
            <command name="xrDestroySceneObserverMSFT"/>
            <command name="xrCreateSceneMSFT"/>
            <command name="xrDestroySceneMSFT"/>
            <command name="xrComputeNewSceneMSFT"/>
            <command name="xrGetSceneComputeStateMSFT"/>
            <command name="xrGetSceneComponentsMSFT"/>
            <command name="xrLocateSceneComponentsMSFT"/>
            <command name="xrGetSceneMeshBuffersMSFT"/>
            <enum offset="0" extends="XrObjectType" name="XR_OBJECT_TYPE_SCENE_OBSERVER_MSFT" comment="XrSceneObserverMSFT"/>
            <enum offset="1" extends="XrObjectType" name="XR_OBJECT_TYPE_SCENE_MSFT" comment="XrSceneMSFT"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_SCENE_OBSERVER_CREATE_INFO_MSFT"/>
            <enum offset="1" extends="XrStructureType" name="XR_TYPE_SCENE_CREATE_INFO_MSFT"/>
            <enum offset="2" extends="XrStructureType" name="XR_TYPE_NEW_SCENE_COMPUTE_INFO_MSFT"/>
            <enum offset="3" extends="XrStructureType" name="XR_TYPE_VISUAL_MESH_COMPUTE_LOD_INFO_MSFT"/>
            <enum offset="4" extends="XrStructureType" name="XR_TYPE_SCENE_COMPONENTS_MSFT"/>
            <enum offset="5" extends="XrStructureType" name="XR_TYPE_SCENE_COMPONENTS_GET_INFO_MSFT"/>
            <enum offset="6" extends="XrStructureType" name="XR_TYPE_SCENE_COMPONENT_LOCATIONS_MSFT"/>
            <enum offset="7" extends="XrStructureType" name="XR_TYPE_SCENE_COMPONENTS_LOCATE_INFO_MSFT"/>
            <enum offset="8" extends="XrStructureType" name="XR_TYPE_SCENE_OBJECTS_MSFT"/>
            <enum offset="9" extends="XrStructureType" name="XR_TYPE_SCENE_COMPONENT_PARENT_FILTER_INFO_MSFT"/>
            <enum offset="10" extends="XrStructureType" name="XR_TYPE_SCENE_OBJECT_TYPES_FILTER_INFO_MSFT"/>
            <enum offset="11" extends="XrStructureType" name="XR_TYPE_SCENE_PLANES_MSFT"/>
            <enum offset="12" extends="XrStructureType" name="XR_TYPE_SCENE_PLANE_ALIGNMENT_FILTER_INFO_MSFT"/>
            <enum offset="13" extends="XrStructureType" name="XR_TYPE_SCENE_MESHES_MSFT"/>
            <enum offset="14" extends="XrStructureType" name="XR_TYPE_SCENE_MESH_BUFFERS_GET_INFO_MSFT"/>
            <enum offset="15" extends="XrStructureType" name="XR_TYPE_SCENE_MESH_BUFFERS_MSFT"/>
            <enum offset="16" extends="XrStructureType" name="XR_TYPE_SCENE_MESH_VERTEX_BUFFER_MSFT"/>
            <enum offset="17" extends="XrStructureType" name="XR_TYPE_SCENE_MESH_INDICES_UINT32_MSFT"/>
            <enum offset="18" extends="XrStructureType" name="XR_TYPE_SCENE_MESH_INDICES_UINT16_MSFT"/>
            <enum offset="0" dir="-" extends="XrResult" name="XR_ERROR_COMPUTE_NEW_SCENE_NOT_COMPLETED_MSFT" comment="Compute new scene not completed."/>
            <enum offset="1" dir="-" extends="XrResult" name="XR_ERROR_SCENE_COMPONENT_ID_INVALID_MSFT" comment="Scene component id invalid."/>
            <enum offset="2" dir="-" extends="XrResult" name="XR_ERROR_SCENE_COMPONENT_TYPE_MISMATCH_MSFT" comment="Scene component type mismatch."/>
            <enum offset="3" dir="-" extends="XrResult" name="XR_ERROR_SCENE_MESH_BUFFER_ID_INVALID_MSFT" comment="Scene mesh buffer id invalid."/>
            <enum offset="4" dir="-" extends="XrResult" name="XR_ERROR_SCENE_COMPUTE_FEATURE_INCOMPATIBLE_MSFT" comment="Scene compute feature incompatible."/>
            <enum offset="5" dir="-" extends="XrResult" name="XR_ERROR_SCENE_COMPUTE_CONSISTENCY_MISMATCH_MSFT" comment="Scene compute consistency mismatch."/>
        </require>
    </extension>

    <extension name="XR_MSFT_scene_understanding_serialization" number="99" type="instance" supported="openxr"
        requires="XR_MSFT_scene_understanding">
        <require>
            <enum value="2" name="XR_MSFT_scene_understanding_serialization_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_scene_understanding_serialization&quot;" name="XR_MSFT_SCENE_UNDERSTANDING_SERIALIZATION_EXTENSION_NAME"/>
            <type name="XrSerializedSceneFragmentDataGetInfoMSFT"/>
            <type name="XrDeserializeSceneFragmentMSFT"/>
            <type name="XrSceneDeserializeInfoMSFT"/>
            <command name="xrDeserializeSceneMSFT"/>
            <command name="xrGetSerializedSceneFragmentDataMSFT"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_SERIALIZED_SCENE_FRAGMENT_DATA_GET_INFO_MSFT"/>
            <enum offset="1" extends="XrStructureType" name="XR_TYPE_SCENE_DESERIALIZE_INFO_MSFT"/>
            <enum offset="0" extends="XrSceneComputeFeatureMSFT" name="XR_SCENE_COMPUTE_FEATURE_SERIALIZE_SCENE_MSFT"/>
            <enum offset="0" extends="XrSceneComponentTypeMSFT" name="XR_SCENE_COMPONENT_TYPE_SERIALIZED_SCENE_FRAGMENT_MSFT"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_100" number="100" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_MSFT_extension_100_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_100&quot;" name="XR_MSFT_extension_100_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_101" number="101" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_MSFT_extension_101_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_101&quot;" name="XR_MSFT_extension_101_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_display_refresh_rate" number="102" type="instance" supported="openxr">
        <require>
            <enum value="1" name="XR_FB_display_refresh_rate_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_display_refresh_rate&quot;" name="XR_FB_DISPLAY_REFRESH_RATE_EXTENSION_NAME"/>

            <type name="XrEventDataDisplayRefreshRateChangedFB"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_EVENT_DATA_DISPLAY_REFRESH_RATE_CHANGED_FB"/>

            <command name="xrEnumerateDisplayRefreshRatesFB"/>
            <command name="xrGetDisplayRefreshRateFB"/>
            <command name="xrRequestDisplayRefreshRateFB"/>
            <enum offset="0" dir="-" extends="XrResult" name="XR_ERROR_DISPLAY_REFRESH_RATE_UNSUPPORTED_FB" comment="The display refresh rate is not supported by the platform."/>
        </require>
    </extension>

    <extension name="XR_HTC_vive_cosmos_controller_interaction" number="103" type="instance" supported="openxr">
        <require>
            <enum value="1" name="XR_HTC_vive_cosmos_controller_interaction_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_vive_cosmos_controller_interaction&quot;" name="XR_HTC_VIVE_COSMOS_CONTROLLER_INTERACTION_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTCX_vive_tracker_interaction" number="104" type="instance" provisional="true" supported="openxr">
        <require>
            <enum value="2"                                            name="XR_HTCX_vive_tracker_interaction_SPEC_VERSION"/>
            <enum value="&quot;XR_HTCX_vive_tracker_interaction&quot;" name="XR_HTCX_VIVE_TRACKER_INTERACTION_EXTENSION_NAME"/>
            <type name="XrViveTrackerPathsHTCX"/>
            <type name="XrEventDataViveTrackerConnectedHTCX"/>

            <enum offset="0" extends="XrStructureType" name="XR_TYPE_VIVE_TRACKER_PATHS_HTCX"/>
            <enum offset="1" extends="XrStructureType" name="XR_TYPE_EVENT_DATA_VIVE_TRACKER_CONNECTED_HTCX"/>
            <command name="xrEnumerateViveTrackerPathsHTCX"/>
        </require>
    </extension>

    <extension name="XR_HTC_facial_tracking" number="105" type="instance" supported="openxr">
        <require>
            <enum value="2"                                  name="XR_HTC_facial_tracking_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_facial_tracking&quot;" name="XR_HTC_FACIAL_TRACKING_EXTENSION_NAME"/>

            <type name="XrSystemFacialTrackingPropertiesHTC"/>
            <type name="XrFacialExpressionsHTC"/>
            <type name="XrEyeExpressionHTC"/>
            <type name="XrLipExpressionHTC"/>
            <type name="XrFacialTrackerCreateInfoHTC"/>
            <type name="XrFacialTrackingTypeHTC"/>
            <type name="XR_FACIAL_EXPRESSION_EYE_COUNT_HTC"/>
            <type name="XR_FACIAL_EXPRESSION_LIP_COUNT_HTC"/>

            <enum offset="0" extends="XrObjectType"    name="XR_OBJECT_TYPE_FACIAL_TRACKER_HTC"             comment="XrFacialTrackerHTC"/>

            <enum offset="0" extends="XrStructureType" name="XR_TYPE_SYSTEM_FACIAL_TRACKING_PROPERTIES_HTC"/>
            <enum offset="1" extends="XrStructureType" name="XR_TYPE_FACIAL_TRACKER_CREATE_INFO_HTC"/>
            <enum offset="2" extends="XrStructureType" name="XR_TYPE_FACIAL_EXPRESSIONS_HTC"/>

            <command name="xrCreateFacialTrackerHTC"/>
            <command name="xrDestroyFacialTrackerHTC"/>
            <command name="xrGetFacialExpressionsHTC"/>
        </require>
    </extension>

    <extension name="XR_HTC_vive_focus3_controller_interaction" number="106" type="instance" supported="openxr">
        <require>
            <enum value="2"                                                     name="XR_HTC_vive_focus3_controller_interaction_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_vive_focus3_controller_interaction&quot;" name="XR_HTC_VIVE_FOCUS3_CONTROLLER_INTERACTION_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_hand_interaction" number="107" type="instance" supported="openxr">
        <require>
            <enum value="1"                                   name="XR_HTC_hand_interaction_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_hand_interaction&quot;" name="XR_HTC_HAND_INTERACTION_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_vive_wrist_tracker_interaction" number="108" type="instance" supported="openxr">
        <require>
            <enum value="1"                                                 name="XR_HTC_vive_wrist_tracker_interaction_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_vive_wrist_tracker_interaction&quot;" name="XR_HTC_VIVE_WRIST_TRACKER_INTERACTION_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_color_space" number="109" type="instance" supported="openxr">
        <require>
            <enum value="3" name="XR_FB_color_space_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_color_space&quot;" name="XR_FB_COLOR_SPACE_EXTENSION_NAME"/>

            <type name="XrColorSpaceFB"/>
            <type name="XrSystemColorSpacePropertiesFB"/>

            <enum offset="0" extends="XrStructureType" name="XR_TYPE_SYSTEM_COLOR_SPACE_PROPERTIES_FB"/>

            <command name="xrEnumerateColorSpacesFB"/>
            <command name="xrSetColorSpaceFB"/>
            <enum offset="0" dir="-" extends="XrResult" name="XR_ERROR_COLOR_SPACE_UNSUPPORTED_FB" comment="The color space is not supported by the runtime."/>
        </require>
    </extension>

    <extension name="XR_FB_extension_110" number="110" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_110_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_110&quot;" name="XR_FB_extension_110_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_hand_tracking_mesh" number="111" type="instance" supported="openxr" requires="XR_EXT_hand_tracking">
        <require>
            <enum value="3"                                    name="XR_FB_hand_tracking_mesh_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_hand_tracking_mesh&quot;" name="XR_FB_HAND_TRACKING_MESH_EXTENSION_NAME"/>

            <type name="XrVector4sFB"/>
            <type name="XrHandTrackingMeshFB"/>
            <type name="XrHandTrackingScaleFB"/>

            <enum offset="1" extends="XrStructureType" name="XR_TYPE_HAND_TRACKING_MESH_FB"/>
            <enum offset="3" extends="XrStructureType" name="XR_TYPE_HAND_TRACKING_SCALE_FB"/>

            <command name="xrGetHandMeshFB"/>
        </require>
    </extension>

    <extension name="XR_FB_hand_tracking_aim" number="112" type="instance" supported="openxr" requires="XR_EXT_hand_tracking">
        <require>
            <enum value="2"                                   name="XR_FB_hand_tracking_aim_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_hand_tracking_aim&quot;" name="XR_FB_HAND_TRACKING_AIM_EXTENSION_NAME"/>

            <type name="XrHandTrackingAimStateFB"/>

            <enum offset="1" extends="XrStructureType" name="XR_TYPE_HAND_TRACKING_AIM_STATE_FB"/>
        </require>
    </extension>

    <extension name="XR_FB_hand_tracking_capsules" number="113" type="instance" supported="openxr" requires="XR_EXT_hand_tracking">
        <require>
            <enum value="3"                                        name="XR_FB_hand_tracking_capsules_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_hand_tracking_capsules&quot;" name="XR_FB_HAND_TRACKING_CAPSULES_EXTENSION_NAME"/>

            <type name="XrHandCapsuleFB"/>
            <type name="XrHandTrackingCapsulesStateFB"/>

            <enum value="2"                            name="XR_HAND_TRACKING_CAPSULE_POINT_COUNT_FB"/>
            <enum value="19"                           name="XR_HAND_TRACKING_CAPSULE_COUNT_FB"/>

            <enum name="XR_FB_HAND_TRACKING_CAPSULE_POINT_COUNT" alias="XR_HAND_TRACKING_CAPSULE_POINT_COUNT_FB" comment="Backward-compatibility alias containing typo."/>

            <enum name="XR_FB_HAND_TRACKING_CAPSULE_COUNT"       alias="XR_HAND_TRACKING_CAPSULE_COUNT_FB"       comment="Backward-compatibility alias containing typo."/>

            <enum offset="0" extends="XrStructureType" name="XR_TYPE_HAND_TRACKING_CAPSULES_STATE_FB"/>
        </require>
    </extension>

    <extension name="XR_FB_spatial_entity" number="114" type="instance" requires="XR_EXT_uuid" supported="openxr">
        <require>
            <enum value="1"                                    name="XR_FB_spatial_entity_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_spatial_entity&quot;"     name="XR_FB_SPATIAL_ENTITY_EXTENSION_NAME"/>

            <enum offset="4"         extends="XrStructureType" name="XR_TYPE_SYSTEM_SPATIAL_ENTITY_PROPERTIES_FB"/>
            <enum offset="3"         extends="XrStructureType" name="XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_FB"/>
            <enum offset="7"         extends="XrStructureType" name="XR_TYPE_SPACE_COMPONENT_STATUS_SET_INFO_FB"/>
            <enum offset="1"         extends="XrStructureType" name="XR_TYPE_SPACE_COMPONENT_STATUS_FB"/>
            <enum offset="5"         extends="XrStructureType" name="XR_TYPE_EVENT_DATA_SPATIAL_ANCHOR_CREATE_COMPLETE_FB"/>
            <enum offset="6"         extends="XrStructureType" name="XR_TYPE_EVENT_DATA_SPACE_SET_STATUS_COMPLETE_FB"/>

            <enum offset="0" dir="-" extends="XrResult"        name="XR_ERROR_SPACE_COMPONENT_NOT_SUPPORTED_FB"            comment="The component type is not supported for this space."/>
            <enum offset="1" dir="-" extends="XrResult"        name="XR_ERROR_SPACE_COMPONENT_NOT_ENABLED_FB"              comment="The required component is not enabled for this space."/>
            <enum offset="2" dir="-" extends="XrResult"        name="XR_ERROR_SPACE_COMPONENT_STATUS_PENDING_FB"           comment="A request to set the component's status is currently pending."/>
            <enum offset="3" dir="-" extends="XrResult"        name="XR_ERROR_SPACE_COMPONENT_STATUS_ALREADY_SET_FB"       comment="The component is already set to the requested value."/>

            <type name="XrAsyncRequestIdFB"/>

            <type name="XrSpaceComponentTypeFB"/>

            <type name="XrSystemSpatialEntityPropertiesFB"/>
            <type name="XrSpatialAnchorCreateInfoFB"/>
            <type name="XrSpaceComponentStatusSetInfoFB"/>
            <type name="XrSpaceComponentStatusFB"/>

            <type name="XrEventDataSpatialAnchorCreateCompleteFB"/>
            <type name="XrEventDataSpaceSetStatusCompleteFB"/>

            <command name="xrCreateSpatialAnchorFB"/>
            <command name="xrGetSpaceUuidFB"/>
            <command name="xrEnumerateSpaceSupportedComponentsFB"/>
            <command name="xrSetSpaceComponentStatusFB"/>
            <command name="xrGetSpaceComponentStatusFB"/>
        </require>
    </extension>

    <extension name="XR_FB_foveation" number="115" type="instance" requires="XR_FB_swapchain_update_state" supported="openxr">
        <require>
            <enum value="1"                            name="XR_FB_foveation_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_foveation&quot;"  name="XR_FB_FOVEATION_EXTENSION_NAME"/>

            <enum offset="0" extends="XrObjectType"    name="XR_OBJECT_TYPE_FOVEATION_PROFILE_FB"        comment="XrFoveationProfileFB"/>

            <enum offset="0" extends="XrStructureType" name="XR_TYPE_FOVEATION_PROFILE_CREATE_INFO_FB"/>
            <enum offset="1" extends="XrStructureType" name="XR_TYPE_SWAPCHAIN_CREATE_INFO_FOVEATION_FB"/>
            <enum offset="2" extends="XrStructureType" name="XR_TYPE_SWAPCHAIN_STATE_FOVEATION_FB"/>

            <type name="XrFoveationProfileCreateInfoFB"/>
            <type name="XrSwapchainCreateInfoFoveationFB"/>
            <type name="XrSwapchainStateFoveationFB"/>

            <command name="xrCreateFoveationProfileFB"/>
            <command name="xrDestroyFoveationProfileFB"/>
        </require>
    </extension>

    <extension name="XR_FB_foveation_configuration" number="116" type="instance" requires="XR_FB_foveation" supported="openxr">
        <require>
            <enum value="1"                                         name="XR_FB_foveation_configuration_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_foveation_configuration&quot;" name="XR_FB_FOVEATION_CONFIGURATION_EXTENSION_NAME"/>

            <enum offset="0" extends="XrStructureType"              name="XR_TYPE_FOVEATION_LEVEL_PROFILE_CREATE_INFO_FB"/>

            <type name="XrFoveationLevelFB"/>
            <type name="XrFoveationDynamicFB"/>
            <type name="XrFoveationLevelProfileCreateInfoFB"/>
        </require>
    </extension>

    <extension name="XR_FB_keyboard_tracking" number="117" type="instance" supported="openxr">
        <require>
            <enum value="1"                                   name="XR_FB_keyboard_tracking_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_keyboard_tracking&quot;" name="XR_FB_KEYBOARD_TRACKING_EXTENSION_NAME"/>

            <type name="XrSystemKeyboardTrackingPropertiesFB"/>
            <type name="XrKeyboardTrackingDescriptionFB"/>
            <type name="XrKeyboardSpaceCreateInfoFB"/>
            <type name="XrKeyboardTrackingQueryFB"/>

            <enum value="128"                          name="XR_MAX_KEYBOARD_TRACKING_NAME_SIZE_FB"/>

            <enum offset="9" extends="XrStructureType" name="XR_TYPE_KEYBOARD_SPACE_CREATE_INFO_FB"/>
            <enum offset="4" extends="XrStructureType" name="XR_TYPE_KEYBOARD_TRACKING_QUERY_FB"/>
            <enum offset="2" extends="XrStructureType" name="XR_TYPE_SYSTEM_KEYBOARD_TRACKING_PROPERTIES_FB"/>

            <command name="xrQuerySystemTrackedKeyboardFB"/>
            <command name="xrCreateKeyboardSpaceFB"/>
        </require>
    </extension>

    <extension name="XR_FB_triangle_mesh" number="118" type="instance" supported="openxr">
        <require>
            <enum value="2"                               name="XR_FB_triangle_mesh_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_triangle_mesh&quot;" name="XR_FB_TRIANGLE_MESH_EXTENSION_NAME"/>

            <enum offset="1" extends="XrStructureType"    name="XR_TYPE_TRIANGLE_MESH_CREATE_INFO_FB"/>

            <type name="XrTriangleMeshFlagsFB"/>
            <type name="XrTriangleMeshCreateInfoFB"/>
            <type name="XrWindingOrderFB"/>

            <enum offset="0" extends="XrObjectType" name="XR_OBJECT_TYPE_TRIANGLE_MESH_FB" comment="XrTriangleMeshFB"/>

            <command name="xrCreateTriangleMeshFB"/>
            <command name="xrDestroyTriangleMeshFB"/>
            <command name="xrTriangleMeshGetVertexBufferFB"/>
            <command name="xrTriangleMeshGetIndexBufferFB"/>
            <command name="xrTriangleMeshBeginUpdateFB"/>
            <command name="xrTriangleMeshEndUpdateFB"/>
            <command name="xrTriangleMeshBeginVertexBufferUpdateFB"/>
            <command name="xrTriangleMeshEndVertexBufferUpdateFB"/>
        </require>
    </extension>

    <extension name="XR_FB_passthrough" number="119" type="instance" supported="openxr">
        <require>
            <enum value="3"                                     name="XR_FB_passthrough_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_passthrough&quot;"         name="XR_FB_PASSTHROUGH_EXTENSION_NAME"/>

            <enum offset="0"          extends="XrStructureType" name="XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES_FB"/>
            <enum offset="1"          extends="XrStructureType" name="XR_TYPE_PASSTHROUGH_CREATE_INFO_FB"/>
            <enum offset="2"          extends="XrStructureType" name="XR_TYPE_PASSTHROUGH_LAYER_CREATE_INFO_FB"/>
            <enum offset="3"          extends="XrStructureType" name="XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_FB"/>
            <enum offset="4"          extends="XrStructureType" name="XR_TYPE_GEOMETRY_INSTANCE_CREATE_INFO_FB"/>
            <enum offset="5"          extends="XrStructureType" name="XR_TYPE_GEOMETRY_INSTANCE_TRANSFORM_FB"/>
            <enum offset="6"          extends="XrStructureType" name="XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES2_FB"/>
            <enum offset="20"         extends="XrStructureType" name="XR_TYPE_PASSTHROUGH_STYLE_FB"/>
            <enum offset="21"         extends="XrStructureType" name="XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_RGBA_FB"/>
            <enum offset="22"         extends="XrStructureType" name="XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_MONO_FB"/>
            <enum offset="23"         extends="XrStructureType" name="XR_TYPE_PASSTHROUGH_BRIGHTNESS_CONTRAST_SATURATION_FB"/>
            <enum offset="30"         extends="XrStructureType" name="XR_TYPE_EVENT_DATA_PASSTHROUGH_STATE_CHANGED_FB"/>

            <enum offset="0"  dir="-" extends="XrResult"        name="XR_ERROR_UNEXPECTED_STATE_PASSTHROUGH_FB"        comment="The object state is unexpected for the issued command."/>
            <enum offset="1"  dir="-" extends="XrResult"        name="XR_ERROR_FEATURE_ALREADY_CREATED_PASSTHROUGH_FB" comment="Trying to create an MR feature when one was already created and only one instance is allowed."/>
            <enum offset="2"  dir="-" extends="XrResult"        name="XR_ERROR_FEATURE_REQUIRED_PASSTHROUGH_FB"        comment="Requested functionality requires a feature to be created first."/>
            <enum offset="3"  dir="-" extends="XrResult"        name="XR_ERROR_NOT_PERMITTED_PASSTHROUGH_FB"           comment="Requested functionality is not permitted - application is not allowed to perform the requested operation."/>
            <enum offset="4"  dir="-" extends="XrResult"        name="XR_ERROR_INSUFFICIENT_RESOURCES_PASSTHROUGH_FB"  comment="There weren't sufficient resources available to perform an operation."/>
            <enum offset="50" dir="-" extends="XrResult"        name="XR_ERROR_UNKNOWN_PASSTHROUGH_FB"                 comment="Unknown Passthrough error (no further details provided)."/>

            <enum value="256"                                   name="XR_PASSTHROUGH_COLOR_MAP_MONO_SIZE_FB"/>

            <enum offset="0"          extends="XrObjectType"    name="XR_OBJECT_TYPE_PASSTHROUGH_FB"                   comment="XrPassthroughFB"/>
            <enum offset="2"          extends="XrObjectType"    name="XR_OBJECT_TYPE_PASSTHROUGH_LAYER_FB"             comment="XrPassthroughLayerFB"/>
            <enum offset="4"          extends="XrObjectType"    name="XR_OBJECT_TYPE_GEOMETRY_INSTANCE_FB"             comment="XrGeometryInstanceFB"/>

            <type name="XrSystemPassthroughPropertiesFB"/>
            <type name="XrSystemPassthroughProperties2FB"/>
            <type name="XrPassthroughCreateInfoFB"/>
            <type name="XrPassthroughLayerCreateInfoFB"/>
            <type name="XrCompositionLayerPassthroughFB"/>
            <type name="XrGeometryInstanceCreateInfoFB"/>
            <type name="XrGeometryInstanceTransformFB"/>
            <type name="XrPassthroughStyleFB"/>
            <type name="XrPassthroughColorMapMonoToRgbaFB"/>
            <type name="XrPassthroughColorMapMonoToMonoFB"/>
            <type name="XrPassthroughBrightnessContrastSaturationFB"/>
            <type name="XrEventDataPassthroughStateChangedFB"/>

            <command name="xrCreatePassthroughFB"/>
            <command name="xrDestroyPassthroughFB"/>
            <command name="xrPassthroughStartFB"/>
            <command name="xrPassthroughPauseFB"/>
            <command name="xrCreatePassthroughLayerFB"/>
            <command name="xrDestroyPassthroughLayerFB"/>
            <command name="xrPassthroughLayerPauseFB"/>
            <command name="xrPassthroughLayerResumeFB"/>
            <command name="xrPassthroughLayerSetStyleFB"/>
            <command name="xrCreateGeometryInstanceFB"/>
            <command name="xrDestroyGeometryInstanceFB"/>
            <command name="xrGeometryInstanceSetTransformFB"/>
        </require>
    </extension>

    <extension name="XR_FB_render_model" number="120" type="instance" supported="openxr">
        <require>
            <enum value="3"                              name="XR_FB_render_model_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_render_model&quot;" name="XR_FB_RENDER_MODEL_EXTENSION_NAME"/>

            <type name="XrRenderModelPathInfoFB"/>
            <type name="XrRenderModelPropertiesFB"/>
            <type name="XrRenderModelBufferFB"/>
            <type name="XrRenderModelLoadInfoFB"/>
            <type name="XrRenderModelKeyFB"/>
            <type name="XrSystemRenderModelPropertiesFB"/>
            <type name="XrRenderModelCapabilitiesRequestFB"/>
            <type name="XR_NULL_RENDER_MODEL_KEY_FB"/>

            <command name="xrEnumerateRenderModelPathsFB"/>
            <command name="xrGetRenderModelPropertiesFB"/>
            <command name="xrLoadRenderModelFB"/>

            <enum value="64"                                    name="XR_MAX_RENDER_MODEL_NAME_SIZE_FB"/>

            <enum offset="0"          extends="XrStructureType" name="XR_TYPE_RENDER_MODEL_PATH_INFO_FB"/>
            <enum offset="1"          extends="XrStructureType" name="XR_TYPE_RENDER_MODEL_PROPERTIES_FB"/>
            <enum offset="2"          extends="XrStructureType" name="XR_TYPE_RENDER_MODEL_BUFFER_FB"/>
            <enum offset="3"          extends="XrStructureType" name="XR_TYPE_RENDER_MODEL_LOAD_INFO_FB"/>
            <enum offset="4"          extends="XrStructureType" name="XR_TYPE_SYSTEM_RENDER_MODEL_PROPERTIES_FB"/>
            <enum offset="5"          extends="XrStructureType" name="XR_TYPE_RENDER_MODEL_CAPABILITIES_REQUEST_FB"/>
            <enum offset="0"  dir="-" extends="XrResult"        name="XR_ERROR_RENDER_MODEL_KEY_INVALID_FB"      comment="The model key is invalid."/>
            <enum offset="20"         extends="XrResult"        name="XR_RENDER_MODEL_UNAVAILABLE_FB"            comment="The model is unavailable."/>
        </require>
    </extension>

    <extension name="XR_KHR_binding_modification" number="121" type="instance" supported="openxr">
        <require>
            <enum value="1" name="XR_KHR_binding_modification_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_binding_modification&quot;" name="XR_KHR_BINDING_MODIFICATION_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_BINDING_MODIFICATIONS_KHR"/>
            <type name="XrBindingModificationsKHR"/>
            <type name="XrBindingModificationBaseHeaderKHR"/>
        </require>
    </extension>

    <extension name="XR_VARJO_foveated_rendering" number="122" type="instance" requires="XR_VARJO_quad_views" supported="openxr">
        <require>
            <enum value="2" name="XR_VARJO_foveated_rendering_SPEC_VERSION"/>
            <enum value="&quot;XR_VARJO_foveated_rendering&quot;" name="XR_VARJO_FOVEATED_RENDERING_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_VIEW_LOCATE_FOVEATED_RENDERING_VARJO"/>
            <enum offset="1" extends="XrStructureType" name="XR_TYPE_FOVEATED_VIEW_CONFIGURATION_VIEW_VARJO"/>
            <enum offset="2" extends="XrStructureType" name="XR_TYPE_SYSTEM_FOVEATED_RENDERING_PROPERTIES_VARJO"/>

            <enum offset="0" extends="XrReferenceSpaceType" name="XR_REFERENCE_SPACE_TYPE_COMBINED_EYE_VARJO"/>

            <type name="XrViewLocateFoveatedRenderingVARJO"/>
            <type name="XrFoveatedViewConfigurationViewVARJO"/>
            <type name="XrSystemFoveatedRenderingPropertiesVARJO"/>
        </require>
    </extension>

    <extension name="XR_VARJO_composition_layer_depth_test" number="123" type="instance" requires="XR_KHR_composition_layer_depth" supported="openxr">
        <require>
            <enum value="2" name="XR_VARJO_composition_layer_depth_test_SPEC_VERSION"/>
            <enum value="&quot;XR_VARJO_composition_layer_depth_test&quot;" name="XR_VARJO_COMPOSITION_LAYER_DEPTH_TEST_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_VARJO"/>
            <type name="XrCompositionLayerDepthTestVARJO"/>
        </require>
    </extension>

    <extension name="XR_VARJO_environment_depth_estimation" number="124" type="instance" supported="openxr">
        <require>
            <enum value="1" name="XR_VARJO_environment_depth_estimation_SPEC_VERSION"/>
            <enum value="&quot;XR_VARJO_environment_depth_estimation&quot;" name="XR_VARJO_ENVIRONMENT_DEPTH_ESTIMATION_EXTENSION_NAME"/>
            <command name="xrSetEnvironmentDepthEstimationVARJO"/>
        </require>
    </extension>

    <extension name="XR_VARJO_marker_tracking" number="125" type="instance" supported="openxr">
        <require>
            <enum value="1"                                    name="XR_VARJO_marker_tracking_SPEC_VERSION"/>
            <enum value="&quot;XR_VARJO_marker_tracking&quot;" name="XR_VARJO_MARKER_TRACKING_EXTENSION_NAME"/>

            <enum offset="0"         extends="XrStructureType" name="XR_TYPE_SYSTEM_MARKER_TRACKING_PROPERTIES_VARJO"/>
            <enum offset="1"         extends="XrStructureType" name="XR_TYPE_EVENT_DATA_MARKER_TRACKING_UPDATE_VARJO"/>
            <enum offset="2"         extends="XrStructureType" name="XR_TYPE_MARKER_SPACE_CREATE_INFO_VARJO"/>


            <enum offset="0" dir="-" extends="XrResult"        name="XR_ERROR_MARKER_NOT_TRACKED_VARJO"               comment="Marker tracking is disabled or the specified marker is not currently tracked."/>
            <enum offset="1" dir="-" extends="XrResult"        name="XR_ERROR_MARKER_ID_INVALID_VARJO"                comment="The specified marker ID is not valid."/>

            <type name="XrSystemMarkerTrackingPropertiesVARJO"/>
            <type name="XrEventDataMarkerTrackingUpdateVARJO"/>
            <type name="XrMarkerSpaceCreateInfoVARJO"/>

            <command name="xrSetMarkerTrackingVARJO"/>
            <command name="xrSetMarkerTrackingTimeoutVARJO"/>
            <command name="xrSetMarkerTrackingPredictionVARJO"/>
            <command name="xrGetMarkerSizeVARJO"/>
            <command name="xrCreateMarkerSpaceVARJO"/>
        </require>
    </extension>

    <extension name="XR_VARJO_view_offset" number="126" type="instance" supported="openxr">
        <require>
            <enum value="1"                                name="XR_VARJO_view_offset_SPEC_VERSION"/>
            <enum value="&quot;XR_VARJO_view_offset&quot;" name="XR_VARJO_VIEW_OFFSET_EXTENSION_NAME"/>
            <command name="xrSetViewOffsetVARJO"/>
        </require>
    </extension>

    <extension name="XR_VARJO_extension_127" number="127" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_VARJO_extension_127_SPEC_VERSION"/>
            <enum value="&quot;XR_VARJO_extension_127&quot;" name="XR_VARJO_extension_127_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_VARJO_extension_128" number="128" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_VARJO_extension_128_SPEC_VERSION"/>
            <enum value="&quot;XR_VARJO_extension_128&quot;" name="XR_VARJO_extension_128_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_VARJO_extension_129" number="129" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_VARJO_extension_129_SPEC_VERSION"/>
            <enum value="&quot;XR_VARJO_extension_129&quot;" name="XR_VARJO_extension_129_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_VARJO_extension_130" number="130" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_VARJO_extension_130_SPEC_VERSION"/>
            <enum value="&quot;XR_VARJO_extension_130&quot;" name="XR_VARJO_extension_130_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_VARJO_extension_131" number="131" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_VARJO_extension_131_SPEC_VERSION"/>
            <enum value="&quot;XR_VARJO_extension_131&quot;" name="XR_VARJO_extension_131_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_VARJO_extension_132" number="132" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_VARJO_extension_132_SPEC_VERSION"/>
            <enum value="&quot;XR_VARJO_extension_132&quot;" name="XR_VARJO_extension_132_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_ML_extension_133" number="133" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_ML_extension_133_SPEC_VERSION"/>
            <enum value="&quot;XR_ML_extension_133&quot;" name="XR_ML_extension_133_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_ML_extension_134" number="134" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_ML_extension_134_SPEC_VERSION"/>
            <enum value="&quot;XR_ML_extension_134&quot;" name="XR_ML_extension_134_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_ML_ml2_controller_interaction" number="135" type="instance" supported="openxr">
        <require>
            <enum value="1"                                            name="XR_ML_ml2_controller_interaction_SPEC_VERSION"/>
            <enum value="&quot;XR_ML_ml2_controller_interaction&quot;" name="XR_ML_ML2_CONTROLLER_INTERACTION_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_ML_extension_136" number="136" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_ML_extension_136_SPEC_VERSION"/>
            <enum value="&quot;XR_ML_extension_136&quot;" name="XR_ML_extension_136_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_ML_extension_137" number="137" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_ML_extension_137_SPEC_VERSION"/>
            <enum value="&quot;XR_ML_extension_137&quot;" name="XR_ML_extension_137_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_ML_extension_138" number="138" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_ML_extension_138_SPEC_VERSION"/>
            <enum value="&quot;XR_ML_extension_138&quot;" name="XR_ML_extension_138_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_ML_extension_139" number="139" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_ML_extension_139_SPEC_VERSION"/>
            <enum value="&quot;XR_ML_extension_139&quot;" name="XR_ML_extension_139_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_ML_extension_140" number="140" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_ML_extension_140_SPEC_VERSION"/>
            <enum value="&quot;XR_ML_extension_140&quot;" name="XR_ML_extension_140_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_ML_extension_141" number="141" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_ML_extension_141_SPEC_VERSION"/>
            <enum value="&quot;XR_ML_extension_141&quot;" name="XR_ML_extension_141_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_ML_extension_142" number="142" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_ML_extension_142_SPEC_VERSION"/>
            <enum value="&quot;XR_ML_extension_142&quot;" name="XR_ML_extension_142_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_spatial_anchor_persistence" number="143" requires="XR_MSFT_spatial_anchor" type="instance" supported="openxr">
        <require>
            <enum value="2"                                              name="XR_MSFT_spatial_anchor_persistence_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_spatial_anchor_persistence&quot;" name="XR_MSFT_SPATIAL_ANCHOR_PERSISTENCE_EXTENSION_NAME"/>

            <type name="XrSpatialAnchorStoreConnectionMSFT"/>
            <type name="XrSpatialAnchorPersistenceNameMSFT"/>
            <type name="XrSpatialAnchorPersistenceInfoMSFT"/>
            <type name="XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT"/>

            <command name="xrCreateSpatialAnchorStoreConnectionMSFT"/>
            <command name="xrDestroySpatialAnchorStoreConnectionMSFT"/>
            <command name="xrPersistSpatialAnchorMSFT"/>
            <command name="xrEnumeratePersistedSpatialAnchorNamesMSFT"/>
            <command name="xrCreateSpatialAnchorFromPersistedNameMSFT"/>
            <command name="xrUnpersistSpatialAnchorMSFT"/>
            <command name="xrClearSpatialAnchorStoreMSFT"/>

            <enum offset="0"         extends="XrObjectType"    name="XR_OBJECT_TYPE_SPATIAL_ANCHOR_STORE_CONNECTION_MSFT"           comment="XrSpatialAnchorStoreConnectionMSFT"/>

            <enum offset="0"         extends="XrStructureType" name="XR_TYPE_SPATIAL_ANCHOR_PERSISTENCE_INFO_MSFT"/>
            <enum offset="1"         extends="XrStructureType" name="XR_TYPE_SPATIAL_ANCHOR_FROM_PERSISTED_ANCHOR_CREATE_INFO_MSFT"/>

            <enum offset="1" dir="-" extends="XrResult"        name="XR_ERROR_SPATIAL_ANCHOR_NAME_NOT_FOUND_MSFT"                   comment="A spatial anchor was not found associated with the spatial anchor name provided"/>
            <enum offset="2" dir="-" extends="XrResult"        name="XR_ERROR_SPATIAL_ANCHOR_NAME_INVALID_MSFT"                     comment="The spatial anchor name provided was not valid"/>

            <enum value="256"                                  name="XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_MSFT"/>
        </require>
    </extension>
    <extension name="XR_MSFT_extension_144" number="144" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_MSFT_extension_144_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_144&quot;" name="XR_MSFT_extension_144_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_145" number="145" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_MSFT_extension_145_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_145&quot;" name="XR_MSFT_extension_145_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_146" number="146" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_MSFT_extension_146_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_146&quot;" name="XR_MSFT_extension_146_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_147" number="147" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_MSFT_extension_147_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_147&quot;" name="XR_MSFT_extension_147_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_148" number="148" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_MSFT_extension_148_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_148&quot;" name="XR_MSFT_extension_148_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_KHR_extension_149" number="149" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_KHR_extension_149_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_extension_149&quot;" name="XR_KHR_extension_149_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_ULTRALEAP_hand_tracking_forearm" number="150" requires="XR_EXT_hand_tracking" type="instance" supported="openxr">
        <require>
            <enum value="1"                                              name="XR_ULTRALEAP_hand_tracking_forearm_SPEC_VERSION"/>
            <enum value="&quot;XR_ULTRALEAP_hand_tracking_forearm&quot;" name="XR_ULTRALEAP_HAND_TRACKING_FOREARM_EXTENSION_NAME"/>

            <type name="XrHandForearmJointULTRALEAP"/>
            <type name="XR_HAND_FOREARM_JOINT_COUNT_ULTRALEAP"/>

            <enum offset="0" extends="XrHandJointSetEXT" name="XR_HAND_JOINT_SET_HAND_WITH_FOREARM_ULTRALEAP"/>
        </require>
    </extension>

    <extension name="XR_ULTRALEAP_extension_151" number="151" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_ULTRALEAP_extension_151_SPEC_VERSION"/>
            <enum value="&quot;XR_ULTRALEAP_extension_151&quot;" name="XR_ULTRALEAP_extension_151_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_ULTRALEAP_extension_152" number="152" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_ULTRALEAP_extension_152_SPEC_VERSION"/>
            <enum value="&quot;XR_ULTRALEAP_extension_152&quot;" name="XR_ULTRALEAP_extension_152_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_ULTRALEAP_extension_153" number="153" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_ULTRALEAP_extension_153_SPEC_VERSION"/>
            <enum value="&quot;XR_ULTRALEAP_extension_153&quot;" name="XR_ULTRALEAP_extension_153_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_ULTRALEAP_extension_154" number="154" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_ULTRALEAP_extension_154_SPEC_VERSION"/>
            <enum value="&quot;XR_ULTRALEAP_extension_154&quot;" name="XR_ULTRALEAP_extension_154_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_ULTRALEAP_extension_155" number="155" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_ULTRALEAP_extension_155_SPEC_VERSION"/>
            <enum value="&quot;XR_ULTRALEAP_extension_155&quot;" name="XR_ULTRALEAP_extension_155_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_156" number="156" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_156_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_156&quot;" name="XR_FB_extension_156_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_spatial_entity_query" number="157" type="instance" requires="XR_FB_spatial_entity_storage" supported="openxr">
        <require>
            <enum value="1"                                      name="XR_FB_spatial_entity_query_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_spatial_entity_query&quot;" name="XR_FB_SPATIAL_ENTITY_QUERY_EXTENSION_NAME"/>

            <enum offset="1"   extends="XrStructureType"         name="XR_TYPE_SPACE_QUERY_INFO_FB"/>
            <enum offset="2"   extends="XrStructureType"         name="XR_TYPE_SPACE_QUERY_RESULTS_FB"/>
            <enum offset="3"   extends="XrStructureType"         name="XR_TYPE_SPACE_STORAGE_LOCATION_FILTER_INFO_FB"/>
            <enum offset="54"  extends="XrStructureType"         name="XR_TYPE_SPACE_UUID_FILTER_INFO_FB"/>
            <enum offset="52"  extends="XrStructureType"         name="XR_TYPE_SPACE_COMPONENT_FILTER_INFO_FB"/>
            <enum offset="103" extends="XrStructureType"         name="XR_TYPE_EVENT_DATA_SPACE_QUERY_RESULTS_AVAILABLE_FB"/>
            <enum offset="104" extends="XrStructureType"         name="XR_TYPE_EVENT_DATA_SPACE_QUERY_COMPLETE_FB"/>

            <type name="XrSpaceQueryActionFB"/>

            <type name="XrSpaceQueryInfoBaseHeaderFB"/>
            <type name="XrSpaceFilterInfoBaseHeaderFB"/>
            <type name="XrSpaceQueryInfoFB"/>
            <type name="XrSpaceStorageLocationFilterInfoFB"/>
            <type name="XrSpaceUuidFilterInfoFB"/>
            <type name="XrSpaceComponentFilterInfoFB"/>
            <type name="XrSpaceQueryResultFB"/>
            <type name="XrSpaceQueryResultsFB"/>

            <type name="XrEventDataSpaceQueryResultsAvailableFB"/>
            <type name="XrEventDataSpaceQueryCompleteFB"/>

            <command name="xrQuerySpacesFB"/>
            <command name="xrRetrieveSpaceQueryResultsFB"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_158" number="158" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_158_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_158&quot;" name="XR_FB_extension_158_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_spatial_entity_storage" number="159" type="instance" requires="XR_FB_spatial_entity" supported="openxr">
        <require>
            <enum value="1"                                        name="XR_FB_spatial_entity_storage_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_spatial_entity_storage&quot;" name="XR_FB_SPATIAL_ENTITY_STORAGE_EXTENSION_NAME"/>

            <enum offset="0"   extends="XrStructureType"           name="XR_TYPE_SPACE_SAVE_INFO_FB"/>
            <enum offset="1"   extends="XrStructureType"           name="XR_TYPE_SPACE_ERASE_INFO_FB"/>
            <enum offset="106" extends="XrStructureType"           name="XR_TYPE_EVENT_DATA_SPACE_SAVE_COMPLETE_FB"/>
            <enum offset="107" extends="XrStructureType"           name="XR_TYPE_EVENT_DATA_SPACE_ERASE_COMPLETE_FB"/>

            <type name="XrSpaceStorageLocationFB"/>
            <type name="XrSpacePersistenceModeFB"/>

            <type name="XrSpaceSaveInfoFB"/>
            <type name="XrSpaceEraseInfoFB"/>

            <type name="XrEventDataSpaceSaveCompleteFB"/>
            <type name="XrEventDataSpaceEraseCompleteFB"/>

            <command name="xrSaveSpaceFB"/>
            <command name="xrEraseSpaceFB"/>
        </require>
    </extension>

    <extension name="XR_OCULUS_audio_device_guid" number="160" type="instance" supported="openxr" protect="XR_USE_PLATFORM_WIN32">
        <require>
            <enum value="1" name="XR_OCULUS_audio_device_guid_SPEC_VERSION"/>
            <enum value="&quot;XR_OCULUS_audio_device_guid&quot;" name="XR_OCULUS_AUDIO_DEVICE_GUID_EXTENSION_NAME"/>
            <enum value="128" name="XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS"/>
            <command name="xrGetAudioOutputDeviceGuidOculus"/>
            <command name="xrGetAudioInputDeviceGuidOculus"/>
        </require>
    </extension>

    <extension name="XR_FB_foveation_vulkan" number="161" type="instance" requires="XR_FB_foveation" protect="XR_USE_GRAPHICS_API_VULKAN" supported="openxr">
        <require>
            <enum value="1"                                  name="XR_FB_foveation_vulkan_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_foveation_vulkan&quot;" name="XR_FB_FOVEATION_VULKAN_EXTENSION_NAME"/>

            <enum offset="0" extends="XrStructureType"       name="XR_TYPE_SWAPCHAIN_IMAGE_FOVEATION_VULKAN_FB"/>

            <type name="XrSwapchainImageFoveationVulkanFB"/>
        </require>
    </extension>

    <extension name="XR_FB_swapchain_update_state_android_surface" number="162" type="instance" supported="openxr" protect="XR_USE_PLATFORM_ANDROID" requires="XR_KHR_android_surface_swapchain,XR_FB_swapchain_update_state">
        <require>
            <enum value="1" name="XR_FB_swapchain_update_state_android_surface_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_swapchain_update_state_android_surface&quot;" name="XR_FB_SWAPCHAIN_UPDATE_STATE_ANDROID_SURFACE_EXTENSION_NAME"/>
            <type name="XrSwapchainStateAndroidSurfaceDimensionsFB"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_SWAPCHAIN_STATE_ANDROID_SURFACE_DIMENSIONS_FB"/>
        </require>
    </extension>

    <extension name="XR_FB_swapchain_update_state_opengl_es" number="163" type="instance" supported="openxr" protect="XR_USE_GRAPHICS_API_OPENGL_ES" requires="XR_KHR_opengl_es_enable,XR_FB_swapchain_update_state">
        <require>
            <enum value="1" name="XR_FB_swapchain_update_state_opengl_es_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_swapchain_update_state_opengl_es&quot;" name="XR_FB_SWAPCHAIN_UPDATE_STATE_OPENGL_ES_EXTENSION_NAME"/>
            <type name="XrSwapchainStateSamplerOpenGLESFB"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_SWAPCHAIN_STATE_SAMPLER_OPENGL_ES_FB"/>
        </require>
    </extension>

    <extension name="XR_FB_swapchain_update_state_vulkan" number="164" type="instance" supported="openxr" protect="XR_USE_GRAPHICS_API_VULKAN" requires="XR_KHR_vulkan_enable,XR_FB_swapchain_update_state">
        <require>
            <enum value="1" name="XR_FB_swapchain_update_state_vulkan_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_swapchain_update_state_vulkan&quot;" name="XR_FB_SWAPCHAIN_UPDATE_STATE_VULKAN_EXTENSION_NAME"/>
            <type name="XrSwapchainStateSamplerVulkanFB"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_SWAPCHAIN_STATE_SAMPLER_VULKAN_FB"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_165" number="165" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_165_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_165&quot;" name="XR_FB_extension_165_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_KHR_swapchain_usage_input_attachment_bit" number="166" type="instance" supported="openxr">
        <require>
            <enum value="3"                                                       name="XR_KHR_swapchain_usage_input_attachment_bit_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_swapchain_usage_input_attachment_bit&quot;" name="XR_KHR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_EXTENSION_NAME"/>
            <enum extends="XrSwapchainUsageFlagBits"                              name="XR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_KHR"                alias="XR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_MND" comment="Specifies that the image may: be used as a input attachment."/>
        </require>
    </extension>

    <extension name="XR_FB_extension_167" number="167" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_167_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_167&quot;" name="XR_FB_extension_167_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_168" number="168" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_168_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_168&quot;" name="XR_FB_extension_168_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_169" number="169" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_169_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_169&quot;" name="XR_FB_extension_169_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_170" number="170" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_170_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_170&quot;" name="XR_FB_extension_170_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_171" number="171" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_171_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_171&quot;" name="XR_FB_extension_171_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_space_warp" number="172" type="instance" supported="openxr">
        <require>
            <enum value="2"                            name="XR_FB_space_warp_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_space_warp&quot;" name="XR_FB_SPACE_WARP_EXTENSION_NAME"/>
            <type name="XrCompositionLayerSpaceWarpInfoFB"/>
            <enum offset="0" extends="XrStructureType" name="XR_TYPE_COMPOSITION_LAYER_SPACE_WARP_INFO_FB"/>
            <type name="XrSystemSpaceWarpPropertiesFB"/>
            <enum offset="1" extends="XrStructureType" name="XR_TYPE_SYSTEM_SPACE_WARP_PROPERTIES_FB"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_173" number="173" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_173_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_173&quot;" name="XR_FB_extension_173_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_174" number="174" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_174_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_174&quot;" name="XR_FB_extension_174_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_175" number="175" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_175_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_175&quot;" name="XR_FB_extension_175_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_scene" number="176" type="instance" requires="XR_FB_spatial_entity" supported="openxr">
        <require>
            <enum value="1"                            name="XR_FB_scene_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_scene&quot;"      name="XR_FB_SCENE_EXTENSION_NAME"/>

            <enum offset="0" extends="XrStructureType" name="XR_TYPE_SEMANTIC_LABELS_FB"/>
            <enum offset="1" extends="XrStructureType" name="XR_TYPE_ROOM_LAYOUT_FB"/>
            <enum offset="2" extends="XrStructureType" name="XR_TYPE_BOUNDARY_2D_FB"/>

            <type name="XrExtent3DfFB"/>
            <type name="XrOffset3DfFB"/>
            <type name="XrRect3DfFB"/>
            <type name="XrSemanticLabelsFB"/>
            <type name="XrRoomLayoutFB"/>
            <type name="XrBoundary2DFB"/>

            <command name="xrGetSpaceBoundingBox2DFB"/>
            <command name="xrGetSpaceBoundingBox3DFB"/>
            <command name="xrGetSpaceSemanticLabelsFB"/>
            <command name="xrGetSpaceBoundary2DFB"/>
            <command name="xrGetSpaceRoomLayoutFB"/>

        </require>
    </extension>

    <extension name="XR_EXT_palm_pose" number="177" type="instance" supported="openxr">
        <require>
            <enum value="2"                            name="XR_EXT_palm_pose_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_palm_pose&quot;" name="XR_EXT_PALM_POSE_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_UNITY_extension_178" number="178" type="instance" supported="disabled">
        <require>
            <enum value="1"                                  name="XR_UNITY_extension_178_SPEC_VERSION"/>
            <enum value="&quot;XR_UNITY_extension_178&quot;" name="XR_UNITY_EXTENSION_178_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_UNITY_extension_179" number="179" type="instance" supported="disabled">
        <require>
            <enum value="1"                                  name="XR_UNITY_extension_179_SPEC_VERSION"/>
            <enum value="&quot;XR_UNITY_extension_179&quot;" name="XR_UNITY_EXTENSION_179_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_UNITY_extension_180" number="180" type="instance" supported="disabled">
        <require>
            <enum value="1"                                  name="XR_UNITY_extension_180_SPEC_VERSION"/>
            <enum value="&quot;XR_UNITY_extension_180&quot;" name="XR_UNITY_EXTENSION_180_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_UNITY_extension_181" number="181" type="instance" supported="disabled">
        <require>
            <enum value="1"                                  name="XR_UNITY_extension_181_SPEC_VERSION"/>
            <enum value="&quot;XR_UNITY_extension_181&quot;" name="XR_UNITY_EXTENSION_181_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_UNITY_extension_182" number="182" type="instance" supported="disabled">
        <require>
            <enum value="1"                                  name="XR_UNITY_extension_182_SPEC_VERSION"/>
            <enum value="&quot;XR_UNITY_extension_182&quot;" name="XR_UNITY_EXTENSION_182_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_UNITY_extension_183" number="183" type="instance" supported="disabled">
        <require>
            <enum value="1"                                  name="XR_UNITY_extension_183_SPEC_VERSION"/>
            <enum value="&quot;XR_UNITY_extension_183&quot;" name="XR_UNITY_EXTENSION_183_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_UNITY_extension_184" number="184" type="instance" supported="disabled">
        <require>
            <enum value="1"                                  name="XR_UNITY_extension_184_SPEC_VERSION"/>
            <enum value="&quot;XR_UNITY_extension_184&quot;" name="XR_UNITY_EXTENSION_184_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_UNITY_extension_185" number="185" type="instance" supported="disabled">
        <require>
            <enum value="1"                                  name="XR_UNITY_extension_185_SPEC_VERSION"/>
            <enum value="&quot;XR_UNITY_extension_185&quot;" name="XR_UNITY_EXTENSION_185_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_UNITY_extension_186" number="186" type="instance" supported="disabled">
        <require>
            <enum value="1"                                  name="XR_UNITY_extension_186_SPEC_VERSION"/>
            <enum value="&quot;XR_UNITY_extension_186&quot;" name="XR_UNITY_EXTENSION_186_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_LIV_extension_187" number="187" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_LIV_extension_187_SPEC_VERSION"/>
            <enum value="&quot;XR_LIV_extension_187&quot;" name="XR_LIV_EXTENSION_187_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_LIV_extension_188" number="188" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_LIV_extension_188_SPEC_VERSION"/>
            <enum value="&quot;XR_LIV_extension_188&quot;" name="XR_LIV_EXTENSION_188_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_LIV_extension_189" number="189" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_LIV_extension_189_SPEC_VERSION"/>
            <enum value="&quot;XR_LIV_extension_189&quot;" name="XR_LIV_EXTENSION_189_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_LIV_extension_190" number="190" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_LIV_extension_190_SPEC_VERSION"/>
            <enum value="&quot;XR_LIV_extension_190&quot;" name="XR_LIV_EXTENSION_190_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_LIV_extension_191" number="191" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_LIV_extension_191_SPEC_VERSION"/>
            <enum value="&quot;XR_LIV_extension_191&quot;" name="XR_LIV_EXTENSION_191_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_LIV_extension_192" number="192" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_LIV_extension_192_SPEC_VERSION"/>
            <enum value="&quot;XR_LIV_extension_192&quot;" name="XR_LIV_EXTENSION_192_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_LIV_extension_193" number="193" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_LIV_extension_193_SPEC_VERSION"/>
            <enum value="&quot;XR_LIV_extension_193&quot;" name="XR_LIV_EXTENSION_193_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_LIV_extension_194" number="194" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_LIV_extension_194_SPEC_VERSION"/>
            <enum value="&quot;XR_LIV_extension_194&quot;" name="XR_LIV_EXTENSION_194_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_LIV_extension_195" number="195" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_LIV_extension_195_SPEC_VERSION"/>
            <enum value="&quot;XR_LIV_extension_195&quot;" name="XR_LIV_EXTENSION_195_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_LIV_extension_196" number="196" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_LIV_extension_196_SPEC_VERSION"/>
            <enum value="&quot;XR_LIV_extension_196&quot;" name="XR_LIV_EXTENSION_196_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_ALMALENCE_digital_lens_control" number="197" type="instance" supported="openxr">
        <require>
            <enum value="1"                                             name="XR_ALMALENCE_digital_lens_control_SPEC_VERSION"/>
            <enum value="&quot;XR_ALMALENCE_digital_lens_control&quot;" name="XR_ALMALENCE_DIGITAL_LENS_CONTROL_EXTENSION_NAME"/>

            <command name="xrSetDigitalLensControlALMALENCE"/>

            <enum offset="0" extends="XrStructureType" name="XR_TYPE_DIGITAL_LENS_CONTROL_ALMALENCE"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_198" number="198" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_198_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_198&quot;" name="XR_FB_EXTENSION_198_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_199" number="199" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_199_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_199&quot;" name="XR_FB_EXTENSION_199_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_spatial_entity_container" number="200" type="instance" requires="XR_FB_spatial_entity" supported="openxr">
        <require>
            <enum value="2"                                          name="XR_FB_spatial_entity_container_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_spatial_entity_container&quot;" name="XR_FB_SPATIAL_ENTITY_CONTAINER_EXTENSION_NAME"/>

            <enum offset="0" extends="XrStructureType"               name="XR_TYPE_SPACE_CONTAINER_FB"/>

            <type name="XrSpaceContainerFB"/>

            <command name="xrGetSpaceContainerFB"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_201" number="201" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_201_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_201&quot;" name="XR_FB_EXTENSION_201_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_202" number="202" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_202_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_202&quot;" name="XR_FB_EXTENSION_202_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_203" number="203" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_203_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_203&quot;" name="XR_FB_EXTENSION_203_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_passthrough_keyboard_hands" number="204" type="instance" supported="openxr" requires="XR_FB_passthrough">
        <require>
            <enum value="2"                                            name="XR_FB_passthrough_keyboard_hands_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_passthrough_keyboard_hands&quot;" name="XR_FB_PASSTHROUGH_KEYBOARD_HANDS_EXTENSION_NAME"/>

            <enum offset="1" extends="XrPassthroughLayerPurposeFB"     name="XR_PASSTHROUGH_LAYER_PURPOSE_TRACKED_KEYBOARD_HANDS_FB"        comment="Passthrough layer purpose for keyboard hands presence."/>
            <enum offset="2" extends="XrPassthroughLayerPurposeFB"     name="XR_PASSTHROUGH_LAYER_PURPOSE_TRACKED_KEYBOARD_MASKED_HANDS_FB" comment="Passthrough layer purpose for keyboard hands presence with keyboard masked hand transitions (i.e passthrough hands rendered only when they are over the keyboard)."/>

            <enum offset="2" extends="XrStructureType"                 name="XR_TYPE_PASSTHROUGH_KEYBOARD_HANDS_INTENSITY_FB"/>

            <type name="XrPassthroughKeyboardHandsIntensityFB"/>

            <command name="xrPassthroughLayerSetKeyboardHandsIntensityFB"/>
        </require>
    </extension>

    <extension name="XR_FB_composition_layer_settings" number="205" type="instance" supported="openxr">
        <require>
            <enum value="1"                                            name="XR_FB_composition_layer_settings_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_composition_layer_settings&quot;" name="XR_FB_COMPOSITION_LAYER_SETTINGS_EXTENSION_NAME"/>

            <enum offset="0" extends="XrStructureType"                 name="XR_TYPE_COMPOSITION_LAYER_SETTINGS_FB"/>
            <type name="XrCompositionLayerSettingsFB"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_206" number="206" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_206_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_206&quot;" name="XR_FB_EXTENSION_206_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_207" number="207" type="instance" supported="disabled">
        <require>
            <enum value="1" name="XR_FB_extension_207_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_207&quot;" name="XR_FB_EXTENSION_207_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_208" number="208" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_208_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_208&quot;" name="XR_FB_EXTENSION_208_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_209" number="209" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_209_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_209&quot;" name="XR_FB_EXTENSION_209_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_210" number="210" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_210_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_210&quot;" name="XR_FB_EXTENSION_210_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_211" number="211" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_211_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_211&quot;" name="XR_FB_EXTENSION_211_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_212" number="212" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_212_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_212&quot;" name="XR_FB_EXTENSION_212_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_213" number="213" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_213_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_213&quot;" name="XR_FB_EXTENSION_213_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_214" number="214" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_214_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_214&quot;" name="XR_FB_EXTENSION_214_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_215" number="215" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_215_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_215&quot;" name="XR_FB_EXTENSION_215_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_216" number="216" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_216_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_216&quot;" name="XR_FB_EXTENSION_216_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_217" number="217" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_217_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_217&quot;" name="XR_FB_EXTENSION_217_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_218" number="218" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_218_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_218&quot;" name="XR_FB_EXTENSION_218_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_219" number="219" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_219_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_219&quot;" name="XR_FB_EXTENSION_219_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_220" number="220" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_220_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_220&quot;" name="XR_FB_EXTENSION_220_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_221" number="221" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_221_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_221&quot;" name="XR_FB_EXTENSION_221_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_222" number="222" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_222_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_222&quot;" name="XR_FB_EXTENSION_222_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_223" number="223" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_223_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_223&quot;" name="XR_FB_EXTENSION_223_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_224" number="224" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_224_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_224&quot;" name="XR_FB_EXTENSION_224_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_225" number="225" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_225_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_225&quot;" name="XR_FB_EXTENSION_225_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_226" number="226" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_226_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_226&quot;" name="XR_FB_EXTENSION_226_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_227" number="227" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_227_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_227&quot;" name="XR_FB_EXTENSION_227_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_META_vulkan_swapchain_create_info" number="228" type="instance" protect="XR_USE_GRAPHICS_API_VULKAN" supported="openxr">
        <require>
            <enum value="1"                                                name="XR_META_vulkan_swapchain_create_info_SPEC_VERSION"/>
            <enum value="&quot;XR_META_vulkan_swapchain_create_info&quot;" name="XR_META_VULKAN_SWAPCHAIN_CREATE_INFO_EXTENSION_NAME"/>

            <enum offset="0" extends="XrStructureType"                     name="XR_TYPE_VULKAN_SWAPCHAIN_CREATE_INFO_META"/>

            <type name="XrVulkanSwapchainCreateInfoMETA"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_229" number="229" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_229_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_229&quot;" name="XR_FB_EXTENSION_229_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_230" number="230" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_230_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_230&quot;" name="XR_FB_EXTENSION_230_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_231" number="231" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_231_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_231&quot;" name="XR_FB_EXTENSION_231_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_232" number="232" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_232_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_232&quot;" name="XR_FB_EXTENSION_232_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_META_performance_metrics" number="233" type="instance" supported="openxr">
        <require>
            <enum value="2"                                       name="XR_META_performance_metrics_SPEC_VERSION"/>
            <enum value="&quot;XR_META_performance_metrics&quot;" name="XR_META_PERFORMANCE_METRICS_EXTENSION_NAME"/>

            <enum offset="1" extends="XrStructureType"            name="XR_TYPE_PERFORMANCE_METRICS_STATE_META"/>
            <enum offset="2" extends="XrStructureType"            name="XR_TYPE_PERFORMANCE_METRICS_COUNTER_META"/>

            <type name="XrPerformanceMetricsStateMETA"/>
            <type name="XrPerformanceMetricsCounterMETA"/>

            <type name="XrPerformanceMetricsCounterUnitMETA"/>

            <command name="xrEnumeratePerformanceMetricsCounterPathsMETA"/>
            <command name="xrSetPerformanceMetricsStateMETA"/>
            <command name="xrGetPerformanceMetricsStateMETA"/>
            <command name="xrQueryPerformanceMetricsCounterMETA"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_234" number="234" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_234_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_234&quot;" name="XR_FB_EXTENSION_234_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_235" number="235" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_235_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_235&quot;" name="XR_FB_EXTENSION_235_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_236" number="236" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_236_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_236&quot;" name="XR_FB_EXTENSION_236_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_237" number="237" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_237_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_237&quot;" name="XR_FB_EXTENSION_237_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_238" number="238" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_238_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_238&quot;" name="XR_FB_EXTENSION_238_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_239" number="239" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_239_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_239&quot;" name="XR_FB_EXTENSION_239_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_240" number="240" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_240_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_240&quot;" name="XR_FB_EXTENSION_240_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_241" number="241" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_241_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_241&quot;" name="XR_FB_EXTENSION_241_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_242" number="242" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_242_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_242&quot;" name="XR_FB_EXTENSION_242_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_243" number="243" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_243_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_243&quot;" name="XR_FB_EXTENSION_243_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_244" number="244" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_244_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_244&quot;" name="XR_FB_EXTENSION_244_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_245" number="245" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_245_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_245&quot;" name="XR_FB_EXTENSION_245_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_META_headset_id" number="246" type="instance" requires="XR_EXT_uuid" supported="openxr">
        <require>
            <enum value="1"                              name="XR_META_headset_id_SPEC_VERSION"/>
            <enum value="&quot;XR_META_headset_id&quot;" name="XR_META_HEADSET_ID_EXTENSION_NAME"/>

            <type name="XrSystemHeadsetIdPropertiesMETA"/>

            <enum offset="0" extends="XrStructureType" name="XR_TYPE_SYSTEM_HEADSET_ID_PROPERTIES_META"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_247" number="247" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_247_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_247&quot;" name="XR_FB_EXTENSION_247_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_248" number="248" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_248_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_248&quot;" name="XR_FB_EXTENSION_248_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_249" number="249" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_249_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_249&quot;" name="XR_FB_EXTENSION_249_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_250" number="250" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_250_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_250&quot;" name="XR_FB_EXTENSION_250_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_251" number="251" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_251_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_251&quot;" name="XR_FB_EXTENSION_251_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_252" number="252" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_252_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_252&quot;" name="XR_FB_EXTENSION_252_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_253" number="253" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_253_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_253&quot;" name="XR_FB_EXTENSION_253_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_254" number="254" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_254_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_254&quot;" name="XR_FB_EXTENSION_254_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_255" number="255" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_255_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_255&quot;" name="XR_FB_EXTENSION_255_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_256" number="256" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_256_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_256&quot;" name="XR_FB_EXTENSION_256_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_257" number="257" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_257_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_257&quot;" name="XR_FB_EXTENSION_257_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_258" number="258" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_258_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_258&quot;" name="XR_FB_EXTENSION_258_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_259" number="259" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_259_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_259&quot;" name="XR_FB_EXTENSION_259_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_260" number="260" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_260_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_260&quot;" name="XR_FB_EXTENSION_260_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_261" number="261" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_261_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_261&quot;" name="XR_FB_EXTENSION_261_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_262" number="262" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_262_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_262&quot;" name="XR_FB_EXTENSION_262_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_263" number="263" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_263_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_263&quot;" name="XR_FB_EXTENSION_263_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_264" number="264" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_264_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_264&quot;" name="XR_FB_EXTENSION_264_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_265" number="265" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_265_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_265&quot;" name="XR_FB_EXTENSION_265_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_266" number="266" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_266_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_266&quot;" name="XR_FB_EXTENSION_266_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_267" number="267" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_267_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_267&quot;" name="XR_FB_EXTENSION_267_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_268" number="268" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_268_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_268&quot;" name="XR_FB_EXTENSION_268_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_269" number="269" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_269_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_269&quot;" name="XR_FB_EXTENSION_269_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_270" number="270" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_270_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_270&quot;" name="XR_FB_EXTENSION_270_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_271" number="271" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_271_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_271&quot;" name="XR_FB_EXTENSION_271_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_272" number="272" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_272_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_272&quot;" name="XR_FB_EXTENSION_272_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_273" number="273" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_273_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_273&quot;" name="XR_FB_EXTENSION_273_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_274" number="274" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_274_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_274&quot;" name="XR_FB_EXTENSION_274_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_275" number="275" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_275_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_275&quot;" name="XR_FB_EXTENSION_275_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_276" number="276" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_276_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_276&quot;" name="XR_FB_EXTENSION_276_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_277" number="277" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_277_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_277&quot;" name="XR_FB_EXTENSION_277_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_278" number="278" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_278_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_278&quot;" name="XR_FB_EXTENSION_278_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_279" number="279" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_279_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_279&quot;" name="XR_FB_EXTENSION_279_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_280" number="280" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_280_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_280&quot;" name="XR_FB_EXTENSION_280_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_281" number="281" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_281_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_281&quot;" name="XR_FB_EXTENSION_281_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_282" number="282" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_282_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_282&quot;" name="XR_FB_EXTENSION_282_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_283" number="283" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_283_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_283&quot;" name="XR_FB_EXTENSION_283_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_284" number="284" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_284_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_284&quot;" name="XR_FB_EXTENSION_284_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_285" number="285" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_285_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_285&quot;" name="XR_FB_EXTENSION_285_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_286" number="286" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_286_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_286&quot;" name="XR_FB_EXTENSION_286_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_287" number="287" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_287_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_287&quot;" name="XR_FB_EXTENSION_287_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_288" number="288" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_288_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_288&quot;" name="XR_FB_EXTENSION_288_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_289" number="289" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_289_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_289&quot;" name="XR_FB_EXTENSION_289_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_290" number="290" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_290_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_290&quot;" name="XR_FB_EXTENSION_290_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_291" number="291" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_291_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_291&quot;" name="XR_FB_EXTENSION_291_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_292" number="292" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_292_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_292&quot;" name="XR_FB_EXTENSION_292_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_293" number="293" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_293_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_293&quot;" name="XR_FB_EXTENSION_293_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_294" number="294" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_294_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_294&quot;" name="XR_FB_EXTENSION_294_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_295" number="295" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_295_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_295&quot;" name="XR_FB_EXTENSION_295_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_296" number="296" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_296_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_296&quot;" name="XR_FB_EXTENSION_296_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_297" number="297" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_297_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_297&quot;" name="XR_FB_EXTENSION_297_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_298" number="298" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_298_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_298&quot;" name="XR_FB_EXTENSION_298_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_FB_extension_299" number="299" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_FB_extension_299_SPEC_VERSION"/>
            <enum value="&quot;XR_FB_extension_299&quot;" name="XR_FB_EXTENSION_299_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_EXT_uuid" number="300" type="instance" supported="openxr">
        <require>
            <enum value="1"                       name="XR_EXT_uuid_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_uuid&quot;" name="XR_EXT_UUID_EXTENSION_NAME"/>
            <type name="XrUuidEXT"/>
            <enum value="16" name="XR_UUID_SIZE_EXT"/>
        </require>
    </extension>

    <extension name="XR_EXT_render_model" number="301" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_EXT_render_model_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_render_model&quot;" name="XR_EXT_RENDER_MODEL_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_EXT_controller_model" number="302" type="instance" supported="disabled">
        <require>
            <enum value="1"                                   name="XR_EXT_controller_model_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_controller_model&quot;" name="XR_EXT_CONTROLLER_MODEL_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_EXT_hand_interaction" number="303" type="instance" supported="disabled">
        <require>
            <enum value="1"                                   name="XR_EXT_hand_interaction_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_hand_interaction&quot;" name="XR_EXT_HAND_INTERACTION_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_QCOM_image_tracking" number="304" type="instance" supported="disabled">
        <require>
            <enum value="1"                                  name="XR_QCOM_image_tracking_SPEC_VERSION"/>
            <enum value="&quot;XR_QCOM_image_tracking&quot;" name="XR_QCOM_IMAGE_TRACKING_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_QCOM_object_tracking" number="305" type="instance" supported="disabled">
        <require>
            <enum value="1"                                   name="XR_QCOM_object_tracking_SPEC_VERSION"/>
            <enum value="&quot;XR_QCOM_object_tracking&quot;" name="XR_QCOM_OBJECT_TRACKING_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_QCOM_plane_detection" number="306" type="instance" supported="disabled">
        <require>
            <enum value="1"                                   name="XR_QCOM_plane_detection_SPEC_VERSION"/>
            <enum value="&quot;XR_QCOM_plane_detection&quot;" name="XR_QCOM_PLANE_DETECTION_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_QCOM_tracking_optimization_settings" number="307" type="instance" supported="disabled">
        <require>
            <enum value="1"                                                  name="XR_QCOM_tracking_optimization_settings_SPEC_VERSION"/>
            <enum value="&quot;XR_QCOM_tracking_optimization_settings&quot;" name="XR_QCOM_TRACKING_OPTIMIZATION_SETTINGS_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_QCOM_ray_casting" number="308" type="instance" supported="disabled">
        <require>
            <enum value="1"                               name="XR_QCOM_ray_casting_SPEC_VERSION"/>
            <enum value="&quot;XR_QCOM_ray_casting&quot;" name="XR_QCOM_RAY_CASTING_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_QCOM_extension_309" number="309" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_QCOM_extension_309_SPEC_VERSION"/>
            <enum value="&quot;XR_QCOM_extension_309&quot;" name="XR_QCOM_EXTENSION_309_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_QCOM_extension_310" number="310" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_QCOM_extension_310_SPEC_VERSION"/>
            <enum value="&quot;XR_QCOM_extension_310&quot;" name="XR_QCOM_EXTENSION_310_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_QCOM_extension_311" number="311" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_QCOM_extension_311_SPEC_VERSION"/>
            <enum value="&quot;XR_QCOM_extension_311&quot;" name="XR_QCOM_EXTENSION_311_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_QCOM_extension_312" number="312" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_QCOM_extension_312_SPEC_VERSION"/>
            <enum value="&quot;XR_QCOM_extension_312&quot;" name="XR_QCOM_EXTENSION_312_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_QCOM_extension_313" number="313" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_QCOM_extension_313_SPEC_VERSION"/>
            <enum value="&quot;XR_QCOM_extension_313&quot;" name="XR_QCOM_EXTENSION_313_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_QCOM_extension_314" number="314" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_QCOM_extension_314_SPEC_VERSION"/>
            <enum value="&quot;XR_QCOM_extension_314&quot;" name="XR_QCOM_EXTENSION_314_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_QCOM_extension_315" number="315" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_QCOM_extension_315_SPEC_VERSION"/>
            <enum value="&quot;XR_QCOM_extension_315&quot;" name="XR_QCOM_EXTENSION_315_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_QCOM_extension_316" number="316" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_QCOM_extension_316_SPEC_VERSION"/>
            <enum value="&quot;XR_QCOM_extension_316&quot;" name="XR_QCOM_EXTENSION_316_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_QCOM_extension_317" number="317" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_QCOM_extension_317_SPEC_VERSION"/>
            <enum value="&quot;XR_QCOM_extension_317&quot;" name="XR_QCOM_EXTENSION_317_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_passthrough" number="318" type="instance" supported="openxr">
        <require>
            <enum value="1"                              name="XR_HTC_passthrough_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_passthrough&quot;" name="XR_HTC_PASSTHROUGH_EXTENSION_NAME"/>

            <type name="XrPassthroughHTC"/>
            <enum offset="0" extends="XrObjectType" name="XR_OBJECT_TYPE_PASSTHROUGH_HTC" comment="XrPassthroughHTC"/>

            <type name="XrPassthroughFormHTC"/>

            <type name="XrPassthroughCreateInfoHTC"/>
            <type name="XrPassthroughColorHTC"/>
            <type name="XrPassthroughMeshTransformInfoHTC"/>
            <type name="XrCompositionLayerPassthroughHTC"/>

            <enum offset="1" extends="XrStructureType" name="XR_TYPE_PASSTHROUGH_CREATE_INFO_HTC"/>
            <enum offset="2" extends="XrStructureType" name="XR_TYPE_PASSTHROUGH_COLOR_HTC"/>
            <enum offset="3" extends="XrStructureType" name="XR_TYPE_PASSTHROUGH_MESH_TRANSFORM_INFO_HTC"/>
            <enum offset="4" extends="XrStructureType" name="XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_HTC"/>

            <command name="xrCreatePassthroughHTC"/>
            <command name="xrDestroyPassthroughHTC"/>
        </require>
    </extension>

    <extension name="XR_HTC_foveation" number="319" type="instance" supported="openxr">
        <require>
            <enum value="1"                            name="XR_HTC_foveation_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_foveation&quot;" name="XR_HTC_FOVEATION_EXTENSION_NAME"/>

            <enum offset="0" extends="XrStructureType" name="XR_TYPE_FOVEATION_APPLY_INFO_HTC"/>
            <enum offset="1" extends="XrStructureType" name="XR_TYPE_FOVEATION_DYNAMIC_MODE_INFO_HTC"/>
            <enum offset="2" extends="XrStructureType" name="XR_TYPE_FOVEATION_CUSTOM_MODE_INFO_HTC"/>

            <type name="XrFoveationModeHTC"/>
            <type name="XrFoveationLevelHTC"/>

            <type name="XrFoveationApplyInfoHTC"/>
            <type name="XrFoveationConfigurationHTC"/>
            <type name="XrFoveationDynamicModeInfoHTC"/>
            <type name="XrFoveationCustomModeInfoHTC"/>

            <command name="xrApplyFoveationHTC"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_320" number="320" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_320_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_320&quot;" name="XR_HTC_extension_320_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_321" number="321" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_321_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_321&quot;" name="XR_HTC_extension_321_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_322" number="322" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_322_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_322&quot;" name="XR_HTC_extension_322_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_323" number="323" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_323_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_323&quot;" name="XR_HTC_extension_323_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_324" number="324" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_324_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_324&quot;" name="XR_HTC_extension_324_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_325" number="325" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_325_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_325&quot;" name="XR_HTC_extension_325_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_326" number="326" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_326_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_326&quot;" name="XR_HTC_extension_326_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_327" number="327" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_327_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_327&quot;" name="XR_HTC_extension_327_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_328" number="328" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_328_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_328&quot;" name="XR_HTC_extension_328_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_329" number="329" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_329_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_329&quot;" name="XR_HTC_extension_329_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_330" number="330" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_330_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_330&quot;" name="XR_HTC_extension_330_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_331" number="331" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_331_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_331&quot;" name="XR_HTC_extension_331_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_332" number="332" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_332_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_332&quot;" name="XR_HTC_extension_332_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_333" number="333" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_333_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_333&quot;" name="XR_HTC_extension_333_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_334" number="334" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_334_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_334&quot;" name="XR_HTC_extension_334_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_335" number="335" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_335_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_335&quot;" name="XR_HTC_extension_335_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_336" number="336" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_336_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_336&quot;" name="XR_HTC_extension_336_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_337" number="337" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_337_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_337&quot;" name="XR_HTC_extension_337_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_338" number="338" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_338_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_338&quot;" name="XR_HTC_extension_338_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_339" number="339" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_339_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_339&quot;" name="XR_HTC_extension_339_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_340" number="340" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_340_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_340&quot;" name="XR_HTC_extension_340_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_341" number="341" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_341_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_341&quot;" name="XR_HTC_extension_341_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_342" number="342" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_342_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_342&quot;" name="XR_HTC_extension_342_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_343" number="343" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_343_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_343&quot;" name="XR_HTC_extension_343_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_344" number="344" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_344_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_344&quot;" name="XR_HTC_extension_344_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_345" number="345" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_345_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_345&quot;" name="XR_HTC_extension_345_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_346" number="346" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_346_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_346&quot;" name="XR_HTC_extension_346_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_347" number="347" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_347_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_347&quot;" name="XR_HTC_extension_347_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_348" number="348" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_348_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_348&quot;" name="XR_HTC_extension_348_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_349" number="349" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_349_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_349&quot;" name="XR_HTC_extension_349_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_350" number="350" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_350_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_350&quot;" name="XR_HTC_extension_350_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_351" number="351" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_351_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_351&quot;" name="XR_HTC_extension_351_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_352" number="352" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_352_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_352&quot;" name="XR_HTC_extension_352_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_353" number="353" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_353_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_353&quot;" name="XR_HTC_extension_353_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_354" number="354" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_354_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_354&quot;" name="XR_HTC_extension_354_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_355" number="355" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_355_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_355&quot;" name="XR_HTC_extension_355_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_356" number="356" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_356_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_356&quot;" name="XR_HTC_extension_356_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_357" number="357" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_357_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_357&quot;" name="XR_HTC_extension_357_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_358" number="358" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_358_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_358&quot;" name="XR_HTC_extension_358_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_359" number="359" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_359_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_359&quot;" name="XR_HTC_extension_359_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_360" number="360" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_360_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_360&quot;" name="XR_HTC_extension_360_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_361" number="361" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_361_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_361&quot;" name="XR_HTC_extension_361_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_362" number="362" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_362_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_362&quot;" name="XR_HTC_extension_362_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_363" number="363" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_363_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_363&quot;" name="XR_HTC_extension_363_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_364" number="364" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_364_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_364&quot;" name="XR_HTC_extension_364_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_365" number="365" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_365_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_365&quot;" name="XR_HTC_extension_365_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_366" number="366" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_366_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_366&quot;" name="XR_HTC_extension_366_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_367" number="367" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_367_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_367&quot;" name="XR_HTC_extension_367_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_368" number="368" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_368_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_368&quot;" name="XR_HTC_extension_368_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_369" number="369" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_369_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_369&quot;" name="XR_HTC_extension_369_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_HTC_extension_370" number="370" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_HTC_extension_370_SPEC_VERSION"/>
            <enum value="&quot;XR_HTC_extension_370&quot;" name="XR_HTC_extension_370_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_EXT_extension_371" number="371" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_EXT_extension_371_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_extension_371&quot;" name="XR_EXT_extension_371_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_EXT_extension_372" number="372" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_EXT_extension_372_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_extension_372&quot;" name="XR_EXT_extension_372_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_KHR_extension_373" number="373" type="instance" supported="disabled">
        <require>
            <enum value="1"                                name="XR_KHR_extension_373_SPEC_VERSION"/>
            <enum value="&quot;XR_KHR_extension_373&quot;" name="XR_KHR_extension_373_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_EXT_active_action_set_priority" number="374" type="instance" supported="openxr">
        <require>
            <enum value="1"                                             name="XR_EXT_active_action_set_priority_SPEC_VERSION"/>
            <enum value="&quot;XR_EXT_active_action_set_priority&quot;" name="XR_EXT_ACTIVE_ACTION_SET_PRIORITY_EXTENSION_NAME"/>
            <enum offset="0" extends="XrStructureType"                  name="XR_TYPE_ACTIVE_ACTION_SET_PRIORITIES_EXT"/>
            <type name="XrActiveActionSetPrioritiesEXT"/>
            <type name="XrActiveActionSetPriorityEXT"/>
        </require>
    </extension>

    <extension name="XR_HUAWEI_6dof_controller_interaction" number="375" type="instance" supported="disabled">
        <require>
            <enum value="1"                                                 name="XR_HUAWEI_6dof_controller_interaction_SPEC_VERSION"/>
            <enum value="&quot;XR_HUAWEI_6dof_controller_interaction&quot;" name="XR_HUAWEI_6DOF_CONTROLLER_INTERACTION_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MNDX_extension_376" number="376" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MNDX_extension_376_SPEC_VERSION"/>
            <enum value="&quot;XR_MNDX_extension_376&quot;" name="XR_MNDX_extension_376_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MNDX_extension_377" number="377" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MNDX_extension_377_SPEC_VERSION"/>
            <enum value="&quot;XR_MNDX_extension_377&quot;" name="XR_MNDX_extension_377_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MNDX_extension_378" number="378" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MNDX_extension_378_SPEC_VERSION"/>
            <enum value="&quot;XR_MNDX_extension_378&quot;" name="XR_MNDX_extension_378_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MNDX_extension_379" number="379" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MNDX_extension_379_SPEC_VERSION"/>
            <enum value="&quot;XR_MNDX_extension_379&quot;" name="XR_MNDX_extension_379_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MNDX_extension_380" number="380" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MNDX_extension_380_SPEC_VERSION"/>
            <enum value="&quot;XR_MNDX_extension_380&quot;" name="XR_MNDX_extension_380_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MNDX_extension_381" number="381" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MNDX_extension_381_SPEC_VERSION"/>
            <enum value="&quot;XR_MNDX_extension_381&quot;" name="XR_MNDX_extension_381_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MNDX_extension_382" number="382" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MNDX_extension_382_SPEC_VERSION"/>
            <enum value="&quot;XR_MNDX_extension_382&quot;" name="XR_MNDX_extension_382_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MNDX_extension_383" number="383" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MNDX_extension_383_SPEC_VERSION"/>
            <enum value="&quot;XR_MNDX_extension_383&quot;" name="XR_MNDX_extension_383_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MNDX_extension_384" number="384" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MNDX_extension_384_SPEC_VERSION"/>
            <enum value="&quot;XR_MNDX_extension_384&quot;" name="XR_MNDX_extension_384_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_385" number="385" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_385_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_385&quot;" name="XR_BYTEDANCE_extension_385_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_386" number="386" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_386_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_386&quot;" name="XR_BYTEDANCE_extension_386_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_387" number="387" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_387_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_387&quot;" name="XR_BYTEDANCE_extension_387_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_388" number="388" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_388_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_388&quot;" name="XR_BYTEDANCE_extension_388_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_389" number="389" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_389_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_389&quot;" name="XR_BYTEDANCE_extension_389_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_390" number="390" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_390_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_390&quot;" name="XR_BYTEDANCE_extension_390_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_391" number="391" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_391_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_391&quot;" name="XR_BYTEDANCE_extension_391_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_392" number="392" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_392_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_392&quot;" name="XR_BYTEDANCE_extension_392_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_393" number="393" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_393_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_393&quot;" name="XR_BYTEDANCE_extension_393_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_394" number="394" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_394_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_394&quot;" name="XR_BYTEDANCE_extension_394_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_395" number="395" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_395_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_395&quot;" name="XR_BYTEDANCE_extension_395_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_396" number="396" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_396_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_396&quot;" name="XR_BYTEDANCE_extension_396_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_397" number="397" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_397_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_397&quot;" name="XR_BYTEDANCE_extension_397_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_398" number="398" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_398_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_398&quot;" name="XR_BYTEDANCE_extension_398_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_399" number="399" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_399_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_399&quot;" name="XR_BYTEDANCE_extension_399_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_400" number="400" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_400_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_400&quot;" name="XR_BYTEDANCE_extension_400_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_401" number="401" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_401_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_401&quot;" name="XR_BYTEDANCE_extension_401_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_402" number="402" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_402_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_402&quot;" name="XR_BYTEDANCE_extension_402_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_403" number="403" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_403_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_403&quot;" name="XR_BYTEDANCE_extension_403_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_404" number="404" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_404_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_404&quot;" name="XR_BYTEDANCE_extension_404_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_405" number="405" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_405_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_405&quot;" name="XR_BYTEDANCE_extension_405_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_406" number="406" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_406_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_406&quot;" name="XR_BYTEDANCE_extension_406_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_407" number="407" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_407_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_407&quot;" name="XR_BYTEDANCE_extension_407_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_408" number="408" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_408_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_408&quot;" name="XR_BYTEDANCE_extension_408_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_409" number="409" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_409_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_409&quot;" name="XR_BYTEDANCE_extension_409_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_BYTEDANCE_extension_410" number="410" type="instance" supported="disabled">
        <require>
            <enum value="1"                                      name="XR_BYTEDANCE_extension_410_SPEC_VERSION"/>
            <enum value="&quot;XR_BYTEDANCE_extension_410&quot;" name="XR_BYTEDANCE_extension_410_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_411" number="411" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MSFT_extension_411_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_411&quot;" name="XR_MSFT_EXTENSION_411_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_412" number="412" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MSFT_extension_412_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_412&quot;" name="XR_MSFT_EXTENSION_412_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_413" number="413" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MSFT_extension_413_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_413&quot;" name="XR_MSFT_EXTENSION_413_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_414" number="414" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MSFT_extension_414_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_414&quot;" name="XR_MSFT_EXTENSION_414_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_415" number="415" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MSFT_extension_415_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_415&quot;" name="XR_MSFT_EXTENSION_415_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_416" number="416" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MSFT_extension_416_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_416&quot;" name="XR_MSFT_EXTENSION_416_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_417" number="417" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MSFT_extension_417_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_417&quot;" name="XR_MSFT_EXTENSION_417_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_418" number="418" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MSFT_extension_418_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_418&quot;" name="XR_MSFT_EXTENSION_418_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_419" number="419" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MSFT_extension_419_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_419&quot;" name="XR_MSFT_EXTENSION_419_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_420" number="420" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MSFT_extension_420_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_420&quot;" name="XR_MSFT_EXTENSION_420_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_MSFT_extension_421" number="421" type="instance" supported="disabled">
        <require>
            <enum value="1"                                 name="XR_MSFT_extension_421_SPEC_VERSION"/>
            <enum value="&quot;XR_MSFT_extension_421&quot;" name="XR_MSFT_EXTENSION_421_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_DANWILLM_extension_422" number="422" type="instance" supported="disabled">
        <require>
            <enum value="1"                                     name="XR_DANWILLM_extension_422_SPEC_VERSION"/>
            <enum value="&quot;XR_DANWILLM_extension_422&quot;" name="XR_DANWILLM_EXTENSION_422_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_DANWILLM_extension_423" number="423" type="instance" supported="disabled">
        <require>
            <enum value="1"                                     name="XR_DANWILLM_extension_423_SPEC_VERSION"/>
            <enum value="&quot;XR_DANWILLM_extension_423&quot;" name="XR_DANWILLM_EXTENSION_423_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_DANWILLM_extension_424" number="424" type="instance" supported="disabled">
        <require>
            <enum value="1"                                     name="XR_DANWILLM_extension_424_SPEC_VERSION"/>
            <enum value="&quot;XR_DANWILLM_extension_424&quot;" name="XR_DANWILLM_EXTENSION_424_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_DANWILLM_extension_425" number="425" type="instance" supported="disabled">
        <require>
            <enum value="1"                                     name="XR_DANWILLM_extension_425_SPEC_VERSION"/>
            <enum value="&quot;XR_DANWILLM_extension_425&quot;" name="XR_DANWILLM_EXTENSION_425_EXTENSION_NAME"/>
        </require>
    </extension>

    <extension name="XR_DANWILLM_extension_426" number="426" type="instance" supported="disabled">
        <require>
            <enum value="1"                                     name="XR_DANWILLM_extension_426_SPEC_VERSION"/>
            <enum value="&quot;XR_DANWILLM_extension_426&quot;" name="XR_DANWILLM_EXTENSION_426_EXTENSION_NAME"/>
        </require>
    </extension>

    </extensions>

</registry>

<<<

`COMMIT_EDITMSG`: >>>

VR GAME WORKS

<<<

`config`: >>>

[core]
	repositoryformatversion = 0
	filemode = false
	bare = false
	logallrefupdates = true
	symlinks = false
	ignorecase = true
[remote "origin"]
	url = https://github.com/James-Riordan/vrgame.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main

<<<

`description`: >>>

Unnamed repository; edit this file 'description' to name the repository.

<<<

`FETCH_HEAD`: >>>

fd3554675bb16c3ffc6b17cf3ba31957ee418d82		branch 'main' of https://github.com/James-Riordan/vrgame

<<<

`HEAD`: >>>

ref: refs/heads/main

<<<

`ORIG_HEAD`: >>>

05edc8760357a70810f4f1e230ca98424ae20874

<<<

`main`: >>>

fd3554675bb16c3ffc6b17cf3ba31957ee418d82

<<<

`main`: >>>

fd3554675bb16c3ffc6b17cf3ba31957ee418d82

<<<

`60e9ddb486ed8819b58b3e35bd256875a3ae1c`: >>>

xï¿½ï¿½ï¿½
ï¿½@ï¿½ï¿½ï¿½)ï¿½TIQ+Aï¿½Gï¿½?.ï¿½Mï¿½p?rï¿½ï¿½DÉ»{)m$ï¿½ï¿½ï¿½ï¿½U6Trï¿½ß¬ï¿½ï¿½ï¿½%ï¿½ï¿½GyBwï¿½ï¿½,Õ¬8ï¿½ï¿½ï¿½ï¿½ï¿½)ï¿½{Gï¿½ï¿½Fï¿½ï¿½ï¿½:m ï¿½ï¿½ï¿½ï¿½'ï¿½3ï¿½ï¿½x@dï¿½ï¿½cï¿½/#ï¿½ï¿½ngiï¿½<.ï¿½hï¿½vï¿½DÕ£7ï¿½ï¿½`ÓV2-gKï¿½mï¿½9[{ï¿½ï¿½R~ï¿½vHyï¿½T&ï¿½ï¿½'bï¿½
<<<

`9afb3b98f3bbe32b9fb4dbda810487e582ba4a`: >>>

xuï¿½1kï¿½0ï¿½;ï¿½Wtï¿½Kï¿½Øµï¿½@Lï¿½ï¿½OZJPT%Qï¿½ï¿½ï¿½$ï¿½ï¿½ï¿½ï¿½^)viï¿½Tï¿½ï¿½xß½wï¿½khï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4ï¿½Ç”ï¿½ï¿½Qï¢†wA|BCiRï¿½ï¿½ï¿½È–ï¿½oï¿½D-ï¿½ï¿½ï¿½ï¿½#{ï¿½ï¿½Bï¿½Ôï¿½ï¿½/$ï¿½Â˜^ï¿½Giï¿½È“ï¿½Fï¿½:ï¿½ï¿½3ï¿½Ş²ï¿½ï¿½>ï¿½Dï¿½ï¿½[ï¿½hï¿½'ï¿½ï¿½ï¿½ï¿½æ®·Ç­ mï¿½.Fï¿½ÕLï¿½ï¿½ï¿½8ï¿½ppG]ï¿½lD'ï¿½rï¿½ï¿½Sï¿½a:ï¿½ï¿½ï¿½Ô‡gï¿½ï¿½ï¿½ï¿½ï¿½ï¿½l}	j.ï¿½I]ï¿½.PEtï¿½ï¿½Yï¿½ï¿½ï¿½eï¿½dï¿½;Tz6ï¿½7eï¿½vz
<<<

`63592a95a479d193f5d3171f84abf3275fbe98`: >>>

xï¿½ï¿½Aï¿½0ï¿½=ï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½Tï¿½ï¿½ï¿½ï¿½3ï¿½fakGAï¿½ï¿½ï¿½uï¿½Õœï¿½xï¿½ï¿½K?ï¿½ï¿½ï¿½neï¿½Oï¿½/pï¿½ï¿½Msï¿½ï¿½Q$VU<kï¿½_O$Eï¿½|ï¿½ï¿½ï¿½<ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@ï¿½ï¿½ï¿½Tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½#<ï¿½p|ï¿½ï¿½:'9?ï¿½Bï¿½eï¿½^Mï¿½ÈZï¿½6ï¿½KVï¿½Ö¿Xï¿½ï¿½ï¿½Kï¿½~yPï¿½
<<<

`ddae762342c30387fcccc7f347665137b7a373`: >>>

xï¿½Tï¿½ï¿½ï¿½0ï¿½Ü¯ï¿½ï¿½#ï¿½ï¿½ï¿½.ï¿½Bï¿½ï¿½ï¿½		!.Un2ï¿½Zuï¿½b;ï¿½ï¿½ï¿½g;!]Tï¿½^ï¿½fï¿½y3o&keï¿½pï¿½ï¿½ï¿½ï¿½Eaï¿½ï¿½ï¿½|	sXï¿½zgï¿½gSï¿½;ï¿½ï¿½Nbï¿½İCmï¿½ï¿½Bï¿½ï¿½h=ï¿½2ï¿½7!câ‘¸ï¿½mï¿½ï¿½pï¿½ï¿½ï¿½ï¿½Ô¥ï¿½P_lï¿½Qyï¿½ï¿½Bï¿½ï¿½)<Nï¿½~ï¿½ï¿½
ï¿½xï¿½ï¿½TN`,<[nï¿½{ï¿½ï¿½bï¿½4ï¿½ï¿½ï¿½T.ï¿½ï¿½ï¿½!+K\Evï¿½ï¿½OUï¿½#ï¿½ï¿½b~4B1ï¿½6fï¿½!VN<ï¿½ï¿½*ï¿½Vï¿½4ï¿½Gï¿½ï¿½Kï¿½Xswï¿½ï¿½,ï¿½ï¿½7Õºï¿½ï¿½ï¿½&}ï¿½ï¿½ï¿½Gï¿½ï¿½|0+K ï¿½txï¿½ï¿½4ï¿½uCï¿½ï¿½ï¿½%Uï¿½Yï¿½ï¿½ï¿½ï¿½ï‚£4ï¿½jï¿½ï¿½7ZYoï¿½ï¿½Zï¿½ï¿½r"U4*ï¿½ï¿½ï¿½v6ï¿½"-Å‰mêˆ¸Bï¿½ ï¿½Â‚Î¯ï¿½ï¿½{ {ï¿½ï¿½,ï¿½ï¿½ï¿½Öï¿½2ï¿½3x9È§ï¿½ï¿½ï¿½6ï¿½ï¿½mï¿½oNrï¿½4ï¿½	ï¿½:ï¿½uï¿½0Ù©?u1z1ï¿½ï¿½ï¿½Rï¿½}fï¿½CPt}ï¿½"lï¿½_+A}UbaQï¿½pï¿½Ì¢{:2ï¿½\Sw'ï¿½ug.8ï¿½ ï¿½ï¿½tï¿½Iï¿½ï¿½ï¿½ï¿½ï¿½ï¿½$I_LSlï¿½oP75xCOï¿½Xï¿½_:ï¿½
%K ï¿½ï¿½ï¿½lï¿½ï¿½ï¿½ï¿½ï¿½3>ï¿½r?%}zï¿½LÓ²ï¿½ï¿½ï¿½
ï¿½wï¿½+W)#|>ï¿½ï¿½ï¿½ï¿½ï¿½cï¿½aq"cï¿½ï¿½ï¿½ï¿½q=Tï¿½ï¿½ï¿½Cï¿½ï¿½@ï¿½ï¿½}ï¿½N
<<<

`e7329b18daf1a3e73625681d07767457e67a36`: >>>

xï¿½ï¿½ï¿½
ï¿½0D=ï¿½+ï¿½ï¿½*H<ï¿½ï¿½^<ï¿½ï¿½=6ï¿½ï¿½IHï¿½ï¿½"ï¿½ï¿½)EOï¿½{Ûï¿½7s2ï¿½Dï¿½ï¿½tT:ï¿½"+Zï¿½J_ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"ï¿½ï¿½~ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½jï¿½HN1ï¿½ï¿½Tï¿½|@ï¿½eï¿½VQï¿½)ï¿½&:Yï¿½=ï¿½4n}`ï¿½ï¿½ï¿½ï¿½ï¿½<Jï¿½Wï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½^{m!ï¿½)ï¿½k×¡ï¿½[ï¿½jï¿½ï¿½ï¿½ï¿½gï¿½ï¿½<ï¿½,/ï¿½ï¿½ï¿½nk}Ã‰ÇŸï¿½Gï¿½~Æ‡O
<<<

`f93f4efb55ac7807104ce11c565a850e735440`: >>>

xmï¿½ï¿½jï¿½0ï¿½;ï¿½)Aï¿½ï¿½P5ï¿½ï¿½ï¿½ï¿½`dï¿½dï¿½ï¿½Rï¿½ï¿½4ï¿½ï¿½ï¿½ï¿½ï¿½jï¿½ï¿½]i\	ï¿½ï¿½ï¿½Cï¿½lï¿½b;xï¿½ï¿½ï¿½ï¿½ï¿½}Yï¿½Mï¿½ï¿½ï¿½1ï¿½(ï¿½;i+|ï¿½ï¿½ï¿½=(m0@+ï¿½Hï¿½ï¿½4Vvï¿½ï¿½U2jb2ï¿½ï¿½7ï¿½sï¿½Tï¿½@m!Í­ï¿½ï¿½vQï¿½ï¿½ï¿½Tï¿½ï¿½ï¿½VWA4ï¿½í‚¯ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½md×¨H%ï¿½#ï¿½yzï¿½Hï¿½j_ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½:z-mcï¿½8ï¿½ï¿½,ï¿½'P^6ï¿½ï¿½ï¿½uï¿½ï¿½wu2ï¿½ï¿½ï¿½Hvï¿½ï¿½iï¿½ï¿½Vï¿½ï¿½ï¿½'h2ï¿½c=ï¿½Yqï¿½ï¿½jï¿½
:p|ï¿½{ï¿½EyHï¿½ï¿½Úï¿½ï¿½
<<<

`0ebde2568f1f4af170d0c77b38807c249830d1`: >>>

xï¿½ï¿½1kï¿½0ï¿½;ï¿½WO	ï¿½ÚBK!-]:uï¿½ï¿½ï¿½);:#ï¿½Miï¿½ï¿½IJ#ï¿½xï¿½ï¿½`ï¿½ï¿½}ï¿½dÑ`ï¿½ï¿½ï¿½Mï¿½![ï¿½ï¿½6ï¿½Øƒï¿½E>]ï¿½Mï¿½|Ì²~,J>ï¿½Eï¿½I2ï¿½vhï¿½}gï¿½ï¿½ï¿½Û–;Uï¿½ï¿½Phï¿½Kï¿½*ï¿½ï¿½ï¿½b"ï¿½ï¿½ksï¿½ï¿½ï¿½5Vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Dï¿½kï¿½ï¿½Q~\q6ï¿½Cï¿½q^ï¿½ï¿½ï¿½Kï¿½ï¿½/ï¿½ï¿½ï¿½n9ï¿½ho][ï¿½^Vï¿½!Llï¿½(ï¿½wIQ9ï¿½ï¿½Pï¿½ï¿½ï¿½Ö»ï¿½ï¿½Ï¿ï¿½yï¿½ï¿½(gï¿½Cï¿½ï¿½ï¿½ï¿½w1ï¿½Z
ì‘£gï¿½Uyï¿½ï¿½Ú©8ï¿½dAJ9ï¿½Uï¿½ï¿½uYï¿½ï¿½ï¿½tEï¿½dï¿½tï¿½ï¿½ï¿½.ï¿½ï¿½ï¿½0ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
<<<

`6248b93b189737f6b003794e900cb261cf06bf`: >>>

xuï¿½ï¿½ï¿½ï¿½0ï¿½ï¿½ï¿½#ï¿½$ï¿½ï¿½àªˆ
jï¿½]ï¿½"F&Ù#ï¿½hï¿½ï¿½ï¿½Ipï¿½)ï¿½`ï¿½ÕfGï¿½ï¿½4ï¿½0Ï²ï¿½ï¿½Kc5X|ï¿½ï¿½i~ï¿½ï¿½Eï¿½wï¿½ï¿½DC5ï¿½Rï¿½ï¿½.[ï¿½ï¿½Sï¿½bï¿½ï¿½ï¿½ï¿½Bï¿½=Í—Oï¿½lï¿½Uï¿½ï¿½Fï¿½ê„Šï¿½EOFWï¿½ï¿½ï¿½ï¿½Wï¿½/nï¿½Ğªï¿½Ú–ï¿½hï¿½^aï¿½>NXï¿½ï¿½8tÖ¡ï¿½ï¿½ï¿½ï¿½ï¿½Tï¿½*ï¿½ï¿½Pï¿½ï¿½ï¿½IU8rï¿½D1ï¿½aï¿½eï¿½ï¿½ï¿½ï¿½ï¿½.ï¿½ï¿½ï¿½rï¿½]Dï¿½ï¿½_È’4ï¿½Ù…]uhï¿½
<<<

`9b90ea880316403b956ad149f779284830526a`: >>>

xï¿½ï¿½M
ï¿½0F]ï¿½ï¿½@e&MAÄµKo0M&Z1Mï¿½<ï¿½ï¿½ï¿½ï¿½ï¿½/ï¿½ï¿½ï¿½&ï¿½Qï¿½Vï¿½ï¿½ï¿½Bï¿½ï¿½YÅ”ï¿½ï¿½zrï¿½ï¿½cï¿½afï¿½ï¿½'U^ï¿½ï¿½ï¿½Bï¿½ï¿½kdï¿½D0ï¿½ï¿½(ï¿½h,ï¿½ï¿½ï¿½ï¿½JĞ«ï¿½Jï¿½gï¿½ï¿½.Kï¿½ï¿½Vyï¿½ï¿½ï¿½HOï¿½kï¿½ï¿½%%ï¿½ï¿½Xï¿½ï¿½ï¿½,ï¿½è¶—6ï¿½ï¿½Cï¿½(ï¿½ï¿½q]rï¿½ï¿½MX
<<<

`f090b2d964c98c3c7dc1d8d2cd3eab37baf569`: >>>

x}SMoï¿½0ï¿½9ï¿½ï¿½0ï¿½:%Mï¿½ï¿½ï¿½ï¿½~ï¿½ï¿½Û®ï¿½lï¿½)G6$:Í¶ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½/ï¿½)>>ï¿½G*ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½ï¿½ï¿½ï¿½!ï¿½ï¿½5<Ò®ï¿½gcï¿½OVï¿½tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Nï¿½sï¿½ï¿½ï¿½@ï¿½hÆˆQï¿½ï¿½3nï¿½eï¿½ï¿½=ï¿½#ï¿½ï¿½ï¿½;ï¿½mï¿½=ï¿½1ï¿½ï¿½|~jSFï¿½ï¿½ï¿½=*ï¿½{ï¿½ï¿½
ï¿½ï¿½	ï¿½ï¿½p7ï¿½!\ï¿½ï¿½pï¿½-ï¿½	ï¿½Y^vï¿½ï¿½8ï¿½ï¿½ï¿½ï¿½Tï¿½Û»ï¿½ï¿½.Fï¿½pjYÎ¼ï¿½ï¿½Ç£/i$ï¿½ï¿½#ï¿½jï¿½ï¿½ï¿½;1jï¿½0ï¿½5zï¿½ï¿½Ü™ï¿½0ï¿½rNï¿½Ku[ï¿½;ï¿½ï¿½)|ï¿½ï¿½ï¿½Úˆï¿½Ã’<:hï¿½ï¿½VVï¿½ï¿½ï¿½ï¿½mï¿½;İ°ï¿½%qï¿½ï¿½'ï¿½ï¿½fï¿½ï¿½3ï¿½ï¿½ï¿½g?ï¿½+ï¿½c/{ï¿½	ï¿½ï¿½ï¿½eyï¿½b.Í’e ï¿½Bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ì˜	ï¿½Zwï¿½ï¿½oï¿½ï¿½ï¿½ï¿½3Bï¿½ï¿½ï¿½:ï¿½ï¿½Tï¿½ï¿½Ü¨aï¿½[ï¿½s	xlï¿½ï¿½ï¿½1$bNï¿½Iï¿½lRXï¿½ÉƒXï¿½ï¿½}ï¿½ï¿½ï¿½9U]tï¿½ï¿½pï¿½8)ï¿½&ï¿½ï¿½ï¿½<P<
<<<

`80657413fa908e0126cc59326dd273ec45eb5b`: >>>

xï¿½Rï¿½J1ï¿½yï¿½bØ§Tï¿½tï¿½VQ)Tï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ntwï¿½$imï¿½ï¿½ï¿½ï¿½Kï¿½lï¿½ï¿½Pï¿½`XX2ï¿½3çœ™ï¿½zï¿½iï¿½Dï¿½ï¿½:ï¿½n=è«¢ï¿½Æ±ï¿½_ï¿½ï¿½mŞ¤(Ğˆï¿½&ï¿½ï¿½*ï¿½ï¿½ï¿½sBï¿½2"ï¿½ï¿½#n@70VIï¿½9ï¿½Yï¿½Wï¿½ï¿½ï¿½ï¿½?ï¿½,H'ï¿½*'ï¿½'ï¿½tï¿½ï¿½	ï¿½ï¿½2gMï¿½ï¿½ï¿½ ï¿½!nyï¿½ae5u5|Eï¿½6ï¿½ï¿½ï¿½ï¿½Yï¿½0Sï¿½Ñ®ï¿½~Kï¿½ï¿½Rï¿½Å™ï¿½Pï¿½ï¿½ï¿½pï¿½ï¿½ï¿½mï¿½Ê‡>2,ï¿½ï¿½ï¿½ï¿½mï¿½Dï¿½ï¿½ï¿½>ï¿½<ï¿½ï¿½Tï¿½AÌ„ï¿½ï¿½0Ç¦>ï¿½ï¿½ï¿½uï¿½ï¿½zï¿½ï¿½ 4ï¿½ï¿½ï¿½<ï¿½$ï¿½ï¿½	ï¿½ï¿½ï¿½ï¿½ï¿½6]bï¿½ï¿½Gï¿½ï¿½iu$ï¿½ï¿½)hï¿½Tï¿½Nï¿½CFï¿½ï¿½'ï¿½.85ï¿½ï¿½1ï¿½4ï¿½ï¿½ï¿½ï¿½ï¿½: ï¿½ï¿½ï¿½ï¿½R#+4ï¿½vAÍÑ†ï¿½M>Â‰Aï¿½/ï¿½Yï¿½ï¿½(-ï¿½Jyï¿½Jï¿½sï¿½Shï¿½5'ï¿½Ü«ï¿½ï¿½ï¿½dGï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½,ï¿½ï¿½ï¿½:ï¿½ï¿½9ï¿½ev=ï¿½ï¿½Ù±6ï¿½f/Zï¿½ï¿½/ï¿½ï¿½ï¿½Fï¿½ï¿½ï¿½ï¿½Æ°yï¿½ï¿½ï¿½hï¿½ï¿½ï¿½ï¿½
<<<

`853269734f8c2c800d6a4cd89c2d65cf6f2f84`: >>>

xï¿½ï¿½ï¿½Jï¿½@ï¿½=ï¿½)~ï¿½ï¿½ï¿½AEXï¿½ï¿½ï¿½ï¿½ï¿½ï¿½iï¿½,ï¿½ï¿½0Iï¿½Eï¿½}/ï¿½ï¿½>ï¿½3ï¿½ï¿½QC.ÉŸ/ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½,
ï¿½ï¿½Ø¹1ï¿½ï¿½ï¿½É¥ï¿½ï¿½U?ï¿½ï¿½_ï¿½ï¿½bï¿½ï¿½Z)eÒ¬ï¿½lï¿½ï¿½nA"ï¿½ê¬‡,cï¿½ &*-ï¿½ï¿½
9ï¿½[<ï¿½ï¿½ï¿½Ó—ï¿½v:Yï¿½ï¿½Hï¿½ï¿½qf8Î©4$ï¿½.0ï¿½!ï¿½ï¿½ï¿½ï¿½OË”ï¿½=ï¿½d$Qß¬ï¿½5-ï¿½ISï¿½ï¿½Eï¿½Ş½Zyï¿½ï¿½ï¿½ï¿½ï¿½Kï¿½Nï¿½&;(ï¿½ï¿½ï¿½QJï¿½cï¿½ï¿½_p }ï¿½$ï¿½ï¿½J~Tß€ï¿½ï¿½ï¿½
<<<

`8083251d46ea0e1a3161776ac7238a4a6d37ff`: >>>

xMï¿½ï¿½
ï¿½0ï¿½=ï¿½)ï¿½ï¿½Zï¿½ï¿½MZï¿½ï¿½ï¿½ï¿½&[ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½nï¿½ï¿½ï¿½ï¿½efgï¿½kï¿½`S+e'ï¿½ï¿½Giï¿½ï¿½:Ndï¿½2İ‰ß­uï¿½HW6#ï¿½G7&Shï¿½ï¿½ï¿½=cï¿½ï¿½xï¿½xï¿½aï¿½ï¿½ï¿½,ï¿½ï¿½tï¿½Bï¿½'eWï¿½ï¿½!Y
Öï¿½ï¿½ï¿½ï¿½i`ï¿½ï¿½<Gï¿½54ï¿½Lï¿½#ï¿½{5a'Exï¿½zpGï¿½ï¿½'ï¿½ï¿½kkEï¿½ï¿½ï¿½/d=Pi
<<<

`4afec26753525c813506abd0ebe8bb217380ee`: >>>

xï¿½ï¿½;nï¿½0DSï¿½ï¿½kĞ¢lIï¿½"Hï¿½27ï¿½Dï¿½k`ï¿½ï¿½,{ï¿½9Cï¿½yï¿½ï¿½ï¿½ï¿½ï¿½Rï¿½ï¿½Qï¿½*D	!Fï¿½É‡ï¿½mï¿½)*%ï¿½#Û”ï¿½ï¿½\tï¿½0Hï¿½2%ï¿½LDï¿½$Oï¿½ï¿½Gï¿½ï¿½|ï¿½ï¿½ï¿½Uï¿½{ï¿½o^ï¿½ï¿½ï¿½`]ï¿½Zï¿½ï¿½ï¿½ï¿½Ï²ï¿½ï¿½ï¿½:ï¿½ï¿½İ¶=^ï¿½n^ï¿½ï¿½J]ï¿½ï¿½Oï¿½ï¿½ï¿½ï¿½G7ï¿½Dï¿½hï¿½ï¿½ï¿½ï¿½ï¿½:ï¿½Â¢Vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½07cï¿½4ï¿½Z)
<<<

`cb6ff3b17df4e78f177429de0cde846d957789`: >>>

x+)JMU01g040031Q(ï¿½ï¿½ï¿½Nï¿½Oï¿½ÉŒO*ï¿½ï¿½IÑ«ï¿½Lgï¿½ï¿½ï¿½[ï¿½ï¿½\2ï¿½ï¿½ï¿½ Å˜ï¿½ï¿½Ş‡ï¿½ï¿½Jï¿½
<<<

`c8a314b4427402e50dc2ae51863612ebe2d628`: >>>

xï¿½ï¿½OOï¿½0ï¿½9ï¿½SX;ï¿½ï¿½Ë’ï¿½?ï¿½pcBï¿½ï¿½!ï¿½ï¿½-Rï¿½ï¿½$lCï¿½wï¿½iï¿½6 ï¿½[cï¿½gï¿½ï¿½&ï¿½ï¿½ï¿½p8<È­ï¿½|ï¿½ï¿½%\éª¶.ï¿½ï¿½vÒ‹ï¿½ï¿½U*ï¿½?ï¿½ï¿½Kï¿½Hï¿½tï¿½}ï¿½5:_cï¿½aï¿½ï¿½ï¿½!ï¿½X:ï¿½hï¿½ï¿½vï¿½=ï¿½Ztaï¿½ï¿½ï¿½ï¿½Hï¿½Sï¿½9Dï¿½dï¿½T+ï¿½Ù©ï¿½ï¿½ï¿½lTï¿½?ï¿½bĞ§Ayï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½}w.wKÅ¶"ï¿½Iï¿½ï¿½ï¿½@Äµï¿½{ï¿½vï¿½0:4ï¿½vyqAÄŠï¿½ï¿½^ï¿½lï¿½Jï¿½*ï¿½COï¿½Aï¿½)ï¿½ï¿½MWpoï¿½ï¿½hï¿½63ï¿½ï¿½ï¿½Û¨ï¿½ï¿½ï¿½ifï¿½zï¿½4ï¿½ï¿½ï¿½Jï¿½ï¿½ï¿½ï¿½7ï¿½RnNï¿½ï¿½:ï¿½ï¿½ï¿½e/ï¿½ï¿½keï¿½ï¿½eiï¿½`_]ï¿½cA'kkï¿½Xv]ï¿½Î®n_ï¿½'ï¿½])ï¿½(ï¿½ï¿½ï¿½ï¿½EOï¿½Û˜ï¿½fH1ï¿½@bï¿½xï¿½ï¿½ï¿½ï¿½İ•ï¿½ï¿½&[ï¿½ï¿½7lï¿½/ï¿½Q^pï¿½dï¿½ï¿½rï¿½ï¿½Ïƒï¿½ï¿½u##5ï¿½ï¿½ï¿½rï¿½ï¿½Í³ï¿½bV)|ï¿½>ï¿½ï¿½ï¿½(ï¿½ï¿½3ï¿½ï¿½H
<<<

`f072847b0d5baab3264b56be51ebb1a4b8d069`: >>>

xï¿½ï¿½?oï¿½0ï¿½;ï¿½S<xï¿½ï¿½ï¿½Yï¿½ï¿½u2fï¿½jPï¿½Éºï¿½"ï¿½d[hï¿½ï¿½{ï¿½ ï¿½p@İ¿ï¿½{ï¿½Æ…_ï¿½|ï¿½ï¿½ï¿½I,ï¿½ï¿½ï¿½ï¿½)DYï¿½ï¿½ï¿½ï¿½ï¿½;Sï¿½ï¿½ï¿½?9ï¿½ï¿½ï¿½Õ’Ò°ï¿½ï¿½[#ï¿½5ï¿½ï¿½Hï¿½kï¿½8ï¿½gï¿½0ï¿½
ï¿½*ï¿½ï¿½nqoï¿½`6ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½at}ï¿½Oï¿½ï¿½ï¿½ï¿½QJï¿½<ï¿½ï¿½tLÎ¦znU@ï¿½ï¿½ï¿½ï¿½ï¿½%ï¿½^ï¿½ï¿½Rï¿½$ï¿½nï¿½ï¿½8eï¿½uï¿½Wäš®'jeï¿½ï¿½?%ï¿½ï¿½qï¿½ï¿½eï¿½1ï¿½Æ¹	7Jï¿½ï¿½Ù>?ï¿½ï¿½ï¿½ï¿½ï¿½T8[ï¿½]nï¿½A*ï¿½ï¿½(ï¿½hï¿½ï¿½ï¿½N%Pï¿½(Û¼ï¿½ï¿½ï¿½ï¿½	oï¿½bï¿½ï¿½Xpaï¿½Nzï¿½^ï¿½ï¿½ï¿½K"ï¿½;ï¿½Vï¿½Ş“^ï¿½}Yï¿½ï¿½gï¿½ï¿½cï¿½ï¿½uï¿½ï¿½Pï¿½Ê¨Eï¿½ï¿½ï¿½\hMvwï¿½ï¿½ï¿½ï¿½Eï¿½#{ï¿½C2ï¿½eï¿½ï¿½g.ï¿½ï¿½oGï¿½>{ï¿½Ğ•Uï¿½ï¿½$?;\?ï¿½ï¿½ï¿½ï¿½ï¿½y.ï¿½N8Ç¶ï¿½ï¿½ï¿½&ï¿½ï¿½+;xï¿½^ï¿½ß™ï¿½ï¿½
<<<

`e42bcef0c0b6d3549a66e348038a41f22ebe50`: >>>

x+)JMU042g040031QH/J,ï¿½ï¿½L.ï¿½Oï¿½ï¿½+Iï¿½(Ñ«ï¿½Lgï¿½ï¿½JØ™ï¿½ï¿½!{ï¿½ï¿½ï¿½ï¿½ï¿½`ï¿½]~8ï¿½ï¿½ï¿½<ï¿½ 9#13ï¿½ï¿½ï¿½o_kï¿½ï¿½&ß ï¿½ï¿½ï¿½ï¿½Xï¿½eï¿½18	UXï¿½Z4ï¿½ï¿½ï¿½ï¿½Sï¿½<Jï¿½ï¿½lJï¿½Kï¿½ï¿½ï¿½ï¿½Su=6ï¿½
<<<

`8773e2f41dd8696f60576236690866c5f13872`: >>>

xï¿½ï¿½1Oï¿½0ï¿½ï¿½ï¿½+Nï¿½)2MUï¿½,ï¿½l,!ï¿½qï¿½%ï¿½ï¿½ï¿½ ï¿½;ï¿½ï¿½ï¿½ï¿½'ï¿½ï¿½ï¿½ï¿½ï¿½ypaï¿½ë¶½ï¿½ï¿½'ï¿½ï¿½#tï¿½ï¿½ï¿½"
NO^ï¿½Yï¿½İ›ï¿½fwï¿½~=Tx%Kkï¿½ï¿½pï¿½ï¿½lï¿½Bï¿½ï¿½!ï¿½ï¿½ï¿½\*ï¿½hï¿½Lï¿½ï¿½Uï¿½ï¿½ï¿½2fï¿½ï¿½ï¿½>dï¿½ï¿½Î€ï¿½ï¿½ï¿½ï¿½\xï¿½ï¿½f7ï¿½ï¿½/Y9ï¿½'ï¿½fï¿½&QLï¿½ï¿½E~9<ï¿½&ï¿½hï¿½ï¿½]Üï¿½"ï¿½ï¿½ï¿½$ï¿½U[ï¿½ï¿½x\ï¿½ï¿½ï¿½zï¿½.ï¿½Cï¿½ï¿½pï¿½sï¿½ï¿½\Ñ‡iJï¿½?Pï¿½Cï¿½tmï¿½[ÔŸï¿½:ï¿½ï¿½ï¿½iIï¿½ï¿½>ï¿½Õ¶ï¿½
<<<

`988a0276dbf0a3024558489d263817e9556c3b`: >>>

xMOMKï¿½@ï¿½ï¿½ï¿½ï¿½K+HD*ï¿½ï¿½ï¿½ï¿½
ï¿½ï¿½ï¿½n2Æ¡ï¿½lØï¿½ï¿½ï¿½wï¿½ 8ï¿½ï¿½ï¿½1ï¿½!ï¿½?<Ş´Qï¿½"kï¿½-v<N1éº²ï¿½ï¿½}rï¿½iï¿½Eï¿½ouï¿½ &ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½8ï¿½4ï¿½v:ï¿½Gï¿½yï¿½ï¿½/ï¿½qï¿½ï¿½ï¿½ï¿½ï¿½gï¿½ï¿½6vÔ“4!ï¿½?ï¿½;ï¿½ï¿½%ï¿½:GY)ï¿½Dbï¿½qï¿½jï¿½T,J}ï¿½ï¿½Q6ï¿½ï¿½ï¿½Bï¿½ï¿½`ï¿½puï¿½yï¿½_dï¿½ï¿½.ï¿½ï¿½Yï¿½ï¿½Å³ï¿½ï¿½Dï¿½ï¿½5ï¿½dï¿½oï¿½ï¿½ï¿½]h
<<<

`9c66bddbab3cdac4e3603961491c702dcab9d0`: >>>

xuï¿½Oï¿½@ï¿½;ï¿½xï¿½E!ï¿½SVï¿½dï¿½ï¿½ï¿½Yï¿½uï¿½ï¿½Õ‘]$ï¿½î­©ï¿½ï¿½ï¿½2ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½4İ°=Wï¿½^ï¿½ï¿½Aï¿½ï¿½ï¿½|ï¿½Gï¿½iï¿½ï¿½"ï¿½A/ï¿½ï¿½ï¿½ï¿½%ï¿½ï¿½0ï¿½_&Aï¿½Lï¿½ï¿½ï¿½ï¿½/_Oï¿½Dï¿½Uï¿½ï¿½x2ï¿½ï¿½g.ï¿½eÎ¶QCï¿½dï¿½xï¿½ï¿½ï¿½Z5ï¿½jdï¿½ï¿½Hpm$/ï¿½ï¿½ï¿½ï¿½9ï¿½mï¿½ï¿½ï¿½Yï¿½bYuXï¿½Oï¿½Mï¿½lï¿½ï¿½ï¿½{ï¿½Wï¿½
<<<

`2bfc1586f9d2290dac330453376be2ab5a17be`: >>>

xuï¿½MNï¿½0ï¿½Yï¿½#ï¿½Iï¿½ï¿½8ï¿½]E]ï¿½-ï¿½%ï¿½ï¿½qï¿½Ø’ï¿½7ï¿½ ï¿½ï¿½#r&ï¿½ï¿½ï¿½ï¿½yoï¿½7ï¿½KX,Ó‹ï¿½N5ï¿½AGVqï¿½Cï¿½Rï¿½ï¿½ï¿½ï¿½qï¿½)yMwï¿½ï¿½6?cJï¿½$Zlï¿½ï¿½(~Lï¿½ï¿½×¡ï¿½`+ï¿½#xï¿½Î¤ï¿½ï¿½ï¿½ï¿½ï¿½nï¿½ï¿½ï¿½Vpï¿½ï¿½VPï¿½ï¿½Um?d-ï¿½ï¿½ï¿½ï¿½zï¿½ï¿½ï¿½Zï¿½ÂƒvSLï¿½5Pdï¿½x~Ş¢ï¿½ï¿½ï¿½'KÊ–4ï¿½p7ï¿½ï¿½ï¿½ï¿½ï¿½nï¿½ï¿½tï¿½Æ>ï¿½ï¿½*ï¿½ï¿½ï¿½$5Òï¿½p(ï¿½ï¿½ï¿½ï¿½ï¿½$'#ï¿½ï¿½ï¿½,ï¿½ï¿½Aï¿½&|mï¿½{lï¿½ï¿½ï¿½ï¿½	gï¿½ï¿½ï¿½ï¿½ï¿½=ï¿½ï¿½ï¿½ï¿½
<<<

`c2dfb7ea3334a4380373d05dc93770139fd99a`: >>>

xï¿½ï¿½Ajï¿½0Eï¿½ï¿½)ï¿½	ï¿½Fï¿½GPJï¿½]ï¿½ï¿½ï¿½ï¿½Vï¿½ì ¨ï¿½ï¿½W!Gï¿½ï¿½}ï¿½ï¿½ï¿½ï¿½,%7pï¿½ï¿½Öª*,ï¿½RZï¿½ï¿½#Õˆivï¿½6ï¿½ï¿½IGDï¿½ï¿½ï¿½W=ï¿½ï¿½ï¿½ï¿½A8.ï¿½ï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½<yï¿½y0ï¿½Û¶ï¿½ï¿½ï¿½_ï¿½ï¿½Yï¿½ï¿½ï¿½ï¿½ï¿½$ï¿½ï¿½kï¿½_ï¿½,0Lï¿½ï¿½0Ytpï¿½ï¿½ï¿½ï¿½ï¿½}iï¿½Wï¿½ï¿½ukï¿½7ï¿½ï¿½ï¿½ï¿½ï¿½l|ï¿½jï¿½ï¿½XSï¿½
<<<

`3211c4066cdd4fca06adde70bca3d6ec1f3f56`: >>>

xï¿½Qï¿½Jï¿½0ï¿½Ü¯rjA[ï¿½,,*ï¿½'?Aï¿½ï¿½Ø†ï¿½IHï¿½ï¿½ï¿½ï¿½ï¿½Nï¿½vaï¿½\Bï¿½Ş¼yoï¿½3ï¿½ï¿½ï¿½Ë«3t62Dï¿½a[ï¿½ï¿½]ï¿½Rï¿½SUï¿½Eï¿½\BChï¿½ï¿½1ï¿½È´ï¿½ï¿½+ï¿½DCiï¿½ï¿½ï¿½ï¿½7ï¿½ï¿½Í»ï¿½4ï¿½ï¿½wï¿½bï¿½	ï¿½zï¿½Sg4BOhï¿½ï¿½ï¿½ï¿½p8$+uï¿½ï¿½vï¿½3ï¿½Üm|^9ï¿½9ï¿½#eU%ï¿½ï¿½iï¿½E$ï¿½@ï¿½G
ï¿½;aï¿½hï¿½^'ï¿½ï¿½ï¿½vï¿½6=ï¿½fï¿½"ï¿½	yï¿½É±ï¿½6ï¿½3Iï¿½ï¿½Uï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Hï¿½ï¿½ï¿½ï¿½eï¿½ï¿½(ï¿½ï¿½ï¿½ï¿½+ï¿½Tï¿½Ûï¿½ï¿½ï¿½ï¿½ZÆ¶ï¿½l!$ï¿½2Í¾ï¿½ï¿½gï¿½ï¿½ï¿½ï¿½Oï¿½ï¿½ï¿½d;ï¿½ï¿½ï¿½ï¿½ï¿½e
<<<

`0abe9db0cdb7f4612614ed0038066d587fe967`: >>>

x5ï¿½1ï¿½0ï¿½ï¿½ï¿½+ï¿½LÉ’"tï¿½ï¿½Uï¿½ï¿½Vlï¿½ï¿½@ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½mï¿½ï¿½}7ï¿½4ï¿½Ø¶ï¿½1Eï¿½L8ï¿½ï¿½çœŠ]ï¿½ï¿½'ï¿½ï¿½jï¿½oï¿½ï¿½Cï¿½ï¿½g)+ï¿½Rï¿½2ï¿½È…ï¿½ï¿½ï¿½Gï¿½foh|ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½dï¿½cyï¿½ï¿½2zï¿½7ï¿½ï¿½ï¿½U?ï¿½
1ï¿½
<<<

`f74d74f804371962c9fb52215c9788554bc313`: >>>

x5ï¿½1Oï¿½0ï¿½ï¿½ï¿½+ï¿½nï¿½ï¿½*Uï¿½ï¿½|ï¿½Mlnó®‰”&Qï¿½^ï¿½ï¿½ï¿½ï¿½ï¿½gï¿½ï¿½}ï¿½cï¿½1=ï¿½<ï¿½pï¿½ï¿½Wï¿½(}ï¿½ï¿½ï¿½L2G"ï¿½uï¿½<<ï¿½Eï¿½ï¿½ï¿½ï¿½rï¿½a!ï¿½ï¿½KM}@ï¿½tï¿½×€^ï¿½wï¿½ï¿½[ï¿½ï¿½ï¿½qï¿½.ï¿½#ï¿½HKï¿½ï¿½U6ï¿½ï¿½yÜ¾mtï¿½ï¿½ï¿½ï¿½ï¿½q9ï¿½ï¿½ï¿½ï¿½{ï¿½-t.~5ï¿½fï¿½ï¿½{ï¿½Zï¿½ï¿½ï¿½"Ö‰6ï¿½ï¿½Sqï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½rï¿½ï¿½ï¿½ï¿½Vï¿½
<<<

`0bb9843f0b410d896e8d602fa84ebde510185b`: >>>

xï¿½ï¿½I!E]s
.Ğ¦ï¿½Hï¿½qï¿½ï¿½Eï¿½ï¿½ï¿½ï¿½ ï¿½_ï¿½Gpï¿½~ï¿½Dï¿½ï¿½ï¿½KmÜ®7f	ï¿½B:";ï¿½@C$>.:DM.%ï¿½Ü’ï¿½o]FkqaÒ³^ï¿½(ï¿½ï¿½1eï¿½ï¿½!%ï¿½ï¿½	ï¿½,ï¿½ï¿½oï¿½ï¿½3~Mï¿½ï¿½ï¿½ï¿½ï¿½<Ü¿ï¿½~dï¿½ï¿½Zp}ì©–ï¿½T~ï¿½Ö«ï¿½(9ï¿½CO;ï¿½ï¿½!hï¿½5ï¿½ï¿½Jï¿½
<<<

`274ada321aea218c0ebbacf188495cd85443ac`: >>>

xuPAnï¿½0ï¿½Wï¿½8ï¿½Z!ï¿½HTï¿½ï¿½ï¿½/ï¿½=rï¿½IVï¿½ï¿½MiUï¿½oï¿½ï¿½Kï¿½`É³ï¿½3ï¿½ï¿½oï¿½=ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½p\cï¿½Wï¿½ï¿½rï¿½7N7Qï¿½Yï¿½ï¿½wê´½ï¿½4İ±ï¿½qï¿½-ï¿½Mï¿½ï¿½ï¿½ï¿½ULï¿½ï¿½ï¿½ï¿½ï¿½;bï¿½fp ï¿½ï¿½ï¿½a$Sï¿½cï¿½ï¿½Rï¿½Ê¢a1ZF22ï¿½Iï¿½ï¿½"ï¿½sIuï¿½uï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½(@ï¿½Zï¿½8ï¿½ï¿½ï¿½H:ï¿½gï¿½"ï¿½jï¿½ï¿½oQï¿½ï¿½ï¿½ï¿½Kï¿½eï¿½uï¿½ï¿½ï¿½Cff7ß¦	gï¿½{wjÅºï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½<{ï¿½ï¿½oï¿½ÌŸï¿½ï¿½1ï¿½_ï¿½>pï¿½ï¿½ï¿½ï¿½Ô˜ï¿½%ï¿½ï¿½uC?zï¿½vï¿½?2ï¿½*!/ï¿½ï¿½Ô†i
<<<

`ff3dfdd9d5ac9f892afd8caf76acee80d3d3bc`: >>>

xï¿½ï¿½ï¿½
ï¿½0Çï¿½Gï¿½ï¿½ï¿½EtPï¿½]|ï¿½4=ï¿½Ğ˜ï¿½ï¿½ï¿½ï¿½Mï¿½`G{ï¿½ï¿½ï¿½Wi[ï¿½fï¿½]Hk<ï¿½ï¿½ï¿½Pï¿½koe<ï¿½|y`#kï¿½ï¿½>ï¿½iï¿½ï¿½ï¿½MYï¿½ï¿½Nï¿½Daï¿½ï¿½ï¿½6Nï¿½ï¿½fï¿½ï¿½GĞ¢ï¿½ï¿½yï¿½Go=ï¿½ï¿½ï¿½ï¿½=ï¿½'ï¿½8ï¿½T,ONï¿½4y<DIYï¿½
_ï¿½ï¿½Yï¿½[?+Sï¿½ï¿½(ï¿½ï¿½P)ï¿½ï¿½oMï¿½bï¿½)>Jï¿½ï¿½T%ï¿½Õ¼ï¿½ï¿½ï¿½{6
<<<

`edc8760357a70810f4f1e230ca98424ae20874`: >>>

xï¿½ï¿½Ajï¿½0Eï¿½ï¿½)ï¿½/13ï¿½2cC]gï¿½ï¿½ï¿½ï¿½ï¿½PYAï¿½ï¿½ï¿½}Lï¿½ï¿½ï¿½ï¿½?>ï¿½ï¿½Jï¿½kï¿½ï¿½ï¿½W3ï¿½ (Nqï¿½#ï¿½jï¿½ï¿½ï¿½eï¿½ï¿½ï¿½ï¿½ï¿½ï¿½EBpOï¿½ï¿½uÏ“Eï¿½ï¿½dBDï¿½jD2R<v'ï¿½qvï¿½ï¿½Gï¿½ï¿½.Ùšï¿½^BDfï¿½ï¿½ï¿½~ï¿½\Kï¿½eï¿½Ø›ï¿½6lï¿½ï¿½ï¿½ï¿½wï¿½Zï¿½cï¿½!ï¿½|ï¿½ï¿½	ï¿½<ï¿½?ï¿½ï¿½ï¿½8ï¿½ï¿½ï¿½.K*ï¿½/ï¿½5ï¿½ï¿½ï¿½Uï¿½
<<<

`cc1957edb711001034db979a555f64c93d0213`: >>>

x]ï¿½I
ï¿½@E]ï¿½)ï¿½ï¿½ï¿½Mï¿½W"ï¿½ï¿½Bï¿½ï¿½ï¿½ï¿½mÒï¿½Cu;ï¿½ï¿½z+ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½/ï¿½ï¿½ï¿½*ï¿½fï¿½ï¿½ï¿½c"ï¿½ï¿½Tï¿½ï¿½'ï¿½ï¿½ï¿½zï¿½ï¿½7GNï¿½0_Î†a4`ï¿½ï¿½Rï¿½fï¿½Ê¢Rh\ï¿½Vï¿½k3Vï¿½x#ï¿½ï¿½Lrï¿½Òˆï¿½ï¿½ï¿½ï¿½mï¿½ï¿½ï¿½=ï¿½ï¿½ï¿½ï¿½uh~ï¿½+ï¿½Å²ï¿½Oï¿½Hï¿½/`ï¿½Vï¿½ï¿½?ï¿½_ï¿½ï¿½ï¿½/d!ï¿½lkumHï¿½ï¿½ï¿½ï¿½Fï¿½ï¿½hï¿½ï¿½_ï¿½ï¿½L}ï¿½0ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½.2ï¿½]ï¿½~raQ){;
<<<

`HEAD`: >>>

0000000000000000000000000000000000000000 9ea3bb988117502408b47c0d0ca560cb188fa0c9 James-Riordan <jamesriordan39@gmail.com> 1764449400 -0500	commit (initial): Initial commit
9ea3bb988117502408b47c0d0ca560cb188fa0c9 0000000000000000000000000000000000000000 James-Riordan <jamesriordan39@gmail.com> 1764449412 -0500	Branch: renamed refs/heads/master to refs/heads/main
0000000000000000000000000000000000000000 9ea3bb988117502408b47c0d0ca560cb188fa0c9 James-Riordan <jamesriordan39@gmail.com> 1764449412 -0500	Branch: renamed refs/heads/master to refs/heads/main
9ea3bb988117502408b47c0d0ca560cb188fa0c9 d90ce937b57c1f1263599285461887a61008d561 James-Riordan <jamesriordan39@gmail.com> 1764460490 -0500	commit: expansion
d90ce937b57c1f1263599285461887a61008d561 5d74823b11271946fe875a9a8550a29c69ec1039 James-Riordan <jamesriordan39@gmail.com> 1764462668 -0500	commit: FPS
5d74823b11271946fe875a9a8550a29c69ec1039 5503f3d31bead2c633117d7613f417b49332b276 James-Riordan <jamesriordan39@gmail.com> 1764463593 -0500	commit: expansion
5503f3d31bead2c633117d7613f417b49332b276 35f38469568ff0c482382817ec52efe616d4625a James-Riordan <jamesriordan39@gmail.com> 1764464665 -0500	commit: expansion
35f38469568ff0c482382817ec52efe616d4625a 9954627c0978a29386624eefbf9801e3f82a7a8a James-Riordan <jamesriordan39@gmail.com> 1764465062 -0500	commit: expansion
9954627c0978a29386624eefbf9801e3f82a7a8a 68cc8934a51ca9f4a3c2cc978dd0ebd4388488b1 James-Riordan <jamesriordan39@gmail.com> 1764465996 -0500	commit: WASD interactive demo
68cc8934a51ca9f4a3c2cc978dd0ebd4388488b1 5dc2dfb7ea3334a4380373d05dc93770139fd99a James-Riordan <jamesriordan39@gmail.com> 1764467032 -0500	commit: slight experimental change
5dc2dfb7ea3334a4380373d05dc93770139fd99a 944afec26753525c813506abd0ebe8bb217380ee James-Riordan <jamesriordan39@gmail.com> 1764469987 -0500	pull: Fast-forward
944afec26753525c813506abd0ebe8bb217380ee 1a0bb9843f0b410d896e8d602fa84ebde510185b James-Riordan <jamesriordan39@gmail.com> 1764471631 -0500	commit: camera
1a0bb9843f0b410d896e8d602fa84ebde510185b 757fd2b80da0fd5d245ad4e22fc3aaab7817ebcb James-Riordan <jamesriordan39@gmail.com> 1764474211 -0500	commit: game fix
757fd2b80da0fd5d245ad4e22fc3aaab7817ebcb 1e3460113f59f2fc51ab5e2c0387107ba3a4995b James-Riordan <jamesriordan39@gmail.com> 1764476969 -0500	commit: 3d
1e3460113f59f2fc51ab5e2c0387107ba3a4995b 0f2cf81c110831e5eaa100973aafcd45a70f46d2 James-Riordan <jamesriordan39@gmail.com> 1764516155 -0500	commit: 3d experiemnt
0f2cf81c110831e5eaa100973aafcd45a70f46d2 ac9b90ea880316403b956ad149f779284830526a James-Riordan <jamesriordan39@gmail.com> 1764523764 -0500	commit: 3d experiment
ac9b90ea880316403b956ad149f779284830526a 0e5847e0609342408bbce866c81885443567f2f0 James-Riordan <jamesriordan39@gmail.com> 1764525462 -0500	commit: 3d red pyramid demo
0e5847e0609342408bbce866c81885443567f2f0 615ea62414d4ff2212616978a3dc3a0b44fa7086 James-Riordan <jamesriordan39@gmail.com> 1764527602 -0500	commit: txt fix
615ea62414d4ff2212616978a3dc3a0b44fa7086 4774483e2dc26a0cb30bd9b7fa2d7e4884e63c85 James-Riordan <jamesriordan39@gmail.com> 1764560021 -0500	commit: large refactor
4774483e2dc26a0cb30bd9b7fa2d7e4884e63c85 79e4be2b6ea666fbb41e06e6b1b7a7427c7a0b8d James-Riordan <jamesriordan39@gmail.com> 1764597625 -0500	commit: VR GAME WORKS
79e4be2b6ea666fbb41e06e6b1b7a7427c7a0b8d 05edc8760357a70810f4f1e230ca98424ae20874 James-Riordan <jamesriordan39@gmail.com> 1764606395 -0500	pull: Fast-forward
05edc8760357a70810f4f1e230ca98424ae20874 fd3554675bb16c3ffc6b17cf3ba31957ee418d82 James-Riordan <jamesriordan39@gmail.com> 1764613954 -0500	pull: Fast-forward

<<<

`main`: >>>

0000000000000000000000000000000000000000 9ea3bb988117502408b47c0d0ca560cb188fa0c9 James-Riordan <jamesriordan39@gmail.com> 1764449429 -0500	update by push
9ea3bb988117502408b47c0d0ca560cb188fa0c9 d90ce937b57c1f1263599285461887a61008d561 James-Riordan <jamesriordan39@gmail.com> 1764460493 -0500	update by push
d90ce937b57c1f1263599285461887a61008d561 5d74823b11271946fe875a9a8550a29c69ec1039 James-Riordan <jamesriordan39@gmail.com> 1764462672 -0500	update by push
5d74823b11271946fe875a9a8550a29c69ec1039 5503f3d31bead2c633117d7613f417b49332b276 James-Riordan <jamesriordan39@gmail.com> 1764463595 -0500	update by push
5503f3d31bead2c633117d7613f417b49332b276 35f38469568ff0c482382817ec52efe616d4625a James-Riordan <jamesriordan39@gmail.com> 1764464667 -0500	update by push
35f38469568ff0c482382817ec52efe616d4625a 9954627c0978a29386624eefbf9801e3f82a7a8a James-Riordan <jamesriordan39@gmail.com> 1764465065 -0500	update by push
9954627c0978a29386624eefbf9801e3f82a7a8a 68cc8934a51ca9f4a3c2cc978dd0ebd4388488b1 James-Riordan <jamesriordan39@gmail.com> 1764465999 -0500	update by push
68cc8934a51ca9f4a3c2cc978dd0ebd4388488b1 5dc2dfb7ea3334a4380373d05dc93770139fd99a James-Riordan <jamesriordan39@gmail.com> 1764467034 -0500	update by push
5dc2dfb7ea3334a4380373d05dc93770139fd99a 944afec26753525c813506abd0ebe8bb217380ee James-Riordan <jamesriordan39@gmail.com> 1764469987 -0500	pull: fast-forward
944afec26753525c813506abd0ebe8bb217380ee 1a0bb9843f0b410d896e8d602fa84ebde510185b James-Riordan <jamesriordan39@gmail.com> 1764471634 -0500	update by push
1a0bb9843f0b410d896e8d602fa84ebde510185b 757fd2b80da0fd5d245ad4e22fc3aaab7817ebcb James-Riordan <jamesriordan39@gmail.com> 1764474214 -0500	update by push
757fd2b80da0fd5d245ad4e22fc3aaab7817ebcb 1e3460113f59f2fc51ab5e2c0387107ba3a4995b James-Riordan <jamesriordan39@gmail.com> 1764476972 -0500	update by push
1e3460113f59f2fc51ab5e2c0387107ba3a4995b 0f2cf81c110831e5eaa100973aafcd45a70f46d2 James-Riordan <jamesriordan39@gmail.com> 1764516158 -0500	update by push
0f2cf81c110831e5eaa100973aafcd45a70f46d2 ac9b90ea880316403b956ad149f779284830526a James-Riordan <jamesriordan39@gmail.com> 1764523767 -0500	update by push
ac9b90ea880316403b956ad149f779284830526a 0e5847e0609342408bbce866c81885443567f2f0 James-Riordan <jamesriordan39@gmail.com> 1764525465 -0500	update by push
0e5847e0609342408bbce866c81885443567f2f0 615ea62414d4ff2212616978a3dc3a0b44fa7086 James-Riordan <jamesriordan39@gmail.com> 1764527605 -0500	update by push
615ea62414d4ff2212616978a3dc3a0b44fa7086 4774483e2dc26a0cb30bd9b7fa2d7e4884e63c85 James-Riordan <jamesriordan39@gmail.com> 1764560024 -0500	update by push
4774483e2dc26a0cb30bd9b7fa2d7e4884e63c85 79e4be2b6ea666fbb41e06e6b1b7a7427c7a0b8d James-Riordan <jamesriordan39@gmail.com> 1764597629 -0500	update by push
79e4be2b6ea666fbb41e06e6b1b7a7427c7a0b8d 05edc8760357a70810f4f1e230ca98424ae20874 James-Riordan <jamesriordan39@gmail.com> 1764606395 -0500	pull: fast-forward
05edc8760357a70810f4f1e230ca98424ae20874 fd3554675bb16c3ffc6b17cf3ba31957ee418d82 James-Riordan <jamesriordan39@gmail.com> 1764613954 -0500	pull: fast-forward

<<<

`main`: >>>

0000000000000000000000000000000000000000 9ea3bb988117502408b47c0d0ca560cb188fa0c9 James-Riordan <jamesriordan39@gmail.com> 1764449400 -0500	commit (initial): Initial commit
9ea3bb988117502408b47c0d0ca560cb188fa0c9 9ea3bb988117502408b47c0d0ca560cb188fa0c9 James-Riordan <jamesriordan39@gmail.com> 1764449412 -0500	Branch: renamed refs/heads/master to refs/heads/main
9ea3bb988117502408b47c0d0ca560cb188fa0c9 d90ce937b57c1f1263599285461887a61008d561 James-Riordan <jamesriordan39@gmail.com> 1764460490 -0500	commit: expansion
d90ce937b57c1f1263599285461887a61008d561 5d74823b11271946fe875a9a8550a29c69ec1039 James-Riordan <jamesriordan39@gmail.com> 1764462668 -0500	commit: FPS
5d74823b11271946fe875a9a8550a29c69ec1039 5503f3d31bead2c633117d7613f417b49332b276 James-Riordan <jamesriordan39@gmail.com> 1764463593 -0500	commit: expansion
5503f3d31bead2c633117d7613f417b49332b276 35f38469568ff0c482382817ec52efe616d4625a James-Riordan <jamesriordan39@gmail.com> 1764464665 -0500	commit: expansion
35f38469568ff0c482382817ec52efe616d4625a 9954627c0978a29386624eefbf9801e3f82a7a8a James-Riordan <jamesriordan39@gmail.com> 1764465062 -0500	commit: expansion
9954627c0978a29386624eefbf9801e3f82a7a8a 68cc8934a51ca9f4a3c2cc978dd0ebd4388488b1 James-Riordan <jamesriordan39@gmail.com> 1764465996 -0500	commit: WASD interactive demo
68cc8934a51ca9f4a3c2cc978dd0ebd4388488b1 5dc2dfb7ea3334a4380373d05dc93770139fd99a James-Riordan <jamesriordan39@gmail.com> 1764467032 -0500	commit: slight experimental change
5dc2dfb7ea3334a4380373d05dc93770139fd99a 944afec26753525c813506abd0ebe8bb217380ee James-Riordan <jamesriordan39@gmail.com> 1764469987 -0500	pull: Fast-forward
944afec26753525c813506abd0ebe8bb217380ee 1a0bb9843f0b410d896e8d602fa84ebde510185b James-Riordan <jamesriordan39@gmail.com> 1764471631 -0500	commit: camera
1a0bb9843f0b410d896e8d602fa84ebde510185b 757fd2b80da0fd5d245ad4e22fc3aaab7817ebcb James-Riordan <jamesriordan39@gmail.com> 1764474211 -0500	commit: game fix
757fd2b80da0fd5d245ad4e22fc3aaab7817ebcb 1e3460113f59f2fc51ab5e2c0387107ba3a4995b James-Riordan <jamesriordan39@gmail.com> 1764476969 -0500	commit: 3d
1e3460113f59f2fc51ab5e2c0387107ba3a4995b 0f2cf81c110831e5eaa100973aafcd45a70f46d2 James-Riordan <jamesriordan39@gmail.com> 1764516155 -0500	commit: 3d experiemnt
0f2cf81c110831e5eaa100973aafcd45a70f46d2 ac9b90ea880316403b956ad149f779284830526a James-Riordan <jamesriordan39@gmail.com> 1764523764 -0500	commit: 3d experiment
ac9b90ea880316403b956ad149f779284830526a 0e5847e0609342408bbce866c81885443567f2f0 James-Riordan <jamesriordan39@gmail.com> 1764525462 -0500	commit: 3d red pyramid demo
0e5847e0609342408bbce866c81885443567f2f0 615ea62414d4ff2212616978a3dc3a0b44fa7086 James-Riordan <jamesriordan39@gmail.com> 1764527602 -0500	commit: txt fix
615ea62414d4ff2212616978a3dc3a0b44fa7086 4774483e2dc26a0cb30bd9b7fa2d7e4884e63c85 James-Riordan <jamesriordan39@gmail.com> 1764560021 -0500	commit: large refactor
4774483e2dc26a0cb30bd9b7fa2d7e4884e63c85 79e4be2b6ea666fbb41e06e6b1b7a7427c7a0b8d James-Riordan <jamesriordan39@gmail.com> 1764597625 -0500	commit: VR GAME WORKS
79e4be2b6ea666fbb41e06e6b1b7a7427c7a0b8d 05edc8760357a70810f4f1e230ca98424ae20874 James-Riordan <jamesriordan39@gmail.com> 1764606395 -0500	pull: Fast-forward
05edc8760357a70810f4f1e230ca98424ae20874 fd3554675bb16c3ffc6b17cf3ba31957ee418d82 James-Riordan <jamesriordan39@gmail.com> 1764613954 -0500	pull: Fast-forward

<<<

`exclude`: >>>

# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~

<<<

`applypatch-msg.sample`: >>>

#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:

<<<

`commit-msg.sample`: >>>

#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}

<<<

`fsmonitor-watchman.sample`: >>>

#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	my $last_update_line = "";
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
		$last_update_line = qq[\n"since": $last_update_token,];
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {$last_update_line
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}

<<<

`post-update.sample`: >>>

#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info

<<<

`pre-applypatch.sample`: >>>

#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:

<<<

`pre-commit.sample`: >>>

#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff-index --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --

<<<

`pre-merge-commit.sample`: >>>

#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:

<<<

`pre-push.sample`: >>>

#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0

<<<

`pre-rebase.sample`: >>>

#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END

<<<

`pre-receive.sample`: >>>

#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi

<<<

`prepare-commit-msg.sample`: >>>

#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi

<<<

`push-to-checkout.sample`: >>>

#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi

<<<

`sendemail-validate.sample`: >>>

#!/bin/sh

# An example hook script to validate a patch (and/or patch series) before
# sending it via email.
#
# The hook should exit with non-zero status after issuing an appropriate
# message if it wants to prevent the email(s) from being sent.
#
# To enable this hook, rename this file to "sendemail-validate".
#
# By default, it will only check that the patch(es) can be applied on top of
# the default upstream branch without conflicts in a secondary worktree. After
# validation (successful or not) of the last patch of a series, the worktree
# will be deleted.
#
# The following config variables can be set to change the default remote and
# remote ref that are used to apply the patches against:
#
#   sendemail.validateRemote (default: origin)
#   sendemail.validateRemoteRef (default: HEAD)
#
# Replace the TODO placeholders with appropriate checks according to your
# needs.

validate_cover_letter () {
	file="$1"
	# TODO: Replace with appropriate checks (e.g. spell checking).
	true
}

validate_patch () {
	file="$1"
	# Ensure that the patch applies without conflicts.
	git am -3 "$file" || return
	# TODO: Replace with appropriate checks for this patch
	# (e.g. checkpatch.pl).
	true
}

validate_series () {
	# TODO: Replace with appropriate checks for the whole series
	# (e.g. quick build, coding style checks, etc.).
	true
}

# main -------------------------------------------------------------------------

if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
then
	remote=$(git config --default origin --get sendemail.validateRemote) &&
	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
	git config --replace-all sendemail.validateWorktree "$worktree"
else
	worktree=$(git config --get sendemail.validateWorktree)
fi || {
	echo "sendemail-validate: error: failed to prepare worktree" >&2
	exit 1
}

unset GIT_DIR GIT_WORK_TREE
cd "$worktree" &&

if grep -q "^diff --git " "$1"
then
	validate_patch "$1"
else
	validate_cover_letter "$1"
fi &&

if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
then
	git config --unset-all sendemail.validateWorktree &&
	trap 'git worktree remove -ff "$worktree"' EXIT &&
	validate_series
fi

<<<

`update.sample`: >>>

#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0

<<<

